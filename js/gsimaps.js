/************************************************************************
 設定
 ************************************************************************/
var GSI = {
  ClientMode: {}
  , Modal: {}
  , Draw: {}
  , Edit: {}
  , Control: {}
  , Utils: {
    Browser: {}
  }
  , GLOBALS: {}
  , TEXT: {}
  , FILEURL: {}
};
GSI.TEXT = GSITEXT;
/************************************************************************
 モバイル判定
************************************************************************/
if (location.pathname.indexOf(CONFIG.MOBILE_FILENAME) < 0) {
  if (
    navigator.userAgent.indexOf('iPhone') > 0 ||
    navigator.userAgent.indexOf('iPad') > 0 ||
    navigator.userAgent.indexOf('iPod') > 0 ||
    navigator.userAgent.indexOf('Android') > 0
  ) {
    var hash = location.hash;
    if (!hash || hash.indexOf("&frommobile") < 0) {
      location.href = CONFIG.MOBILEURL + hash;
    }
  }
}

/************************************************************************
 jQuery
  メソッド補完、追加
 ************************************************************************/
jQuery.extend({
  stringify: function stringify(obj) {
    var t = typeof (obj);
    if (t != "object" || obj === null) {
      // simple data type
      if (t == "string") obj = '"' + obj + '"';
      return String(obj);
    } else {
      // recurse array or object
      var json = [], arr = (obj && obj.constructor == Array);

      for (var n in obj) {
        var v = obj[n];
        t = typeof (v);
        if (obj.hasOwnProperty(n)) {
          if (t == "string") v = '"' + v + '"'; else if (t == "object" && v !== null) v = jQuery.stringify(v);
          json.push((arr ? "" : '"' + n + '":') + String(v));
        }
      }
      return (arr ? "[" : "{") + String(json) + (arr ? "]" : "}");
    }
  }
});

try {
  window.console = window.console || { log: function () { } };
} catch (e) { }

try {
  window.JSON || (window.JSON = {
    parse: function (src) {
      return $.parseJSON(src);
    },

    stringify: function (obj) {
      return $.stringify(obj);
    }
  });

}
catch (e) { }

// ie8 array のmap, filterメソッド追加
try {
  (function (fn) {
    if (!fn.map) fn.map = function (f) { var r = []; for (var i = 0; i < this.length; i++)if (this[i] !== undefined) r[i] = f(this[i]); return r; }
    if (!fn.filter) fn.filter = function (f) { var r = []; for (var i = 0; i < this.length; i++)if (this[i] !== undefined && f(this[i])) r[i] = this[i]; return r; }
  })(Array.prototype);
}
catch (e) { }

// leafletのsetOpacityがIE8で利かないためjQueryに任せる
L.DomUtil.setOpacity = function (el, opacity) {
  $(el).css({ opacity: opacity });
};

// JQuery.ajax IE11の場合XMLHttpRequestを使用させるため
if (window.ActiveXObject !== undefined && !window.XDomainRequest) {
  jQuery.ajaxSettings.xhr = function () {
    try {
      return new window.XMLHttpRequest();
    } catch (e) { }
  };
}

/************************************************************************
 Proj4js
 ************************************************************************/
Proj4js.defs["EPSG:3097"] = "+proj=utm +zone=51 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";		    //UTM Zone51
Proj4js.defs["EPSG:3098"] = "+proj=utm +zone=52 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";		    //UTM Zone52
Proj4js.defs["EPSG:3099"] = "+proj=utm +zone=53 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";		    //UTM Zone53
Proj4js.defs["EPSG:3100"] = "+proj=utm +zone=54 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";		    //UTM Zone54
Proj4js.defs["EPSG:3101"] = "+proj=utm +zone=55 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";		    //UTM Zone55
Proj4js.defs["SR-ORG:1235"] = "+proj=utm +zone=56 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";	    //UTM Zone56
Proj4js.defs['EPSG:4301'] = "+proj=longlat +ellps=bessel +towgs84=-146.336,506.832,680.254,0,0,0,0 +no_defs";	//日本測地系（経緯度座標）
Proj4js.defs["EPSG:4612"] = "+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs";
Proj4js.defs["EPSG:4019"] = "+proj=longlat +ellps=GRS80 +no_defs";
Proj4js.defs["EPSG:3857"] = "+title= Google Mercator EPSG:3857 +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs";
Proj4js.defs["EPSG:32651"] = "+proj=utm +zone=51 +datum=WGS84 +units=m +no_defs";
Proj4js.defs["EPSG:32652"] = "+proj=utm +zone=52 +datum=WGS84 +units=m +no_defs";
Proj4js.defs["EPSG:32653"] = "+proj=utm +zone=53 +datum=WGS84 +units=m +no_defs";
Proj4js.defs["EPSG:32654"] = "+proj=utm +zone=54 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
Proj4js.defs["EPSG:32655"] = "+proj=utm +zone=55 +datum=WGS84 +units=m +no_defs";
Proj4js.defs["EPSG:32656"] = "+proj=utm +zone=56 +datum=WGS84 +units=m +no_defs";

Proj4js.defs["EPSG:6668"] = "+proj=longlat +ellps=GRS80 +no_defs";
Proj4js.defs["EPSG:6669"] = "+proj=tmerc +lat_0=33 +lon_0=129.5 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6670"] = "+proj=tmerc +lat_0=33 +lon_0=131 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6671"] = "+proj=tmerc +lat_0=36 +lon_0=132.1666666666667 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6672"] = "+proj=tmerc +lat_0=33 +lon_0=133.5 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6673"] = "+proj=tmerc +lat_0=36 +lon_0=134.3333333333333 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6674"] = "+proj=tmerc +lat_0=36 +lon_0=136 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6675"] = "+proj=tmerc +lat_0=36 +lon_0=137.1666666666667 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6676"] = "+proj=tmerc +lat_0=36 +lon_0=138.5 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6677"] = "+proj=tmerc +lat_0=36 +lon_0=139.8333333333333 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6678"] = "+proj=tmerc +lat_0=40 +lon_0=140.8333333333333 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6679"] = "+proj=tmerc +lat_0=44 +lon_0=140.25 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6680"] = "+proj=tmerc +lat_0=44 +lon_0=142.25 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6681"] = "+proj=tmerc +lat_0=44 +lon_0=144.25 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6682"] = "+proj=tmerc +lat_0=26 +lon_0=142 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6683"] = "+proj=tmerc +lat_0=26 +lon_0=127.5 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6684"] = "+proj=tmerc +lat_0=26 +lon_0=124 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6685"] = "+proj=tmerc +lat_0=26 +lon_0=131 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";
Proj4js.defs["EPSG:6686"] = "+proj=tmerc +lat_0=20 +lon_0=136 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs";

Proj4js.defs["EPSG:6688"] = "+proj=utm +zone=51 +ellps=GRS80 +datum=WGS80 +units=m +no_defs";
Proj4js.defs["EPSG:6689"] = "+proj=utm +zone=52 +ellps=GRS80 +datum=WGS80 +units=m +no_defs";
Proj4js.defs["EPSG:6690"] = "+proj=utm +zone=53 +ellps=GRS80 +datum=WGS80 +units=m +no_defs";
Proj4js.defs["EPSG:6691"] = "+proj=utm +zone=54 +ellps=GRS80 +datum=WGS80 +units=m +no_defs";
Proj4js.defs["EPSG:6692"] = "+proj=utm +zone=55 +ellps=GRS80 +datum=WGS80 +units=m +no_defs";

Proj4js.defs["EPSG:2443"] = "+proj=tmerc +lat_0=33 +lon_0=129.5 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2444"] = "+proj=tmerc +lat_0=33 +lon_0=131 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2445"] = "+proj=tmerc +lat_0=36 +lon_0=132.1666666666667 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2446"] = "+proj=tmerc +lat_0=33 +lon_0=133.5 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2447"] = "+proj=tmerc +lat_0=36 +lon_0=134.3333333333333 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2448"] = "+proj=tmerc +lat_0=36 +lon_0=136 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2449"] = "+proj=tmerc +lat_0=36 +lon_0=137.1666666666667 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2450"] = "+proj=tmerc +lat_0=36 +lon_0=138.5 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2451"] = "+proj=tmerc +lat_0=36 +lon_0=139.8333333333333 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2452"] = "+proj=tmerc +lat_0=40 +lon_0=140.8333333333333 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2453"] = "+proj=tmerc +lat_0=44 +lon_0=140.25 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2454"] = "+proj=tmerc +lat_0=44 +lon_0=142.25 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2455"] = "+proj=tmerc +lat_0=44 +lon_0=144.25 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2456"] = "+proj=tmerc +lat_0=26 +lon_0=142 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2457"] = "+proj=tmerc +lat_0=26 +lon_0=127.5 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2458"] = "+proj=tmerc +lat_0=26 +lon_0=124 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2459"] = "+proj=tmerc +lat_0=26 +lon_0=131 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2460"] = "+proj=tmerc +lat_0=20 +lon_0=136 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
Proj4js.defs["EPSG:2461"] = "+proj=tmerc +lat_0=26 +lon_0=154 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"

dslorethumbnail_click = function (elements) {
  var x = new GSI.Modal.dsloreDialog(elements);
  x.show();

  //return false;
};

/************************************************************************
 GSI.Draw
 L.FeatureGroup
 L.Polygon
 L.Draw.Circle
 L.Draw.Polyline
 L.Draw.Polygon
 L.Draw.SimpleShape
 ************************************************************************/
L.Draw.SimpleShape.prototype._onMouseUp = function () {
  if (this._shape) {
    this._fireCreatedEvent();

    this.disable();

  } else {

    this.disable();
    if (this.options.repeatMode) {
      this.enable();
    }
  }
};

L.FeatureGroup.include({
  closePopup: function () {
    for (var id in this._layers) {
      this._layers[id].closePopup();
    }
    return this;
  },
  unbindPopup: function () {
    for (var id in this._layers) {
      this._layers[id].unbindPopup();
    }
    return this;
  }
});

GSI.Circle = L.Circle.extend({

  initialize: function (latlng, radius, options) {
    this._bounds = new L.LatLngBounds();
    L.Circle.prototype.initialize.call(this, latlng, radius, options);
    this._circleToLatLngs();

  },

  _circleToLatLngs: function () {
    var idx = 0;

    var latlngs = [];
    latlngs[idx] = []
    var numSides = CONFIG.CIRCLETOPOLYGONNUMSIDES;
    var center = this.getLatLng();
    var radius = this._mRadius;
    var wrap = false;

    var direct = GSI.Utils.Geodesic.vincentyDirect(center, 0, radius, wrap);
    var prev = L.latLng(direct.lat, direct.lng);
    latlngs[idx].push(prev);

    var isOver = false;

    if (prev.lat > 85.0511287798 || prev.lat < -85.0511287798) isOver = true;
    for (step = 1; step <= numSides;) {
      direct = GSI.Utils.Geodesic.vincentyDirect(center, 360 / numSides * step, radius, wrap);
      var gp = L.latLng(direct.lat, direct.lng);

      if (Math.abs(gp.lng - prev.lng) > 180) {
        var inverse = GSI.Utils.Geodesic.vincentyInverse(prev, gp);
        var sec = GSI.Utils.Geodesic.intersection(prev, inverse.initialBearing, {
          lat: -89,
          lng: ((gp.lng - prev.lng) > 0) ? -GSI.Utils.Geodesic.INTERSECT_LNG : GSI.Utils.Geodesic.INTERSECT_LNG
        }, 0);
        if (sec) {
          latlngs[idx].push(L.latLng(sec.lat, sec.lng));
          idx++;
          latlngs[idx] = [];
          prev = L.latLng(sec.lat, -sec.lng);
          latlngs[idx].push(prev);
          if (sec.lat > 85.0511287798 || sec.lat < -85.0511287798) isOver = true;
          if (prev.lat > 85.0511287798 || prev.lat < -85.0511287798) isOver = true;
        } else {
          idx++;
          latlngs[idx] = [];
          latlngs[idx].push(gp);
          prev = gp;
          step++;

          if (gp.lat > 85.0511287798 || gp.lat < -85.0511287798) isOver = true;
        }
      } else {
        latlngs[idx].push(gp);
        prev = gp;
        step++;
        if (gp.lat > 85.0511287798 || gp.lat < -85.0511287798) isOver = true;
      }
    }

    this._latlngs = this._convertLatLngs(latlngs);
    if (isOver) {
      try {
        if (this._strokeLine) this._strokeLine.remove();
        this._strokeLine = null;
      }
      catch (ex) { }

      this._lineLatLngs = this._makeStrokeLine(latlngs);
      if (this._map) {
        this._strokeLine = L.polyline(this._lineLatLngs, {
          color: this.options.color,
          stroke: this.options.stroke,
          fill: false,
          opacity: this.options.opacity,
          weight: this.options.weight,
          lineCap: this.options.lineCap,
          lineJoin: this.options.lineJoin,
          dashArray: this.options.dashArray
        }).addTo(this._map);
      }
    }
    else {
      this._lineLatLngs = null;
      try {
        if (this._strokeLine) this._strokeLine.remove();
        this._strokeLine = null;
      }
      catch (ex) { }
    }
  },

  onAdd: function () {
    this._renderer._initPath(this);
    this._reset();
    this._renderer._addPath(this);

    try {
      if (this._strokeLine) this._strokeLine.remove();
      this._strokeLine = null;
    }
    catch (ex) { }

    if (this._lineLatLngs)
      this._strokeLine = L.polyline(this._lineLatLngs, {
        color: this.options.color,
        stroke: this.options.stroke,
        fill: false,
        opacity: this.options.opacity,
        weight: this.options.weight,
        lineCap: this.options.lineCap,
        lineJoin: this.options.lineJoin,
        dashArray: this.options.dashArray
      }).addTo(this._map);

  },

  onRemove: function () {
    this._renderer._removePath(this);
    if (this._strokeLine) this._strokeLine.remove();
    this._strokeLine = null;
  },
  _makeStrokeLine: function (latlngs) {
    var result = [];
    var prevLatLng = null;
    var MAX_LAT = 85.0511287798;
    var MIN_LAT = -85.0511287798;

    for (var i = 0; i < latlngs.length; i++) {
      var arr = [];
      for (var j = 0; j < latlngs[i].length; j++) {

        var latlng = L.latLng(latlngs[i][j]);

        if (latlng.lat > MAX_LAT) {
          if (prevLatLng && prevLatLng.lat < MAX_LAT)
            arr.push(L.latLng(MAX_LAT, latlng.lng));
          result.push(arr);
          arr = [];
        }
        else if (latlng.lat < MIN_LAT) {

          if (prevLatLng && prevLatLng.lat > MIN_LAT)
            arr.push(L.latLng(MIN_LAT, latlng.lng));
          result.push(arr);
          arr = [];
        }
        else {
          if (prevLatLng) {
            if (prevLatLng.lat > MAX_LAT)
              arr.push(L.latLng(MAX_LAT, prevLatLng.lng));
            else if (prevLatLng.lat < MIN_LAT)
              arr.push(L.latLng(MIN_LAT, prevLatLng.lng));
          }
          arr.push(latlng);
        }

        prevLatLng = latlng;
      }

      if (arr.length > 0) result.push(arr);
    }

    return result;
  },

  _simplifyPoints: function () {
    var parts = this._parts,
      tolerance = this.options.smoothFactor;

    for (var i = 0, len = parts.length; i < len; i++) {
      parts[i] = L.LineUtil.simplify(parts[i], tolerance);
    }
  },
  _update: function () {

    if (!this._map) { return; }
    this._circleToLatLngs();
    this._clipPoints();
    this._simplifyPoints();
    this._updatePath();
  },

  _clipPoints: function () {
    // polygons need a different clipping algorithm so we redefine that

    var bounds = this._renderer._bounds,
      w = this.options.weight,
      p = new L.Point(w, w);

    // increase clip padding by stroke width to avoid stroke on clip edges
    bounds = new L.Bounds(bounds.min.subtract(p), bounds.max.add(p));

    this._parts = [];
    if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
      return;
    }

    if (this.options.noClip) {
      this._parts = this._rings;
      return;
    }

    for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
      clipped = L.PolyUtil.clipPolygon(this._rings[i], bounds, true);
      if (clipped.length) {
        this._parts.push(clipped);
      }
    }
  },
  _project: function () {

    L.Circle.prototype._project.call(this);

    var pxBounds = new L.Bounds();
    this._rings = [];
    this._projectLatlngs(this._latlngs, this._rings, pxBounds);

    var w = this._clickTolerance(),
      p = new L.Point(w, w);

    if (this._bounds.isValid() && pxBounds.isValid()) {
      pxBounds.min._subtract(p);
      pxBounds.max._add(p);
      this._pxBounds = pxBounds;
    }
  },

  _projectLatlngs: function (latlngs, result, projectedBounds) {
    var flat = latlngs[0] instanceof L.LatLng,
      len = latlngs.length,
      i, ring;

    if (flat) {
      ring = [];
      for (i = 0; i < len; i++) {
        ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
        projectedBounds.extend(ring[i]);
      }
      result.push(ring);
    } else {
      for (i = 0; i < len; i++) {
        this._projectLatlngs(latlngs[i], result, projectedBounds);
      }
    }
  },

  _convertLatLngs: function (latlngs) {
    var result = [],
      flat = L.LineUtil.isFlat(latlngs);

    for (var i = 0, len = latlngs.length; i < len; i++) {
      if (flat) {
        result[i] = L.latLng(latlngs[i]);
        this._bounds.extend(result[i]);
      } else {
        result[i] = this._convertLatLngs(latlngs[i]);
      }
    }

    return result;
  },

  _updatePath: function () {

    var stroke = this.options.stroke;
    if (this._lineLatLngs && stroke) {
      this.options.stroke = false;
      this._renderer._updateStyle(this);

    }
    this._renderer._updatePoly(this, true);

    this.options.stroke = stroke;

  }
});

// マーカー移動中にマップにイベントを渡さない

GSI.MarkerDrag = L.Handler.extend({
  initialize: function (marker) {
    this._marker = marker;
  },

  addHooks: function () {
    var icon = this._marker._icon;

    if (!this._draggable) {
      this._draggable = new GSI.Draggable(icon, icon, true);
    }

    this._draggable.on({
      dragstart: this._onDragStart,
      drag: this._onDrag,
      dragend: this._onDragEnd
    }, this).enable();

    L.DomUtil.addClass(icon, 'leaflet-marker-draggable');
  },

  removeHooks: function () {
    this._draggable.off({
      dragstart: this._onDragStart,
      drag: this._onDrag,
      dragend: this._onDragEnd
    }, this).disable();

    if (this._marker._icon) {
      L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
    }
  },

  moved: function () {
    return this._draggable && this._draggable._moved;
  },

  _onDragStart: function () {
    // @section Dragging events
    // @event dragstart: Event
    // Fired when the user starts dragging the marker.

    // @event movestart: Event
    // Fired when the marker starts moving (because of dragging).

    this._oldLatLng = this._marker.getLatLng();
    this._marker
      .closePopup()
      .fire('movestart')
      .fire('dragstart');
  },

  _onDrag: function (e) {
    var marker = this._marker,
      shadow = marker._shadow,
      iconPos = L.DomUtil.getPosition(marker._icon),
      latlng = marker._map.layerPointToLatLng(iconPos);

    // update shadow position
    if (shadow) {
      L.DomUtil.setPosition(shadow, iconPos);
    }

    if (this._oldLatLng)
      latlng.alt = this._oldLatLng.alt;

    marker._latlng = latlng;
    e.latlng = latlng;
    e.oldLatLng = this._oldLatLng;

    // @event drag: Event
    // Fired repeatedly while the user drags the marker.
    marker
      .fire('move', e)
      .fire('drag', e);
  },

  _onDragEnd: function (e) {
    // @event dragend: DragEndEvent
    // Fired when the user stops dragging the marker.

    // @event moveend: Event
    // Fired when the marker stops moving (because of dragging).
    delete this._oldLatLng;
    this._marker
      .fire('moveend')
      .fire('dragend', e);
  }
});

GSI.Draggable = L.Draggable.extend({
  _onDown: function (e) {
    L.Draggable.prototype._onDown.call(this, e);
    L.DomEvent.stop(e);
  }
});

GSI.Circle.addInitHook(function () {
  if (L.Edit.Circle) {
    this.editing = new L.Edit.Circle(this);

    if (this.options.editable) {
      this.editing.enable();
    }
  }

  this.on('add', function () {
    if (this.editing && this.editing.enabled()) {
      this.editing.addHooks();
    }
  });

  this.on('remove', function () {
    if (this.editing && this.editing.enabled()) {
      this.editing.removeHooks();
    }
  });
});

L.circle = function (latlng, radius, options) {
  return new GSI.Circle(latlng, radius, options);
};

GSI.Draw.convertRadius = function (radius, latlng, unit) {
  var result = {
    radius: radius.toFixed(1),
    latlng: latlng,
    unit: unit
  };
  if (unit == "m") {
    if (result.radius > 1000) {
      result.radius = (radius / 1000).toFixed(4);
      result.unit = 'km';
    }
  }
  if (unit == "px") {
    result.radius = Math.floor(result.radius);
  }
  return result;

};

GSI.PixelRectangle = L.Polygon.extend({
  initialize: function (center, width, height, anchorX, anchorY, options) {
    this._center = center;
    this._width = width;
    this._height = height;
    this._anchorX = anchorX;
    this._anchorY = anchorY;
    options.noGeodesic = true;
    L.Polygon.prototype.initialize.call(this, [this._center, this._center, this._center], options);
  },
  onZoomEnd: function () {
    this.setLatLngs(this._boundsToLatLngs(this._center, this._width, this._height, this._anchorX, this._anchorY));
  },
  onAdd: function (map) {
    L.Polygon.prototype.onAdd.call(this, map);
    this.setLatLngs(this._boundsToLatLngs(this._center, this._width, this._height, this._anchorX, this._anchorY));

    this._onZoomEnd = L.bind(this.onZoomEnd, this);
    map.on('zoomend', this._onZoomEnd);
  },
  onRemove: function (map) {
    map.off('zoomend', this._onZoomEnd);

    L.Polygon.prototype.onRemove.call(this, map);
  },
  _boundsToLatLngs: function (center, width, height, anchorX, anchorY) {

    var centerPoint = this._map.latLngToContainerPoint(center);

    var left = centerPoint.x - anchorX;
    var top = centerPoint.y - anchorY;

    var right = centerPoint.x + (width - anchorX);
    var bottom = centerPoint.y + (height - anchorY);

    var southWest = this._map.containerPointToLatLng(L.point(left, bottom));
    var northEast = this._map.containerPointToLatLng(L.point(right, top));

    latLngBounds = L.latLngBounds(southWest, northEast);
    return [
      latLngBounds.getSouthWest(),
      latLngBounds.getNorthWest(),
      latLngBounds.getNorthEast(),
      latLngBounds.getSouthEast()
    ];
  }
});

GSI.Draw.Circle = L.Draw.Circle.extend({

  _onMouseDown: function (e) {

    if (!$(e.originalEvent.target).hasClass("gsi_centercross") && $(e.originalEvent.target).hasClass("leaflet-marker-icon")) {
      return;
    }
    if (this._shape) {

      this._map.getContainer().focus();

      this.fire("start");
      this._startLatLng = e.latlng;

      L.DomEvent
        .on(document, 'mouseup', this._onMouseUp, this)
        .on(document, 'touchend', this._onMouseUp, this)
        .preventDefault(e.originalEvent);

    }
    else {
      this.fire("start");

      L.Draw.Circle.prototype._onMouseDown.call(this, e);
    }
  },

  setRadius: function (radius) {
    if (!this._shape) {
      this._shape = new GSI.Circle(this._map.getCenter(), radius, this.options.shapeOptions);
      this._map.addLayer(this._shape);
    } else {
      this._shape.setRadius(radius);
      this._shape.redraw();
    }
  },

  _onMouseMove: function (e) {
    var latlng = e.latlng,
      showRadius = this.options.showRadius,
      useMetric = this.options.metric,
      radius;

    this._tooltip.updatePosition(latlng);
    if (this._isDrawing) {
      this._drawShape(latlng);

      // Get the new radius (rounded to 1 dp)
      radius = this._shape.getRadius().toFixed(1);

      this._tooltip.updateContent({
        text: this._endLabelText,
        subtext: showRadius ? '半径: ' + L.GeometryUtil.readableDistance(radius, useMetric) : ''

      });
    }
    else {
      if (this._shape) this._shape.setLatLng(latlng);
    }

    if (this._isDrawing) {
      this.fire("change", GSI.Draw.convertRadius(this._shape.getRadius(), latlng, "m"));
    }
  },

  _drawShape: function (latlng) {
    if (!this._shape) {
      this._shape = new GSI.Circle(this._startLatLng, this._startLatLng.distanceTo(latlng), this.options.shapeOptions);
      this._map.addLayer(this._shape);
    } else {
      this._shape.setRadius(this._startLatLng.distanceTo(latlng));
    }
  },

  _fireCreatedEvent: function () {
    var circle = new GSI.Circle(this._startLatLng, this._shape.getRadius(), this.options.shapeOptions);
    L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, circle);
  }
});

GSI.Draw.CircleMarker = L.Draw.Circle.extend({

  _getPixelDistance: function (latlng1, latlng2) {

    var p1 = this._map.latLngToContainerPoint(latlng1);
    var p2 = this._map.latLngToContainerPoint(latlng2);
    var a = p1.x - p2.x;
    var b = p1.y - p2.y;
    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));

  },

  _drawShape: function (latlng) {
    var distance = this._getPixelDistance(this._startLatLng, latlng);
    if (!this._shape) {

      var options = $.extend(true, { radius: distance }, this.options.shapeOptions);
      this._shape = new L.CircleMarker(this._startLatLng, options);
      this._map.addLayer(this._shape);
    } else {
      this._shape.setRadius(distance);
    }
  },

  _fireCreatedEvent: function () {
    var options = $.extend(true, { radius: this._shape.getRadius() }, this.options.shapeOptions);
    var circle = new L.CircleMarker(this._startLatLng, options);
    L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, circle);
  },

  _onMouseDown: function (e) {

    if (!$(e.originalEvent.target).hasClass("gsi_centercross") && $(e.originalEvent.target).hasClass("leaflet-marker-icon")) {
      return;
    }

    if (this._shape) {
      this._map.getContainer().focus();

      this.fire("start");
      this._startLatLng = e.latlng;

      L.DomEvent
        .on(document, 'mouseup', this._onMouseUp, this)
        .on(document, 'touchend', this._onMouseUp, this)
        .preventDefault(e.originalEvent);

    }
    else {
      this.fire("start");

      L.Draw.Circle.prototype._onMouseDown.call(this, e);
    }

  },

  setRadius: function (radius) {
    if (!this._shape) {

      var options = $.extend(true, { radius: radius }, this.options.shapeOptions);
      this._shape = new L.CircleMarker(this._map.getCenter(), options);
      this._map.addLayer(this._shape);
    } else {
      this._shape.setRadius(radius);
    }
  },

  _onMouseMove: function (e) {
    var latlng = e.latlng,
      showRadius = this.options.showRadius,
      useMetric = this.options.metric,
      radius;

    this._tooltip.updatePosition(latlng);
    if (this._isDrawing) {
      this._drawShape(latlng);

      // Get the new radius (rounded to 1 dp)
      radius = this._shape.getRadius().toFixed(0);

      this._tooltip.updateContent({
        text: this._endLabelText,
        subtext: showRadius ? '半径: ' + radius + 'px' : ''
      });
    }
    else {
      if (this._shape) this._shape.setLatLng(latlng);
    }
    if (this._isDrawing) {
      this.fire("change", { radius: this._shape.getRadius().toFixed(0) });
    }
  }
});

L.Polyline.prototype.spliceLatLngs = function () { // (Number index, Number howMany)
  var removed = [].splice.apply(this._latlngs, arguments);
  this._convertLatLngs(this._latlngs, true);
  this.redraw();
  return removed;
};

L.Polyline.prototype._projectOrig = L.Polyline.prototype._project;
L.Polyline.prototype._project = function (e) {
  if (!this.options.geodesic) {
    L.Polyline.prototype._projectOrig.call(this);
    return;
  }
  this.options.noClip = true;
  var pxBounds = new L.Bounds();
  this._rings = [];

  var origLatlngs = $.extend(true, [], this._latlngs);
  if (L.LineUtil.isFlat(origLatlngs)) origLatlngs = [origLatlngs];

  if (this instanceof L.Polygon) {
    var isMultiPolygon = false;
    if (L.LineUtil.isFlat(origLatlngs)) {
      if (!origLatlngs[0].equals(origLatlngs[origLatlngs.length - 1])) {
        origLatlngs.push(L.latLng(origLatlngs[0].lat, origLatlngs[0].lng, origLatlngs[0].alt));
      }
    } else {
      for (var i = 0; i < origLatlngs.length; i++) {

        if (L.LineUtil.isFlat(origLatlngs[i])) {
          if (!origLatlngs[i][0].equals(origLatlngs[i][origLatlngs[i].length - 1])) {
            origLatlngs[i].push(L.latLng(origLatlngs[i][0].lat, origLatlngs[i][0].lng, origLatlngs[i][0].alt));
          }
        } else {
          isMultiPolygon = true;
          for (var j = 0; j < origLatlngs[i].length; j++) {
            if (!origLatlngs[i][j][0].equals(origLatlngs[i][j][origLatlngs[i][j].length - 1])) {
              origLatlngs[i][j].push(L.latLng(origLatlngs[i][j][0].lat, origLatlngs[i][j][0].lng, origLatlngs[i][j][0].alt));
            }
          }
        }
      }
    }
  }

  var latlngs = null;

  if (isMultiPolygon) {
    latlngs = [];
    for (var i = 0; i < origLatlngs.length; i++) {
      latlngs.push(GSI.Utils.Geodesic.createLine(origLatlngs[i], GSI.Utils.Geodesic.LINESTEPS));
    }
  } else {
    latlngs = GSI.Utils.Geodesic.createLine(origLatlngs, GSI.Utils.Geodesic.LINESTEPS);
  }
  this._projectLatlngs(latlngs, this._rings, pxBounds);

  var w = this._clickTolerance(),
    p = new L.Point(w, w);

  if (this._bounds.isValid() && pxBounds.isValid()) {
    pxBounds.min._subtract(p);
    pxBounds.max._add(p);
    this._pxBounds = pxBounds;
  }
};

L.Polygon.prototype.spliceLatLngs = function () { // (Number index, Number howMany)

  var latlngs = this._latlngs;

  var flat = L.LineUtil.isFlat(latlngs);
  if (!flat) latlngs = latlngs[0];

  var removed = [].splice.apply(latlngs, arguments);
  this._convertLatLngs(latlngs, true);
  this.redraw();
  return removed;
};

L.Draw.Polyline.prototype._onTouch = function (e) {
  // #TODO: use touchstart and touchend vs using click(touch start & end).
  if (GSI.Utils.Browser.touch) { // #TODO: get rid of this once leaflet fixes their click/touch.
    this._onMouseMove(e);
    this._onMouseDown(e);
    this._onMouseUp(e);
  }
};

L.Draw.Polyline.prototype._onContextMenu = function (e) {
  L.DomEvent.preventDefault(e);

  if (this._map && e.originalEvent.button == 2 && this._markers.length > 1) {
    this._map.fire("drawcancel");
  }
  this.deleteLastVertex();
},

L.Draw.Polyline.prototype._onMouseUp = function (e) {
  if (this._mouseDownOrigin) {
    if (e.originalEvent.button == 2) {
    }
    else {
      // We detect clicks within a certain tolerance, otherwise let it
      // be interpreted as a drag by the map
      var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY)
        .distanceTo(this._mouseDownOrigin);
      if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) {
        this.addVertex(e.latlng);
      }
    }
  }

  this._mouseDownOrigin = null;
};

GSI.Draw.Polyline = L.Draw.Polyline.extend({

  options: {
    allowIntersection: true,
    repeatMode: false,
    drawError: {
      color: '#b00b00',
      timeout: 2500
    },
    icon: new L.DivIcon({
      iconSize: new L.Point(8, 8),
      className: 'leaflet-div-icon leaflet-editing-icon'
    }),
    touchIcon: new L.DivIcon({
      iconSize: new L.Point(24, 24),
      className: 'leaflet-div-icon leaflet-editing-icon gsi_draw_icon'
    }),
    guidelineDistance: 20,
    maxGuideLineLength: 4000,
    shapeOptions: {
      stroke: true,
      color: '#f06eaa',
      weight: 4,
      opacity: 0.5,
      fill: false,
      clickable: true
    },
    metric: true, // Whether to use the metric meaurement system or imperial
    showLength: true, // Whether to display distance in the tooltip
    zIndexOffset: 2000 // This should be > than the highest z-index any map layers
  },

  initialize: function (map, options) {
    if (GSI.Utils.Browser.touch) {
      this.options.icon = this.options.touchIcon;
    }

    // Need to set this here to ensure the correct message is used.
    this.options.drawError.message = L.drawLocal.draw.handlers.polyline.error;

    // Merge default drawError options with custom options
    if (options && options.drawError) {
      options.drawError = L.Util.extend({}, this.options.drawError, options.drawError);
    }

    // Save the type so super can fire, need to do this as cannot do this.TYPE :(
    this.type = L.Draw.Polyline.TYPE;

    L.Draw.Feature.prototype.initialize.call(this, map, options);

  },
  _updateFinishHandler: function () {
    var markerCount = this._markers.length;
    // The last marker should have a click handler to close the polyline
    if (markerCount > 1) {
      this._markers[markerCount - 1].on('click', this._finishShape, this);

    }

    // Remove the old marker click handler (as only the last point should close the polyline)
    if (markerCount > 2) {
      this._markers[markerCount - 2].off('click', this._finishShape, this);
    }
  },

  _getTooltipText: function () {

    var labelText = L.Draw.Polyline.prototype._getTooltipText.call(this);
    if (this._currentLatLng) {
      var dms = GSI.Utils.latLngToDMS(this._currentLatLng);

      labelText.text += "<br>"
        + dms.lat.d + "度" + dms.lat.m + "分" + dms.lat.s.toFixed(2) + "秒,"
        + dms.lng.d + "度" + dms.lng.m + "分" + dms.lng.s.toFixed(2) + "秒"
        ;

    }
    return labelText;
  },

  _vertexChanged: function (latlng, added) {
    this._currentLatLng = latlng;

    L.Draw.Polyline.prototype._vertexChanged.call(this, latlng, added);

    var currentLatLng = this._currentLatLng,
      previousLatLng = this._markers[this._markers.length - 1].getLatLng(),
      distance;

    distance = this._measurementRunningTotal + currentLatLng.distanceTo(previousLatLng);
    var distanceStr = '0 m';
    if (distance > 1000) {
      distanceStr = (distance / 1000).toFixed(3) + ' km';
    } else {
      distanceStr = Math.ceil(distance) + ' m';
    }
    this.fire('measurechange', { distance: distanceStr });
  }
});

L.drawLocal.draw.handlers.polyline.inner_error = '<strong>エラー:</strong> 対象のポリゴン内を指定して下さい';
L.drawLocal.draw.handlers.polyline.inner_error2 = '<strong>エラー:</strong> 中抜きポリゴン同士が交差しています';
L.drawLocal.draw.handlers.polyline.inner_error3 = '<strong>エラー:</strong> 対象のポリゴン外を通過しています';

GSI.Draw.Polygon = L.Draw.Polygon.extend({

  options: {
    allowIntersection: false,
    repeatMode: false,
    drawError: {
      color: '#b00b00',
      timeout: 2500
    },
    icon: new L.DivIcon({
      iconSize: new L.Point(8, 8),
      className: 'leaflet-div-icon leaflet-editing-icon'
    }),
    touchIcon: new L.DivIcon({
      iconSize: new L.Point(24, 24),
      className: 'leaflet-div-icon leaflet-editing-icon gsi_draw_icon'
    }),
    guidelineDistance: 20,
    maxGuideLineLength: 4000,
    metric: true, // Whether to use the metric meaurement system or imperial
    showLength: true, // Whether to display distance in the tooltip
    zIndexOffset: 2000, // This should be > than the highest z-index any map layers

    showArea: false,
    shapeOptions: {
      stroke: true,
      color: '#f06eaa',
      weight: 4,
      opacity: 0.5,
      fill: true,
      fillColor: null, //same as color by default
      fillOpacity: 0.2,
      clickable: true
    }
  },

  initialize: function (map, options) {
    if (GSI.Utils.Browser.touch) {
      this.options.icon = this.options.touchIcon;
    }

    // Need to set this here to ensure the correct message is used.
    this.options.drawError.message = L.drawLocal.draw.handlers.polyline.error;

    // Merge default drawError options with custom options
    if (options && options.drawError) {
      options.drawError = L.Util.extend({}, this.options.drawError, options.drawError);
    }
    this.type = L.Draw.Polygon.TYPE;

    L.Draw.Feature.prototype.initialize.call(this, map, options);

  },

  _pointInPolygon: function (poly, p) {
    var p1, p2;
    var inside = false;
    var oldPoint = poly[poly.length - 1];
    for (var i = 0; i < poly.length; i++) {
      var newPoint = poly[i];
      if (newPoint.lng > oldPoint.lng) { p1 = oldPoint; p2 = newPoint; }
      else { p1 = newPoint; p2 = oldPoint; }
      if ((p1.lng < p.lng) == (p.lng <= p2.lng) && (p.lat - p1.lat) * (p2.lng - p1.lng) < (p2.lat - p1.lat) * (p.lng - p1.lng)) {
        inside = !inside;
      }
      oldPoint = newPoint;
    }
    return inside;
  },

  _lineIentersectedPolygon: function (poly, line) {
    //_lineIentersected
    if (!line || line.length < 2) return false;

    for (var i = 0; i < poly.length; i++) {
      var p1 = poly[i];
      var p2 = poly[(poly.length - 1 > i ? i + 1 : 0)];

      if (this._lineIentersected(p1, p2, line[0], line[1])) {
        return true;
      }

    }
    return false;
  },

  addVertex: function (latlng) {
    if (this.options.ownerPolygon) {
      // 中抜きが外のポリゴン内か、他の中抜きと交差していないか
      this.options.drawError.message = L.drawLocal.draw.handlers.polyline.inner_error;
      var isMulti = false;
      var latlngs = this.options.ownerPolygon.getLatLngs();
      var err = false;
      if (L.LineUtil.isFlat(latlngs)) {
        err = !this._pointInPolygon(latlngs, latlng);
      } else {

        if (L.LineUtil.isFlat(latlngs[0])) {
          err = !this._pointInPolygon(latlngs[0], latlng);
        } else {
          isMulti = true;
          var newLatLngs = this._poly.getLatLngs();
          if (newLatLngs.length <= 0) {
            err = true;
            for (var i = 0; i < latlngs.length; i++) {
              if (this._pointInPolygon(latlngs[i][0], latlng)) {
                err = false;
                this._ownerIndex = i;
                break;
              }
            }
          } else {
            err = !this._pointInPolygon(latlngs[this._ownerIndex][0], latlng);
          }

        }
        if (!err) {
          if (!isMulti) {
            var newLatLngs = this._poly.getLatLngs();
            if (newLatLngs.length > 0) {
              newLatLngs = [newLatLngs[newLatLngs.length - 1], latlng];
            } else newLatLngs = undefined;

            if (newLatLngs && this._lineIentersectedPolygon(latlngs[0], newLatLngs)) {
              err = true;
              this.options.drawError.message = L.drawLocal.draw.handlers.polyline.inner_error3;
            } else {
              for (var i = 1; i < latlngs.length; i++) {
                err = this._pointInPolygon(latlngs[i], latlng);
                if (err) {
                  this.options.drawError.message = L.drawLocal.draw.handlers.polyline.inner_error2;
                  break;
                } else if (newLatLngs) {

                  if (this._polyIntersected(latlngs[i], newLatLngs)) {
                    err = true;
                    this.options.drawError.message = L.drawLocal.draw.handlers.polyline.inner_error2;
                    break;
                  }

                }
              }
            }
          } else {
            // マルチポリゴン
            var newLatLngs = this._poly.getLatLngs();
            if (newLatLngs.length > 0) {
              newLatLngs = [newLatLngs[newLatLngs.length - 1], latlng];
            } else newLatLngs = undefined;

            if (newLatLngs && this._lineIentersectedPolygon(latlngs[this._ownerIndex][0], newLatLngs)) {
              err = true;
              this.options.drawError.message = L.drawLocal.draw.handlers.polyline.inner_error3;
            } else {
              for (var i = 1; i < latlngs[this._ownerIndex].length; i++) {
                err = this._pointInPolygon(latlngs[this._ownerIndex][i], latlng);
                if (err) {
                  this.options.drawError.message = L.drawLocal.draw.handlers.polyline.inner_error2;
                  break;
                } else if (newLatLngs) {

                  if (this._polyIntersected(latlngs[this._ownerIndex][i], newLatLngs)) {
                    err = true;
                    this.options.drawError.message = L.drawLocal.draw.handlers.polyline.inner_error2;
                    break;
                  }
                }
              }
            }

          }
        }
      }

      if (err) {

        this._showErrorTooltip();
        return;
      }
    }
    this.options.drawError.message = L.drawLocal.draw.handlers.polyline.error;

    this._poly._originalPoints = [];

    for (var i = 0; i < this._poly._latlngs.length; i++) {
      this._poly._originalPoints.push(this._map.latLngToLayerPoint(this._poly._latlngs[i]));
    }

    var markersLength = this._markers.length;

    if (markersLength > 0 && !this.options.allowIntersection && this._poly.newLatLngIntersects(latlng)) {

      this._showErrorTooltip();
      return;
    }
    else if (this._errorShown) {
      this._hideErrorTooltip();
    }

    this._markers.push(this._createMarker(latlng));

    this._poly.addLatLng(latlng);

    if (!this.options.shapeOptions) this.options.shapeOptions = {};
    this.options.shapeOptions._ownerIndex = this._ownerIndex;
    if (this._poly.getLatLngs().length === 2) {
      this._map.addLayer(this._poly);
    }

    this._vertexChanged(latlng, true);

    //L.Draw.Polygon.prototype.addVertex.call(this, latlng);

  },
  _polyIntersected: function (poly1, poly2) {

    for (var i = 0; i < poly1.length; i++) {
      var from1 = poly1[i];
      var to1 = (i < poly1.length - 1 ? poly1[i + 1] : poly1[0]);

      for (var j = 0; j < poly2.length; j++) {
        var from2 = poly2[j];
        var to2 = (j < poly2.length - 1 ? poly2[j + 1] : poly2[0]);
        if (this._lineIentersected(from1, to1, from2, to2)) {
          return true;
        }
      }

    }
    return false;

  },
  _lineIentersected: function (from1, to1, from2, to2) { //ax, ay, bx, by, cx, cy, dx, dy) {
    var ax = from1.lng;
    var ay = from1.lat;
    var bx = to1.lng;
    var by = to1.lat;
    var cx = from2.lng;
    var cy = from2.lat;
    var dx = to2.lng;
    var dy = to2.lat;

    var ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);
    var tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);
    var tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);
    var td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);

    return tc * td <= 0 && ta * tb <= 0; // 端点を含む場合
  },

  _finishShape: function () {
    this._poly._originalPoints = [];

    for (var i = 0; i < this._poly._latlngs.length; i++) {
      this._poly._originalPoints.push(this._map.latLngToLayerPoint(this._poly._latlngs[i]));
    }
    L.Draw.Polygon.prototype._finishShape.call(this);
  },

  _getTooltipText: function () {

    var labelText = L.Draw.Polygon.prototype._getTooltipText.call(this);
    if (this._currentLatLng) {
      var dms = GSI.Utils.latLngToDMS(this._currentLatLng);

      labelText.text += "<br>"
        + dms.lat.d + "度" + dms.lat.m + "分" + dms.lat.s.toFixed(2) + "秒,"
        + dms.lng.d + "度" + dms.lng.m + "分" + dms.lng.s.toFixed(2) + "秒"
        ;

    }
    return labelText;
  },

  _vertexChanged: function (latlng, added) {
    L.Draw.Polygon.prototype._vertexChanged.call(this, latlng, added);

    var latlngs = this._poly.getLatLngs();
    if (!L.LineUtil.isFlat(latlngs)) latlngs = latlngs[0];

    this.fire('measurechange', {
      distance: this._area2MeasurementString(this._area)
    });
  },

  _area2MeasurementString: function (area) {
    var result = '0 m&sup2;';
    if (area) {
      if (area < 1000000) {
        result = Math.ceil(area) + ' m&sup2;';
      }
      else {
        result = (area / 1000000).toFixed(3) + ' km&sup2;';
      }
    }

    return result;
  },

  _getMeasurementString: function () {
    var area = this._area;

    if (!area) {
      return null;
    }

    return this._area2MeasurementString(area);
  },

  _updateFinishHandler: function () {
    var markerCount = this._markers.length;

    // The first marker should have a click handler to close the polygon
    if (markerCount === 1) {
      this._markers[0].on('click', this._finishShape, this);
    }

    // Add and update the double click handler
    if (markerCount > 2) {
      this._markers[markerCount - 1].on('click', this._finishShape, this);
      // Only need to remove handler if has been added before
      if (markerCount > 3) {
        this._markers[markerCount - 2].off('click', this._finishShape, this);
      }
    }
  }
});

GSI.Draw.FreehandPolyline = L.Draw.SimpleShape.extend({

  initialize: function (map, options) {
    this._endLabelText = L.drawLocal.draw.handlers.simpleshape.tooltip.end;
    this._initialLabelText = "マウスダウンで線の描画開始";

    L.Draw.SimpleShape.prototype.initialize.call(this, map, options);
  },

  _onMouseDown: function (e) {
    if (!$(e.originalEvent.target).hasClass("gsi_centercross") && $(e.originalEvent.target).hasClass("leaflet-marker-icon")) {
      return;
    }

    this.fire("start");
    L.Draw.SimpleShape.prototype._onMouseDown.call(this, e);
  },

  _onTouch: function (e) {
    // #TODO: use touchstart and touchend vs using click(touch start & end).
    if (GSI.Utils.Browser.touch) { // #TODO: get rid of this once leaflet fixes their click/touch.
      this._onMouseMove(e);
      this._onMouseDown(e);
      this._onMouseUp(e);
    }
  },
  _drawShape: function (latlng) {
    if (!this._shape) {
      this._shape = new L.Polyline([], this.options.shapeOptions);
      this._map.addLayer(this._shape);
    }
    else {
      var latlngs = this._shape.getLatLngs();

      if (latlngs.length > 0) {
        var prevLatLng = latlngs[latlngs.length - 1];

        if (prevLatLng.lat != latlng.lat || prevLatLng.lng != latlng.lng) {
          this._shape.addLatLng(latlng);
        }
      }
      else {
        this._shape.addLatLng(latlng);
      }
    }
  },
  _fireCreatedEvent: function () {
    var plyline = new L.Polyline(this._shape.getLatLngs(), this.options.shapeOptions);
    L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, plyline);
  }
});

/************************************************************************
 GSI.Links
 ************************************************************************/
GSI.Links = {};

GSI.Links.getURL = function (pageStateManager, id, center, z, bounds) {
  if (id == "gsi3d_l") {
    if (GSI.Utils.Browser.ie && (GSI.Utils.Browser.version <= 10)) {
      alert('お使いのWebブラウザは地理院地図3Dに対応していません。\nChrome、Firefox、IE11　をご使用ください。');
      return null;
    }
    var args = "";
    args += "?z=" + z;
    args += "&lat=" + center.lat;
    args += "&lon=" + center.lng;
    args += "&pxsize=2048";
    args += "&" + pageStateManager.getLayersQueryString({ visibleOnly: true, withRelief: true })

    return "./index_3d.html" + args;
  }
  else if (id == "gsi3d_s") {
    if (GSI.Utils.Browser.ie && (GSI.Utils.Browser.version <= 10)) {
      alert('お使いのWebブラウザは地理院地図3Dに対応していません。\nChrome、Firefox、IE11　をご使用ください。');
      return null;
    }
    var args = "";
    args += "?z=" + z;
    args += "&lat=" + center.lat;
    args += "&lon=" + center.lng;
    args += "&pxsize=1024";
    args += "&" + pageStateManager.getLayersQueryString({ visibleOnly: true, withRelief: true })

    return "./index_3d.html" + args;
  }
  else if (id == "gsi3d_view") {
    if (GSI.Utils.Browser.ie && (GSI.Utils.Browser.version <= 10)) {
      alert('お使いのWebブラウザは地理院地図3Dに対応していません。\nChrome、Firefox、IE11　をご使用ください。');
      return null;
    }

    var size = GSI.GLOBALS.gsimaps._mainMap._map.getSize();
    if (size.x > 2048) size.x = 2048;
    if (size.y > 2048) size.y = 2048;

    if (size.x % 2 == 1) size.x -= 1;
    if (size.y % 2 == 1) size.y -= 1;

    var args = "";
    args += "?z=" + z;
    args += "&lat=" + center.lat;
    args += "&lon=" + center.lng;
    args += "&w=" + size.x;
    args += "&h=" + size.y;
    args += "&" + pageStateManager.getLayersQueryString({ visibleOnly: true, withRelief: true })

    return "./index_3d.html" + args;
  }

  else if (id == 'gsiglobe') {
    if (GSI.Utils.Browser.ie && (GSI.Utils.Browser.version <= 10)) {
      alert('お使いのWebブラウザは地理院地図Globeに対応していません。\nChrome、Firefox、IE11　をご使用ください。');
      return null;
    }

    var url = CONFIG.GLOBEURL;

    // GlobeのURL生成
    var queryString = pageStateManager.getPositionQueryString();
    if (queryString != "") queryString += "/1/";

    var base = pageStateManager.getBaseLayerQueryString();
    var hasBase = (base != '');
    if (base != '')
      queryString += (queryString != '' ? '&' : '#') + base;
    var ls = pageStateManager.getLayersQueryString();
    var disp = pageStateManager.getTileViewSetting();

    if (ls != '')
      queryString += (queryString != '' ? '&' : '#') + ls;
    if (disp != '')
      queryString += (queryString != '' ? '&' : '#') + disp;

    url += queryString;

    return url; //'https://maps.gsi.go.jp/globe/index_globe.html';
  }

  else if (id == 'mapion') {
    var zoomLevel = z;
    if (z <= 6) { zoomLevel = 6; }
    return "./link.html?site=mapion&lat=" + center.lat + "&lng=" + center.lng + "&z=" + zoomLevel;
  }
  else if (id == 'itsumonavi') {
    var zoomLevel = 18;
    var japanP = GSI.Utils.world2Japan(center);
    var y = Math.round(japanP.y * 3600 * 1000);
    var x = Math.round(japanP.x * 3600 * 1000);

    if (z <= 5) { zoomLevel = 1; }
    else if (z <= 6) { zoomLevel = 2; }
    else if (z <= 7) { zoomLevel = 3; }
    else if (z <= 8) { zoomLevel = 4; }
    else if (z <= 9) { zoomLevel = 6; }
    else if (z <= 10) { zoomLevel = 7; }
    else if (z <= 11) { zoomLevel = 8; }
    else if (z <= 12) { zoomLevel = 9; }
    else if (z <= 13) { zoomLevel = 10; }
    else if (z <= 14) { zoomLevel = 11; }
    else if (z <= 15) { zoomLevel = 13; }
    else if (z <= 16) { zoomLevel = 14; }
    else if (z <= 17) { zoomLevel = 16; }
    else { zoomLevel = 18; }

    return "./link.html?site=itsumonavi&lat=" + y + "&lng=" + x + "&z=" + zoomLevel;
  }

  else if (id == 'ucodehref') {
    return 'http://ucopendb.gsi.go.jp/ucode_app/logical_code/ucode_disp.php?lat=' + center.lat + '&lng=' + center.lng + '&zoom=' + z;
  }

  else if (id == 'gsivector') {
    var zoomlevel = z - 1;
    return 'https://maps.gsi.go.jp/vector/#' + zoomlevel + '/' + center.lat + '/' + center.lng + '/&ls=vstd&disp=1&d=l';
  }

  else {
    return id;
  }
};

/************************************************************************
 GSI.showTopMassage
 ************************************************************************/
GSI.showTopMassage = function () {
  var message = (CONFIG.TOPMESSAGE && CONFIG.TOPMESSAGE.DETAILS ? CONFIG.TOPMESSAGE.DETAILS : '現在情報はありません');
  GSI.Modal.Message.show(message, { className: "gsi_modal_topmessage", width: 500, closeBtnVisible: true });
};

/************************************************************************
 GSI.Utils
 ************************************************************************/
GSI.Utils.encodeHTML = function (src) {
  src = src.replace(/&/g, '&amp;');
  src = src.replace(/</g, '&lt;');
  src = src.replace(/>/g, '&gt;');
  return src;
};

GSI.Utils.getInternetExplorerVersion = function () {
  var rv = -1;
  if (navigator.appName == 'Microsoft Internet Explorer') {
    var ua = navigator.userAgent;
    var re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
    if (re.exec(ua) != null)
      rv = parseFloat(RegExp.$1);
  }
  else if (navigator.appName == 'Netscape') {
    var ua = navigator.userAgent;
    var re = new RegExp("Trident/.*rv:([0-9]{1,}[\.0-9]{0,})");
    if (re.exec(ua) != null)
      rv = parseFloat(RegExp.$1);
  }
  return rv;
};

GSI.Utils.Browser = {};
GSI.Utils.Browser.userAgent = window.navigator.userAgent.toLowerCase();

if (typeof document.documentElement.style.maxHeight != "undefined") {

  var ieVersion = GSI.Utils.getInternetExplorerVersion();

  if (ieVersion < 1) {
    // IE 以外
  } else {
    // IE8 以降
    GSI.Utils.Browser.ie = true;
    GSI.Utils.Browser.version = ieVersion;
  }
} else {
  // IE 6.0 以下

  GSI.Utils.Browser.ie = true;
  GSI.Utils.Browser.version = 6;
}

GSI.Utils.Browser.isiPhone = GSI.Utils.Browser.userAgent.indexOf('iphone') >= 0;
GSI.Utils.Browser.isiPod = GSI.Utils.Browser.userAgent.indexOf('ipod') >= 0;
GSI.Utils.Browser.isiPad = GSI.Utils.Browser.userAgent.indexOf('ipad') >= 0;
GSI.Utils.Browser.isiOS = (GSI.Utils.Browser.isiPhone || GSI.Utils.Browser.isiPod || GSI.Utils.Browser.isiPad);
GSI.Utils.Browser.isAndroid = GSI.Utils.Browser.userAgent.indexOf('android') >= 0;
GSI.Utils.Browser.isSmartMobile = (GSI.Utils.Browser.isiOS || GSI.Utils.Browser.isAndroid);
GSI.Utils.Browser.isChrome = GSI.Utils.Browser.userAgent.indexOf('chrome') != -1;
GSI.Utils.Browser.isMac = !!GSI.Utils.Browser.userAgent.match(/mac|ppc/);

GSI.Utils.hasFileAPI = (window.File && window.FileReader && window.FileList && window.Blob);

GSI.Utils.Browser.msPointer = window.navigator && window.navigator.msPointerEnabled &&
  window.navigator.msMaxTouchPoints && !window.PointerEvent;
GSI.Utils.Browser.pointer = (window.PointerEvent && window.navigator.pointerEnabled && window.navigator.maxTouchPoints) ||
  GSI.Utils.Browser.msPointer;

GSI.Utils.Browser.TouchDevice = function () {
  var f = false;
  if (GSI.Utils.Browser.isiPhone ||
    GSI.Utils.Browser.isiPod ||
    GSI.Utils.Browser.isiPad ||
    GSI.Utils.Browser.isiOS ||
    GSI.Utils.Browser.isAndroid ||
    GSI.Utils.Browser.isSmartMobile
  ) {
    f = true;
  }
  return f;
};

var phantomjs = GSI.Utils.Browser.userAgent.indexOf('phantom') !== -1;

GSI.Utils.Browser.touch = !window.L_NO_TOUCH && !phantomjs && (function () {

  var msPointer = window.navigator && window.navigator.msPointerEnabled &&
    window.navigator.msMaxTouchPoints && !window.PointerEvent;
  var pointer = (window.PointerEvent && window.navigator.pointerEnabled && window.navigator.maxTouchPoints) ||
    msPointer;

  var startName = 'ontouchstart';

  // IE10+ (We simulate these into touch* events in L.DomEvent and L.DomEvent.Pointer) or WebKit, etc.
  if (pointer || (startName in document.documentElement)) {
    return true;
  }

  // Firefox/Gecko
  var div = document.createElement('div'),
    supported = false;

  if (!div.setAttribute) {
    return false;
  }
  div.setAttribute(startName, 'return;');

  if (typeof div[startName] === 'function') {
    supported = true;
  }

  div.removeAttribute(startName);
  div = null;

  return supported;
}());

GSI.Utils.getCurrentID = function () {
  var id = 1;
  if (!GSI.Utils._currentID) {
    GSI.Utils._currentID = 1;
  }
  id = GSI.Utils._currentID;
  GSI.Utils._currentID++;
  return id;
};

GSI.Utils.isLocalUrl = function (url) {

  if ((GSI.ClientMode.baseUrl && GSI.ClientMode.baseUrl != '') || url.match(/(http|https):\/\/.+/)) {
    return false;
  }
  else {
    return true;
  }
};

GSI.Utils.flashPlayerVersion = null;

GSI.Utils.canUseWebGL = function () {
  try {
    var canvas = document.createElement('canvas');
    var webGLContext = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    if (!(!!(window.WebGLRenderingContext && webGLContext && webGLContext.getShaderPrecisionFormat))) {

      return false;
    }

    var gl = canvas.getContext("experimental-webgl");
    var extensions = gl.getSupportedExtensions();
    var supportedExtensions = {};
    for (var i = 0; i < extensions.length; i++) {
      supportedExtensions[extensions[i]] = true;
    }

    if (
      supportedExtensions["WEBGL_depth_texture"] && // 深度テクスチャ
      supportedExtensions["WEBGL_color_buffer_float"] // 浮動小数点テクスチャ
    ) {
      return true;
    } else {
      return false;
    }
  } catch (ex) {
    return false;
  }
};

GSI.Utils.canUseFlashPlayer = function () {
  if (GSI.Utils.flashPlayerVersion == null) {
    GSI.Utils.flashPlayerVersion = GSI.Utils.getFlashPlayerVersion();

  }
  return (GSI.Utils.flashPlayerVersion > 0);
};

GSI.Utils.getFlashPlayerVersion = function () {
  var result = 0;
  if (navigator.plugins && navigator.mimeTypes['application/x-shockwave-flash']) {
    var plugin = navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin;
    if (plugin) {
      result = parseInt(plugin.description.match(/\d+\.\d+/));
    }
  } else {
    try {
      var flashOCX = new ActiveXObject("ShockwaveFlash.ShockwaveFlash").GetVariable("$version").match(/([0-9]+)/);
      if (flashOCX) {
        result = parseInt(flashOCX[0]);
      }
    } catch (e) { }
  }
  if (result <= 6) {
    result = 0;
  }
  return result;
};

GSI.Utils.getCurrentPath = function () {
  var _location = (GSI.ClientMode.location ? GSI.ClientMode.location : location);
  var port = _location.port;
  var pathName = _location.pathname;

  if (pathName.length <= 0 || pathName.charAt(0) != '/')
    pathName = '/' + pathName;

  return _location.protocol + '//' +
    (_location.host ? _location.host : _location.hostname) +
    pathName;

};

GSI.Utils.getTimeStampString = function () {
  var now = new Date();

  var year = now.getFullYear(); // 年
  var month = now.getMonth() + 1; // 月
  var day = now.getDate(); // 日
  var hour = now.getHours(); // 時
  var min = now.getMinutes(); // 分
  var sec = now.getSeconds(); // 秒
  var msec = now.getMilliseconds(); // ミリ秒
  var result =
    year + '' +
    ('00' + month).slice(-2) +
    ('00' + day).slice(-2) +
    ('00' + hour).slice(-2) +
    ('00' + min).slice(-2) +
    ('00' + sec).slice(-2) +
    msec;
  return result;
};

GSI.Utils.getScreenSize = function () {
  return {
    w: window.innerWidth ? window.innerWidth : $(window).width(),
    h: window.innerHeight ? window.innerHeight : $(window).height()
  };
};

GSI.Utils.world2Japan = function (latLng) {
  var worldLonLat = new Proj4js.Proj('EPSG:4326');
  var japanLonLat = new Proj4js.Proj('EPSG:4301');
  var worldP = new Proj4js.Point(latLng.lng, latLng.lat);
  var japanP = Proj4js.transform(worldLonLat, japanLonLat, worldP);
  return { x: japanP.x, y: japanP.y }
};

GSI.Utils.latLngToDMS = function (latLng) {

  var latLng = { lat: latLng.lat, lng: latLng.lng };
  var latMinus = (latLng.lat < 0 ? -1 : 1);
  var lngMinus = (latLng.lng < 0 ? -1 : 1);

  latLng.lat = Math.abs(latLng.lat);
  latLng.lng = Math.abs(latLng.lng);

  var latD = Math.floor(latLng.lat);
  var latM = Math.floor((latLng.lat - latD) * 60);
  var latS = (latLng.lat - latD - (latM / 60)) * 3600;

  if (latS == 60) { latS = 0; latM = latM + 1; };
  if (latM == 60) { latM = 0; latD = latD + 1; };

  var lngD = Math.floor(latLng.lng);
  var lngM = Math.floor((latLng.lng - lngD) * 60);
  var lngS = (latLng.lng - lngD - (lngM / 60)) * 3600;

  if (lngS == 60) { lngS = 0; lngM = lngM + 1; };
  if (lngM == 60) { lngM = 0; lngD = lngD + 1; };

  return {
    lat: {
      d: latD, m: latM, s: latS
    },
    lng: {
      d: lngD, m: lngM, s: lngS
    }
  };
};

GSI.Utils.dotLineTo = function (texture, p1x, p1y, p2x, p2y, dashArray) {

  if (texture.setLineDash !== undefined) {
    texture.setLineDash(dashArray);
    texture.lineTo(p2x, p2y);
  }
  else if (texture.mozDash !== undefined) {
    texture.mozDash = dashArray;
    texture.lineTo(p2x, p2y);
  }
  else {
    var d = Math.sqrt(Math.pow(p2x - p1x, 2) + Math.pow(p2y - p1y, 2));
    var rad = Math.atan2(p2y - p1y, p2x - p1x);
    var space = (dashArray && dashArray.length >= 2 && dashArray[0] > 0 ? dashArray[0] : 5);
    var dotted = Math.round(d / space / 2);

    for (var i = 0; i < dotted; i++) {
      var p3x = Math.cos(rad) * space * (i * 2) + p1x;
      var p3y = Math.sin(rad) * space * (i * 2) + p1y;
      var p4x = Math.cos(rad) * space * (i * 2 + 1) + p1x;
      var p4y = Math.sin(rad) * space * (i * 2 + 1) + p1y;

      texture.moveTo(p3x, p3y);
      texture.lineTo(p4x, p4y);

    }
  }
}

// 磁北線を表示できる範囲内かどうかを返す
GSI.Utils.isVaridVariation = function (latLng) {
  //経度：122度～154度
  //緯度：20度～46度
  return !(latLng.lat < 20 || latLng.lat > 46 || latLng.lng < 122 || latLng.lng > 154);
}

// 指定緯度経度の偏角を算出し、角度を返す
GSI.Utils.getVariation = function (latLng) {
  var px = latLng.lng;
  var py = latLng.lat;

  //経緯度座標(10進数)を小数点以下6桁に丸める
  px = px * 1000000;
  px = parseInt(px);
  px = px / 1000000;
  py = py * 1000000;
  py = parseInt(py);
  py = py / 1000000;

  //西偏角計算
  var KEE = px - 138;
  var KNN = py - 37;
  var KKK = (7 + 40.585 / 60) + (19.003 / 60) * KNN - (6.265 / 60) * KEE + (0.009 / 60) * KNN * KNN + (0.024 / 60) * KNN * KEE - (0.591 / 60) * KEE * KEE;

  return KKK;
};

GSI.Utils.ConverUnit = function (map, shape, radius, unit_src, unit_to) {
  if (unit_src == "px" && unit_to == "m") {
    var r_radius = radius;
    var r_latlng = shape.getLatLng();
    var p = map.latLngToContainerPoint(r_latlng);
    var p_to_x = p.x;
    var p_to_y = p.y;
    p_to_x += r_radius;

    var r_latlng_to = map.containerPointToLatLng(L.point(p_to_x, p_to_y));
    var r = r_latlng.distanceTo(r_latlng_to);

    radius = r;
  }

  if (unit_src == "m" && unit_to == "px") {
    var r_latlng = shape.getBounds();
    var n_p = map.latLngToContainerPoint(r_latlng._northEast);
    var s_p = map.latLngToContainerPoint(r_latlng._southWest);

    var r = Math.floor((n_p.x - s_p.x) * 0.5);

    radius = r;
  }
  return radius;
};

GSI.Utils.Cookie = L.Class.extend({

  _config: {
    defaults: {}
  },
  initialize: function () { },
  _encode: function (s) {
    return this._config.raw ? s : encodeURIComponent(s);
  },
  _decode: function (s) {
    return this._config.raw ? s : decodeURIComponent(s);
  },
  _stringifyCookieValue: function (value) {
    return this._encode(this._config.json ? JSON.stringify(value) : String(value));
  },
  _parseCookieValue: function (s) {
    if (s.indexOf('"') === 0) {
      s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
    }

    try {
      var pluses = /\+/g;
      s = decodeURIComponent(s.replace(pluses, ' '));
      return this._config.json ? JSON.parse(s) : s;
    } catch (e) { }
  },
  _read: function (s, converter) {
    return this._config.raw ? s : this._parseCookieValue(s);
  },
  get: function (key) {
    var result = key ? undefined : {};
    var cookies = document.cookie ? document.cookie.split('; ') : [];

    for (var i = 0, l = cookies.length; i < l; i++) {
      var parts = cookies[i].split('=');
      var name = this._decode(parts.shift());
      var cookie = parts.join('=');
      if (key && key === name) {
        result = this._read(cookie);
        break;
      }

      if (!key && (cookie = this._read(cookie)) !== undefined) {
        result[name] = cookie;
      }
    }

    return result;
  },
  set: function (key, value, options) {
    options = $.extend({}, this._config.defaults, options);

    if (typeof options.expires === 'number') {
      var hours = options.expires, t = options.expires = new Date();
      t.setTime(+t + hours * 1000 * 60 * 60);//
    }

    return (document.cookie = [
      this._encode(key), '=', this._stringifyCookieValue(value),
      options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
      options.path ? '; path=' + options.path : '',
      options.domain ? '; domain=' + options.domain : '',
      options.secure ? '; secure' : ''
    ].join(''));

  },
  remove: function (key, options) {
    if (this.get(key) === undefined) {
      return false;
    }

    this.set(key, '', $.extend({}, options, { expires: -1 }));
    return !this.get(key);
  }
});

GSI.Utils.sendSelectedLayer = function (id) {
  $.ajax({
    type: "GET",
    data: id,
    url: "./layers_txt/anchor.txt",
    datatype: "text",
    cache: false,
  });
};

GSI.Utils.sendSelectedFunction = function (function_id) {
  // 202303 convetersを追加
  $.ajax({
    type: "GET",
    data: function_id,
    url: "./js/anchor_func.js",
    datatype: "text",
    converters: {'text script': window.String},
    cache: false,
  });
};

GSI.Utils.get2ndMesh = function (lat, lon) {

  //1st mesh code
  var lat1 = Math.floor((lat * 60) / 40);
  var lat2 = (lat * 60) % 40;

  var lon1 = Math.floor(lon - 100);
  var lon2 = lon - 100 - lon1;

  //2nd mesh code
  var m2lat = Math.floor(lat2 / 5);
  var m2lon = Math.floor((lon2 * 60) / 7.5);

  return "" + lat1 + lon1 + m2lat + m2lon;
};
GSI.Utils.rpad = function (src, letter, num) {
  var dst = src;
  var len = num - src.length;
  if (dst) dst = "";
  for (var i = 0; i < len; i++) {
    dst += letter;
  }
  return dst;
};
GSI.Utils.lpad = function (src, letter, num) {
  var dst = "";
  var len = num - src.length;
  for (var i = 0; i < len; i++) {
    dst += letter;
  }
  return dst + src;
};

L.LatLng.prototype._originalDistanceTo = L.LatLng.prototype.distanceTo;
L.LatLng.prototype.distanceTo = function (other) {
  other = L.latLng(other);
  var ret = null;

  if (CONFIG.USEGSIDISTANCE)
    return GSI.Utils.DistanceCalculator.calc(this, other);
  else
    return L.LatLng.prototype._originalDistanceTo.call(this, other);

};
GSI.Utils.setMixBlendMode = function (item, flg) {
  if ((flg != true) && (flg != "1")) {
    flg = false;
  }
  if (flg == "1") {
    flg = true;
  }

  if (item._visibleInfo.layer.setBlendEnable) {
    item._visibleInfo.layer.setBlendEnable(flg);
    return;
  }
  if (item._visibleInfo.layer._container == null) {
    return;
  }
  if (GSI.Utils.Browser.ie || L.Browser.edge) {
    return;
  }
  if ((flg === undefined) || (flg == null)) {
    //flg = false;
    return;
  }

  var el = item._visibleInfo.layer._container.getAttribute('style');
  if (el) {
    el = el.replace("mix-blend-mode: multiply; ", "");
  }
  else {
    el = "";
  }
  if (flg == true) {
    el = "mix-blend-mode: multiply; " + el;
  }
  item._visibleInfo.layer._container.setAttribute('style', el);
};

GSI.Utils.objAssign = function(tt, src){
  var dest;
  if (Array.isArray(src) == true){
    dest = $.extend([], src);
  }
  else{
    dest = $.extend({}, src);

  }

  return dest;
};

GSI.Utils.getNextOutsideTileNo = function(){
	if ( !GSI.Utils._outsideTileNo ){
		GSI.Utils._outsideTileNo = 0;
	}

	return GSI.Utils._outsideTileNo++;
};

/************************************************************************
 GSI.UTM
 ************************************************************************/
GSI.UTM = {};

GSI.UTM.Utils = {

  PROJ_WORLD: new Proj4js.Proj('EPSG:4326'),
  lng2Zone: function (lng) {
    return Math.floor(lng / 6) + 31;
  },
  zone2Lng: function (zone) {
    return (zone - 31) * 6;
  },
  getUTMDefName: function (zone) {
    var defName = '';

    if (!zone) return defName;
    switch (zone + '') {
      case '51':
        defName = 'EPSG:3097';
        break;
      case '52':
        defName = 'EPSG:3098';
        break;
      case '53':
        defName = 'EPSG:3099';
        break;
      case '54':
        defName = 'EPSG:3100';
        break;
      case '55':
        defName = 'EPSG:3101';
        break;
      case '56':
        defName = 'SR-ORG:1235';
        break;
    }
    return defName;
  },
  getUTMMark: function (lat) {
    var mark = '';
    if (lat >= 16 && lat < 24) {
      mark = "Q";
    } else if (lat >= 24 && lat < 32) {
      mark = "R";
    } else if (lat >= 32 && lat < 40) {
      mark = "S";
    } else if (lat >= 40 && lat < 48) {
      mark = "T";
    } else if (lat >= 48 && lat < 56) {
      mark = "U";
    }
    return mark;
  },
  _parseUSNGText: function (s) {
    var result = {};
    var j = 0;
    var k;
    var usngStr = [];
    var usngStr_temp = []

    usngStr_temp = s.toUpperCase()

    var regexp = /%20/g
    usngStr = usngStr_temp.replace(regexp, "")
    regexp = / /g
    usngStr = usngStr_temp.replace(regexp, "")

    if (usngStr.length < 7) {
      return null;
    }

    result.zone = usngStr.charAt(j++) * 10 + usngStr.charAt(j++) * 1;
    result.mylet = usngStr.charAt(j++)
    result.sq1 = usngStr.charAt(j++)
    result.sq2 = usngStr.charAt(j++)

    result.precision = (usngStr.length - j) / 2;
    result.east = '';
    result.north = '';
    for (var k = 0; k < result.precision; k++) {
      result.east += usngStr.charAt(j++)
    }

    if (usngStr[j] == " ") { j++ }
    for (var k = 0; k < result.precision; k++) {
      result.north += usngStr.charAt(j++)
    }

    return result;
  },
  _USNGtoUTM: function (zone, mylet, sq1, sq2, east, north) {
    var result = {};

    //Starts (southern edge) of N-S zones in millons of meters
    var zoneBase = [1.1, 2.0, 2.9, 3.8, 4.7, 5.6, 6.5, 7.3, 8.2, 9.1, 0, 0.8, 1.7, 2.6, 3.5, 4.4, 5.3, 6.2, 7.0, 7.9];

    var segBase = [0, 2, 2, 2, 4, 4, 6, 6, 8, 8, 0, 0, 0, 2, 2, 4, 4, 6, 6, 6];  //Starts of 2 million meter segments, indexed by zone

    // convert easting to UTM
    var eSqrs = "ABCDEFGHJKLMNPQRSTUVWXYZ".indexOf(sq1);
    var appxEast = 1 + eSqrs % 8;

    // convert northing to UTM
    var letNorth = "CDEFGHJKLMNPQRSTUVWX".indexOf(mylet);
    if (zone % 2)  //odd number zone
      var nSqrs = "ABCDEFGHJKLMNPQRSTUV".indexOf(sq2)
    else        // even number zone
      var nSqrs = "FGHJKLMNPQRSTUVABCDE".indexOf(sq2);

    var zoneStart = zoneBase[letNorth];
    var appxNorth = Number(segBase[letNorth]) + nSqrs / 10;
    if (appxNorth < zoneStart)
      appxNorth += 2;

    result.N = appxNorth * 1000000 + Number(north) * Math.pow(10, 5 - north.length);
    result.E = appxEast * 100000 + Number(east) * Math.pow(10, 5 - east.length)
    result.zone = zone;
    result.letter = mylet;

    return result;
  },
  _UTMtoLL: function (UTMNorthing, UTMEasting, UTMZoneNumber, ret) {
    var EASTING_OFFSET = 500000.0;   // (meters)
    var NORTHING_OFFSET = 10000000.0; // (meters)
    var k0 = 0.9996;
    var EQUATORIAL_RADIUS = 6378137.0; // GRS80 ellipsoid (meters)
    var ECC_SQUARED = 0.006694380023;
    var ECC_PRIME_SQUARED = ECC_SQUARED / (1 - ECC_SQUARED);
    var E1 = (1 - Math.sqrt(1 - ECC_SQUARED)) / (1 + Math.sqrt(1 - ECC_SQUARED));
    var RAD_2_DEG = 180.0 / Math.PI;

    // remove 500,000 meter offset for longitude
    var xUTM = parseFloat(UTMEasting) - EASTING_OFFSET;
    var yUTM = parseFloat(UTMNorthing);
    var zoneNumber = parseInt(UTMZoneNumber);

    // origin longitude for the zone (+3 puts origin in zone center)
    var lonOrigin = (zoneNumber - 1) * 6 - 180 + 3;

    // M is the "true distance along the central meridian from the Equator to phi
    // (latitude)
    var M = yUTM / k0;
    var mu = M / (EQUATORIAL_RADIUS * (1 - ECC_SQUARED / 4 - 3 * ECC_SQUARED *
      ECC_SQUARED / 64 - 5 * ECC_SQUARED * ECC_SQUARED * ECC_SQUARED / 256));

    // phi1 is the "footprint latitude" or the latitude at the central meridian which
    // has the same y coordinate as that of the point (phi (lat), lambda (lon) ).
    var phi1Rad = mu + (3 * E1 / 2 - 27 * E1 * E1 * E1 / 32) * Math.sin(2 * mu)
      + (21 * E1 * E1 / 16 - 55 * E1 * E1 * E1 * E1 / 32) * Math.sin(4 * mu)
      + (151 * E1 * E1 * E1 / 96) * Math.sin(6 * mu);
    var phi1 = phi1Rad * RAD_2_DEG;

    // Terms used in the conversion equations
    var N1 = EQUATORIAL_RADIUS / Math.sqrt(1 - ECC_SQUARED * Math.sin(phi1Rad) *
      Math.sin(phi1Rad));
    var T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
    var C1 = ECC_PRIME_SQUARED * Math.cos(phi1Rad) * Math.cos(phi1Rad);
    var R1 = EQUATORIAL_RADIUS * (1 - ECC_SQUARED) / Math.pow(1 - ECC_SQUARED *
      Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
    var D = xUTM / (N1 * k0);

    // Calculate latitude, in decimal degrees
    var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10
      * C1 - 4 * C1 * C1 - 9 * ECC_PRIME_SQUARED) * D * D * D * D / 24 + (61 + 90 *
        T1 + 298 * C1 + 45 * T1 * T1 - 252 * ECC_PRIME_SQUARED - 3 * C1 * C1) * D * D *
      D * D * D * D / 720);
    lat = lat * RAD_2_DEG;

    // Calculate longitude, in decimal degrees
    var lng = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 *
      C1 * C1 + 8 * ECC_PRIME_SQUARED + 24 * T1 * T1) * D * D * D * D * D / 120) /
      Math.cos(phi1Rad);

    lng = lonOrigin + lng * RAD_2_DEG;
    return L.latLng(lat, lng);
  },
  point2LatLng: function (s) {
    var latLng = null;
    try {
      var usngp = this._parseUSNGText(s, usngp);
      if (!usngp) return null;
      var coords = this._USNGtoUTM(usngp.zone, usngp.mylet, usngp.sq1, usngp.sq2, usngp.east, usngp.north)

      if (usngp.mylet < 'N') {
        coords.N -= NORTHING_OFFSET
      }

      latLng = this._UTMtoLL(coords.N, coords.E, usngp.zone)
    }
    catch (e) {
      latLng = null;
    }
    return latLng;
  },
  latlng2PointName: function (lat, lng) {
    var zone = GSI.UTM.Utils.lng2Zone(lng);
    var defName = GSI.UTM.Utils.getUTMDefName(zone);

    if (defName == '') return '';

    var projUTM = new Proj4js.Proj(defName);
    var latLngPoint = new Proj4js.Point(lng, lat);
    var utmPoint = Proj4js.transform(GSI.UTM.Utils.PROJ_WORLD, projUTM, latLngPoint);

    return GSI.UTM.Utils.getUTMPointName(
      zone,
      GSI.UTM.Utils.getUTMMark(lat),
      utmPoint.x,
      utmPoint.y,
      4
    );
  },
  getUTMPointName: function (zone, mark, x, y, num, hideNumber) {

    var x10mNumber = '';
    var y10mNumber = '';
    if (!hideNumber && x && y) {
      var zero = '';
      for (var i = 0; i < num; i++) {
        zero += '0';
      }

      x10mNumber = zero + Math.floor(x / 10);
      x10mNumber = x10mNumber.substr(x10mNumber.length - num, num);
      y10mNumber = zero + Math.floor(y / 10);
      y10mNumber = y10mNumber.substr(y10mNumber.length - num, num);
    }

    var letters = GSI.UTM.Utils.findGridLetters(zone, Math.floor(y / 10) * 10, Math.floor(x / 10) * 10);
    return zone + mark + letters + x10mNumber + y10mNumber;
  },
  findSet: function (zoneNum) {
    zoneNum = parseInt(zoneNum);
    zoneNum = zoneNum % 6;
    switch (zoneNum) {

      case 0:
        return 6;

      case 1:
        return 1;

      case 2:
        return 2;

      case 3:
        return 3;

      case 4:
        return 4;

      case 5:
        return 5;

      default:
        return -1;
    }
  },
  BLOCK_SIZE: 100000,
  GRIDSQUARE_SET_ROW_SIZE: 20,
  GRIDSQUARE_SET_COL_SIZE: 8,

  findGridLetters: function (zoneNum, northing, easting) {
    zoneNum = parseInt(zoneNum);
    northing = parseFloat(northing);
    easting = parseFloat(easting);
    row = 1;

    // northing coordinate to single-meter precision
    north_1m = Math.round(northing);

    // Get the row position for the square identifier that contains the point
    while (north_1m >= GSI.UTM.Utils.BLOCK_SIZE) {
      north_1m = north_1m - GSI.UTM.Utils.BLOCK_SIZE;
      row++;
    }

    // cycle repeats (wraps) after 20 rows
    row = row % GSI.UTM.Utils.GRIDSQUARE_SET_ROW_SIZE;
    col = 0;

    // easting coordinate to single-meter precision
    east_1m = Math.round(easting);

    // Get the column position for the square identifier that contains the point
    while (east_1m >= GSI.UTM.Utils.BLOCK_SIZE) {
      east_1m = east_1m - GSI.UTM.Utils.BLOCK_SIZE;
      col++;
    }

    // cycle repeats (wraps) after 8 columns
    col = col % GSI.UTM.Utils.GRIDSQUARE_SET_COL_SIZE;

    return GSI.UTM.Utils.lettersHelper(GSI.UTM.Utils.findSet(zoneNum), row, col);
  },
  lettersHelper: function (set, row, col) {
    // handle case of last row
    if (row == 0) {
      row = GSI.UTM.Utils.GRIDSQUARE_SET_ROW_SIZE - 1;
    }
    else {
      row--;
    }

    if (col == 0) {
      col = GSI.UTM.Utils.GRIDSQUARE_SET_COL_SIZE - 1;
    }
    else {
      col--;
    }

    switch (set) {

      case 1:
        l1 = "ABCDEFGH";              // column ids
        l2 = "ABCDEFGHJKLMNPQRSTUV";  // row ids
        return l1.charAt(col) + l2.charAt(row);

      case 2:
        l1 = "JKLMNPQR";
        l2 = "FGHJKLMNPQRSTUVABCDE";
        return l1.charAt(col) + l2.charAt(row);

      case 3:
        l1 = "STUVWXYZ";
        l2 = "ABCDEFGHJKLMNPQRSTUV";
        return l1.charAt(col) + l2.charAt(row);

      case 4:
        l1 = "ABCDEFGH";
        l2 = "FGHJKLMNPQRSTUVABCDE";
        return l1.charAt(col) + l2.charAt(row);

      case 5:
        l1 = "JKLMNPQR";
        l2 = "ABCDEFGHJKLMNPQRSTUV";
        return l1.charAt(col) + l2.charAt(row);

      case 6:
        l1 = "STUVWXYZ";
        l2 = "FGHJKLMNPQRSTUVABCDE";
        return l1.charAt(col) + l2.charAt(row);
    }
  }
};

GSI.UTM.Grid = L.Evented.extend({

  options: {
    lineStyle: {
      color: "#FF0000",
      weight: 2,
      color2: "#FF0000",
      opacity: 1,
      fillOpacity: 1,
      dashArray: [3, 3],
      visible: false,
      clickable: false,
      noGeodesic: true
    },
    zoneLineStyle: {
      color: "#FF0000",
      weight: 2,
      color2: "#FF0000",
      opacity: 1,
      fillOpacity: 1,
      dashArray: null,
      visible: false,
      clickable: false,
      noGeodesic: true
    },
    labelClassName: 'utmgrid_label',
    visible: false
  },
  _lines: [],
  _labels: [],
  _zoneLines: [],
  _zoneLabels: [],
  initialize: function (map, options) {
    this._lines = [];
    this._labels = [];
    this._zoneLines = [];
    this._zoneLabels = [];

    this._map = map;
    this._onMoveEnd = L.bind(this.onMoveEnd, this);

    options = L.setOptions(this, options);
    options.lineStyle.clickable = false;
    options.lineStyle.noGeodesic = true;
    options.zoneLineStyle.noGeodesic = true;
    if (this.options.visible) {
      this.options.visible = false;
      this.setVisible(true);//this.refresh();
    }
  },
  onMoveEnd: function () {
    this.refresh();
  },
  refresh: function () {
    if (!this.options.visible) {
      this.clear();
      return;
    }

    if (GSI.Utils.Browser.ie && GSI.Utils.Browser.version <= 8) {
      this.clear();
    }

    var bounds = this._map.getBounds();
    var zoom = this._map.getZoom();

    for (var i = 0; i < this.options.condition.length; i++) {
      var c = this.options.condition[i];
      if (zoom <= c.zoom) {
        if (c.grid == 'a') {
          this._clearLayerArr(this._lines, 0);
          this._clearLayerArr(this._labels, 0);
          this.drawZoneGrid(bounds);
        }
        else {
          this.drawGrid(bounds, zoom, c.grid);
          this.drawZoneGrid(bounds, true, this.options.zoneLineStyle);
        }
        try {
          if (this._layer) this._layer.bringToBack();
        }
        catch (ex) { }
        break;
      }
    }
  },

  drawPath: function (texture, latLngBounds, pixelBounds) {
    var bounds = (latLngBounds ? latLngBounds : this._map.getBounds());
    pixelBounds = (pixelBounds ? pixelBounds : this._map.getPixelBounds());
    var zoom = this._map.getZoom();

    for (var i = 0; i < this.options.condition.length; i++) {
      var c = this.options.condition[i];
      if (zoom <= c.zoom) {
        if (c.grid == 'a') {
          this.drawZoneGridPath(texture, pixelBounds, bounds);
        }
        else {
          this.drawGridPath(texture, pixelBounds, bounds, zoom, c.grid);
          this.drawZoneGridPath(texture, pixelBounds, bounds, true, this.options.zoneLineStyle);
        }
        break;
      }
    }
  },

  _drawTextToTexture: function (texture, latlng, text, pixelBounds) {
    var zoom = this._map.getZoom();
    var p = this._map.project(latlng, zoom);
    p.x -= pixelBounds.min.x;
    p.y -= pixelBounds.min.y;
    texture.globalAlpha = 1.0;
    texture.fillStyle = this.options.lineStyle.color;
    texture.textBaseline = 'bottom';
    texture.textAlign = 'left';
    texture.font = "bold 12pt 'Lucida Grande','Hiragino Kaku Gothic ProN', 'ヒラギノ角ゴ ProN W3', Meiryo, メイリオ, sans-serif";
    texture.fillText(text, p.x + 8, p.y - 6);
  },

  _drawGridLineToTexture: function (texture, latlngs, pixelBounds, lineStyle) {
    var zoom = this._map.getZoom();
    latlngs = (L.LineUtil.isFlat(latlngs) ? latlngs : latlngs[0]);
    texture.beginPath();
    texture.lineWidth = lineStyle.weight;
    texture.strokeStyle = lineStyle.color;

    if (latlngs.length > 0) {
      var p = this._map.project(latlngs[0], zoom);
      p.x -= pixelBounds.min.x;
      p.y -= pixelBounds.min.y;
      texture.moveTo(p.x, p.y);
    }
    for (var i = 1; i < latlngs.length; i++) {

      var p1 = this._map.project(latlngs[i - 1], zoom);
      var p2 = this._map.project(latlngs[i], zoom);
      p1.x -= pixelBounds.min.x;
      p1.y -= pixelBounds.min.y;
      p2.x -= pixelBounds.min.x;
      p2.y -= pixelBounds.min.y;

      if (lineStyle.dashArray && lineStyle.dashArray.length > 0)
        this._lineToDot(texture, p1.x, p1.y, p2.x, p2.y);
      else
        texture.lineTo(p2.x, p2.y);

    }
    texture.stroke();

  },

  drawGridPath: function (texture, pixelBounds, bounds, zoom, meter) {
    // グリッド
    var startZone = GSI.UTM.Utils.lng2Zone(bounds.getWest());
    var projUTM = new Proj4js.Proj(GSI.UTM.Utils.getUTMDefName(startZone));
    var startLatLngPoint = new Proj4js.Point(bounds.getWest(), bounds.getSouth());
    var startUTMPoint = Proj4js.transform(GSI.UTM.Utils.PROJ_WORLD, projUTM, startLatLngPoint);

    startUTMPoint.x = Math.floor(startUTMPoint.x / meter) * meter;
    startUTMPoint.x -= meter;

    startUTMPoint.y = Math.floor(startUTMPoint.y / meter) * meter;
    startUTMPoint.y -= meter;

    // x軸ループ
    var utmX = startUTMPoint.x;
    var zone = startZone;
    var lineStyle = $.extend(true, {}, this.options.lineStyle);
    var xExit = false;

    var gridPoints = [];
    var gridPoints2 = [];

    var lineIndex = 0;
    var labelIndex = 0;

    while (true) {
      var currentZoneLng = GSI.UTM.Utils.zone2Lng(zone);
      var nextZoneLng = GSI.UTM.Utils.zone2Lng(zone + 1);

      var isNextZone = true;
      var xExit2 = true;

      // y軸ループ
      var latlngs = [];
      var labelLatlngs = [];
      var utmYs = [];
      var utmY = startUTMPoint.y;
      var yIndex = 0;
      var yIndex2 = 0;

      var x10mNumber = '';
      if (meter < 100 * 1000) {
        x10mNumber = utmX;
      }

      var lastMark = '';

      while (true) {
        var utmPoint = new Proj4js.Point(utmX, utmY);
        var latLngPoint = Proj4js.transform(projUTM, GSI.UTM.Utils.PROJ_WORLD, utmPoint);
        var mark = GSI.UTM.Utils.getUTMMark(latLngPoint.y);

        if (lastMark != '' && lastMark != mark) {

          var latLng = L.latLng(24 + Math.floor((latLngPoint.y - 24) / 8) * 8, latLngPoint.x);

          var changeUTMPoint = Proj4js.transform(GSI.UTM.Utils.PROJ_WORLD, projUTM, new Proj4js.Point(latLng.lng, latLng.lat));

          utmYs.push(changeUTMPoint.y);
          if (CONFIG.UTMGRIDBOUNDARYLABEL_HIDEMETER) latLng._hideMeter = true
          labelLatlngs.push(latLng);

          if (!gridPoints2[yIndex2]) gridPoints2[yIndex2] = [];
          gridPoints2[yIndex2].push(latLng);

          yIndex2++;
        }

        lastMark = mark;

        var latLng = L.latLng(latLngPoint.y, latLngPoint.x);

        utmYs.push(utmY);
        latlngs.push(latLng);
        labelLatlngs.push(latLng);

        if (!gridPoints[yIndex]) gridPoints[yIndex] = [];
        gridPoints[yIndex].push(latLng);

        if (latLngPoint.x < nextZoneLng) isNextZone = false;
        if (latLngPoint.x <= bounds.getEast()) xExit2 = false;

        yIndex++;
        utmY += meter;
        if (latLngPoint.y > bounds.getNorth()) break;
      }

      if (latlngs.length > 0) {
        this._drawGridLineToTexture(texture, latlngs, pixelBounds, lineStyle);
        lineIndex++;
      }

      if (isNextZone) {
        // 横線
        for (var i = 0; i < gridPoints.length; i++) {
          if (!gridPoints[i]) continue;

          this._drawGridLineToTexture(texture, gridPoints[i], pixelBounds, lineStyle);

          lineIndex++;
        }

        for (var i = 0; i < gridPoints2.length; i++) {
          if (!gridPoints2[i]) continue;
          this._drawGridLineToTexture(texture, gridPoints2[i], pixelBounds, lineStyle);
          lineIndex++;
        }

        gridPoints = [];
        gridPoints2 = [];
        zone++;
        projUTM = new Proj4js.Proj(GSI.UTM.Utils.getUTMDefName(zone));

        startLatLngPoint = new Proj4js.Point(GSI.UTM.Utils.zone2Lng(zone), bounds.getSouth());
        startUTMPoint = Proj4js.transform(GSI.UTM.Utils.PROJ_WORLD, projUTM, startLatLngPoint);

        startUTMPoint.x = Math.floor(startUTMPoint.x / meter) * meter;
        startUTMPoint.x -= meter;

        startUTMPoint.y = Math.floor(startUTMPoint.y / meter) * meter;
        startUTMPoint.y -= meter;
        utmX = startUTMPoint.x;
      }
      else {
        // ラベル表示
        for (var i = 0; i < labelLatlngs.length; i++) {
          var latlng = labelLatlngs[i];
          var utmY = utmYs[i];
          var mark = GSI.UTM.Utils.getUTMMark(latlng.lat); // 2015-07-19

          this._drawTextToTexture(texture, latlng,
            GSI.UTM.Utils.getUTMPointName(zone, mark, utmX, utmY, 4, (latlng._hideMeter || meter >= 100000)), pixelBounds);

          labelIndex++;
        }
      }
      if (xExit) {
        // 横線
        for (var i = 0; i < gridPoints.length; i++) {
          if (!gridPoints[i]) continue;

          this._drawGridLineToTexture(texture, gridPoints[i], pixelBounds, lineStyle);

          lineIndex++;
        }

        for (var i = 0; i < gridPoints2.length; i++) {
          if (!gridPoints2[i]) continue;
          this._drawGridLineToTexture(texture, gridPoints2[i], pixelBounds, lineStyle);
          lineIndex++;
        }

        gridPoints = [];
        gridPoints2 = [];
        break;
      }

      utmX += meter;
      xExit = xExit2;
    }
  },

  drawZoneGridPath: function (texture, pixelBounds, bounds, nolabel, style) {
    // 小縮尺用グリッド
    var startX = Math.floor(bounds.getWest() / 6) * 6;
    var startY = Math.floor(bounds.getSouth() / 8) * 8;

    var endX = (Math.floor(bounds.getEast() / 6) + 1) * 6;
    var endY = (Math.floor(bounds.getNorth() / 8) + 1) * 8;

    var lineStyle = $.extend(true, {}, (style ? style : this.options.lineStyle));

    var lineIndex = 0;
    var labelIndex = 0;

    for (var y = startY; y <= endY; y += 8) {
      var mark = GSI.UTM.Utils.getUTMMark(y);

      if (y < 16) continue;
      if (y >= 57) break;

      var latlngs = [];
      for (var x = startX; x <= endX; x += 6) {
        if (!nolabel) {
          var zone = Math.floor(x / 6) + 31;
          var nextZone = Math.floor((x + 6) / 6) + 31;

          if (zone < 51) continue;
          if (zone > 57) break;

          if (y + 8 <= endY && y + 8 < 57 && x + 6 <= endX && nextZone <= 57) {
            this._drawTextToTexture(texture, L.latLng([y, x]), //{ 'lng' : x, 'lat' : y} ,
              zone + mark, pixelBounds);
            labelIndex++;
          }
        }
        latlngs.push(L.latLng(y, x));
      }
      this._drawGridLineToTexture(texture, latlngs, pixelBounds, lineStyle);

      lineIndex++;
    }

    for (var x = startX; x <= endX; x += 6) {
      var zone = Math.floor(x / 6) + 31;
      if (zone < 51 || zone > 57) continue;

      var latlngs = [];

      for (var y = startY; y <= endY; y += 8) {
        if (y < 16 || y >= 57) continue;

        latlngs.push(L.latLng(y, x));
      }
      this._drawGridLineToTexture(texture, latlngs, pixelBounds, lineStyle);

      lineIndex++;
    }
  },

  _lineToDot: function (texture, p1x, p1y, p2x, p2y) {
    var d = Math.sqrt(Math.pow(p2x - p1x, 2) + Math.pow(p2y - p1y, 2));
    var rad = Math.atan2(p2y - p1y, p2x - p1x);
    var space = 3;
    var dotted = Math.round(d / space / 2);

    for (var i = 0; i < dotted; i++) {
      var p3x = Math.cos(rad) * space * (i * 2) + p1x;
      var p3y = Math.sin(rad) * space * (i * 2) + p1y;
      var p4x = Math.cos(rad) * space * (i * 2 + 1) + p1x;
      var p4y = Math.sin(rad) * space * (i * 2 + 1) + p1y;

      texture.moveTo(p3x, p3y);
      texture.lineTo(p4x, p4y);

    }
  },

  _updateStyle: function (texture, layer) {
    if (!layer._parts) return;

    var options = layer.options;
    if (options.stroke) {
      texture.lineWidth = options.weight;
      texture.strokeStyle = options.color;
    }
    if (options.fill) {
      texture.fillStyle = options.fillColor || options.color;
    }
  },

  _drawPath: function (texture, layer) {
    if (!layer._parts) return;

    var i, j, len, len2, point, drawMethod;
    var vp = this._map._pathViewport;

    var origin = this._map.getPixelOrigin();
    var pixelBounds = this._map.getPixelBounds();
    texture.beginPath();

    var parts = layer._parts;

    for (i = 0, len = parts.length; i < len; i++) {

      for (j = 0, len2 = parts[i].length; j < len2; j++) {
        point = parts[i][j];
        drawMethod = (j === 0 ? 'move' : 'line') + 'To';

        texture[drawMethod](point.x + (origin.x - pixelBounds.min.x), point.y + (origin.y - pixelBounds.min.y));
      }
      // TODO refactor ugly hack
      if (layer instanceof L.Polygon || layer instanceof L.Circle) {
        texture.closePath();
      }
    }

    texture.save();
    this._updateStyle(texture, layer);

    var opacity = 1;
    if (layer.options.fill) {

      texture.globalAlpha = (layer.options.fillOpacity ? layer.options.fillOpacity : 1) * opacity;
      texture.fill();
    }
    if (layer.options.stroke) {
      texture.globalAlpha = opacity;
      texture.stroke();
    }

    texture.restore();
  },

  drawGrid: function (bounds, zoom, meter) {
    // グリッド
    var startZone = GSI.UTM.Utils.lng2Zone(bounds.getWest());
    var projUTM = new Proj4js.Proj(GSI.UTM.Utils.getUTMDefName(startZone));
    var startLatLngPoint = new Proj4js.Point(bounds.getWest(), bounds.getSouth());
    var startUTMPoint = Proj4js.transform(GSI.UTM.Utils.PROJ_WORLD, projUTM, startLatLngPoint);

    startUTMPoint.x = Math.floor(startUTMPoint.x / meter) * meter;
    startUTMPoint.x -= meter;

    startUTMPoint.y = Math.floor(startUTMPoint.y / meter) * meter;
    startUTMPoint.y -= meter;

    // x軸ループ
    var utmX = startUTMPoint.x;
    var zone = startZone;
    var lineStyle = $.extend(true, {}, this.options.lineStyle);
    var xExit = false;

    var gridPoints = [];
    var gridPoints2 = [];

    var lineIndex = 0;
    var labelIndex = 0;

    var layer = (this._layer ? this._layer : L.featureGroup());
    layer._noMeasure = true;

    while (true) {
      var currentZoneLng = GSI.UTM.Utils.zone2Lng(zone);
      var nextZoneLng = GSI.UTM.Utils.zone2Lng(zone + 1);

      var isNextZone = true;
      var xExit2 = true;

      // y軸ループ
      var latlngs = [];
      var labelLatlngs = [];
      var utmYs = [];
      var utmY = startUTMPoint.y;
      var yIndex = 0;
      var yIndex2 = 0;

      var x10mNumber = '';
      if (meter < 100 * 1000) {
        x10mNumber = utmX;
      }

      var lastMark = '';

      while (true) {
        var utmPoint = new Proj4js.Point(utmX, utmY);
        var latLngPoint = Proj4js.transform(projUTM, GSI.UTM.Utils.PROJ_WORLD, utmPoint);
        var mark = GSI.UTM.Utils.getUTMMark(latLngPoint.y);

        if (lastMark != '' && lastMark != mark) {

          var latLng = L.latLng(24 + Math.floor((latLngPoint.y - 24) / 8) * 8, latLngPoint.x);

          var changeUTMPoint = Proj4js.transform(GSI.UTM.Utils.PROJ_WORLD, projUTM, new Proj4js.Point(latLng.lng, latLng.lat));

          utmYs.push(changeUTMPoint.y);
          if (CONFIG.UTMGRIDBOUNDARYLABEL_HIDEMETER) latLng._hideMeter = true
          labelLatlngs.push(latLng);

          if (!gridPoints2[yIndex2]) gridPoints2[yIndex2] = [];
          gridPoints2[yIndex2].push(latLng);

          yIndex2++;
        }

        lastMark = mark;

        var latLng = L.latLng(latLngPoint.y, latLngPoint.x);

        utmYs.push(utmY);
        latlngs.push(latLng);
        labelLatlngs.push(latLng);

        if (!gridPoints[yIndex]) gridPoints[yIndex] = [];
        gridPoints[yIndex].push(latLng);

        if (latLngPoint.x < nextZoneLng) isNextZone = false;
        if (latLngPoint.x <= bounds.getEast()) xExit2 = false;

        yIndex++;
        utmY += meter;
        if (latLngPoint.y > bounds.getNorth()) break;
      }

      if (latlngs.length > 0) {
        if (this._lines.length <= lineIndex) {
          var polyline = L.polyline(latlngs, lineStyle);
          polyline._noMeasure = true;
          layer.addLayer(polyline);
          this._lines.push(polyline);
        }
        else {
          var polyline = this._lines[lineIndex];
          polyline.setLatLngs(latlngs);
        }
        lineIndex++;
      }

      if (isNextZone) {
        // 横線
        for (var i = 0; i < gridPoints.length; i++) {
          if (!gridPoints[i]) continue;
          if (this._lines.length <= lineIndex) {
            var polyline = L.polyline(gridPoints[i], lineStyle);
            polyline._noMeasure = true;
            layer.addLayer(polyline);
            this._lines.push(polyline);
          }
          else {
            var polyline = this._lines[lineIndex];
            polyline.setLatLngs(gridPoints[i]);
          }
          lineIndex++;
        }

        for (var i = 0; i < gridPoints2.length; i++) {
          if (!gridPoints2[i]) continue;
          if (this._lines.length <= lineIndex) {
            var polyline = L.polyline(gridPoints2[i], lineStyle);
            polyline._noMeasure = true;
            layer.addLayer(polyline);
            this._lines.push(polyline);
          }
          else {
            var polyline = this._lines[lineIndex];
            polyline.setLatLngs(gridPoints2[i]);
          }
          lineIndex++;
        }

        gridPoints = [];
        gridPoints2 = [];
        zone++;
        projUTM = new Proj4js.Proj(GSI.UTM.Utils.getUTMDefName(zone));

        startLatLngPoint = new Proj4js.Point(GSI.UTM.Utils.zone2Lng(zone), bounds.getSouth());
        startUTMPoint = Proj4js.transform(GSI.UTM.Utils.PROJ_WORLD, projUTM, startLatLngPoint);

        startUTMPoint.x = Math.floor(startUTMPoint.x / meter) * meter;
        startUTMPoint.x -= meter;

        startUTMPoint.y = Math.floor(startUTMPoint.y / meter) * meter;
        startUTMPoint.y -= meter;
        utmX = startUTMPoint.x;
      }
      else {
        // ラベル表示
        for (var i = 0; i < labelLatlngs.length; i++) {
          var latlng = labelLatlngs[i];
          var utmY = utmYs[i];
          var mark = GSI.UTM.Utils.getUTMMark(latlng.lat); // 2015-07-19
          if (this._labels.length <= labelIndex) {
            var label = new L.Label({
              zoomAnimation: true,
              noHide: true,
              offset: [8, -24],
              className: this.options.labelClassName + " nomaptoimage",
              clickable: false
            });
            label.setContent(GSI.UTM.Utils.getUTMPointName(zone, mark, utmX, utmY, 4, (latlng._hideMeter || meter >= 100000)));
            label.setLatLng(latlng);
            layer.addLayer(label);
            this._labels.push(label);
          }
          else {
            var label = this._labels[labelIndex];
            label.setContent(GSI.UTM.Utils.getUTMPointName(zone, mark, utmX, utmY, 4, (latlng._hideMeter || meter >= 100000)));
            label.setLatLng(latlng);
          }
          labelIndex++;
        }
      }
      if (xExit) {
        // 横線
        for (var i = 0; i < gridPoints.length; i++) {
          if (!gridPoints[i]) continue;

          if (this._lines.length <= lineIndex) {
            var polyline = L.polyline(gridPoints[i], lineStyle);
            polyline._noMeasure = true;
            layer.addLayer(polyline);
            this._lines.push(polyline);

          }
          else {
            var polyline = this._lines[lineIndex];
            polyline.setLatLngs(gridPoints[i]);
          }
          lineIndex++;
        }

        for (var i = 0; i < gridPoints2.length; i++) {
          if (!gridPoints2[i]) continue;
          if (this._lines.length <= lineIndex) {
            var polyline = L.polyline(gridPoints2[i], lineStyle);
            polyline._noMeasure = true;
            layer.addLayer(polyline);
            this._lines.push(polyline);
          }
          else {
            var polyline = this._lines[lineIndex];
            polyline.setLatLngs(gridPoints2[i]);
          }
          lineIndex++;
        }

        gridPoints = [];
        gridPoints2 = [];
        break;
      }

      utmX += meter;
      xExit = xExit2;
    }

    if (!this._layer) {
      this._layer = layer;
      this._map.addLayer(this._layer);
    }

    this._clearLayerArr(this._lines, lineIndex);
    this._clearLayerArr(this._labels, labelIndex);

  },
  drawZoneGrid: function (bounds, nolabel, style) {
    // 小縮尺用グリッド
    var startX = Math.floor(bounds.getWest() / 6) * 6;
    var startY = Math.floor(bounds.getSouth() / 8) * 8;

    var endX = (Math.floor(bounds.getEast() / 6) + 1) * 6;
    var endY = (Math.floor(bounds.getNorth() / 8) + 1) * 8;

    var lineStyle = $.extend(true, {}, (style ? style : this.options.lineStyle));

    var lineIndex = 0;
    var labelIndex = 0;

    var layer = (this._layer ? this._layer : L.featureGroup());
    layer._noMeasure = true;

    for (var y = startY; y <= endY; y += 8) {
      var mark = GSI.UTM.Utils.getUTMMark(y);

      if (y < 16) continue;
      if (y >= 57) break;

      var latlngs = [];
      for (var x = startX; x <= endX; x += 6) {
        if (!nolabel) {
          var zone = Math.floor(x / 6) + 31;
          var nextZone = Math.floor((x + 6) / 6) + 31;

          if (zone < 51) continue;
          if (zone > 57) break;

          if (y + 8 <= endY && y + 8 < 57 && x + 6 <= endX && nextZone <= 57) {
            if (this._zoneLabels.length <= labelIndex) {
              var label = new L.Label({
                zoomAnimation: true,
                noHide: true,
                offset: [8, -24],
                className: this.options.labelClassName + " nomaptoimage"

              });
              label.setContent(zone + mark);
              label.setLatLng({ 'lng': x, 'lat': y });
              layer.addLayer(label);
              this._zoneLabels.push(label);
            }
            else {
              var label = this._zoneLabels[labelIndex];
              label.setContent(zone + mark);
              label.setLatLng({ 'lng': x, 'lat': y });
            }
            labelIndex++;
          }
        }
        latlngs.push(L.latLng(y, x));
      }

      if (this._zoneLines.length <= lineIndex) {
        var polyline = L.polyline(latlngs, lineStyle);
        polyline._noMeasure = true;
        layer.addLayer(polyline);
        this._zoneLines.push(polyline);
      }
      else {
        var polyline = this._zoneLines[lineIndex];
        polyline.setStyle(lineStyle);
        polyline.setLatLngs(latlngs);
      }
      lineIndex++;
    }

    for (var x = startX; x <= endX; x += 6) {
      var zone = Math.floor(x / 6) + 31;
      if (zone < 51 || zone > 57) continue;

      var latlngs = [];

      for (var y = startY; y <= endY; y += 8) {
        if (y < 16 || y >= 57) continue;

        latlngs.push(L.latLng(y, x));
      }
      if (this._zoneLines.length <= lineIndex) {
        var polyline = L.polyline(latlngs, lineStyle);
        polyline._noMeasure = true;
        layer.addLayer(polyline);

        this._zoneLines.push(polyline);
      }
      else {
        var polyline = this._zoneLines[lineIndex];
        polyline.setStyle(lineStyle);
        polyline.setLatLngs(latlngs);
      }
      lineIndex++;
    }

    if (!this._layer) {
      this._layer = layer;
      this._map.addLayer(this._layer);
    }

    this._clearLayerArr(this._zoneLines, lineIndex);
    this._clearLayerArr(this._zoneLabels, labelIndex);
  },
  _clearLayerArr: function (arr, idx) {
    if (this._layer) {
      for (var i = idx; i < arr.length; i++) {
        this._layer.removeLayer(arr[i]);
      }
    }
    if (arr.length > idx) {
      arr.splice(idx);
    }
  },
  clear: function () {
    if (this._layer) {
      this._map.removeLayer(this._layer);
      this._layer = null;
    }

    this._lines = [];
    this._labels = [];
    this._zoneLines = [];
    this._zoneLabels = [];
  },
  setVisible: function (visible) {
    if (visible) {
      this.show();
    }
    else {
      this.hide();
    }

    this.fire("change");
  },
  getVisible: function () {
    return this.options.visible;
  },
  show: function () {
    if (!this.options.visible) {
      this.options.visible = true;
      this._map.on('moveend', this._onMoveEnd);
      this.refresh();
    }
  },
  hide: function () {
    if (this.options.visible) {
      this.options.visible = false;
      this._map.off('moveend', this._onMoveEnd);
      this.refresh();
    }
  }
});

GSI.CenterCross = L.Evented.extend({

  marker: null,
  options: {
    visible: true
  },
  initialize: function (map, options) {
    options = L.setOptions(this, options);
    this.map = map;
    this._refresh = L.bind(this.refresh, this);

    this.setVisible(this.options.visible);
  },
  refresh: function () {
    if (this.options.visible) {
      var pos = this.map.getCenter();
      if (!this.marker) {

        var icon = L.divIcon({
          iconSize: [32, 32],
          iconAnchor: [16, 16],
          className: 'gsi_centercross', html: ""
        });

        this.marker = new GSI.CenterCrossMarker(pos, {
          icon: icon,
          clickable:
            false, draggable: false,
          keyboard: false,
          opacity: 0.8,
          zIndexOffset: 0
        });
        this.marker.addTo(this.map);
      }
      else {
        this.marker.setLatLng(pos);
      }
    }
    else if (this.marker) {
      this.map.removeLayer(this.marker);
      this.marker = null;
    }
  },
  setVisible: function (on) {
    this.options.visible = on;
    if (this.options.visible) {
      this.map.on('move', this._refresh);
    }
    else {
      this.map.off('move', this._refresh);
    }
    this.refresh();

    this.fire("change", { visible: this.options.visible });
  },
  getVisible: function () {
    return this.options.visible;
  }
});

GSI.ZoomGuide = L.Evented.extend({
  options: {
    visible: true
  },
  initialize: function (map, options) {
    options = L.setOptions(this, options);
    this.map = map;
    this.setVisible(this.options.visible);
  },

  setVisible: function (on) {
    this.options.visible = on;
  },
  getVisible: function () {
    return this.options.visible;
  }
});

/************************************************************************
 L.Class
 - GSI.COCOTileLayer
 ************************************************************************/
GSI.COCOTileLayer = L.Layer.extend({
  visible: true,
  options: {
    minZoom: 0,
    maxZoom: 18,
    tileSize: 256,
    errorTileUrl: '',
    zoomOffset: 0,
    refreshInterval: 1000,
    unloadInvisibleTiles: L.Browser.mobile,
    updateWhenIdle: L.Browser.mobile
  },
  initialize: function (map, url, options) {
    this.map = map;
    options = L.setOptions(this, options);
    this.visible = options.visible;
    // detecting retina displays, adjusting tileSize and zoom levels
    if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

      options.tileSize = Math.floor(options.tileSize / 2);
      options.zoomOffset++;

      if (options.minZoom > 0) {
        options.minZoom--;
      }
      this.options.maxZoom--;
    }

    if (options.bounds) {
      options.bounds = L.latLngBounds(options.bounds);
    }

    this._url = url;
    if (options.visible) {
      this.addTo(this.map);
    }
  },
  onAdd: function (map) {
    this._map = map;

    this._reset();
    this._update();

    map.on({
      'viewreset': this._reset,
      'moveend': this._moveend,
      'movestart': this._movestart
    }, this);
  },
  addTo: function (map) {
    this.visible = true;
    map.addLayer(this);
    return this;
  },
  getVisible: function () {
    return this.visible;
  },
  setVisible: function (on) {
    if (on) {
      this.addTo(this.map);
    }
    else if (this._map) {
      this.visible = false;
      this.map.removeLayer(this);
      this.fire('hide', null);
    }
  },
  refresh: function () {
    if (this.visible) {
      this._reset();
      this._update();
    }
  },
  onRemove: function (map) {
    map.off({
      'viewreset': this._reset,
      'moveend': this._update,
      'movestart': this._movestart
    }, this);

    this._map = null;
  },
  _reset: function (e) {

    if (this._tiles) {
      for (var id in this._tiles) {
        var tile = this._tiles[id];
        if (tile.ajax) {
          tile.ajax.abort();
          tile.ajax = null;
        }
      }
    }

    if (this.refreshTimerId) {
      clearTimeout(this.refreshTimerId);
      this.refreshTimerId = null;
    }

    this._haveTiles = {};
    this._tiles = {};
    this._tilesToLoad = 0;
  },
  _moveend: function () {
    if (!this._map) { return; }

    this._reset();
    this.refreshTimerId = setTimeout(
      L.Util.bind(this._timerRefresh, this),
      this.options.refreshInterval);

  },
  _movestart: function () {
    this._reset();
  },
  _timerRefresh: function () {
    this._update();
  },
  _update: function () {

    if (this.refreshTimerId) {
      clearTimeout(this.refreshTimerId);
      this.refreshTimerId = null;
    }

    if (!this._map) { return; }

    var map = this._map,
      bounds = this.map.getPixelBounds(),
      zoom = this.map.getZoom(),
      tileSize = this._getTileSize();

    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
      return;
    }

    var tileBounds = L.bounds(
      bounds.min.divideBy(tileSize)._floor(),
      bounds.max.divideBy(tileSize)._floor());

    this._addTilesFromCenterOut(tileBounds);

  },
  _getTileSize: function () {
    var map = this._map,
      zoom = this.map.getZoom() + this.options.zoomOffset,
      zoomN = this.options.maxNativeZoom,
      tileSize = this.options.tileSize;

    if (zoomN && zoom > zoomN) {
      tileSize = Math.round(this.map.getZoomScale(zoom) / this.map.getZoomScale(zoomN) * tileSize);
    }

    return tileSize;
  },
  _tileShouldBeLoaded: function (tilePoint) {
    if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
      return false; // already loaded
    }

    var options = this.options;

    if (!options.continuousWorld) {
      var limit = this._getWrapTileNum();

      // don't load if exceeds world bounds
      if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||
        tilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }
    }

    if (options.bounds) {
      var tileSize = options.tileSize,
        nwPoint = tilePoint.multiplyBy(tileSize),
        sePoint = nwPoint.add([tileSize, tileSize]),
        nw = this._map.unproject(nwPoint),
        se = this._map.unproject(sePoint);

      // TODO temporary hack, will be removed after refactoring projections
      // https://github.com/Leaflet/Leaflet/issues/1618
      if (!options.continuousWorld && !options.noWrap) {
        nw = nw.wrap();
        se = se.wrap();
      }

      if (!options.bounds.intersects([nw, se])) { return false; }
    }
    return true;
  },
  _addTilesFromCenterOut: function (bounds) {
    var queue = [],
      center = bounds.getCenter();

    var j, i, point;

    for (j = bounds.min.y; j <= bounds.max.y; j++) {
      for (i = bounds.min.x; i <= bounds.max.x; i++) {
        point = new L.Point(i, j);

        if (this._tileShouldBeLoaded(point)) {
          queue.push(point);
        }
      }
    }

    var tilesToLoad = queue.length;

    if (tilesToLoad === 0) { return; }

    queue.sort(function (a, b) {
      return a.distanceTo(center) - b.distanceTo(center);
    });

    this._tilesToLoad += tilesToLoad;

    for (i = 0; i < tilesToLoad; i++) {
      this._addTile(queue[i]);
    }

    this.fire('loadstart', null);
  },
  _getTilePos: function (tilePoint) {
    var origin = this._map.getPixelOrigin(),
      tileSize = this._getTileSize();

    return tilePoint.multiplyBy(tileSize).subtract(origin);
  },
  _addTile: function (tilePoint) {
    var tilePos = this._getTilePos(tilePoint);

    var tile = {};
    this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;
    this._loadTile(tile, tilePoint);
  },
  _resetTile: function (/*tile*/) { },
  _adjustTilePoint: function (tilePoint) {

    var limit = this._getWrapTileNum();

    if (!this.options.continuousWorld && !this.options.noWrap) {
      tilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;
    }

    if (this.options.tms) {
      tilePoint.y = limit.y - tilePoint.y - 1;
    }

    tilePoint.z = this._getZoomForUrl();
  },
  _getZoomForUrl: function () {

    var options = this.options,
      zoom = this._map.getZoom();

    if (options.zoomReverse) {
      zoom = options.maxZoom - zoom;
    }

    zoom += options.zoomOffset;
    return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
  },
  _getWrapTileNum: function () {
    var crs = this._map.options.crs;

    var s = crs.scale(this._map.getZoom());
    var size = L.point(s, s);

    return size.divideBy(this._getTileSize())._floor();
  },
  getTileUrl: function (url, tilePoint) {
    return L.Util.template(url, L.extend({
      z: tilePoint.z,
      x: tilePoint.x,
      y: tilePoint.y
    }, this.options));
  },
  _loadTile: function (tile, tilePoint) {
    this._adjustTilePoint(tilePoint);

    this._loadTileAjax(this._url.concat(), tile, tilePoint);
  },
  _loadTileAjax: function (url, tile, tilePoint) {
    if (url.length != 0) {
      tile.src = this.getTileUrl(url[0], tilePoint);
      tile.ajax = $.ajax({
        url: tile.src,
        cache: CONFIG.LOADCOCOTILECACHE,
        crossDomain: true,
        success: L.Util.bind(this._tileLoaded, this, url, tile, tilePoint),
        complete: L.Util.bind(this._tileLoaded_Complete, this, url, tile, tilePoint)
      });
    }
  },
  _tileLoaded: function (url, tile, tilePoint) {
    if (tile.ajax) {
      var lines = tile.ajax.responseText.split("\n");
      if (lines.length > 0) {

        var line = lines[0];
        var ids = line.split(',');

        for (var i = 0; i < ids.length; i++) {
          var tileId = ids[i];
          this._haveTiles[tileId] = true;
        }
      }
    }
  },
  _tileLoaded_Complete: function (url, tile, tilePoint) {
    if (tile.ajax) {
      var ret = false;
      if (url.length > 0) {
        url.shift();
        if (url.length > 0) {
          this._loadTileAjax(url, tile, tilePoint);
          ret = true;
        }
      }

      if (!ret) {
        tile.ajax = null;
      }
    }

    tile.loaded = true;
    var n = 0;
    for (var id in this._tiles) {
      n++;
      var tile = this._tiles[id];
      if (tile.ajax || !tile.loaded) {
        return;
      }
    }

    if (this.options.onLoad) this.options.onLoad(this._haveTiles);

    if (this.refreshTimerId_load) {
      clearTimeout(this.refreshTimerId_load);
      this.refreshTimerId_load = null;
    }

    if (n == 0) {
      return;
    }

    var that = this;
    this.refreshTimerId_load = setTimeout(
      function () {
        that.refreshTimerId_load = null;
        that.fire('load', { tileIds: that._haveTiles });
      }
      , 100);

  }
});

/************************************************************************
 L.Class
 - GSI.Dialog
 ************************************************************************/
GSI.Dialog = L.Evented.extend({
  options: {
    containerClass: 'gsi_dialog',
    headerClass: 'gsi_dialog_header',
    contentClass: 'gsi_dialog_content',
    effect: null,
    top: 0,
    left: 0,
    width: 300,
    resizable: ""
  },
  _userResized: false,
  initialize: function (dialogManager, options) {
    options = L.setOptions(this, options);

    this._dialogManager = dialogManager;

    this._dialogManager.append(this);
    this.create();

    if (options.visible)
      this.show();
  },

  getTitle: function () {
    return this.options.title;
  },

  isMinimized: function () {
    return this._dialogManager.isMinimized(this);
  },

  isResizable: function () {
    return (this.options.resizable && this.options.resizable != '' ? true : false);
  },
  createHeader: function () {
    return $('<span>').html('　　　　　　　');
  },
  createContent: function () {
    return $('<div>').html('　　　　　　　');
  },

  _cloceButtonClick: function () {
    this.hide(true);
  },

  _minimizeButtonClick: function () {
    this.minimize();

  },

  _dragMove: function () { },

  create: function () {
    if (this.container) return;
    this.container = $('<div>').addClass(this.options.containerClass);
    this.headerFrame = $('<div>').addClass(this.options.headerClass);
    this.contentFrame = $('<div>').addClass(this.options.contentClass);

    this.closeBtn = $('<a>').html('×').attr({ 'href': 'javascript:void(0);' }).addClass('closebtn');

    if (this.options.minimize) {
      this.minimizeBtn = $('<a>').html('-').attr({ 'href': 'javascript:void(0);' }).addClass('minimizebtn');
    }

    this.headerTitle = $('<div>').addClass('title');
    this.headerFrame.append(this.headerTitle);
    if (this.minimizeBtn) this.headerFrame.append(this.minimizeBtn);
    this.headerFrame.append(this.closeBtn);
    this.headerTitle.append(this.createHeader());

    this.contentFrame.append(this.createContent());

    this.container.append(this.headerFrame);
    this.container.append(this.contentFrame);

    $(document.body).append(this.container);

    this.container.draggable({
      delay: 100,
      scroll: false,
      handle: this.headerFrame,
      stop: L.bind(function () { this._dialogManager.adjust(this); this._dragEnd(); }, this),
      start: L.bind(function () { this.container.css({ "clip": "auto" }); }, this),
      drag: L.bind(function () { this._dragMove(); }, this)
    })
      .on('mousedown', L.bind(this.onClick, this))
      .on('touchstart', L.bind(this.onClick, this));

    if (this.options.width) {
      this.container.css({ width: this.options.width });
    }
    this.closeBtn.on('click',L.bind(this._cloceButtonClick, this));

    if (this.minimizeBtn) this.minimizeBtn.on('click',L.bind(this._minimizeButtonClick, this));

    this.container.hide();

    var left = this.options.left;
    if (left == 'center') {
      var screenSize = this._dialogManager.getScreenSize();
      left = Math.floor((screenSize.w / 2) - (parseInt(this.options.width) / 2));
      left += screenSize.left;
    } else {
      var screenSize = this._dialogManager.getScreenSize();
      if (left + this.options.width > screenSize.w) {
        left = screenSize.w - this.options.width - 8;
      }
    }

    this.container.css({
      left: left + 'px',
      top: this.options.top + 'px',
      width: this.options.width + 'px',
      "min-width": "80px",
      height: 'auto'
    });

    if (this.isResizable()) {
      this.container.resizable({
        resize: L.bind(function (evt, ui) {
          this._onResize(ui);
          this._userResized = true;
        }, this),
        handles: this.options.resizable
      });
    }

    if (this._createAfter) this._createAfter();
  },

  _dragEnd: function (e, ui) {
    var size = this._dialogManager.getScreenSize();

    var w = this.container.outerWidth();
    var h = this.container.outerHeight();
    var left = this.container.position().left;
    var top = this.container.position().top;

    var right = w + left;
    if (size.w < right || size.left > left || top + h > size.h) {
      if (top + h > size.h)
        h = size.h - top;
      this.container.css({
        "clip": "rect(" + (this._marginLeft ? this._marginLeft : 0) + "px,"
          + (w - (right - (size.left + size.w))) + "px," + 9999 + "px," + (size.left - left) + "px)"
      });
    }
    else
      this.container.css({ "clip": "auto" });
  },
  css: function (css) {
    if (this.container) this.container.css(css);
  },
  _onResize: function () { },

  addClass: function (className) {
    if (this.container) this.container.addClass(className);
  },

  removeClass: function (className) {
    if (this.container) this.container.removeClass(className);
  },

  show: function (noActivate) {

    if (this.container && this._dialogManager.isMinimized(this)) {
      this._dialogManager.removeMinimizeList(this);
      this.normalize();
      return;
    }

    if (!this.container) this.create();

    this._dialogManager.appendVisibleList(this, noActivate);

    var visible = this.container.is(":visible");
    if (!visible) this.container.css({ "visibility": "hidden" }).show();
    this._dragEnd();
    if (!visible) this.container.css({ "visibility": "visible" }).hide();

    if (!this.container.is(":visible")) {
      this.container.css({ "opacity": 0, "transform": "scale(0)" }).show();
    }
    this.container.finish().animate(
      {
        "opacity": 1
      },
      {
        "duration": 200,
        "step": L.bind(function (now) {
          this.container.css({ "transform": "scale(" + now + ")" });
        }, this),

        "complete": L.bind(function () {
          if (this.afterShow) this.afterShow();
        }, this)
      }
    );
    return;
  },
  hide: function () {
    this._dialogManager.removeMinimizeList(this);
    this._dialogManager.removeVisibleList(this);

    this.container.finish().css({ "transform": "scale(1)" }).animate(
      {
        "opacity": 0
      },
      {
        "duration": 200,
        "step": L.bind(function (now) {
          this.container.css({ "transform": "scale(" + now + ")" });
        }, this),

        "complete": L.bind(function () {
          this.container.hide().css({ "opacity": 1, "transform": "scale(1)" });
        }, this)
      }
    );
    return;
  },

  normalize: function () {

    this._dialogManager.appendVisibleList(this);

    var visible = this.container.is(":visible");
    if (!visible) this.container.css({ "visibility": "hidden" }).show();
    this._dragEnd();
    if (!visible) this.container.css({ "visibility": "visible" }).hide();

    this.container.finish().css({ "opacity": 0, "transform": "scale(0)" }).show().animate(
      {
        "opacity": 1
      },
      {
        "duration": 200,
        "step": L.bind(function (now) {
          this.container.css({ "transform": "scale(" + now + ")" });
        }, this),

        "complete": L.bind(function () {
        }, this)
      }
    );
    return;
  },

  minimize: function () {
    this._dialogManager.removeVisibleList(this);

    var pos = this.container.offset();
    var screenSize = this._dialogManager.getScreenSize();
    this.container.finish().css({ "transform": "scale(1)" }).animate(
      {
        "opacity": 0
      },
      {
        "duration": 300,
        "step": L.bind(function (to, now) {
          var x = (to.x - Math.floor(to.x * now)) / (now * 2);
          var y = (to.y - Math.floor(to.y * now)) / (now * 2);

          this.container.css({ "transform": "scale(" + now + ") translate(" + x + "px, " + y + "px)" });
        }, this, { x: screenSize.w - pos.left, y: screenSize.h - pos.top }),

        "complete": L.bind(function () {
          this.container.hide().css({ "opacity": 1, "transform": "scale(1)" });
        }, this)
      }
    );

    this._dialogManager.appendMinimizeList(this);
  },

  setMaxScrollHeight: function (maxHeight) { },
  getVisible: function () {
    return (this.container && this.container.is(':visible') ? true : false);
  },
  onClick: function () {
    this._dialogManager.activate(this);
  },

  getLeft: function () {
    if (!this.container) return this.options.left;

    var visible = this.container.is(':visible');

    if (!visible) {
      this.container.css({ "visibility": "hidden" }).show();
    }

    var left = this.container.offset().left;
    if (!visible) {
      this.container.hide().css({ "visibility": "visible" });
    }

    return left;
  },

  setLeft: function (left) {
    if (!this.container) {
      this.options.left = left;
      return;
    }

    this.container.css({ "left": left + "px" });
    this._dialogManager.adjust(this);
  }
});

/************************************************************************
 L.Class
 - GSI.Dialog
   - GSI.HelpDialog (ヘルプダイアログ管理)
 ************************************************************************/
GSI.HelpDialog = L.Class.extend({
  options: {
  },
  initialize: function (map, mapMouse, options) {
    this.map = map;
    this.mapMouse = mapMouse;
    this._blind = $("<div>")
      .on('click',L.bind(function () { this.hide(); }, this))
      .addClass("help_window_blind");

    this._frame = $("<div>").addClass("help_window_frame");

    this._titleFrame = $("<div>").addClass("help_window_content_title");

    this._contentFrame = $("<div>").addClass("help_window_content_frame");

    this._contentFrame.on({
      /* フリック開始時 */
      'touchstart': L.bind(function (e) {
        this._touchX = e.originalEvent.changedTouches[0].pageX;
        this._touchStartX = this._touchX;
        this._accel = 0;
        this._touchY = e.originalEvent.changedTouches[0].pageY; //←縦方向のタッチ位置も取得
      }, this),
      /* フリック中 */
      'touchmove': L.bind(function (e) {
        var moveX = this.touchX - e.originalEvent.changedTouches[0].pageX,
          moveY = this.touchY - e.originalEvent.changedTouches[0].pageY, //←縦方向のタッチ位置も取得
          moveRate = moveX / moveY; //←フリックした縦横の移動量の比率を計算

        //↓垂直方向から15度以上の方向にフリックした場合のみ、ページのスクロールをキャンセル
        if (moveRate > Math.tan(15 * Math.PI / 180)) {
          e.preventDefault();
        }

        this._accel = (e.originalEvent.changedTouches[0].pageX - this._touchX) * 5;
        this._touchX = e.originalEvent.changedTouches[0].pageX;
        this._touchEndX = this._touchX;

      }, this),
      /* フリック終了 */
      'touchend': L.bind(function (e) {

        if (Math.abs(this._touchEndX - this._touchStartX) > 50) {
          if (this._accel > 1)
            this.prev();
          else if (this._accel < -1)
            this.next();
        }
      }, this)
    });

    this._closeButton = $("<a>")
      .attr({ "href": "javascript:void(0);" })
      .on('click',L.bind(function () { this.hide(); }, this))
      .addClass("help_window_closebtn").html("×");

    this._titleFrame.append($("<span>"));
    this._titleFrame.append(this._closeButton);
    this._frame.append(this._titleFrame);
    this._frame.append(this._contentFrame);

    this._nextButton = $("<a>")
      .attr({
        "href": "javascript:void(0);"
      })
      .addClass("help_window_frame_button")
      .addClass("help_window_frame_next_button")
      .html("")
      .on('click',L.bind(function () { this._nextButton.trigger('blur'); this.next(); }, this));

    this._prevButton = $("<a>")
      .attr({
        "href": "javascript:void(0);"
      })
      .addClass("help_window_frame_button")
      .addClass("help_window_frame_prev_button")
      .html("")
      .on('click',L.bind(function () { this._prevButton.trigger('blur'); this.prev(); }, this));

    this._frame.append(this._prevButton);
    this._frame.append(this._nextButton);

    this._contentList = [];
    this._selectedIndex = -1;

    $("#help .help_content").each(L.bind(function (index, elem) {
      this._contentList.push({
        content: $(elem).clone(),
        title: $(elem).attr("title")
      });
    }, this));

    this.select(0);

    $("body").append(this._blind);
    $("body").append(this._frame);
  },

  next: function () {
    if (this._contentList.length > this._selectedIndex + 1)
      this.select(this._selectedIndex + 1);
    else
      this.select(0);
  },

  prev: function () {
    if (0 <= this._selectedIndex - 1)
      this.select(this._selectedIndex - 1);
    else
      this.select(this._contentList.length - 1);

  },

  select: function (index) {
    if (this._contentList && this._contentList.length > index && index >= 0) {
      if (this._selectedIndex >= 0) {
        this._contentFrame.fadeOut(100, L.bind(function () {
          this._titleFrame.find("span").empty().append(this._contentList[index].title);
          this._contentFrame.empty().append(this._contentList[index].content);
          this._contentFrame.fadeIn(100);
        }, this));
      }
      else {
        this._titleFrame.find("span").empty().append(this._contentList[index].title);
        this._contentFrame.empty().append(this._contentList[index].content);
      }
      this._selectedIndex = index;
    }

  },
  getVisible: function () {
    return (this._blind ? this._blind.is(":visible") : false);
  },

  show: function () {
    this._blind.fadeIn(200);
    this._frame.fadeIn(200);
  },
  hide: function () {
    this._blind.fadeOut(200);
    this._frame.fadeOut(200);
  },
  create: function () {
    this.title = $('<div>').html(this.options.title);

    return $('<div>').append(this.title);
  }
});

GSI.HelpDialog.hide = function () {
  if (GSI.GLOBALS.HelpDialog) GSI.GLOBALS.HelpDialog.hide();
};

/************************************************************************
 L.Class
 - GSI.Dialog
   - GSI.SearchResultDialog
 ************************************************************************/
GSI.SearchResultDialog = GSI.Dialog.extend({
  options: {
    title: '検索結果',
    maxMarkerNum: 30,
    minimize: true
  },
  initialize: function (dialogManager, map, options) {
    this.map = map;
    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);
  },
  setTitle: function (title) {
    var subTitle = $('<a>').html("協力:東大CSIS").addClass('searchresultdialog_subtitle')
      .css({ 'font-size': '7pt' }).attr('href', 'https://geocode.csis.u-tokyo.ac.jp/home/simple-geocoding/')
      .attr('target', '_blank');

    this.title.html(title).append(subTitle);
  },
  _onResize: function () {
    GSI.Dialog.prototype._onResize.call(this);

    var height = this.container.outerHeight(false)
      - this.headerFrame.outerHeight(true)
      - this.selectFrame.outerHeight(true) - 8;

    this.listFrame.css({ "max-height": 'none', height: height + 'px' });
  },
  createHeader: function () {
    this.title = $('<div>').html(this.options.title);

    return $('<div>').append(this.title);
  },
  hide: function () {
    if (this.markerList) this.map.removeLayer(this.markerList);
    GSI.Dialog.prototype.hide.call(this);
  },
  createContent: function () {
    this.frame = $('<div>');
    var selectFrame = $('<div>').addClass("searchresultdialog_select_frame");
    this.selectFrame = selectFrame;

    this.kenSelect = $('<select>').css({ 'width': '48%' });

    this.shiSelect = $('<select>').css({ 'width': '48%', 'margin-left': '4px' });

    this.typeSelect = $('<select>').css({ 'width': '48%', 'margin-left': '4px','margin-top': '3px' });
    this.typeSelectDiv = $('<div>').css({ 'width': '100%', 'text-align': 'left'});

    this.initializeKenSelect();

    this.kenSelect.on('change',L.bind(this.onKenChange, this));
    this.shiSelect.empty();
    this.shiSelect.append($('<option>').html("市区町村").val(","));
    this.shiSelect.on('change',L.bind(this.onShiChange, this));
    this.typeSelect.empty();
    this.typeSelect.append($('<option>').html("すべて").val(","));
    this.typeSelect.append($('<option>').html("居住地名").val("5,居住地名"));
    this.typeSelect.append($('<option>').html("居住地名以外").val("3,居住地名以外"));
    this.typeSelect.on('change',L.bind(this.onTypeSelectChange, this));
    this.typeSelectDiv.append(this.typeSelect);

    selectFrame.append(this.kenSelect).append(this.shiSelect).append(this.typeSelectDiv);

    this.frame.append(selectFrame);

    this.listFrame = $('<div>').addClass('searchresultdialog_ul_frame');
    this.listContainer = $('<ul>').addClass('searchresultdialog_ul');

    var li = $('<li>').addClass('nodata').html('中');
    this.listContainer.append(li);
    this.listFrame.append(this.listContainer);

    this.frame.append(this.listFrame);

    return this.frame;
  },
  setMaxScrollHeight: function (maxHeight) {
    if (this.listFrame) {
      this.listFrame.css({ 'max-height': maxHeight + 'px' });
    }
  },
  initializeKenSelect: function () {
    var select = this.kenSelect;
    select.empty();
    select.append($('<option>').html("都道府県").val(","));

    var kenCode = '';
    for (var key in GSI.MUNI_ARRAY) {
      var muni = GSI.MUNI_ARRAY[key].split(',');

      if (muni.length == 4) {
        if (kenCode != muni[0]) {
          var option = $('<option>').html(muni[1]).val(muni[0] + ',' + muni[1]);

          select.append(option);
          kenCode = muni[0];
        }
      }
    }
  },
  onKenChange: function () {
    var selectedKen = this.kenSelect.val().split(',');
    var selectedKenCode = selectedKen[0];
    var selectedKenName = selectedKen[1];

    var select = this.shiSelect;
    select.empty();
    select.append($('<option>').html("市区町村").val(","));

    for (var key in GSI.MUNI_ARRAY) {
      var muni = GSI.MUNI_ARRAY[key].split(',');

      if (muni.length == 4) {
        if (selectedKenCode == muni[0]) {
          var option = $('<option>').html(muni[3]).val(muni[2] + ',' + muni[3]);

          select.append(option);
        }
      }
    }
    this.showResult();
  },
  onShiChange: function () {
    this.showResult();
  },
  onTypeSelectChange: function (){
    this.showResult();
  },
  setChimeisResult: function (result) {
    if (result) {
      for (var i = result.length - 1; i >= 0; i--) {
        if (result[i].geometry.coordinates[0] <= 0) {
          if (result[i].geometry.coordinates[1] <= 0) {
            result.splice(i, 1);
          }
        }
      }
    }
    this.chimeiResult = result;
    this.showResult();
  },
  clear: function () {
    if (this.markerList) this.map.removeLayer(this.markerList);
    this.setTitle('検索中');
    this.addressResult = [];
    this.chimeiResult = [];
    var ul = this.listContainer;
    ul.empty();
    var li = $('<li>').addClass('nodata').html('検索中');
    this.listContainer.append(li);

    this.kenSelect[0].selectedIndex = 0;
    this.shiSelect.empty();
    this.shiSelect.append($('<option>').html("市区町村").val(","));
    this.typeSelect[0].selectedIndex = 0;
  },
  makeItem: function (item, index, subTitle) {
    var a = $('<a>').attr({ 'href': 'javascript:void(0);' });
    var title = item.properties.title;

    var div = $('<div>').html(title).addClass('title');
    a.append(div);

    if (subTitle && subTitle != '') {
      div = $('<div>').html(subTitle).addClass('muni');
      a.append(div);
    }

    a.on('click',L.bind(this.onResultClick, this, item));
    a.on('mouseenter', L.bind(this.onResultMouseover, this, item));
    a.on('mouseleave', L.bind(this.onResultMouseout, this, item));
    a.css({ "padding-left": '32px' });
    if (this.options.maxMarkerNum < 0 || this.markerNum < this.options.maxMarkerNum) {
      var latitude = item.geometry.coordinates[1];
      var longitude = item.geometry.coordinates[0];
      if (latitude && longitude) {
        a.css(
          {
            "background": "url(image/mapicon/search_result.png) no-repeat 0px 50%"
          }
        );

        if (!this._resultIcon) {
          this._resultIcon = L.icon({
            iconUrl: 'image/mapicon/search_result.png',
            iconSize: [24, 24],
            iconAnchor: [3, 22]
          });
        }
        item._isActive = false;
        item._marker = L.marker([latitude, longitude], {
          title: title,
          icon: this._resultIcon
        });
        item._marker.bindPopup(
          title + "<br>" +
          (subTitle && subTitle != '' ? subTitle + '<br>' : '') +
          latitude + "," + longitude,
          {
            maxWidth: 5000
          }
        );
        this.markerList.addLayer(item._marker);
        this.markerNum++;
      }
    }
    return a;
  },
  showResult: function () {
    this.container.css({"height":"auto"});
    if (this.markerList) this.map.removeLayer(this.markerList);

    this.markerList = L.layerGroup();

    var selectedKen = this.kenSelect.val().split(',');
    var selectedKenCode = selectedKen[0];

    var selectedSi = this.shiSelect.val().split(',');
    var selectedSiCode = selectedSi[0];

    var selectedType = this.typeSelect.val();
    var selectedTypeCode = selectedType[0];

    var ul = this.listContainer;
    ul.empty();
    var viewNum = 0;
    this.markerNum = 0;
    var results = [this.addressResult, this.chimeiResult];
    var that = this;
    var num = 0;
    $.each(results, function () {
      num += this.length;
      $.each(this, function () {
        var record = this;
        var addressCode = "";
        if (record.properties.addressCode) {
          addressCode = parseInt(record.properties.addressCode, 10) + "";
        }
        if (selectedKenCode != '' && addressCode.substring(0, addressCode.length - 3) != selectedKenCode) return;
        if (selectedSiCode != '' && selectedSiCode != addressCode) return;

        if (selectedTypeCode != ''){
          var dataSource = record.properties.dataSource;
          if (selectedTypeCode == '5') {
            if (dataSource != 5 && dataSource != null && dataSource != undefined)  return;
          } else if (selectedTypeCode == '3') {
            if (dataSource == 5 || dataSource == null || dataSource == undefined)  return;
          }
        }
        var li = $('<li>');
        var muniNm = "";
        if (addressCode) {
          var addressData = GSI.MUNI_ARRAY[addressCode];
          if (addressData) {
            addressData = addressData.split(",");
            muniNm = (addressData[1] + addressData[3]).replace("　", "");
          }
          var a = that.makeItem(record, viewNum, muniNm);
          li.append(a);
          ul.append(li);
        } else {
          var a = that.makeItem(record, viewNum, "    ");
          li.append(a);
          ul.append(li);
          // 緯度経度からリバースジオコーダ機能を呼び出して地名を取得

          $.ajax({
            url: CONFIG.SERVERAPI.GETADDR,
            dataType: "json",
            data: {
              lon: record.geometry.coordinates[0],
              lat: record.geometry.coordinates[1]
            },
            success: function (data2) {
              // リバースジオコーダの結果を画面に表示
              if (data2.results) {
                var addressCode = parseInt(data2.results.muniCd);
                record.properties.addressCode = addressCode;
                var addressData = GSI.MUNI_ARRAY[addressCode];
                if (addressData) {
                  addressData = addressData.split(",");
                  muniNm = (addressData[1] + addressData[3]).replace("　", "");
                  li.find("div.muni").html(muniNm);
                }
              }
            }
          });
        }
        viewNum++;
      });
    });
    this.setTitle('検索結果:' + num + '件中' + viewNum + '件表示');
    this.markerList.addTo(this.map);
  },
  onResultClick: function (resultItem) {
    this._setActiveItem(null);
    this._setActiveItem(resultItem);
    var latitude = resultItem.geometry.coordinates[1];
    var longitude = resultItem.geometry.coordinates[0];
    if (longitude && resultItem) {
      var zoom = CONFIG.SEARCHRESULTCLICKZOOM;
      if (resultItem.properties.ilvl) {
        zoom = 6 + 2 * resultItem.properties.ilvl;
        if (zoom > 17) {
          zoom = 17;
        }
      }

      if (resultItem.properties.zl) {
        zoom = resultItem.properties.zl;
      }

      this.map.setView([latitude, longitude], zoom);
    }

  },
  _setActiveItem: function (item) {
    if (!item) {
      if (this._activeItem) {
        this._activeItem._isActive = false;
        if (this._activeItem._marker) {
          this.markerList.addLayer(this._activeItem._marker);
        }
        if (this._resultActiveMarker) {
          this.markerList.removeLayer(this._resultActiveMarker);
        }
        this._activeItem._isActive = false;
        this._activeItem = null;
      }
      return;
    }

    if (item != this._activeItem) {
      if (item._marker) {
        this.markerList.removeLayer(item._marker);
      }

      var latitude = item.geometry.coordinates[1];
      var longitude = item.geometry.coordinates[0];
      if (!this._resultActiveMarker) {
        var icon = L.icon({
          iconUrl: 'image/mapicon/search_result_active.png',
          iconSize: [32, 32],
          iconAnchor: [5, 29]
        });

        this._resultActiveMarker = L.marker([latitude, longitude], {
          icon: icon,
          zIndexOffset: 1000
        });

      }
      else {
        this._resultActiveMarker.setLatLng([latitude, longitude]);
      }

      this.markerList.addLayer(this._resultActiveMarker);
      this._activeItem = item;
      this._activeItem._isActive = true;
    }
  },
  onResultMouseover: function (resultItem) {
    this._setActiveItem(resultItem);
  },
  onResultMouseout: function (resultItem) {
    if (resultItem._isActive) {
      resultItem._isActive = false;
      if (resultItem._marker) {
        this.markerList.addLayer(resultItem._marker);
      }
      if (this._resultActiveMarker) {
        this.markerList.removeLayer(this._resultActiveMarker);
      }
    }
  }
});

/************************************************************************
 L.Class
 - GSI.Dialog
   - GSI.ShareDialog（共有ダイアログ管理）
 ************************************************************************/
GSI.ShareDialog = GSI.Dialog.extend({
  options: {
    title: GSI.TEXT.SHARE.DIALOG_TITLE,
    minimize: true
  },
  initialize: function (gsimaps, dialogManager, map, mapManager, pageStateManager, layersJSON, sakuzuList, options) {
    this._gsimaps = gsimaps;
    this.map = map;
    this.mapManager = mapManager;
    this.pageStateManager = pageStateManager;
    this.layersJSON = layersJSON;
    this.sakuzuList = sakuzuList;

    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);
  },
  show: function (mode) {
    this._mode = mode;
    this._createTextareaContent(true);
    this._createSettingContent();
    this._initializeSetting(mode);

    switch (mode) {
      case GSI.ShareDialog.MODE.LINK:
        this.title.html(GSI.TEXT.SHARE.DIALOG_LINK_TITLE);
        this._settingButton.hide();
        this._downloadButton.hide();
        this._copyButton.hide();
        this._setMessage(GSI.TEXT.SHARE.DIALOG_LINK_MESSAGE);
        this._initializeLinkMode();
        break;
      case GSI.ShareDialog.MODE.BUILTIN:
        this.title.html(GSI.TEXT.SHARE.DIALOG_BUILTIN_TITLE);
        this._settingButton.show();
        this._downloadButton.hide();
        this._copyButton.show();
        this._setMessage(GSI.TEXT.SHARE.DIALOG_BUILTIN_MESSAGE);
        this._initializeBuiltInMode();
        break;

      case GSI.ShareDialog.MODE.FILE:
        this.title.html(GSI.TEXT.SHARE.DIALOG_SAVE_TITLE);
        if (!GSI.Utils.hasFileAPI) {
          this._downloadButton.hide();
          this._copyButton.show();
          this._setMessage(GSI.TEXT.SHARE.DIALOG_SAVE_MESSAGE_IE8);
        }
        else {
          this._setMessage(GSI.TEXT.SHARE.DIALOG_SAVE_MESSAGE);
          // if (this._zeroClipboard) this._zeroClipboard.destroy();
          // this._zeroClipboard = null; 12
          this._copyButton.hide();
          this._downloadButton.show();
        }

        this._initializeFileMode();
        break;
    }
    this._settingFrame.hide();

    GSI.Dialog.prototype.show.call(this);
  },
  _setCheckdState: function (elem, checked) {
    elem.attr({ 'checked': checked });
    elem.prop({ 'checked': checked });
  },
  _initializeSetting: function (mode) {
    this._setCheckdState(this._positionShareCheck, true);
    this._setCheckdState(this._basemapCheck, true);
    this._setCheckdState(this._layerpCheck, true);

    this._setCheckdState(this._visibleHeaderCheck, (mode != GSI.ShareDialog.MODE.BUILTIN));
    this._setCheckdState(this._visibleMapMenuButtonCheck, (mode != GSI.ShareDialog.MODE.BUILTIN));

    this._setCheckdState(this._visibleContextMenuCheck, (mode != GSI.ShareDialog.MODE.BUILTIN));

    this._setCheckdState(this._visibleMapMenuCheck, false);

    this._setCheckdState(this._showCurrentFolderCheck, false);

    this._setCheckdState(this._centerCrossCheck, this.pageStateManager.getViewSettingVisible(CONFIG.PARAMETERNAMES.CENTERCROSS));
    this._setCheckdState(this._latLngGridCheck, false);
    this._setCheckdState(this._utmGridCheck, false);
    if (!CONFIG.DISABLE_KOKUDOKIHONZUZUKAKU) this._setCheckdState(this._kokudokihonzukakuCheck, false);
    this._setCheckdState(this._tileGridCheck, false);
    this._setCheckdState(this._chiikiMeshCheck, false);
    this._setCheckdState(this._t25000Check, false);
    this._setCheckdState(this._jihokuLineCheck, false);
  },
  _initializeLinkMode: function () {
    this._textarea.val(location.href);
  },
  _initializeBuiltInMode: function () {
    var url = this.getUrl('');
    var w = 500;
    var h = 400;

    var html = '<iframe frameborder="0" scrolling="no" marginheight="0" marginwidth="0"' +
      ' width="' + w + '"' +
      ' height="' + h + '"' +
      ' src="' + url + '"' +
      '></iframe>';
    this._textarea.val(html);
  },
  _initializeFileMode: function () {
    var _location = (GSI.ClientMode.location ? GSI.ClientMode.location : location);
    if (!this._htmlTemplate || this._htmlTemplate == '') {
      var url = _location.pathname.replace(/index.html/i, "");
      if (!_location.pathname.lastIndexOf("/") == _location.pathname.length - 1) {
        url += "/";
      }
      url += "index_client.html";

      this._ajax = $.ajax({
        type: "GET",
        dataType: "text",
        url: url,
        success: L.Util.bind(this._onHtmlTemplateLoad, this),
        error: L.Util.bind(this._onHtmlTemplateLoadError, this)
      });
    }
    else {
      this._refreshShareFile();
    }
  },
  _refreshShareFile: function () {
    var javascript = '';
    var html = this._htmlTemplate;

    if (this.sakuzuList) {
      var list = this.sakuzuList.getGeoJSONList();

      javascript += 'GSI.ClientMode.sakuzuList = ' + JSON.stringify(list) + ';' + '\n';
    }

    var _location = (GSI.ClientMode.location ? GSI.ClientMode.location : location);

    var url = _location.protocol + "//" + _location.host;
    var url_ = this._makeQueryString();
    if (url_.indexOf("?") == 0) {
      url_ = "&" + url_.substring(1, url_.length);
    }

    var lp = _location.pathname;
    var da = lp.lastIndexOf("/");
    if ((da >= 0) && (da < lp.length - 1)){
      var x = lp.substring(da + 1);
      if (x == "index.html"){
        lp = lp.substring(0, da + 1);
      }
    }
    var url_site = lp + "index_pm.html?postmessage=1" + url_;

    html = html.replace('/*url*/', url);
    html = html.replace('/*url_site*/', url_site);
    html = html.replace(/GSI.ClientMode/g, 'ClientMode');
    javascript = javascript.replace(/GSI.ClientMode/g, 'ClientMode');

    html = html.replace('/*INSERT-SCRIPT*/', javascript);
    this._textarea.trigger('focus');
    this._textarea.val(html);
  },
  _onDownLoadClick: function () {
    var fileName = 'gsi' + GSI.Utils.getTimeStampString() + '.html';
    var blob = new Blob([this._textarea.val()], { "type": "text/html" });

    GSI.Utils.saveFile("text/html", fileName, blob);
  },
  _onHtmlTemplateLoad: function (html) {
    this._htmlTemplate = html.replace('\r\n', '\n');
    this._htmlTemplate = this._htmlTemplate.replace('\r', '\n');

    this._htmlTemplate = html;
    this._refreshShareFile();
  },
  _onHtmlTemplateLoadError: function () {
    alert(GSI.TEXT.SHARE.DIALOG_TEMPLATELOADERROR);
    this.hide();
  },
  _onSettingChange: function () {
    switch (this._mode) {
      case GSI.ShareDialog.MODE.LINK:
        this._initializeLinkMode();
        break;
      case GSI.ShareDialog.MODE.BUILTIN:
        this._initializeBuiltInMode();
        break;

      case GSI.ShareDialog.MODE.FILE:
        this._refreshShareFile();
        break;
    }
  },
  _makeQueryString: function (additionalParam) {
    var queryString = '';
    if (this._positionShareCheck.is(':checked')) {
      queryString = this.pageStateManager.getPositionQueryString();
      if (queryString != "") {
        queryString += "/";
      }
    }
    else {
      queryString += "#//";
    }

    var fBase = false;
    var fBassLS_Trim = false;
    var base = this.pageStateManager.getBaseLayerQueryString();
    if (base != '') {
      fBase = true;
    }
    if (this._basemapCheck.is(':checked')) {
      if (base != '') {
        queryString += (queryString != '' ? '&' : '#') + base;
      }
    }
    else {
      if (fBase) {
        fBassLS_Trim = true;
      }
    }

    var ls = this.pageStateManager.getLayersQueryString();
    var disp = this.pageStateManager.getTileViewSetting();

    var hasReliefFree = ls.indexOf( "relief_free") >= 0 ? true: false;
    if (this._layerpCheck.is(':checked')) {
      if (ls != '') {
        if (fBassLS_Trim) {
          var ls_ary = ls.split("%7C");
          ls = "";
          for (var n_ls_ary = 1; n_ls_ary < ls_ary.length; n_ls_ary++) {
            if (ls != "") {
              ls += "%7C";
            }
            ls += ls_ary[n_ls_ary];
          }
          if (ls != "") {
            ls = "ls=" + ls;
          }
        }
        if (ls != '') {
          queryString += (queryString != '' ? '&' : '#') + ls;
        }
      }

      if (disp != '') {
        if (fBassLS_Trim) {
          var disp_trim = "";
          for (var n_disp = 6; n_disp < disp.length; n_disp++) {
            disp_trim += disp.charAt(n_disp);
          }
          disp = "";
          if (disp_trim != "") {
            disp = "disp=" + disp_trim;
          }
        }
        if (disp != '') {
          queryString += (queryString != '' ? '&' : '#') + disp;
        }
      }
    }
    else {
      if (this._basemapCheck.is(':checked')) {
        if (base != '') {
          if (ls != '') {
            var ls_ary = ls.split("%7C");
            ls = "";
            if (ls_ary.length > 1) {
              ls += ls_ary[0];
            }
            if (ls != "") {
              ls = "ls=" + ls;
            }
          }
          if (ls != '') {
            queryString += (queryString != '' ? '&' : '#') + ls;
          }

          if (disp != '') {
            var disp_trim = "";
            if (disp.length >= 6) {
              disp_trim = disp.charAt(5);
            }
            disp = "";
            if (disp_trim != "") {
              disp = "disp=" + disp_trim;
            }
          }
          if (disp != '') {
            queryString += (queryString != '' ? '&' : '#') + disp;
          }
        }
      }
    }

    if (this._showCurrentFolderCheck.is(':checked')) {
      var lcd = this.pageStateManager.getCurrentPathQueryString();
      if (lcd != '') {
        queryString += (queryString != '' ? '&' : '#') + lcd;
      }
    }

    var hcList = [];
    if (!this._visibleHeaderCheck.is(':checked'))
      hcList.push(CONFIG.HIDDENCONTROLPARAMETER.HEADER);

    if (!this._visibleMapMenuButtonCheck.is(':checked'))
      hcList.push(CONFIG.HIDDENCONTROLPARAMETER.INFOMENU);
    if (!this._visibleContextMenuCheck.is(':checked'))
      hcList.push(CONFIG.HIDDENCONTROLPARAMETER.CONTEXTMENU);

    var skips = {};
    skips[CONFIG.PARAMETERNAMES.CLICKMOVE] = true;
    skips[CONFIG.PARAMETERNAMES.COCOTILE] = true;
    skips[CONFIG.PARAMETERNAMES.MINIMAP] = true;

    var visibles = {};
    visibles[CONFIG.PARAMETERNAMES.CENTERCROSS] = this._centerCrossCheck.is(':checked');
    visibles[CONFIG.PARAMETERNAMES.JIHOKULINE] = this._jihokuLineCheck.is(':checked');
    visibles[CONFIG.PARAMETERNAMES.LATLNGGRID] = this._latLngGridCheck.is(':checked');
    visibles[CONFIG.PARAMETERNAMES.UTMGRID] = this._utmGridCheck.is(':checked');
    if (!CONFIG.DISABLE_KOKUDOKIHONZUZUKAKU) visibles[CONFIG.PARAMETERNAMES.KOKUDOKIHONZUKAKU] = this._kokudokihonzukakuCheck.is(':checked');
    visibles[CONFIG.PARAMETERNAMES.TILEGRID] = this._tileGridCheck.is(':checked');
    visibles[CONFIG.PARAMETERNAMES.CHIIKIMESH] = this._chiikiMeshCheck.is(':checked');
    visibles[CONFIG.PARAMETERNAMES.T25000GRID] = this._t25000Check.is(':checked');
    visibles[CONFIG.PARAMETERNAMES.SPLITWINDOW] = this._gsimaps.splited();
    visibles[CONFIG.PARAMETERNAMES.COMPAREMAP] = this._gsimaps.compared();

    if (this.mapManager._footer && this.mapManager._footer.isVisible())
      visibles[CONFIG.PARAMETERNAMES.FOOTER] = this.mapManager._footer.getDisplayMode();
    else
      visibles[CONFIG.PARAMETERNAMES.FOOTER] = 0;

    var visibleDialogs = {};
    visibleDialogs[CONFIG.DIALOGPARAMETER.LEFTPANEL] = this._visibleMapMenuCheck.is(':checked');

    var visibles2 = {};
    var visibleDialogs2 = {};
    if (this._gsimaps.splited() && this._gsimaps._subMap) {
      if (this._gsimaps._subMap._footer && this._gsimaps._subMap._footer.isVisible())
        visibles2[CONFIG.PARAMETERNAMES.FOOTER] = this._gsimaps._subMap._footer.getDisplayMode();
      else
        visibles2[CONFIG.PARAMETERNAMES.FOOTER] = 0;

      if (this._gsimaps._subMap._viewListDialog)
        visibleDialogs2[CONFIG.DIALOGPARAMETER.VIEWLISTDIALOG] = this._gsimaps._subMap._viewListDialog.getVisible(); // 情報リスト設定：情報リスト d=l

      if (this._gsimaps._subMap._layerTreeDialog)
        visibleDialogs2[CONFIG.DIALOGPARAMETER.LAYERTREEDIALOG] = this._gsimaps._subMap._layerTreeDialog.getVisible(); // 情報リスト設定：選択中の情報   d=v
    }

    var queryParams = this.pageStateManager.getQueryParams({
      hcList: hcList,
      vsInfo: {
        skips: skips,
        visibles: visibles,
        visibles2: visibles2
      },
      visibleDialogs: visibleDialogs,
      visibleDialogs2: visibleDialogs2
    });

    var queryArgs = "";
    for (var key in queryParams) {
      if (key == "hc") {
        queryArgs += (queryString != '' ? '?' : '') + key + '=' + queryParams[key];
      }
      else {
        queryString += (queryString != '' ? '&' : '#') + key + '=' + queryParams[key];
      }
    }
    if (hasReliefFree) {
      var currentData = this._gsimaps._mainMap._mapLayerList.getElevationData();
      var text = GSI.ReliefTileLayer.encodeElevationData(currentData);
      queryString += (queryString != '' ? '&' : '#') + 'reliefdata=' + text;
    }
    if (this._gsimaps.splited() || this._gsimaps.compared()) {
      if (!this._gsimaps.compared()) {
        queryString += (queryString != '' ? '&' : '#') + "sync=" + (this._gsimaps._syncSplitMap ? "1" : "0");
        if (!this._gsimaps._syncSplitMap) {
          var center = this._gsimaps._subMap._map.getCenter();
          queryString += (queryString != '' ? '&' : '#') + "ll2=" + encodeURIComponent(
            center.lat.toFixed(6) + ',' + center.lng.toFixed(6) + ',' + this._gsimaps._subMap._map.getZoom()
          );
        }
      }

      var ls = this.pageStateManager.getLayersQueryString2();
      var disp = this.pageStateManager.getTileViewSetting2();
      var hasReliefFree2 = ls.indexOf( "relief_free") >= 0 ? true: false;
      if (this._layerpCheck.is(':checked')) {
        if (ls != '') {
          if (fBassLS_Trim) {
            var ls_ary = ls.split("%7C");
            ls = "";
            for (var n_ls_ary = 1; n_ls_ary < ls_ary.length; n_ls_ary++) {
              if (ls != "") {
                ls += "%7C";
              }
              ls += ls_ary[n_ls_ary];
            }
            if (ls != "") {
              ls = "ls2=" + ls;
            }
          }
          if (ls != '') {
            queryString += (queryString != '' ? '&' : '#') + ls;
          }
        }

        if (disp != '') {
          if (fBassLS_Trim) {
            var disp_trim = "";
            for (var n_disp = 6; n_disp < disp.length; n_disp++) {
              disp_trim += disp.charAt(n_disp);
            }
            disp = "";
            if (disp_trim != "") {
              disp = "disp2=" + disp_trim;
            }
          }
          if (disp != '') {
            queryString += (queryString != '' ? '&' : '#') + disp;
          }
        }
      }
      else {
        if (this._basemapCheck.is(':checked')) {
          if (base != '') {
            if (ls != '') {
              var ls_ary = ls.split("%7C");
              ls = "";
              if (ls_ary.length > 1) {
                ls += ls_ary[0];
              }
              if (ls != "") {
                ls = "ls2=" + ls;
              }
            }
            if (ls != '') {
              queryString += (queryString != '' ? '&' : '#') + ls;
            }

            if (disp != '') {
              var disp_trim = "";
              if (disp.length >= 6) {
                disp_trim = disp.charAt(5);
              }
              disp = "";
              if (disp_trim != "") {
                disp = "disp2=" + disp_trim;
              }
            }
            if (disp != '') {
              queryString += (queryString != '' ? '&' : '#') + disp;
            }
          }
        }
      }
      if (hasReliefFree2) {
        var currentData = this._gsimaps._subMap._mapLayerList.getElevationData();
        var text = GSI.ReliefTileLayer.encodeElevationData(currentData);
        queryString += (queryString != '' ? '&' : '#') + 'reliefdata2=' + text;
      } 
    }

    if (additionalParam && additionalParam != '') {
      queryString += (queryString != '' ? '&' : '#') + additionalParam;
    }

    return queryArgs + queryString;
  },
  getUrl: function (additionalParam) {
    var url = GSI.Utils.getCurrentPath();
    var queryString = this._makeQueryString();

    return url + queryString;
  },
  afterShow: function () {
    this._initializeCopy();
  },
  _initializeCopy: function () {
    // if (!this._zeroClipboard) {
    //   this._zeroClipboard = new ZeroClipboard(this._copyButton[0]);//.attr({ id: 'fe_text' })[0]);

    //   this._zeroClipboard.on('ready', L.bind(function () {

    //     this._zeroClipboard.on('beforecopy', L.bind(function () {
    //       this._zeroClipboard.setText(this._textarea.val());
    //       alert('クリップボードにコピーしました');
    //     }, this));

    //     this._zeroClipboard.on('aftercopy', L.bind(function () {
    //     }, this));
    //   }, this));
    // }
  },
  hide: function () {
    // 終了時のアラート表示 外す
    window._sakuzuDialogFlag = false;
    if (!window._shareDialogFlag) $(window).off('beforeunload');
    GSI.Dialog.prototype.hide.call(this);
  },
  _setMessage: function (msg) {
    this._messageFrame.empty();

    var img = $('<img>').attr({ 'src': 'image/system/info.png' });
    this._messageFrame.append(img).append($('<div>').html(msg));
  },
  createHeader: function () {
    this.title = $('<div>').html(this.options.title);

    return $('<div>').append(this.title);
  },
  createContent: function () {
    this._frame = $('<div>').addClass('gsi_sharedialog_frame');

    this._messageFrame = $('<div>').addClass('messageframe');
    this._textareaFrame = $('<div>').addClass('textareaframe');

    this._contentFrame = $('<div>');
    this._settingFrame = $('<div>').addClass('settingframe');

    this._frame.append(this._messageFrame);
    this._frame.append(this._textareaFrame);
    this._frame.append(this._contentFrame);
    this._frame.append(this._settingFrame);

    return this._frame;
  },
  _createTextareaContent: function (visible) {
    if (this._textareaContent) {
      if (visible) this._textareaContent.show();
      else this._textareaContent.hide();
      return;
    }
    var frame = $('<div>').addClass('textareacontent');

    var textareaFrame = $('<div>');
    this._textarea = $('<textarea>').attr({ rows: 4, readonly: "readonly", 'wrap': 'off' }).on('click',function () { this.select(); });
    this._textarea.trigger('focus');
    this._textarea.val('');
    textareaFrame.append(this._textarea);

    this._downloadButton = $('<a>').attr({ 'href': 'javascript:void(0);' }).addClass("normalbutton").css({ 'float': 'right' })
      .html(GSI.TEXT.SHARE.DIALOG_DOWNLOADBTN).on('click',L.bind(this._onDownLoadClick, this));

    if (!GSI.Utils.canUseFlashPlayer()) {
      this._copyButton = $('<span>').css({ 'float': 'right' }).html(GSI.TEXT.SHARE.DIALOG_NOCOPYMSG);
    }
    else {
      this._copyButton = $('<a>').attr({ 'href': 'javascript:void(0);' }).addClass("normalbutton").css({ 'float': 'right' })
        .html(GSI.TEXT.SHARE.DIALOG_COPYBTN);
    }

    frame.append(textareaFrame);

    this._settingButton = $('<a>').attr({ 'href': 'javascript:void(0);' }).addClass("normalbutton").css({ 'float': 'left' })
      .html('詳細設定')
      .on('click',L.bind(function () { this._settingFrame.slideToggle('fast'); }, this));

    var buttonFrame = $('<div>').addClass('buttonframe');

    buttonFrame.append(this._copyButton);
    buttonFrame.append(this._downloadButton);
    buttonFrame.append(this._settingButton);
    buttonFrame.append($('<div>').css({ clear: 'both' }));
    frame.append(buttonFrame);

    this._textareaFrame.append(frame);
    this._textareaContent = frame;
  },
  _createShareBuiltInContent: function () {
    if (this._shareBuiltInContent) return;
  },
  _createShareFileContent: function () {
    if (this._shareFileContent) return;
  },
  _createSettingContent: function () {
    if (this._settingContent) return

    this._settingContent = $('<div>').addClass('settingcontent');
    this._settingContent.append($('<h3>').html('基本設定'));

    var __createItem = function ($this, title) {
      var li = $('<li>');
      var id = 'GSI_ShareDialog_check' + GSI.Utils.getCurrentID();
      var check = $('<input>').attr({ 'type': 'checkbox', 'id': id }).addClass('normalcheck');
      li.append(check);
      var label = $('<label>').attr({ 'for': id });
      label.html(title);
      li.append(label);
      check.on('click',L.bind($this._onSettingChange, $this));
      return { li: li, checkbox: check };
    };

    var ul = $('<ul>');
    var item = null;

    // 緯度経度
    item = __createItem(this, '表示中の中心位置とズームを共有');
    ul.append(item.li);
    this._positionShareCheck = item.checkbox;

    // 背景地図
    item = __createItem(this, '表示中の背景地図を共有');
    ul.append(item.li);
    this._basemapCheck = item.checkbox;

    // レイヤー
    item = __createItem(this, '表示中のレイヤーを共有');
    ul.append(item.li);
    this._layerpCheck = item.checkbox;

    this._settingContent.append(ul);

    this._settingContent.append($('<h3>').html('機能設定'));

    ul = $('<ul>');

    // 検索とお知らせバーを表示
    item = __createItem(this, '検索とメニューを表示');
    ul.append(item.li);
    this._visibleHeaderCheck = item.checkbox;

    // 地図選択ボタンを表示
    item = __createItem(this, '地図選択ボタンを表示');
    ul.append(item.li);
    this._visibleMapMenuButtonCheck = item.checkbox;
    // コンテキストメニューを表示
    item = __createItem(this, 'コンテキストメニューを表示');
    ul.append(item.li);
    this._visibleContextMenuCheck = item.checkbox;

    this._settingContent.append(ul);

    this._settingContent.append($('<h3>').html('選択中の情報設定'));

    ul = $('<ul>');

    // 情報リスト
    item = __createItem(this, '地図選択を開く');
    ul.append(item.li);
    this._visibleMapMenuCheck = item.checkbox;

    // 表示階層を共有
    item = __createItem(this, '表示中のフォルダを開いた状態で表示');
    ul.append(item.li);
    this._showCurrentFolderCheck = item.checkbox;

    this._settingContent.append(ul);

    this._settingContent.append($('<h3>').html('表示設定'));

    ul = $('<ul>');

    // 中心十字線
    item = __createItem(this, '中心十字線を表示');
    ul.append(item.li);
    this._centerCrossCheck = item.checkbox;

    // 緯度経度グリッド
    item = __createItem(this, '緯度経度グリッドを表示');
    ul.append(item.li);
    this._latLngGridCheck = item.checkbox;

    // UTMグリッド
    item = __createItem(this, 'UTMグリッドを表示');
    ul.append(item.li);
    this._utmGridCheck = item.checkbox;

    // タイル座標
    item = __createItem(this, 'タイル座標を表示');
    ul.append(item.li);
    this._tileGridCheck = item.checkbox;

    // 地域メッシュ
    item = __createItem(this, '地域メッシュを表示');
    ul.append(item.li);
    this._chiikiMeshCheck = item.checkbox;

    // 2万5千分1地形図郭
    item = __createItem(this, '図郭を表示');
    ul.append(item.li);
    this._t25000Check = item.checkbox;

    // 国土基本図図郭
    if (!CONFIG.DISABLE_KOKUDOKIHONZUZUKAKU) {
      item = __createItem(this, '国土基本図図郭を表示');
      ul.append(item.li);
      this._kokudokihonzukakuCheck = item.checkbox;
    }

    // 磁北線
    item = __createItem(this, '磁北線を表示');
    ul.append(item.li);
    this._jihokuLineCheck = item.checkbox;

    this._settingContent.append(ul);

    this._settingFrame.append(this._settingContent);
  }
});

GSI.ShareDialog.MODE = {
  LINK: "link",
  BUILTIN: "builtin",
  FILE: "file"
};

/************************************************************************
 L.Class
 - GSI.Dialog
   - GSI.LoadOutsideTileDialog（外部タイル読込ダイアログ管理）
 ************************************************************************/
GSI.LoadOutsideTileDialog = GSI.Dialog.extend({

  options: {
    title: "外部タイル読込",
    width: "300px",
    minimize: true
  },

  initialize: function (dialogManager, map, mapLayerList, showingMapListPanel, options) {
    this._map = map;
    this._mapLayerList = mapLayerList;
    this._showingMapListPanel = showingMapListPanel;
    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);
  },

  // 表示
  show: function () {
    GSI.Dialog.prototype.show.call(this);

  },
  // 非表示
  hide: function () {
    GSI.Dialog.prototype.hide.call(this);
  },
  createHeader: function () {
    this.title = $('<div>').html(this.options.title);

    return $('<div>').append(this.title);
  },
  createContent: function () {
    this.frame = $('<div>').css({ "padding": "5px" }).addClass("gsi_loadoutsidetiledialog_content");

    var dl = $("<dl>");
    var dt = null;
    var dd = null;
    var label = null;
    var table = null;
    var tr = null;
    var td = null;
    var div = null;

    dt = $("<dt>");

    this._loadFromUrlRadio = $("<input>").addClass("normalcheck")
      .attr({ "name": "gsi_loadoutsidetiledialog", "type": "radio", "id": "gsi_loadoutsidetiledialog_url" })
      .prop({ "checked": "checked" });
    label = $("<label>").attr({ "for": "gsi_loadoutsidetiledialog_url" }).html("URLを指定");
    dt.append(this._loadFromUrlRadio).append(label);
    dl.append(dt);

    dd = $("<dd>");
    div = $("<div>").addClass("caption").html("レイヤー名:");
    dd.append(div);

    div = $("<div>");
    this._layerNameInput = $("<input>").attr({ "type": "text", "placeholder": "表示名称" });
    div.append(this._layerNameInput);
    dd.append(div);

    div = $("<div>").addClass("caption").html("URL:URL例は<a target='_blank' href='https://maps.gsi.go.jp/help/pdf/GSIMaps.pdf#page=54'>こちら</a>");
    dd.append(div);

    div = $("<div>");
    this._urlInput = $("<textarea>").attr({ "placeholder": "例:https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png" });
    div.append(this._urlInput);
    dd.append(div);

    //オプション
    this._optionBtn = $("<a>")
      .addClass("option_btn").attr({ "href": "javascript:void(0);" })
      .html("オプション")
      .on('click',L.bind(function () {
        if (this._optionFrame.is(":visible")) {
          this._optionBtn.removeClass("expand");
          this._optionFrame.slideUp(300, L.bind(function () {
            this.container.css({ "height": "auto" });
          }, this));
        }
        else {
          this._optionBtn.addClass("expand");
          this._optionFrame.slideDown(300, L.bind(function () {
            this.container.css({ "height": "auto" });
          }, this));
        }
      }, this));

    dd.append(this._optionBtn);

    this._optionFrame = $("<div>").addClass("options").hide();

    // 南西原点
    div = $("<div>");
    this._tmsInput = $("<input>").addClass("normalcheck")
      .attr({ "type": "checkbox", "id": "gsi_loadoutsidetiledialog_tms" });
    label = $("<label>").attr({ "for": "gsi_loadoutsidetiledialog_tms" }).html("南西原点");
    div.append(this._tmsInput).append(label);
    this._optionFrame.append(div);

    div = $("<div>");
    span = $("<span>").html("minZoom:");
    this._minZoomSelect = this._createZoomSelect();
    div.append(span).append(this._minZoomSelect);

    span = $("<span>").css({ "margin-left": "8px" }).html("maxZoom:");
    this._maxZoomSelect = this._createZoomSelect();
    div.append(span).append(this._maxZoomSelect);

    this._optionFrame.append(div);

    div = $("<div>");
    span = $("<span>").html("maxNativeZoom:");
    this._maxNativeZoomSelect = this._createZoomSelect();
    div.append(span).append(this._maxNativeZoomSelect);
    this._optionFrame.append(div);

    dd.append(this._optionFrame);

    dl.append(dd);

    dt = $("<dt>");
    this._loadFromFileRadio = $("<input>").addClass("normalcheck")
      .attr({ "name": "gsi_loadoutsidetiledialog", "type": "radio", "id": "gsi_loadoutsidetiledialog_file" });
    label = $("<label>").attr({ "for": "gsi_loadoutsidetiledialog_file" }).html("保存した設定ファイルを選択");
    dt.append(this._loadFromFileRadio).append(label);
    dl.append(dt);

    dd = $("<dd>");

    div = $("<div>");
    this._fileInput = $("<input>").attr({ "type": "file" }).css({ "border": "none" });
    div.append(this._fileInput);
    dd.append(div);

    dl.append(dd);

    this.frame.append(dl);

    var msgFrame = $("<div>").addClass("msg_frame").html("※国土地理院以外の機関が配信しているデータをご利用の際は、当該データの利用規約に従いご利用ください。");
    this.frame.append(msgFrame);

    var btnFrame = $("<div>").addClass("button_frame");

    this._loadButton = $("<a>").addClass("normalbutton").attr({ "href": "javascript:void(0);" }).html("上記の内容で読込開始");
    this._loadButton.on('click',L.bind(function () { this._load(); }, this));
    btnFrame.append(this._loadButton);

    this.frame.append(btnFrame);

    this._loadFromUrlRadio.on('click',L.bind(this._loadModeChange, this));
    this._loadFromFileRadio.on('click',L.bind(this._loadModeChange, this));

    this._fileInput.on("change", L.bind(this._onFileInputChange, this));
    this._loadModeChange();
    return this.frame;
  },

  // zoom選択リスト生成
  _createZoomSelect: function () {
    var select = $("<select>");
    select.append($('<option>').html("").val(""));

    for (var z = CONFIG.OUTSIDETILE.ZOOMRANGE.MIN; z <= CONFIG.OUTSIDETILE.ZOOMRANGE.MAX; z++) {

      select.append($('<option>').html(z).val(z));
    }

    return select;
  },

  // ファイル選択時
  _onFileInputChange: function (e) {
    if (e.target.files && e.target.files.length > 0)
      this._file = e.target.files[0];
    else {
      this._file = null;
      return;
    }

  },

  // 読み込みラジオ変更時
  _loadModeChange: function () {
    if (this._loadFromUrlRadio.is(":checked")) {
      // 202303 remoPropではなくpropでfalseを設定する。
      // this._layerNameInput.removeProp("disabled");
      // this._urlInput.removeProp("disabled");
      // this._tmsInput.removeProp("disabled");
      this._layerNameInput.prop({"disabled": false});
      this._urlInput.prop({ "disabled": false });
      this._tmsInput.prop({ "disabled": false });
      this._fileInput.prop({ "disabled": "disabled" });
    }
    else {

//      this._fileInput.removeProp("disabled");
      this._fileInput.prop({"disabled": false});

      this._layerNameInput.prop({ "disabled": "disabled" });
      this._urlInput.prop({ "disabled": "disabled" });
      this._tmsInput.prop({ "disabled": "disabled" });
    }

  },

  // jsonからレイヤーリスト生成
  _layersTextToLayerList: function (json) {
    var result = [];

    if (json.layers) {
      this._findLayer(json.layers, result);
    }
    return result;
  },

  // layersJSON内のレイヤー列挙
  _findLayer: function (arr, result) {
    for (var i = 0; i < arr.length; i++) {
      if (arr[i]["type"] == "LayerGroup") {
        if (arr[i]["entries"]) {
          this._findLayer(arr[i]["entries"], result);

        }
      }
      else if (arr[i]["type"] == "Layer") {
        var layerType = GSI.LayersJSON.url2LayerType(arr[i]["url"]);

        if (layerType == "tile") {
          var item = {
            "type": "Layer",
            "url": arr[i]["url"],
            "title": arr[i]["title"]
          };

          if (arr[i]["minZoom"] || arr[i]["minZoom"])
            item["minZoom"] = arr[i]["minZoom"];
          if (arr[i]["maxZoom"] || arr[i]["maxZoom"])
            item["maxZoom"] = arr[i]["maxZoom"];
          if (arr[i]["maxNativeZoom"] || arr[i]["maxNativeZoom"])
            item["maxNativeZoom"] = arr[i]["maxNativeZoom"];
          if (arr[i]["tms"])
            item["tms"] = arr[i]["tms"];

          result.push(item);
        }
      }

    }
  },

  // レイヤー一覧追加
  _appendToLayerList: function (list) {
    if (!list || list.length <= 0) {
      this._loadFinish("指定のファイルにはレイヤーが含まれていません");
      return;
    }

    this._queue = [];

    for (var i = 0; i < list.length; i++) {
      var info = $.extend({}, list[i]);
      var url = info.url;
      var title = info.title;

      if (!info.layerType){
        info.layerType = GSI.LayersJSON.url2LayerType(url);
      }

      delete info["url"];
      delete info["title"];

      this._queue.push({
        url: url,
        title: title,
        info: info
      });

    }

    this._totalQueueSize = this._queue.length;
    this._appendNext();
  },

  // 読み込みキュー次へ
  _appendNext: function () {
    if (!this._queue || this._queue.length <= 0) {
      //終わり
      this._queue = null;
      this._loadFinish();
      return;
    }

    try {
      var queueItem = this._queue.pop();
      this._mapLayerList.appendOutSideTile(queueItem.url, queueItem.title, queueItem.info);

      this._msg.html("外部タイル読込中 [" + (this._totalQueueSize - this._queue.length) + "/" + this._totalQueueSize + "]");
    }
    catch (e) {

    }

    this._queueTimerId = setTimeout(L.bind(function () {
      if (this._queueTimerId) {
        try {
          clearTimeout(this._queueTimerId);
          this._queueTimerId = null;
        }
        catch (e) {

        }
      }
      this._appendNext();
    }, this), 10);

  },

  // 外部タイル読込開始
  _loadStart: function () {
    if (!this._blind) {
      this._blind = $("<div>").addClass("window_blind");
      this._msg = $("<div>").addClass("window_blind_message").html("外部タイル読込中");
      $("body").append(this._blind);
      $("body").append(this._msg);
    }

    this._blind.fadeIn(300);
    this._msg.fadeIn(300);
  },

  // 読み込み終了
  _loadFinish: function (msg) {
    if (msg) alert(msg);
    if (this._blind) {
      this._blind.fadeOut(300, L.bind(function () {
        this._blind.remove();
        this._blind = null;
      }, this));
      this._msg.fadeOut(300, L.bind(function () {
        this._msg.remove();
        this._msg = null;
      }, this));
    }
  },

  //読み込み
  _load: function () {
    if (this._queue) return;

    if (this._loadFromUrlRadio.is(":checked")) {

      var url = (this._urlInput.val()) ? this._urlInput.val().trim() : '';
      var title = (this._layerNameInput.val()) ? this._layerNameInput.val().trim() : '';
      var isTMS = this._tmsInput.is(":checked");

      var layerType = GSI.LayersJSON.url2LayerType(url);

      if (layerType != "tile") {
        this._loadFinish(layerType != "tile" ? "タイルのURLを正しく入力して下さい\n" : "");
        return;
      }

      if (title == "") title = "外部タイル";

      var layerInfo = {

        url: url,
        title: title,
        tms: isTMS,
        layertype: layerType
      };

      if (this._minZoomSelect.val() != "") layerInfo.minZoom = parseInt(this._minZoomSelect.val());
      if (this._maxZoomSelect.val() != "") layerInfo.maxZoom = parseInt(this._maxZoomSelect.val());
      if (this._maxNativeZoomSelect.val() != "") layerInfo.maxNativeZoom = parseInt(this._maxNativeZoomSelect.val());

      this._urlInput.val("");
      this._layerNameInput.val("");
      this._tmsInput.removeProp("checked");
      this._minZoomSelect.val("");
      this._maxZoomSelect.val("");
      this._maxNativeZoomSelect.val("");

      this._loadStart();
      this._appendToLayerList([layerInfo]);
    }
    else {
      if (!this._file) {
        this._loadFinish("ファイルを選択して下さい");

        return;
      }

      this._loadStart();
      var reader = new FileReader();
      reader.onload = L.bind(function () {
        this._fileLoading = false;
        var text = reader.result;
        try {
          var json = JSON.parse(text);
          var list = this._layersTextToLayerList(json);
          this._appendToLayerList(list);
        }
        catch (e) {
          this._loadFinish("layers.txt形式のファイルを指定して下さい");
        }

      }, this);

      reader.readAsText(this._file);
    }
  }
});

/************************************************************************
 L.Class
 - GSI.Dialog
   - GSI.EditOutsideTileDialog（外部タイル情報編集ダイアログ管理）
 ************************************************************************/
GSI.EditOutsideTileDialog = GSI.Dialog.extend({

  options: {
    title: "外部タイル編集",
    width: "300px",
    minimize: true
  },

  initialize: function (dialogManager, map, options) {
    this._map = map;
    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);
  },

  // 表示
  show: function (target) {
    this._target = target;
    GSI.Dialog.prototype.show.call(this);
    this._layerNameInput.val(this._target.title);
    if (this._target.tms)
      this._tmsInput.prop({ "checked": "checked" });
    else
      this._tmsInput.removeProp("checked");

    this._urlInput.val(this._target.url);
    this._minZoomSelect.val(this._target.minZoom);
    this._maxZoomSelect.val(this._target.maxZoom);
    this._maxNativeZoomSelect.val(this._target.maxNativeZoom);
  },

  // 非表示
  hide: function () {
    GSI.Dialog.prototype.hide.call(this);
  },
  createHeader: function () {
    this.title = $('<div>').html(this.options.title);

    return $('<div>').append(this.title);
  },
  createContent: function () {
    this.frame = $('<div>').css({ "padding": "5px" }).addClass("gsi_editoutsidetiledialog_content");
    var div = null;
    var span = null;

    div = $("<div>").addClass("caption").html("レイヤー名:");
    this.frame.append(div);

    div = $("<div>");
    this._layerNameInput = $("<input>").attr({ "type": "text", "placeholder": "表示名称" });
    div.append(this._layerNameInput);
    this.frame.append(div);

    div = $("<div>").addClass("caption").html("URL:");
    this.frame.append(div);

    div = $("<div>");
    this._urlInput = $("<textarea>").attr({ "placeholder": "例:https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png" });
    div.append(this._urlInput);
    this.frame.append(div);

    // 南西原点
    div = $("<div>");
    this._tmsInput = $("<input>").addClass("normalcheck")
      .attr({ "type": "checkbox", "id": "gsi_editoutsidetiledialog_tms" });
    label = $("<label>").attr({ "for": "gsi_editoutsidetiledialog_tms" }).html("南西原点");
    div.append(this._tmsInput).append(label);
    this.frame.append(div);

    div = $("<div>");
    span = $("<span>").html("minZoom:");
    this._minZoomSelect = this._createZoomSelect();
    div.append(span).append(this._minZoomSelect);

    span = $("<span>").css({ "margin-left": "8px" }).html("maxZoom:");
    this._maxZoomSelect = this._createZoomSelect();
    div.append(span).append(this._maxZoomSelect);

    this.frame.append(div);

    div = $("<div>");
    span = $("<span>").html("maxNativeZoom:");
    this._maxNativeZoomSelect = this._createZoomSelect();
    div.append(span).append(this._maxNativeZoomSelect);
    this.frame.append(div);

    var btnFrame = $("<div>").addClass("button_frame");

    this._okBtn = $("<a>").addClass("normalbutton").attr({ "href": "javascript:void(0);" }).html("上記の内容で変更");
    this._okBtn.on('click',L.bind(this._onOkClick, this));
    btnFrame.append(this._okBtn);
    this.frame.append(btnFrame);

    return this.frame;
  },

  // OKボタンクリック時
  _onOkClick: function () {

    if (this._target) {

      var url = (this._urlInput.val()) ? this._urlInput.val().trim() : '';
      var title = (this._layerNameInput.val()) ? this._layerNameInput.val().trim() : '';
      var isTMS = this._tmsInput.is(":checked");

      var layerType = GSI.LayersJSON.url2LayerType(url);

      if (layerType != "tile") {
        alert(layerType != "tile" ? "タイルのURLを正しく入力して下さい\n" : "");
        return;
      }

      if (title == "") title = "外部タイル";

      this._target.title = this._layerNameInput.val();
      this._target.url = this._urlInput.val();
      this._target.tms = isTMS;

      if (this._minZoomSelect.val() != "")
        this._target.minZoom = parseInt(this._minZoomSelect.val());
      else
        delete this._target["minZoom"];

      if (this._maxZoomSelect.val() != "")
        this._target.maxZoom = parseInt(this._maxZoomSelect.val());
      else
        delete this._target["maxZoom"];

      if (this._maxNativeZoomSelect.val() != "")
        this._target.maxNativeZoom = parseInt(this._maxNativeZoomSelect.val());
      else
        delete this._target["maxNativeZoom"];

      this.fire("change", { "_target": this._target });
    }
    this.hide();
  },

  // ズーム選択リスト生成
  _createZoomSelect: function () {
    var select = $("<select>");
    select.append($('<option>').html("").val(""));

    for (var z = CONFIG.OUTSIDETILE.ZOOMRANGE.MIN; z <=  CONFIG.OUTSIDETILE.ZOOMRANGE.MAX; z++) {

      select.append($('<option>').html(z).val(z));
    }

    return select;
  }
});

/************************************************************************
 L.Class
 - GSI.Dialog
   - GSI.QRCodeDialog（QRコードダイアログ管理）
 ************************************************************************/
GSI.QRCodeDialog = GSI.Dialog.extend({
  options: {
    title: GSI.TEXT.SHARE.QRCODE_DIALOG_TITLE,
    minimize: true
  },
  initialize: function (dialogManager, map, options) {
    this.map = map;

    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);
  },

  // 表示
  show: function () {
    this._refreshQRCode();
    GSI.Dialog.prototype.show.call(this);
  },

  // 非表示
  hide: function () {
    GSI.Dialog.prototype.hide.call(this);
  },

  // QRコード画像再生成
  _refreshQRCode: function () {
    this._imageFrame.empty();

    var size = this._sizeSelect.val();

    switch (size) {
      case "270":
        this._imageFrame.css({ "height": "280px" });
        break;

      case "180":
        this._imageFrame.css({ "height": "190px" });
        break;

      case "120":
        this._imageFrame.css({ "height": "130px" });
        break;

    }

    this._imageFrame.qrcode({
      width: parseInt(size),
      height: parseInt(size),
      text: window.location.href,
      background: this._fillColorSelector.data("color"),
      foreground: this._foreColorSelector.data("color")
    });

    this._imageFrame.find("canvas").css({
      "margin-left": -parseInt(parseInt(this._sizeSelect.val()) / 2) + "px",
      "margin-top": -parseInt(parseInt(this._sizeSelect.val()) / 2) + "px"
    });
  },

  // 画像保存
  _saveImage: function (contentType) {

    var size = this._sizeSelect.val();
    var margin = 10;

    switch (size) {
      case "270":
        margin = 25;
        break;

      case "180":
        margin = 20;
        break;

      case "120":
        margin = 15;
        break;

    }

    var canvas = this._imageFrame.find("canvas")[0];
    var saveCanvas = document.createElement("canvas");
    saveCanvas.width = canvas.width + margin * 2;
    saveCanvas.height = canvas.height + margin * 2;

    var ctx = saveCanvas.getContext("2d");
    ctx.fillStyle = this._fillColorSelector.data("color");
    ctx.fillRect(0, 0, saveCanvas.width, saveCanvas.height);
    ctx.drawImage(canvas, margin, margin)

    var data = saveCanvas.toDataURL(contentType);
    var fileName = '';
    switch (contentType) {
      case 'image/jpeg':
        fileName = 'gsiqrcode' + size + '.jpg';
        break;
      case 'image/gif':
        fileName = 'gsiqrcode' + size + '.gif';
        break;
      default:
        fileName = 'gsiqrcode' + size + '.png';
        break;
    }

    var createImage = function (base64, mime) {
      var tmp = base64.split(',');
      var data = atob(tmp[1]);
      var mime = tmp[0].split(':')[1].split(';')[0];
      var buf = new Uint8Array(data.length);
      for (var i = 0; i < data.length; i++) {
        buf[i] = data.charCodeAt(i);
      }
      var blob = new Blob([buf], { type: mime });
      return blob;
    };

    var blob = null;
    blob = createImage(data, contentType);

    GSI.Utils.saveFile(contentType, fileName, blob);

  },

  createHeader: function () {
    this.title = $('<div>').html(this.options.title);

    return $('<div>').append(this.title);
  },
  createContent: function () {
    this._frame = $('<div>').addClass('gsi_qrcodedialog_frame');

    this._settingFrame = $('<div>').addClass('settingframe');

    var table = $('<table>');
    var tr = null;
    var th = null;
    var td = null;
    var id = null;

    // 前景色
    tr = $('<tr>');

    th = $('<th>').html('前景色');
    tr.append(th);

    id = 'GSI_QRCode_foreColor_' + GSI.Utils.getCurrentID();
    this._foreColorSelector = $('<div>').attr({ id: id }).data({ "color": "#000" }).css({ "background": '#000' }).html('　　').addClass('color_select');
    this._foreColorSelector.simpleColorPicker({
      showEffect: 'slide',
      hideEffect: 'slide',
      onChangeColor: L.bind(function (color) {
        this._foreColorSelector.data({ "color": color }).css({ 'background': color });
        this._refreshQRCode();
      }, this)
    });

    td = $('<td>').css({ "width": "50px" }).append(this._foreColorSelector);
    tr.append(td);

    // 背景色
    th = $('<th>').html('背景色');
    tr.append(th);
    id = 'GSI_QRCode_fillColor_' + GSI.Utils.getCurrentID();
    this._fillColorSelector = $('<div>').attr({ id: id }).data({ "color": "#fff" }).css({ "background": '#fff' }).html('　　').addClass('color_select');
    this._fillColorSelector.simpleColorPicker({
      showEffect: 'slide',
      hideEffect: 'slide',
      onChangeColor: L.bind(function (color) {
        this._fillColorSelector.data({ "color": color }).css({ 'background': color });
        this._refreshQRCode();
      }, this)
    });

    td = $('<td>').append(this._fillColorSelector);
    tr.append(td);
    table.append(tr);

    // サイズ
    tr = $('<tr>');

    th = $('<th>').html('サイズ');
    tr.append(th);

    this._sizeSelect = $("<select>");
    this._sizeSelect
      .append($('<option>').html("大(270px×270px)").val("270"))
      .append($('<option>').html("中(180px×180px)").val("180"))
      .append($('<option>').html("小(120px×120px)").val("120"));

    this._sizeSelect.val("180")
      .on('change',L.bind(function () {
        this._refreshQRCode();
      }, this));
    td = $('<td>').attr({ "colspan": 3 }).append(this._sizeSelect);
    tr.append(td);

    table.append(tr);

    this._settingFrame.append(table);

    this._frame.append(this._settingFrame);

    // QRコード表示
    this._imageFrame = $("<div>").addClass('imageframe');
    this._frame.append(this._imageFrame);

    // 保存
    this._saveFrame = $("<div>").addClass('saveframe');

    this._imageTypeSelect = $("<select>");
    this._imageTypeSelect
      .append($('<option>').html("PNG形式").val("image/png"))
      .append($('<option>').html("JPEG形式").val("image/jpeg"));

    this._imageTypeSelect.val("image/png")

    this._saveButton = $("<a>").attr({ "href": "javascript:void(0);" }).html("でダウンロードする")
      .on('click',L.bind(function () { this._saveImage(this._imageTypeSelect.val()); }, this));

    this._saveFrame.append(this._imageTypeSelect);
    this._saveFrame.append(this._saveButton);

    this._frame.append(this._saveFrame);

    return this._frame;
  }
});
/*
GSI.OpacitySlider = L.Evented.extend({

  options: { value: 1 },
  element: null,
  initialize: function (options) {
    options = L.setOptions(this, options);
    this.opacity = options.value;
    this.element = $('<div>').addClass('gsi_opacity_slider');

    this.bg = $('<div>').addClass('gsi_opacity_slider_bg');
    this.element.append(this.bg);

    this.btn = $('<div>').addClass('gsi_opacity_slider_btn').draggable({
      containment: this.element,
      scroll: false,
      drag: L.bind(function (event, ui) {
        var w = this.element.outerWidth(false) - 24;
        this.opacity = 1 - ui.position.left / w;

        this.fire('change', this.opacity);
      }, this)
    });
    this.element.append(this.btn);
  },
  refresh: function (opacity) {
    this.opacity = opacity;
    var w = this.element.outerWidth(false) - 24;
    var left = Math.floor(w * (1 - this.opacity));
    this.btn.css({ left: left });
  },
  getElement: function () { return this.element; },
  getOpacity: function () {
    return this.opacity;
  }
});
 */
/************************************************************************
 L.Class
 - GSI.EvacDialog
 ************************************************************************/
GSI.EvacDialog = L.Control.extend({
  options: {
    width: '310px',
    position: 'bottomright',
  },
  initialize: function (map) {
    this._mapF = map;
    L.Util.setOptions(this, this.options);
    this._isShow = false;
  },
  show: function () {
    if (this._isShow == false) {

      this.addTo(this._mapF);
    }
    this._isShow = true;
  },
  hide: function () {
    if (this._isShow == true) {
      this.remove();
    }
    this._isShow = false;
  },
  onAdd: function (map) {
    this._map = map;
    this._container = L.DomUtil.create('div', 'evac_dialog');
    // 202303 生成時にidを追加
    this._container.id = 'evacDialogContainer';
    //content
    var frame = $('<div>').addClass('evac_dialog_content').html(this.createContent());

    $(this._container).css({ 'opacity': '0.7' }).append(frame);

    return this._container
  },
  createContent: function () {
    return GSI.TEXT.EVAC.KIYAKU + "<br>" + GSI.TEXT.EVAC.KIYAKULINK;
  }
});

/************************************************************************
 L.Class
 - GSI.DialogManager
 ************************************************************************/
GSI.DialogManager = L.Class.extend({
  initialize: function (container) {

    this._container = container

    this.dialogList = [];
    this.visibleList = [];
    this.minimizeList = [];
    this._minimizeContainerBottom = 0;
  },
  append: function (dlg) {
    this.dialogList.push(dlg);
  },

  refreshClip: function () {
    for (var i = 0; i < this.visibleList.length; i++) {
      this.visibleList[i]._dragEnd();
    }
  },

  setMinimizePosition: function (pos) {
    this._minimizeContainerBottom = pos.bottom;
    if (this._minimizeContainer) this._minimizeContainer.css({ "bottom": this._minimizeContainerBottom + "px" });

  },
  appendMinimizeList: function (dlg) {
    for (var i = 0; i < this.minimizeList.length; i++) {
      var d = this.minimizeList[i];
      if (d == dlg) {
        this.minimizeList.splice(i, 1);
        break;
      }
    }

    if (!this._titleChangeHandler) {
      this._titleChangeHandler = L.bind(this._onTitleChange, this);
    }
    dlg.on("titlechange", this._titleChangeHandler);

    this.minimizeList.push(dlg);
    this._refreshMinimizeButtons();
  },

  _onTitleChange: function (e) {
    if (!e.target._titleContainer) return;
    e.target._titleContainer.html(e.target.getTitle());
  },

  _refreshMinimizeButtons: function () {
    if (!this._minimizeContainer) {
      this._minimizeContainer = $("<div>").addClass("gsi_dialogmanager_minimizecontainer").css({ "bottom": this._minimizeContainerBottom + "px" });

      this._container.append(this._minimizeContainer);
    }

    if (this._marginRight) {
      this._minimizeContainer.css({ "right": (this._container.outerWidth() - this._marginRight) + "px" });
    } else {
      this._minimizeContainer.css({ "right": "0px" });
    }

    this._minimizeContainer.empty();
    if (this.minimizeList.length <= 0) {

      this._minimizeContainer.hide();
      return;
    }

    for (var i = this.minimizeList.length - 1; i >= 0; i--) {
      var dlg = this.minimizeList[i];
      var a = $("<a>").attr({ "href": "javascript:void(0);" })
      var span = $("<span>").html(dlg.getTitle());
      a.append(span);
      this._minimizeContainer.append(a);
      dlg._titleContainer = span;

      a.on("click", L.bind(function (dlg) {
        dlg.show();
      }, this, dlg));
    }

    this._minimizeContainer.show();
  },

  isMinimized: function (dlg) {
    for (var i = 0; i < this.minimizeList.length; i++) {
      var d = this.minimizeList[i];
      if (d == dlg) {
        return true;
        break;
      }
    }
    return false;
  },
  removeMinimizeList: function (dlg) {
    for (var i = 0; i < this.minimizeList.length; i++) {
      var d = this.minimizeList[i];
      if (d == dlg) {

        dlg.off("titlechange", this._titleChangeHandler);
        this.minimizeList.splice(i, 1);
        break;
      }
    }
    this._refreshMinimizeButtons();
  },

  appendVisibleList: function (dlg, noActivate) {
    for (var i = 0; i < this.visibleList.length; i++) {
      var d = this.visibleList[i];
      if (d == dlg) {
        if (noActivate) return;
        this.visibleList.splice(i, 1);
        break;
      }
    }

    this.adjust(dlg);
    if (noActivate && this.visibleList.length > 0) {
      this.visibleList.splice(this.visibleList.length - 1, 0, dlg);
    }
    else
      this.visibleList.push(dlg);
    this.refreshZIndex();

    if (!this._onWindowResize) {
      this._onWindowResize = L.bind(this.onWindowResize, this);
      $(window).on('resize', this._onWindowResize);
    }
  },
  removeVisibleList: function (dlg) {
    for (var i = 0; i < this.visibleList.length; i++) {
      var d = this.visibleList[i];
      if (d == dlg) {
        this.visibleList.splice(i, 1);
        break;
      }
    }
    this.refreshZIndex();

    if (this.visibleList.length <= 0) {
      if (this._onWindowResize) {
        $(window).off('resize', this._onWindowResize);
        this._onWindowResize = null;
      }
    }
  },
  activate: function (dlg) {
    this.appendVisibleList(dlg);
  },
  refreshZIndex: function () {
    var zIndex = 10000;
    var dlgIndex = -1;
    var idx = 1;

    for (var i = 0; i < this.visibleList.length - 1; i++) {
      var opacity = 0.6 + (0.4 / this.visibleList.length * idx);
      if (this.visibleList[i].options.containerClass != "evac_dialog") {
        this.visibleList[i].css({ 'z-index': zIndex, opacity: opacity });
      }
      this.visibleList[i].addClass("deactive");

      zIndex++;
      idx++;
    }

    if (this.visibleList.length > 0) {
      if (this.visibleList[this.visibleList.length - 1].options.containerClass != "evac_dialog") {
        this.visibleList[this.visibleList.length - 1].css({ 'z-index': zIndex, opacity: 0.95 });
      }
      else {
        this.visibleList[this.visibleList.length - 1].css({ 'z-index': zIndex, opacity: 0.6 });
      }
      this.visibleList[i].removeClass("deactive");
    }
  },

  setMarginLeft: function (left) {
    this._marginLeft = left;

    var windowSize = this.getScreenSize();
    for (var i = 0; i < this.visibleList.length; i++) {
      var d = this.visibleList[i];
      this.adjust(d, windowSize);
    }
    this._refreshMinimizeButtons();
  },

  setMarginRight: function (right) {
    this._marginRight = right;

    var windowSize = this.getScreenSize();
    for (var i = 0; i < this.visibleList.length; i++) {
      var d = this.visibleList[i];
      this.adjust(d, windowSize);
    }

    this._refreshMinimizeButtons();

  },

  getScreenSize: function () {
    var p = this._container.offset();
    var result = {
      left: p.left,
      top: 0,
      w: this._container.outerWidth(),
      h: p.top + this._container.outerHeight()
    };
    if (this._marginLeft) {
      result.left += this._marginLeft + 2;
      result.w -= this._marginLeft + 2;
    }
    if (this._marginRight) result.w -= (result.w - this._marginRight);

    return result;
  },

  adjust: function (d, windowSize) {
    if (!windowSize) windowSize = this.getScreenSize();

    var visible = d.container.is(':visible');
    if (!visible) {
      d.container.css({ 'visibility': 'hidden' });
      d.container.show();
    }

    var offset = d.container.offset();
    var width = d.container.outerWidth(true);
    var height = d.container.outerHeight(true);
    var left = null;
    var top = null;

    // width
    if (!d.isResizable()) {
      if (windowSize.h > windowSize.w) {
        var newWidth = Math.floor(windowSize.w * 0.9);
        if (d.options.width > newWidth) {
          d.container.css({ "max-width": newWidth });
          width = newWidth;
        }
        else {
          d.container.css({ "max-width": d.options.width });
          width = parseInt(d.options.width);
        }
      }
      else {
        var newWidth = Math.floor(windowSize.w * 0.6);
        if (d.options.width > newWidth) {
          d.container.css({ "max-width": newWidth });
          width = newWidth;
        }
        else {
          d.container.css({ "max-width": d.options.width });
          width = parseInt(d.options.width);
        }
      }
    }

    // height
    if (!d._userResized) {
      if (windowSize.h > windowSize.w) {
        d.setMaxScrollHeight(Math.floor(windowSize.h * 0.4));
      }
      else {
        d.setMaxScrollHeight(Math.floor(windowSize.h * 0.65));
      }
    }

    //left
    if (offset.left > (windowSize.left + windowSize.w) - (width / 4)) {
      left = windowSize.left + (windowSize.w - (width / 4));
    }

    if (offset.left <= windowSize.left - (width / 2)) {
      left = windowSize.left - Math.floor(width / 2);
      d.container.css({ left: -Math.floor(width / 2) + 'px' });
    }

    if (left != null) {
      d.container.css({ left: left + 'px' });
    }

    //top
    if (offset.top > windowSize.h - (height / 2)) {
      top = (windowSize.h - (height / 2));
    }

    if (offset.top < 0) {
      top = 0;
    }

    if (top != null) {
      d.container.css({ top: top + 'px' });
    }

    if (!visible) {
      d.container.hide();
      d.container.css({ 'visibility': 'visible' });
    }

    d._dragEnd();
  },
  onWindowResize: function () {
    var windowSize = this.getScreenSize();
    for (var i = 0; i < this.visibleList.length; i++) {
      var d = this.visibleList[i];
      this.adjust(d, windowSize);
    }
  },
  isVisibleDialog: function (dlg) {
    for (var i = 0; i < this.visibleList.length; i++) {
      var d = this.visibleList[i];
      if (d == dlg) {
        return true;
      }
    }
    return false;
  }
});

/************************************************************************
 L.Class
 - GSI.EvacuationManager
 ************************************************************************/
GSI.EvacuationManager = L.Class.extend({
  initialize: function (queryParams) {
    this._isVisibleDialog = false;
    if (queryParams) {
      this._queryparams = null;
      this._queryParams = queryParams;
    }
  },
  Reset: function (qp) {
    this.initialize(qp);
  },
  Out: function () {
    return this._queryParams;
  },
  accept: function () {
    var d;

    if (this._queryParams.params["disp"]) {
      d = this._queryParams.params["disp"];
    }

    var ls, ly, lcd;
    if (this._queryParams.params["ls"]) {
      ls = this._queryParams.params["ls"].split("|");
      GSI.Utils.rpad(d, "0", ls.length);
    }
    ly = this._queryParams._layers;
    lcd = this._queryParams.params["lcd"];
    if (ls) {
      if (d.charAt(ls.length - 1) == "1") {
        this._isVisibleDialog = true;
      }

      if (lcd && lcd.indexOf(CONFIG.layerEvacuationHeader) >= 0) {
        for (var i = ls.length - 1; i >= 0; i--) {
          if ((lcd != ls[i]) && ls[i].indexOf(CONFIG.layerEvacuationHeader) >= 0) {
            ls.splice(i, 1);
            this._isVisibleDialog = (this._isVisibleDialog || (d.charAt(i) == "1"))
          }
        }
      }
      else {
        var lsct = 0;
        for (var i = ls.length - 1; i >= 0; i--) {
          if (ls[i].indexOf(CONFIG.layerEvacuationHeader) >= 0) {
            if (lsct > 0) {
              ls.splice(i, 1);
            }
            lsct++;
          }
        }
      }
      this._queryParams.params["ls"] = ls.join('|');
    }

    var dct = 0;
    if (ly) {
      for (var i = ly.length - 1; i >= 0; i--) {
        if (lcd && lcd.indexOf(CONFIG.layerEvacuationHeader) >= 0) {
          if ((lcd != ly[i].id) && ly[i].id.indexOf(CONFIG.layerEvacuationHeader) >= 0) {
            ly.splice(i, 1);
          }
        }
        else {
          if (ly[i].id.indexOf(CONFIG.layerEvacuationHeader) >= 0) {
            if (dct > 0) {
              ly.splice(i, 1);
            }
            dct++;
          }
        }
      }
    }
  },
  cancel: function () {
    var ls, ly, lcd;
    if (this._queryParams.params["ls"]) {
      ls = this._queryParams.params["ls"].split("|");
    }
    ly = this._queryParams._layers;
    lcd = this._queryParams.params["lcd"];

    if (ls) {
      for (var i = ls.length - 1; i >= 0; i--) {
        if (ls[i].indexOf(CONFIG.layerEvacuationHeader) >= 0) {
          ls.splice(i, 1);
        }
      }
      this._queryParams.params["ls"] = ls.join('|');
    }

    if (lcd) {
      if (lcd.indexOf(CONFIG.layerEvacuationHeader) >= 0) {
        this._queryParams.params["lcd"] = null;
      }
    }

    if (ly) {
      for (var i = ly.length - 1; i >= 0; i--) {
        if (ly[i].id.indexOf(CONFIG.layerEvacuationHeader) >= 0) {
          ly.splice(i, 1);
        }
      }
    }
    this._isVisibleDialog = false;
  },
  isVisibleDialog: function () {
    return this._isVisibleDialog;
  }
});

/************************************************************************
 L.Class
 - GSI.Edit.Marker
 ************************************************************************/
GSI.Edit.Marker = L.Evented.extend({
  options: {},
  initialize: function (marker, options) {
    this.marker = marker;
    this.marker.dragging.enable();

    this._dragHandler = L.bind(this._onDrag, this);
    this.marker.on("drag", this._dragHandler);

    this._zIndexOffset = marker.options.zIndexOffet;
    this.marker.setZIndexOffset(3500);

    if (this.marker) this._map = this.marker._map;
    options = L.setOptions(this, options);
  },

  _onDrag: function (e) {
    if (e.oldLatLng) {
      this.marker._latlng.alt = e.oldLatLng.alt;
    }
  },

  setOptions: function (options) {
    if (!this.marker) return;

    if (options.icon)
      this.marker.setIcon(options.icon);
  },
  enable: function () {
    if (!this.marker) return;

    if (this.marker.dragging) this.marker.dragging.enable();
  },
  disable: function () {
    if (!this.marker) return;

    this.marker.off("drag", this._dragHandler);
    if (this.marker.dragging) this.marker.dragging.disable();
  }
});

/************************************************************************
 L.Class
 - GSI.GeoLocation（位置情報取得）
 ************************************************************************/
/*
GSI.GeoLocation = L.Evented.extend({
  options: {
    watchInterval: 5000,
    max: 1000
  },
  initialize: function (map) {
    this.map = map;
  },

  getLocation: function () {
    if (GSI.GeoLocation.can) {
      if (this._getLocationId) return false;

      this._locationCounter = 0;
      this._getLocationId = navigator.geolocation.watchPosition(
        L.bind(function (loc) {
          if (loc.coords.accuracy < 100 || this._locationCounter >= 0) {
            var lat = loc.coords.latitude;
            var lng = loc.coords.longitude;
            var z = this.map.getZoom();
            if (z < 15) {
              z = CONFIG.SEARCHRESULTCLICKZOOM;
            }
            this.map.setView([lat, lng], z);
            // クリア
            navigator.geolocation.clearWatch(this._getLocationId);
            this._getLocationId = null;
          }
          this._locationCounter++;
        }, this),
        L.bind(function (error) {
          alert(GSI.TEXT.GEOLOCATION.ERROR[error.code] + "\n\n(message)\n" + error.message);
        }, this),
        { enableHighAccuracy: true, timeout: 60000, maximumAge: 0 }
      );

      return true;
    }
    else return false;

  }
});

GSI.GeoLocation.can = (navigator.geolocation && typeof navigator.geolocation.getCurrentPosition == 'function' ? true : false);
*/
/************************************************************************
 L.Class
 - GSI.LocationWatcher（位置情報監視）
 ************************************************************************/
GSI.LocationWatcher = L.Evented.extend({
  options: {
    watchInterval: 3000,
  },
  initialize: function () {

  },

  start: function () {

    if (this._getLocationId) return;

    this._getLocationId = navigator.geolocation.watchPosition(
      L.bind(function (loc) {
        if (!this._watchTimerId) {
          this.fire("change", { "coords": loc.coords, "original": loc });
          this._watchTimerId = setInterval(L.bind(this._onWatch, this), this.options.watchInterval);
        } else {
          this._lastLocation = loc;
        }
      }, this),
      L.bind(function (error) {
        if (error.code == 1) {
          this.fire("stop");
        }
        alert(GSI.TEXT.GEOLOCATION.ERROR[error.code] + "\n\n(message)\n" + error.message);
      }, this),
      { enableHighAccuracy: true, timeout: 60000, maximumAge: 3000 }
    );
  },

  _onWatch: function () {
    if (!this._lastLocation) return;
    this.fire("change", { "coords": this._lastLocation.coords, "original": this._lastLocation });
    this._lastLocation = null;
  },

  destroy: function () {
    this.off();
    if (!this._getLocationId) return;
    // クリア
    navigator.geolocation.clearWatch(this._getLocationId);
    this._getLocationId = null;
    if (this._watchTimerId) {
      clearTimeout(this._watchTimerId);
      this._watchTimerId = null;
    }
  }
});

/************************************************************************
 L.Class
 - GSI.Header
 ************************************************************************/
GSI.Header = L.Evented.extend({
  options: {
    visible: true
  },
  topMessageVisible: false,
  header: null,
  initialize: function (map, options) {
    options = L.setOptions(this, options);
    if (!options.visible) {
      $("#header").hide();
      $("#topmessage").hide();
      this.topMessageVisible = false;
    }
    else {
      this.header = $("#header");
      this.logoImage = $("#logoimage");
      this.topMessage = $("#topmessage");

      // お知らせ表示
      if (this._isVisibleStart()) //options.message && options.message != '' )
      {
        this.topMessage.empty().append($("<div>").addClass('message').html(options.message));
        var closeBtn = $('<a>').addClass('closebtn').attr({ 'href': 'javascript:void(0);' }).html('×');

        this.topMessage.append(closeBtn);

        closeBtn.on('click',L.bind(this.onCloseClick, this));

        this.topMessageVisible = true;
      }
      else {
        $("#topmessage").hide();
        this.header.addClass('border_bottom');
        this.topMessageVisible = false;
      }
    }
    this.map = map;
  },
  _isVisibleStart: function () {
    if (this.options.message && this.options.message != '') {
      if (this.options.expires > 0) {
        try {
          var cookie = new GSI.Utils.Cookie();
          var isHidden = cookie.get('topmessage_hidden');
          var id = cookie.get('topmessage_id');
          // id change
          if (isHidden == '1' && (id == this.options.id)) return false;
        }
        catch (e) { }
      }
      else {
        try {
          cookie.remove('topmessage_hidden');
          cookie.remove('topmessage_id');
        }
        catch (e) { }
      }
      return true;
    }
    else {
      return false;
    }
  },
  hideTopMessage: function () {
    this.topMessage.hide();
    this.header.addClass('border_bottom');
    this.topMessageVisible = false;

    try {
      if (this.options.expires > 0) {
        var cookie = new GSI.Utils.Cookie();
        cookie.set('topmessage_hidden', '1', { expires: this.options.expires });
        if (this.options.id)
          cookie.set('topmessage_id', this.options.id, { expires: this.options.expires });
        else
          cookie.remove('topmessage_id');
      }
      else {
        cookie.remove('topmessage_hidden');
        cookie.remove('topmessage_id');
      }
    }
    catch (e) { }
  },
  onCloseClick: function () {
    $("#map").animate(
      {
        top: "40px"
      },
      {
        duration: 80, easing: "linear",
        complete: L.bind(function () { this.hideTopMessage(); this.fire('topmessagechange'); }, this),
        step: L.bind(function () { this.fire('topmessagechange'); }, this)
      }
    );
  },
  getHeight: function () {
    if (!this.options.visible) return 0;
    var height = this.header.outerHeight();
    if ( !this.header.is(":visible")) height = 40;
    return height + (this.topMessageVisible ? this.topMessage.outerHeight(true) : 0);

  },
  refresh: function (screenSize) {
    if (!this.options.visible) return;

    var removeClassName = 'logo_l';
    var addClassName = 'logo_s';
    var imageUrl = 'image/logo_s.png';

    if (screenSize.w >= 600) {
      removeClassName = 'logo_s';
      addClassName = 'logo_l';
      imageUrl = 'image/logo_l.png';
    }

    this.header.removeClass(removeClassName);
    this.header.addClass(addClassName);
    if (this.currentImageUrl != imageUrl) {
      this.logoImage.attr({ src: imageUrl });
      this.currentImageUrl = imageUrl;
    }
  }
});

/************************************************************************
 L.Class
 - GSI.IconSelector
 ************************************************************************/
GSI.IconSelector = L.Evented.extend({
  iconList: [],
  options: {
    cols: 10
  },
  initialize: function (image, iconList, options) {
    this.image = image;
    this.image.css({ cursor: 'pointer' });
    this.iconList = (iconList ? iconList : []);

    options = L.setOptions(this, options);

    this.image.on('click',L.bind(this.onClick, this));
  },
  onClick: function () {
    this.show();
  },
  onSelect: function (iconInfo) {
    this.image.attr({ src: iconInfo.url });
    this.selectedIcon = iconInfo;
    this.fire('select', { selectedIcon: iconInfo });
    this.hide();
  },
  setSelectedIcon: function (iconUrl) {
    this.selectedIcon = null;
    for (var i = 0; i < this.iconList.length; i++) {
      if (this.iconList[i].url == iconUrl) {
        this.selectedIcon = this.iconList[i];
        break;
      }
    }
  },
  create: function () {
    if (this.container) return;

    this.container = $('<div>').addClass('gsi_iconselector').hide();

    var table = $('<table>');
    var tbody = $('<tbody>');
    var tr = null;
    var colNo = 0;

    for (var i = 0; i < this.iconList.length; i++) {
      var iconInfo = this.iconList[i];
      colNo = i % this.options.cols;

      if (colNo == 0) {
        tr = $('<tr>');
        tbody.append(tr);
      }

      var td = $('<td>');
      var a = $('<a>').attr({ href: 'javascript:void(0);' }).on('click',L.bind(this.onSelect, this, iconInfo));
      var image = $('<img>').attr({ src: iconInfo.url });
      if (iconInfo.size) {
        image.css({
          width: iconInfo.size[0],
          height: iconInfo.size[1]
        });
      }

      a.append(image);
      td.append(a);
      tr.append(td);
    }

    if (tr) {
      for (var i = colNo; i < this.options.cols; i++) {
        var td = $('<td>').html('<br>');
        tr.append(td);
      }
    }

    table.append(tbody);
    this.container.append(table);
    this.container.css('overflow', 'scroll').css('height', '500px');

    $(document.body).append(this.container);
  },
  show: function () {
    if (!this.container) this.create();

    var windowSize = GSI.Utils.getScreenSize();
    var offset = this.image.offset();
    var containerSize = { w: 0, h: 0 };
    if (!this.container.is(':visible')) {
      this.container.css({ "visibility": "hidden" });
      this.container.show();
      containerSize.w = this.container.outerWidth(true);
      containerSize.h = this.container.outerHeight(true);
      this.container.hide();
      this.container.css({ "visibility": "visible" });
    }
    else {
      containerSize.w = this.container.outerWidth(true);
      containerSize.h = this.container.outerHeight(true);
    }

    var pos = {
      left: offset.left - Math.floor(containerSize.w / 2),
      top: offset.top + this.image.outerHeight(true)
    };

    if (pos.top + containerSize.h > windowSize.h) pos.top = windowSize.h - containerSize.h;
    if (pos.left + containerSize.w > windowSize.w) pos.left = windowSize.w - containerSize.w;

    if (pos.left < 0) pos.left = 0;
    this.container.css({
      left: pos.left + 'px',
      top: pos.top + 'px'
    });

    this.container.slideDown('fast');

    if (!this._onScreenMouseDown) {
      this._onScreenMouseDown = L.bind(this.onScreenMouseDown, this);
      $(document.body).on('mousedown', this._onScreenMouseDown);
    }
  },
  hide: function () {
    if (this._onScreenMouseDown) {
      $(document.body).off('mousedown', this._onScreenMouseDown);
      this._onScreenMouseDown = null;
    }

    if (!this.container) return;
    this.container.slideUp('fast');
  },
  onScreenMouseDown: function (event) {
    if (!this.container) return;
    if (this.container[0] == event.target) return;

    var target = $(event.target);
    var parents = target.parents();

    for (var i = 0; i < parents.length; i++) {
      if (parents[i] == this.container[0]) {
        return;
      }
    }

    this.hide();
  }
});

/************************************************************************
 L.Class
 - GSI.JihokuLine（磁北線）
 ************************************************************************/
GSI.JihokuLine = L.Class.extend({
  options: {
    visible: false,
    num: 5,
    lineStyle: {
      "color": "#ff0000",
      "weight": 2,
      "opacity": 1,
      "fill": false,
      "fillOpacity": 1,
      "clickable": false
    },
    labelClassName: 'jihoku_label'
  },
  initialize: function (map, options) {
    options = L.setOptions(this, options);
    options.lineStyle.noGeodesic = true;
    this._map = map;

    this._refresh = L.bind(this.refresh, this);

    this.setVisible(this.options.visible);
  },
  getVariation: function () {
    //円周率
    var pi = Math.PI;
    var center = this._map.getCenter();
    return GSI.Utils.getVariation(center) * pi / 180;	// 角度をラジアンに変換
  },

  drawPath: function (texture, latLngBounds, pixelBounds) {
    if (!this._lines) return;

    if (!pixelBounds) {
      pixelBounds = this._map.getPixelBounds();
      latLngBounds = this._map.getBounds();
    }

    var zoom = this._map.getZoom();

    texture.lineWidth = this.options.lineStyle.weight;
    texture.strokeStyle = this.options.lineStyle.color;
    texture.globalAlpha = 1;

    for (var i = 0; i < this._lines.length; i++) {
      var line = this._lines[i];
      var latlngs = line.getLatLngs();

      if (!L.LineUtil.isFlat(latlngs)) latlngs = latlngs[0];

      var p1 = this._map.project(latlngs[0], zoom);
      var p2 = this._map.project(latlngs[latlngs.length - 1], zoom);
      p1.x -= pixelBounds.min.x;
      p1.y -= pixelBounds.min.y;
      p2.x -= pixelBounds.min.x;
      p2.y -= pixelBounds.min.y;

      texture.beginPath();
      texture.moveTo(p1.x, p1.y);
      texture.lineTo(p2.x, p2.y);
      texture.stroke();
    }

    if (this._label) {
      var latLng = this._label._latlng;

      var p = this._map.project(latLng, zoom);
      p.x -= pixelBounds.min.x;
      p.y -= pixelBounds.min.y;

      texture.globalAlpha = 1.0;
      texture.fillStyle = this.options.lineStyle.color;
      texture.textBaseline = 'top';
      texture.textAlign = 'left';
      texture.font = "bold 10.5pt 'Lucida Grande','Hiragino Kaku Gothic ProN', 'ヒラギノ角ゴ ProN W3', Meiryo, メイリオ, sans-serif";
      texture.fillText(this._label._variation, p.x + 8, p.y - 32);
    }

  },

  _updateStyle: function (texture, layer) {
    if (!layer._parts) return;

    var options = layer.options;
    if (options.stroke) {
      texture.lineWidth = options.weight;
      texture.strokeStyle = options.color;
    }
    if (options.fill) {
      texture.fillStyle = options.fillColor || options.color;
    }
  },

  _drawPath: function (texture, layer) {
    if (!layer._parts) return;

    var i, j, len, len2, point, drawMethod;
    var vp = this._map._pathViewport;

    var origin = this._map.getPixelOrigin();
    var pixelBounds = this._map.getPixelBounds();
    texture.beginPath();

    var parts = layer._parts;

    for (i = 0, len = parts.length; i < len; i++) {

      for (j = 0, len2 = parts[i].length; j < len2; j++) {
        point = parts[i][j];
        drawMethod = (j === 0 ? 'move' : 'line') + 'To';

        texture[drawMethod](point.x + (origin.x - pixelBounds.min.x), point.y + (origin.y - pixelBounds.min.y));
      }
      // TODO refactor ugly hack
      if (layer instanceof L.Polygon || layer instanceof L.Circle) {
        texture.closePath();
      }
    }

    texture.save();
    this._updateStyle(texture, layer);

    var opacity = 1;
    if (layer.options.fill) {

      texture.globalAlpha = (layer.options.fillOpacity ? layer.options.fillOpacity : 1) * opacity;
      texture.fill();
    }
    if (layer.options.stroke) {
      texture.globalAlpha = opacity;
      texture.stroke();
    }

    texture.restore();
  },

  clear: function () {
    if (this._layer) {
      this._map.removeLayer(this._layer);
      this._layer = null;
    }
    this._lines = null;
    this._label = null;
  },
  refresh: function () {
    var center = this._map.getCenter();
    //非表示 or 下記範囲外
    //経度：122度～154度
    //緯度：20度～46度
    if (
      (!this.options.visible)
      ||
      !GSI.Utils.isVaridVariation(center)
    ) {
      this.clear();
      return;
    }

    // ズームレベルが設定を下回る場合、表示しない
    if (this._map.getZoom() < CONFIG.JIHOKULINEAVAILABLEZOOM) {
      this.clear();
      return;
    }

    var mc = GSI.Utils.get2ndMesh(center.lat, center.lng);

    var count = this.options.num;
    if (!GSI.MeshDeclination[mc]) {
      this.clear();
      return;
    }
    var variation = GSI.MeshDeclination[mc];
    var idx1 = variation.indexOf(",");
    var nVariation = parseFloat(variation.substring(0, idx1));
    var sVariation = variation.substring(idx1 + 1);

    //円周率
    var pi = Math.PI;
    var center = this._map.getCenter();
    var rad = nVariation * pi / 180;	// 角度をラジアンに変換

    // 地図中央の経度
    var centerLng = this._map.getCenter().lng;
    var bounds = this._map.getBounds();

    // 表示されている領域の高さ
    var mapHeight = Math.abs(bounds.getSouth() - bounds.getNorth());
    // 表示されている領域の幅
    var mapWidth = Math.abs(bounds.getEast() - bounds.getWest());

    if (!this._lines) this._lines = [];
    var layer = (this._layer ? this._layer : L.featureGroup());
    layer._noMeasure = true;

    var lineStyle = this.options.lineStyle;

    for (var i = 0; i < count; i++) {
      var latLngArr = null;

      if (Math.tan(rad) >= 0) {
        latLngArr = [
          L.latLng(bounds.getNorth(), bounds.getWest() + (mapWidth - mapHeight * Math.tan(rad) / Math.cos(center.lat * pi / 180)) * i / (count - 1)),
          L.latLng(bounds.getSouth(), bounds.getWest() + (mapWidth - mapHeight * Math.tan(rad) / Math.cos(center.lat * pi / 180)) * i / (count - 1) + mapHeight * Math.tan(rad) / Math.cos(center.lat * pi / 180))
        ];
      } else {
        latLngArr = [
          L.latLng(bounds.getNorth(), bounds.getWest() + (mapWidth - mapHeight * Math.tan(rad) / Math.cos(center.lat * pi / 180)) * i / (count - 1) + mapHeight * Math.tan(rad) / Math.cos(center.lat * pi / 180)), L.latLng(bounds.getSouth(),
            bounds.getWest() + (mapWidth - mapHeight * Math.tan(rad) / Math.cos(center.lat * pi / 180)) * i / (count - 1))
        ];
      }

      if (this._lines.length - 1 < i) {
        var line = L.polyline(latLngArr, lineStyle);
        line._noMeasure = true;
        layer.addLayer(line);

        this._lines.push(line);
      }
      else {
        this._lines[i].setLatLngs(latLngArr);
      }
    }

    var KKK_NUM = sVariation;

    if (!this._label) {

      // ラベル表示
      var label = new L.Label({
        zoomAnimation: true,
        noHide: true,
        offset: [0, -34],
        className: this.options.labelClassName + " nomaptoimage",
        clickable: false
      });
      label.setContent('<div unselectable="on">' + KKK_NUM + '</div>');
      label.setLatLng(this._map.getCenter());
      this._label = label;
      layer.addLayer(label);
    }
    else {

      this._label.setContent('<div unselectable="on">' + KKK_NUM + '</div>');
      this._label.setLatLng(this._map.getCenter());

    }
    this._label._variation = sVariation;

    if (!this._layer) {
      this._layer = layer;
      this._map.addLayer(this._layer);
    }
    if (this._layer) this._layer.bringToBack();
  },
  setVisible: function (on) {
    this.options.visible = on;
    if (this.options.visible) {
      this._map.on('move', this._refresh);
    }
    else {
      this._map.off('move', this._refresh);
    }
    this.refresh();
  },
  getVisible: function () {
    return this.options.visible;
  }
});

/************************************************************************
 L.Class
 - GSI.TileGrid（タイル座標）
 ************************************************************************/
GSI.TileGridLayer = L.GridLayer.extend({

  _initContainer: function () {
    if (this._container) { return; }
    var tilePane = this._map._panes.overlayPane;
    this._container = L.DomUtil.create('div', 'leaflet-layer ' + (this.options.className || ''));
    this._updateZIndex();

    if (this.options.opacity < 1) {
      this._updateOpacity();
    }

    tilePane.insertBefore(this._container, tilePane.firstChild);

  },

  createTile: function (coords) {
    // create a <canvas> element for drawing
    var tile = L.DomUtil.create('canvas', 'leaflet-tile');
    // setup tile width and height according to the options
    var size = this.getTileSize();
    tile.width = size.x;
    tile.height = size.y;
    // get a canvas context and draw something on it using coords.x, coords.y and coords.z
    var ctx = tile.getContext('2d');
    // return the tile so it can be rendered on screen
    this.drawTile(tile, coords);

    return tile;
  },

  drawTo: function (texture) {
    var ctx = texture;
    var zoom = this._map.getZoom();

    var origin = this._map.getPixelOrigin();
    var pixelBounds = this._map.getPixelBounds();

    for (var key in this._tiles) {
      var tile = this._tiles[key];

      var pos = $(tile).position();
      pos.left += (origin.x - pixelBounds.min.x);
      pos.top += (origin.y - pixelBounds.min.y);

      ctx.globalAlpha = 1.0;
      ctx.fillStyle = '#FF0000';
      ctx.strokeStyle = '#FF0000';
      ctx.strokeRect(
        pos.left,
        pos.top, 255, 255);

      ctx.textAlign = 'center';
      ctx.font = 'bold 24px sans-serif';
      ctx.fillStyle = '#FF0000';
      ctx.strokeStyle = '#fff';

      ctx.lineWidth = 5;
      ctx.strokeText(zoom + '/' + tile._tilePoint.x + '/' + tile._tilePoint.y,
        pos.left + 128, pos.top + 128);
      ctx.globalAlpha = 1.0;
      ctx.fillText(zoom + '/' + tile._tilePoint.x + '/' + tile._tilePoint.y,
        pos.left + 128, pos.top + 128);
    }
  },

  drawTile: function (canvas, coords) {
    var ctx = canvas.getContext('2d');
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = '#FF0000';
    ctx.strokeStyle = '#FF0000';
    ctx.strokeRect(0, 0, 255, 255);
    ctx.textAlign = 'center';
    ctx.font = 'bold 24px sans-serif';
    ctx.fillStyle = '#FF0000';
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 5;
    ctx.strokeText(coords.z + '/' + coords.x + '/' + coords.y, 128, 128);
    ctx.globalAlpha = 1.0;
    ctx.fillText(coords.z + '/' + coords.x + '/' + coords.y, 128, 128);
  }
});

GSI.TileGrid = L.Evented.extend({
  options: {
    lineStyle: {
      color: "#1D417A",
      weight: 2,
      opacity: 1,
      fillOpacity: 1,
      dashArray: [3, 3]
    },
    labelClassName: 'latlnggrid_label'
  },
  visible: false,
  initialize: function (map, options) {
    this._layer = null;
    this._map = map;

    options = L.setOptions(this, options);

    options.lineStyle.clickable = false;
    options.lineStyle.noGeodesic = true;

    this._visible = options.visible;
    this.setVisible(this._visible);
  },

  drawPath: function (texture, latLngBounds, pixelBounds) {
    if (!pixelBounds) {
      pixelBounds = this._map.getPixelBounds();
      latLngBounds = this._map.getBounds();
    }

    var tileSize = 256;
    var tileBounds = L.bounds(
      pixelBounds.min.divideBy(tileSize)._floor(),
      pixelBounds.max.divideBy(tileSize)._floor());

    var zoom = this._map.getZoom();

    var canvas = document.createElement("canvas");
    canvas.width = tileSize;
    canvas.height = tileSize;

    var ctx = canvas.getContext("2d");

    for (var j = tileBounds.min.y; j <= tileBounds.max.y; j++) {
      for (var i = tileBounds.min.x; i <= tileBounds.max.x; i++) {

        var p = L.point(i * tileSize - pixelBounds.min.x, j * tileSize - pixelBounds.min.y);

        ctx.clearRect(0, 0, tileSize, tileSize);
        ctx.beginPath();
        var lineWidth = ctx.lineWidth;
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = '#FF0000';
        ctx.strokeStyle = '#FF0000';
        ctx.strokeRect(0, 0, tileSize, tileSize);
        ctx.textAlign = 'center';
        ctx.font = 'bold 24px sans-serif';
        ctx.fillStyle = '#FF0000';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 5;
        ctx.strokeText(zoom + '/' + i + '/' + j, 128, 128);
        ctx.globalAlpha = 1.0;
        ctx.fillText(zoom + '/' + i + '/' + j, 128, 128);
        ctx.lineWidth = lineWidth;

        texture.drawImage(canvas, p.x, p.y, tileSize, tileSize);

      }
    }
  },

  setVisible: function (on) {
    this._visible = on;
    if (this._layer)
      this._map.removeLayer(this._layer);
    if (this._visible) {
      this._layer = new GSI.TileGridLayer({ minZoom: 2, maxZoom: 18 });
      this._map.addLayer(this._layer);
    }
    this.fire("change");
  },
  getVisible: function () {
    return this._visible;
  }
});

/************************************************************************
 L.Class
 - GSI.ChiikiMesh（地域メッシュ）
 ************************************************************************/
GSI.ChiikiMesh = L.Evented.extend({
  options: {
    lineStyle: {
      color: "#1D417A",
      weight: 2,
      opacity: 1,
      fillOpacity: 1,
      dashArray: [3, 3]
    },
    labelClassName: 'latlnggrid_label'
  },
  visible: false,
  initialize: function (map, options) {
    this._layer = null;
    this._map = map;

    options = L.setOptions(this, options);

    options.lineStyle.clickable = false;
    options.lineStyle.noGeodesic = true;

    this._visible = options.visible;
    this.setVisible(this._visible);
  },
  setVisible: function (on) {
    this._visible = on;

    if (this._layer)
      this._map.removeLayer(this._layer);
    if (this._visible) {

      if (!this._style) {
        $.ajax({
          type: "GET",
          url: CONFIG.CHIIKIMESH.STYLEURL,
          dataType: "text",
          cache: false,
          success: L.bind(this._onStyleLoad, this),
          error: L.bind(this._onStyleLoadError, this)
        });
      }
      else {
        this._layer = new GSI.VectorTileLayer(
          CONFIG.CHIIKIMESH.GEOJSONURL,
          this._style.options, this._style.geojsonOptions, true);

        this._map.addLayer(this._layer);
      }
    }

    this.fire("change");
  },
  getVisible: function () {
    return this._visible;
  },

  _onStyleLoad: function (text) {
    try {
      this._style = eval("(" + text + ")");
      this._style.options.skipLoadStyle = true;
    }
    catch (e) {
      this._onStyleLoadError();
      return;
    }
    if (this._layer)
      this._map.removeLayer(this._layer);
    if (this._visible) {

      this._layer = new GSI.VectorTileLayer(
        CONFIG.CHIIKIMESH.GEOJSONURL,
        this._style.options, this._style.geojsonOptions, true);

      this._map.addLayer(this._layer, this._style.geojsonOptions);
    }
  },

  _onStyleLoadError: function (text) {
    if (this._visible) {
      this._layer = new L.TileLayer.GeoJSON(
        CONFIG.CHIIKIMESH.GEOJSONURL,
        {});

      this._map.addLayer(this._layer);
    }
  }
});

/************************************************************************
 L.Evented
 - GSI.LatLngGrid（緯度経度グリッド）
 ************************************************************************/
GSI.LatLngGrid = L.Evented.extend({
  options: {
    lineStyle: {
      color: "#1D417A",
      weight: 2,
      opacity: 1,
      fillOpacity: 1,
      dashArray: [3, 3],
      noGeodesic: true
    },
    labelClassName: 'latlnggrid_label'
  },
  visible: false,
  initialize: function (map, options) {
    this._layer = null;
    this._map = map;

    options = L.setOptions(this, options);

    options.lineStyle.clickable = false;
    options.lineStyle.noGeodesic = true;

    this._refresh = L.bind(this.refresh, this);
    this._visible = options.visible;
    this.setVisible(this._visible);
  },
  clear: function () {
    if (this._layer) {
      this._map.removeLayer(this._layer);
      this._layer = null;
    }
    this._lines = null;
    this._labels = null;
  },

  drawPath: function (texture, latLngBounds, pixelBounds) {

    if (!this._lines) return;

    if (!pixelBounds) {
      pixelBounds = this._map.getPixelBounds();
      latLngBounds = this._map.getBounds();
    }

    var zoom = this._map.getZoom();
    var distance = 3600 * 5;

    for (var i = 0; i < this.options.condition.length; i++) {
      var c = this.options.condition[i];
      if (zoom <= c.zoom) {
        distance = c.grid;
        break;
      }
    }

    var south = latLngBounds.getSouth();
    var north = latLngBounds.getNorth();
    var west = latLngBounds.getWest();
    var east = latLngBounds.getEast();

    if (south < -90) south = -90;
    if (north >= 90) north = 90;

    if (west < -180) west = -180;
    if (west > 180) west = 180;

    if (east < -180) east = -180;
    if (east > 180) east = 180;

    var startLat = Math.floor(Math.floor(Math.floor(south * distance) / distance) * 3600);
    startLat = Math.floor(Math.floor(south * 3600) / distance) * distance;

    var endLat = Math.floor(north * 3600);

    var startLng = Math.floor(Math.floor(Math.floor(west * distance) / distance) * 3600);
    startLng = Math.floor(Math.floor(west * 3600) / distance) * distance;
    var endLng = Math.floor(east * 3600);

    texture.lineWidth = this.options.lineStyle.weight;
    texture.strokeStyle = this.options.lineStyle.color;
    texture.globalAlpha = 1;

    for (var y = startLat; y < endLat + distance; y += distance) {
      var lat = y / 3600.0;

      if (lat < -80 || lat > 80) continue;

      var p1 = this._map.project(L.latLng(lat, west), zoom);
      var p2 = this._map.project(L.latLng(lat, east), zoom);
      p1.x -= pixelBounds.min.x;
      p1.y -= pixelBounds.min.y;
      p2.x -= pixelBounds.min.x;
      p2.y -= pixelBounds.min.y;

      texture.beginPath();
      texture.moveTo(p1.x, p1.y);
      this._lineToDot(texture, p1.x, p1.y, p2.x, p2.y);
      texture.stroke();

      for (var x = startLng; x < endLng + distance; x += distance) {
        var lng = x / 3600.0;

        if (lng < -180 || lng > 180) continue;

        var dms = GSI.Utils.latLngToDMS({ 'lng': lng, 'lat': lat });
        dms.lat.s = Math.round(dms.lat.s);
        dms.lng.s = Math.round(dms.lng.s);

        if (dms.lat.s == 60) { dms.lat.s = 0; dms.lat.m++; }
        if (dms.lng.s == 60) { dms.lng.s = 0; dms.lng.m++; }
        if (dms.lat.m == 60) { dms.lat.m = 0; dms.lat.d++; }
        if (dms.lng.m == 60) { dms.lng.m = 0; dms.lng.d++; }

        var latText = (lat < 0 ? '-' : '') + dms.lat.d + '°' + dms.lat.m + ' ′' + Math.round(dms.lat.s) + ' ″';
        var lngText = (lng < 0 ? '-' : '') + dms.lng.d + '°' + dms.lng.m + '′' + Math.round(dms.lng.s) + ' ″';

        var pText = this._map.project(L.latLng(lat, lng), zoom);
        pText.x -= pixelBounds.min.x;
        pText.y -= pixelBounds.min.y;
        texture.globalAlpha = 1.0;
        texture.fillStyle = '#1D417A';
        texture.textBaseline = 'bottom';
        texture.textAlign = 'left';
        texture.font = "bold 12pt 'Lucida Grande','Hiragino Kaku Gothic ProN', 'ヒラギノ角ゴ ProN W3', Meiryo, メイリオ, sans-serif";
        texture.fillText(latText, pText.x + 8, pText.y - 24);
        texture.fillText(lngText, pText.x + 8, pText.y - 6);
      }

    }

    for (var x = startLng; x < endLng + distance; x += distance) {
      var lng = x / 3600.0;
      if (lng < -180 || lng > 180) continue;

      var p1 = this._map.project(L.latLng(north, lng), zoom);
      var p2 = this._map.project(L.latLng(south, lng), zoom);
      p1.x -= pixelBounds.min.x;
      p1.y -= pixelBounds.min.y;
      p2.x -= pixelBounds.min.x;
      p2.y -= pixelBounds.min.y;

      texture.beginPath();
      texture.moveTo(p1.x, p1.y);
      this._lineToDot(texture, p1.x, p1.y, p2.x, p2.y);
      texture.stroke();

    }

  },

  _lineToDot: function (texture, p1x, p1y, p2x, p2y) {
    var d = Math.sqrt(Math.pow(p2x - p1x, 2) + Math.pow(p2y - p1y, 2));
    var rad = Math.atan2(p2y - p1y, p2x - p1x);
    var space = 3;
    var dotted = Math.round(d / space / 2);

    for (var i = 0; i < dotted; i++) {
      var p3x = Math.cos(rad) * space * (i * 2) + p1x;
      var p3y = Math.sin(rad) * space * (i * 2) + p1y;
      var p4x = Math.cos(rad) * space * (i * 2 + 1) + p1x;
      var p4y = Math.sin(rad) * space * (i * 2 + 1) + p1y;

      texture.moveTo(p3x, p3y);
      texture.lineTo(p4x, p4y);

    }
  },

  _updateStyle: function (texture, layer) {
    if (!layer._parts) return;

    var options = layer.options;
    if (options.stroke) {
      texture.lineWidth = options.weight;
      texture.strokeStyle = options.color;
    }
    if (options.fill) {
      texture.fillStyle = options.fillColor || options.color;
    }
  },

  _drawPath: function (texture, layer) {
    if (!layer._parts) return;

    var i, j, len, len2, point, drawMethod;
    var vp = this._map._pathViewport;

    var origin = this._map.getPixelOrigin();
    var pixelBounds = this._map.getPixelBounds();
    texture.beginPath();

    var parts = layer._parts;

    for (i = 0, len = parts.length; i < len; i++) {

      for (j = 0, len2 = parts[i].length; j < len2; j++) {
        point = parts[i][j];
        drawMethod = (j === 0 ? 'move' : 'line') + 'To';

        texture[drawMethod](point.x + (origin.x - pixelBounds.min.x), point.y + (origin.y - pixelBounds.min.y));
      }
      // TODO refactor ugly hack
      if (layer instanceof L.Polygon || layer instanceof L.Circle) {
        texture.closePath();
      }
    }

    texture.save();
    this._updateStyle(texture, layer);

    var opacity = 1;
    if (layer.options.fill) {

      texture.globalAlpha = (layer.options.fillOpacity ? layer.options.fillOpacity : 1) * opacity;
      texture.fill();
    }
    if (layer.options.stroke) {
      texture.globalAlpha = opacity;
      texture.stroke();
    }

    texture.restore();
  },

  refresh: function () {
    if (!this._visible) {
      this.clear();
      return;
    }

    if (GSI.Utils.Browser.ie && GSI.Utils.Browser.version <= 8) {
      this.clear();
    }
    var bounds = this._map.getBounds();
    var zoom = this._map.getZoom();
    var distance = 3600 * 5;

    for (var i = 0; i < this.options.condition.length; i++) {
      var c = this.options.condition[i];
      if (zoom <= c.zoom) {
        distance = c.grid;
        break;
      }
    }

    var south = bounds.getSouth();
    var north = bounds.getNorth();
    var west = bounds.getWest();
    var east = bounds.getEast();

    if (south < -90) south = -90;
    if (north >= 90) north = 90;

    if (west < -180) west = -180;
    if (west > 180) west = 180;

    if (east < -180) east = -180;
    if (east > 180) east = 180;

    var startLat = Math.floor(Math.floor(Math.floor(south * distance) / distance) * 3600);
    startLat = Math.floor(Math.floor(south * 3600) / distance) * distance;

    var endLat = Math.floor(north * 3600);

    var startLng = Math.floor(Math.floor(Math.floor(west * distance) / distance) * 3600);
    startLng = Math.floor(Math.floor(west * 3600) / distance) * distance;
    var endLng = Math.floor(east * 3600);

    var lineStyle = this.options.lineStyle;
    if (!this._lines) this._lines = [];
    if (!this._labels) this._labels = [];

    var lineNo = 0;
    var labelNo = 0;
    var layer = (this._layer ? this._layer : L.featureGroup());

    layer._noMeasure = true;

    for (var y = startLat; y < endLat + distance; y += distance) {
      var lat = y / 3600.0;

      if (lat < -80 || lat > 80) continue;
      var latLngArr = [
        L.latLng(lat, west),
        L.latLng(lat, east)
      ];

      if (lineNo >= this._lines.length) {
        var line = L.polyline(latLngArr, lineStyle);
        line._noMeasure = true;
        this._lines.push(line);
        layer.addLayer(line);
      }
      else {
        this._lines[lineNo].setLatLngs(latLngArr);
      }
      lineNo++;

      // ラベル表示
      for (var x = startLng; x < endLng + distance; x += distance) {
        var lng = x / 3600.0;

        if (lng < -180 || lng > 180) continue;

        var dms = GSI.Utils.latLngToDMS({ 'lng': lng, 'lat': lat });
        dms.lat.s = Math.round(dms.lat.s);
        dms.lng.s = Math.round(dms.lng.s);

        if (dms.lat.s == 60) { dms.lat.s = 0; dms.lat.m++; }
        if (dms.lng.s == 60) { dms.lng.s = 0; dms.lng.m++; }
        if (dms.lat.m == 60) { dms.lat.m = 0; dms.lat.d++; }
        if (dms.lng.m == 60) { dms.lng.m = 0; dms.lng.d++; }

        var content =
          '<div unselectable = "on">' + (lat < 0 ? '-' : '') + dms.lat.d + '°' + dms.lat.m + ' ′' + Math.round(dms.lat.s) + ' ″' + '</div>'
          +
          '<div unselectable = "on">' + (lng < 0 ? '-' : '') + dms.lng.d + '°' + dms.lng.m + '′' + Math.round(dms.lng.s) + ' ″' + '</div>';
        var latLng = { 'lng': lng, 'lat': lat };

        var label = null;

        if (labelNo >= this._labels.length) {
          label = new L.Label({
            zoomAnimation: true,
            noHide: true,
            offset: [8, -34],
            className: this.options.labelClassName + " nomaptoimage",
            clickable: false
          });
          label.setContent(content);
          label.setLatLng(latLng);
          this._labels.push(label);
          layer.addLayer(label);
        }
        else {
          label = this._labels[labelNo];
          label.setContent(content);
          label.setLatLng(latLng);
        }
        labelNo++;
      }
    }

    for (var x = startLng; x < endLng + distance; x += distance) {
      var lng = x / 3600.0;
      if (lng < -180 || lng > 180) continue;

      var latLngArr = [
        L.latLng(north, lng),
        L.latLng(south, lng)
      ];

      if (lineNo >= this._lines.length) {
        var line = L.polyline(latLngArr, lineStyle);
        line._noMeasure = true;
        this._lines.push(line);
        layer.addLayer(line);
      }
      else {
        this._lines[lineNo].setLatLngs(latLngArr);
      }
      lineNo++;
    }

    if (!this._layer) {
      this._layer = layer;
      this._map.addLayer(this._layer);
    }

    // 不要なライン、ラベルの削除
    this._clearLayerArr(this._lines, lineNo);
    this._clearLayerArr(this._labels, labelNo);

    if (this._layer) this._layer.bringToBack();
  },
  _clearLayerArr: function (arr, idx) {
    if (this._layer) {
      for (var i = idx; i < arr.length; i++) {
        this._layer.removeLayer(arr[i]);
      }
    }
    if (arr.length > idx) {
      arr.splice(idx);
    }
  },
  setVisible: function (on) {
    this._visible = on;
    if (this._visible) {
      this._map.on('moveend', this._refresh);
      this.refresh();
    }
    else {
      this._map.off('moveend', this._refresh);
      this.clear();
    }
    this.fire("change");
  },
  getVisible: function () {
    return this._visible;
  }
});

/************************************************************************
 L.Class
 - GSI.LayerOpacitySetter（各レイヤーへの不透明度設定）
 ************************************************************************/
GSI.LayerOpacitySetter = L.Class.extend({
  opacity: 1,
  getOpacity: function () {
    return this.opacity;
  },
  setOpacity: function (layer, opacity) {
    this.opacity = opacity;
    this._setLayerOpacity(layer);
  },
  _setLayerOpacity: function (layer) {
    if (!layer) return;

    if (layer.setOpacity) {
      layer.setOpacity(this.opacity);
    }
    else if (layer._renderer && layer._renderer._container) {
      $(layer._path).css({ opacity: this.opacity });
    }
    else if (layer._icon) {
      $(layer._icon).css({ opacity: this.opacity });
    }
    else if (layer._container) {
      $(layer._container).css({ opacity: this.opacity });
    }
    if (layer.eachLayer) {
      layer.eachLayer(L.bind(this._setLayerOpacity, this));
    }
  }
});

/************************************************************************
 L.Class
 - GSI.LayersJSON（layers.txt読み込み）
 ************************************************************************/
GSI.LayersJSON = L.Evented.extend({
  ajax: null,
  currentFileIndex: -1,
  options: {
    files: ["layers.txt"]
  },
  initialize: function (options) {
    this.layers = [];
    this.visibleLayers = [];
    this.visibleLayersHash = {};
    this._load_base = false;
    this._loadingData = null;
    this._data = [];
    this._urlData = {};
    this._tabs = null;
    this._tabUrl = options.tabsUrl;

    options = L.setOptions(this, options);

    if (options.layers) {
      this.options.layers = $.extend(true, [], options.layers);

      this._loadingUrlList = [];
      this._urlData = {};
      for (var i = 0; i < this.options.layers.length; i++) {
        var url = this.options.layers[i];
        this._urlData[url] = {};
        this._loadingUrlList.push({
          url: url,
          load: false,
          layers: [],
          isDetail: true
        });
      }
    }
  },
  initialize_layers: function (layers) {
    this.visibleLayers = [];
    this.visibleLayersHash = {};

    if (!layers) {
      this.options.visibleLayers = [];
    }
    else {
      this.options.visibleLayers = layers;
    }

    var fBaseMap = false;
    for (var i = 0; i < this.options.visibleLayers.length; i++) {
      var layerData = this.options.visibleLayers[i];
      var fBaseMapItem = false;
      for (var iBaseMap = 0; iBaseMap < CONFIG.BASETILES.length; iBaseMap++) {
        if (layerData.id == CONFIG.BASETILES[iBaseMap].id) {
          fBaseMapItem = true;
          break;
        }
      }

      if (fBaseMapItem) {
        if (fBaseMap) {
          continue;
        }
        fBaseMap = true;
      }

      var info = {
        id: layerData.id,
        idx: this.visibleLayers.length,
        initialOpacity: layerData.opacity,
        hidden: layerData.hidden,
        blend: layerData.blend
      };
      this.visibleLayers.push(info);
      if (!this.visibleLayersHash[layerData.id])
        this.visibleLayersHash[layerData.id] = [];

      this.visibleLayersHash[layerData.id].push(info);
    }
  },
  initialize_layers_data: function (layers) {
    this.initialize_layers(layers);
    this._initializeData(this._data, null);

  },
  loadBase: function () {
    var load = this._load_base;
    this._load_base = true;
    return load;
  },
  setHasTileList: function (tileIdList) {
    this.hasTileList = tileIdList;
    this.refreshHasState();
  },
  refreshHasState: function () {
    if (!this.hasTileList || !this.layers) return;
    for (var i = 0; i < this.layers.length; i++) {
      var info = this.layers[i];
      info.hasTile = (this.hasTileList[info.id] == true || !info.cocotile);
    }

  },

  add: function (layers) {
    if (!layers) return;

    for (var i = 0; i < layers.length; i++) {
      var url = "";
      if (layers[i].url)
        url = layers[i].url;
      else
        url = layers[i];

      if (!this._urlData[url])
        this._urlData[url] = {};

      this._loadingUrlList.push({ url: url, isDetail: true, top: layers[i].top });
    }

    for (var url in this._urlData) {
      if (this._urlData[url].req || (this._urlData[url].loaded && !this._urlData[url].error)) {
        continue;
      }
      this._urlData[url].req = $.ajax({
        type: "GET",
        url: url,
        dataType: "text",
        cache: CONFIG.LOADLAYERSTXTCACHE,
        success: L.bind(this._onLoad, this, url),
        error: L.bind(this._onLoadError, this, url)
      });
    }

    this._loadFinishCheck();
  },
  load: function () {
    if (this._tabUrl && this._tabUrl != "") {
      // タブ情報読み込み
      $.ajax({
        type: "GET",
        dataType: "JSON",
        url: this._tabUrl,
        async: true
      })
        .done(L.bind(function (data) {
          CONFIG.layersTab = data;
          this._tabs = data;
          for (var i = 0; i < this._tabs.length; i++) {
            this._data.push({
              "type": "LayerGroup",
              "title": this._tabs[i].caption,
              "iconUrl": "",
              "toggleall": false,
              "isDetail": this._tabs[i].isDetail,
              "entries": [],
              "isTab": true
            });
            if (this._tabs[i].isDetail) {
              this._detailTabIndex = i;
            }
          }
        }, this))
        .always(L.bind(this._tabLoaded, this));
    }
    else {
      this._data.push({
        "type": "LayerGroup",
        "title": "トップ",
        "iconUrl": "",
        "toggleall": false,
        "isDetail": true,
        "entries": [],
        "isTab": true
      });
      this._tabs = [{
        "isDetail": true,
        "caption": "トップ",
        "layers": null
      }];
      this._detailTabIndex = 0;
      this._loadLayers();
    }

  },

  _tabLoaded: function () {
    if (!this._tabs) {
      alert("タブ情報が読み込めません");
      return;
    }
    this._loadLayers();
  },

  _loadLayers: function () {
    for (var url in this._urlData) {
      if (this._urlData[url].req || (this._urlData[url].loaded && !this._urlData[url].error)) {
        continue;
      }
      this._urlData[url].req = $.ajax({
        type: "GET",
        url: url,
        dataType: "text",
        cache: CONFIG.LOADLAYERSTXTCACHE,
        success: L.bind(this._onLoad, this, url),
        error: L.bind(this._onLoadError, this, url)
      });
    }
  },

  _onLoadError: function (url) {
    if (this._urlData) {
      this._urlData[url].req = null;
      this._urlData[url].loaded = true;
      this._urlData[url].error = true;
    }
  },
  _onLoad: function (url, data) {
    var json = JSON.parse(data);

    var initEvecDisaster = function(entries, func) {
      if  (!entries) return;
      for( var i=0; i<entries.length; i++ ) {
        if (entries[i].title == "指定緊急避難場所") {
          entries[i]["title_evac"] = CONFIG.layerEvacuationFolderSYS;
        } else if (entries[i].title == "自然災害伝承碑") {
          entries[i]["title_evac"] = CONFIG.DisasterLoreFolder;
          entries[i]["title_disasterlore"] = CONFIG.DisasterLoreFolderSYS;
        } else if (entries[i].title == "火山地形分類データ") {
          entries[i]["title_evac"] = CONFIG.VolcanoTerrainFolderSYS;
        } else {
          func( entries[i].entries, func );
        }
      }
    };
    if ((json.layers) && (json.layers[0].title) && (!json.layers[0].title_sys)) {
      var hybridjson = JSON.parse("{ \"layers\":[] }");
      for (var ll in json.layers) {
        if (json.layers[ll].title == "指定緊急避難場所") {
          var json_evac2 = JSON.parse("{ \"type\": \"LayerGroup\", \"title\": \"" + CONFIG.layerEvacuationFolder + "\", \"title_evac\": \"" + CONFIG.layerEvacuationFolderSYS + "\", \"iconUrl\": \"\", \"open\": false, \"toggleall\": false, \"entries\": [] }");
          json_evac2.entries = json.layers[ll].entries.concat();
          hybridjson.layers.push(json_evac2);
        }
        else if (json.layers[ll].title == "自然災害伝承碑") {
          var json_dh = JSON.parse("{ \"type\": \"LayerGroup\", \"title\": \"" + CONFIG.DisasterLoreFolder + "\", \"title_disasterlore\": \"" + CONFIG.DisasterLoreFolderSYS + "\", \"iconUrl\": \"\", \"open\": false, \"toggleall\": false, \"entries\": [] }");
          json_dh.entries = json.layers[ll].entries.concat();
          hybridjson.layers.push(json_dh);
        }
        else if (json.layers[ll].title == "火山地形分類データ") {
          var json_dh = JSON.parse("{ \"type\": \"LayerGroup\", \"title\": \"" + CONFIG.VolcanoTerrainFolder + "\", \"title_volcano_terrain\": \"" + CONFIG.VolcanoTerrainFolderSYS + "\", \"iconUrl\": \"\", \"open\": false, \"toggleall\": false, \"entries\": [] }");
          json_dh.entries = json.layers[ll].entries.concat();
          hybridjson.layers.push(json_dh);
        }
        else {
          initEvecDisaster( json.layers[ll].entries, initEvecDisaster );
          hybridjson.layers.push(json.layers[ll]);
        }
      }
      json = hybridjson;
    }

    if (json.layers) {
      this._onLoad_SRC_URL(json.layers, url);
    }

    if (this._urlData) {
      this._urlData[url].req = null;
      this._urlData[url].loaded = true;
      this._urlData[url].layers = $.extend(true, [], json.layers);
    }

    this._loadFinishCheck();

  },

  _loadFinishCheck: function () {
    var loaded = true;
    for (var key in this._urlData) {
      if (!this._urlData[key].loaded) {
        loaded = false;
        break;
      }
    }
    if (!loaded) return;

    for (var i = 0; i < this._loadingUrlList.length; i++) {
      // concatは？

      var urlData = this._urlData[this._loadingUrlList[i].url];
      if (this._loadingUrlList[i].isDetail) {
        if (!this._load_base) {
          var jsonBase = {
            "layers": [
              {
                "type": "LayerGroup",
                "title": CONFIG.layerBaseFolder,
                "title_sys": CONFIG.layerBaseFolderSYS,
                "iconUrl": "",
                "open": false,
                "toggleall": false,
                "entries": []
              }
            ]
          };

          jsonBase.layers[0].entries = $.extend(true, [], urlData.layers).concat();

          urlData = jsonBase;

        }

        if (this._loadingUrlList[i].top) {
          var baseLayerGroupIndex = null;
          for (var j = 0; j < this._data[this._detailTabIndex].entries.length; j++) {
            if (this._data[this._detailTabIndex].entries[j].title_sys == CONFIG.layerBaseFolderSYS) {
              baseLayerGroupIndex = j;
              break;
            }
          }
          for (var j = 0; j < urlData.layers.length; j++) {
            this._data[this._detailTabIndex].entries.splice(baseLayerGroupIndex, 0,
              $.extend(true, {}, urlData.layers[j]));
            baseLayerGroupIndex++;

          }
        }
        else {
          for (var j = 0; j < urlData.layers.length; j++) {
            this._data[this._detailTabIndex].entries.push($.extend(true, {}, urlData.layers[j]));
          }
        }
      }
      else {

        for (var j = 0; j < urlData.layers.length; j++) {
          this._data[this._loadingUrlList[i].tabIndex].entries.push($.extend(true, {}, urlData.layers[j]));
        }
      }
    }

    this._loadingUrlList = null;

    var _data = this._data.concat();
    this._initializeTreeCopy(_data, null);
    this._original = $.extend(true, [], _data);

    this.layers = [];

    if (!this._tabDataLoaded) {
      this._loadingUrlList = [];
      this._tabDataLoaded = true;
      for (var i = 0; i < this._tabs.length; i++) {
        if (this._tabs[i].layers == null) continue;
        for (var j = 0; j < this._tabs[i].layers.length; j++) {
          var url = this._tabs[i].layers[j];
          if (!this._urlData[url])
            this._urlData[url] = {};

          this._loadingUrlList.push({ url: url, isDetail: this._tabs[i].isDetail, tabIndex: i });
        }
      }
    }

    this._initializeData(this._data, null);

    this.fire("load", { tree: this.tree, visibleLayers: this.visibleLayers, visibleLayersHash: this.visibleLayersHash });

  },

  clone: function (layers) {
    var result = new GSI.LayersJSON({
      layers: this.options.layerBase,
      layersTab: this.options.layersTab
    });

    result._detailTabIndex = this._detailTabIndex;
    result._tabs = $.extend(true, [], this._tabs);
    result._data = $.extend(true, [], this._original);
    result._original = $.extend(true, [], this._original);

    var baseLayerGroup = this._findBaseLayerGroup(result._data);
    result._initializeData([baseLayerGroup], null);

    result.layers = [];
    if (layers)
      result.initialize_layers(layers);

    result._initializeData(result._data, null);

    return result;
  },

  _findBaseLayerGroup: function (list) {
    var result = null;

    for (var i = 0; i < list.length; i++) {
      var item = list[i];
      if (item["type"] != "LayerGroup") continue;

      if (item.title_sys == CONFIG.layerBaseFolderSYS) {
        result = item;
      }
      else if (item.entries) {
        result = this._findBaseLayerGroup(item.entries);
      }
      if (result) {
        break;
      }
    }

    return result;
  },

  _onLoad_SRC_URL: function (data, url) {
    for (var i = 0; i < data.length; i++) {
      if (data[i].type == "LayerGroup") {
        data[i].src_url = url;

        if (data[i].entries) {
          this._onLoad_SRC_URL(data[i].entries, url);
        }
      }
    }
  },
  getBase: function () {
    if (!this._baseEntries) {
      this._baseEntries = this._findBaseEntries(this._data[this._detailTabIndex].entries);
    }
    return this._baseEntries;
  },

  _findBaseEntries: function (entries) {
    var result = null;
    if (!entries) {
      return null;
    }
    for (var i = 0; i < entries.length; i++) {
      var item = entries[i];
      if (item.type != "LayerGroup") continue;

      if (item.title_sys == CONFIG.layerBaseFolderSYS) return item.entries;

      result = this._findBaseEntries(item.entries);

      if (result) break;
    }

    return result;
  },
  getOriginal: function () {
    return this._original;
  },
  _onFileLoad: function (e) {

    this._data = JSON.parse(e.text);
    this._original = $.extend(true, [], this._data);
    this.layers = [];

    this._initializeData(this._data, null);
    this.fire("load", { tree: this._data, visibleLayers: this.visibleLayers, visibleLayersHash: this.visibleLayersHash });
  },
  _initializeData: function (data, parent) {
    if (!data) return;
    this._initializeTree(data, parent);
    this.tree = data;
  },

  _getFolderId: function (lv) {
    if (!this._currentFolderIdList) this._currentFolderIdList = {};

    if (!this._currentFolderIdList['' + lv])
      this._currentFolderIdList['' + lv] = 1;

    var result = this._currentFolderIdList['' + lv];

    this._currentFolderIdList['' + lv]++;

    return result;
  },
  _initializeTree: function (tree, parent) {
    if (!this.layersHash) this.layersHash = {};

    if (!tree) return;
    var folderCount = 0;
    for (var i = 0; i < tree.length; i++) {

      if (tree[i].type == "Layer") {
        var info = tree[i];

        if (Array.isArray(info.url)) {
          for (var k = 0; k < info.url.length; k++) {
            if ((ua.indexOf("msie") >= 0) && (vs.indexOf("msie 9") >= 0)) {
              info.url[k] = info.url[k].replace('https://', '//');
            }
            if ((info.url[k].indexOf('{z}/{x}/{y}.png') != -1 || info.url[k].indexOf('{z}/{x}/{y}.jpg') != -1) && (info.url[k].indexOf('//maps.gsi.go.jp/') != -1 || info.url[i].indexOf('//cyberjapandata.gsi.go.jp/') != -1)) {
              info.url[k] = info.url[k].replace('cyberjapandata.gsi.go.jp', 'maps.gsi.go.jp');
              info.url[k] = info.url[k].replace('http://', '//');
              info.url[k] = info.url[k].replace('https://', '//');
            }
          }
        }
        else {
          if ((ua.indexOf("msie") >= 0) && (vs.indexOf("msie 9") >= 0)) {
            info.url = info.url.replace('https://', '//');
          }
          if ((info.url.indexOf('{z}/{x}/{y}.png') != -1 || info.url.indexOf('{z}/{x}/{y}.jpg') != -1) && (info.url.indexOf('//maps.gsi.go.jp/') != -1 || info.url.indexOf('//cyberjapandata.gsi.go.jp/') != -1)) {
            info.url = info.url.replace('cyberjapandata.gsi.go.jp', 'maps.gsi.go.jp');
            info.url = info.url.replace('http://', '//');
            info.url = info.url.replace('https://', '//');
          }
        }

        info.layerType = GSI.LayersJSON.url2LayerType(info.url);

        if (info.cocotile) {
          if (this.hasTileList) {
            info.hasTile = (this.hasTileList[info.id] == true);
          }
        }

        if (this.visibleLayersHash[info.id]) {
          for (var j = 0; j < this.visibleLayersHash[info.id].length; j++) {
            var layerInfo = this.visibleLayersHash[info.id][j];
            info.initialOpacity = layerInfo.initialOpacity;
            if (!this.visibleLayersHash[info.id][j].info)
              this.visibleLayersHash[info.id][j].info = info;
          }
        }

        if (!this.layersHash[info.id])
          this.layersHash[info.id] = info;
        this.layers.push(info);
      }
      else {
        if (!tree[i].id) {
          tree[i].isMultiLayer = false;
          tree[i].id = (parent ? parent.id + '_' + folderCount : 'f' + folderCount);
          folderCount++;
        }
        else if (tree[i].isMultiLayer != false) {
          var info = tree[i];
          info.layerType = 'multiLayer';
          info.isMultiLayer = true;
          if (this.visibleLayersHash[info.id]) {
            for (var j = 0; j < this.visibleLayersHash[info.id].length; j++) {
              var layerInfo = this.visibleLayersHash[info.id][j];
              info.initialOpacity = layerInfo.initialOpacity;
              this.visibleLayersHash[info.id][j].info = info;
            }
          }
          if (!this.layersHash[info.id])
            this.layersHash[info.id] = info;

          this.layers.push(info);
        }
      }
      if (tree[i].id != "f0"){
        //最上層にparentを付けない
        tree[i].parent = parent;
      }
      this._initializeTree(tree[i].isMultiLayer ? null : tree[i].entries, tree[i]);
    }
  },
  _initializeTreeCopy: function (tree, parent) {
    if (!tree) return;
    var folderCount = 0;
    for (var i = 0; i < tree.length; i++) {
      tree[i].parent = null;

      this._initializeTreeCopy(tree[i].entries, tree[i]);
    }
  },
  _onFileLoadErrorRetry: function () {
    this.reader = new FileReader();
    this.reader.onload = L.bind(this._onFileLoad, this);
    this.reader.onerror = L.bind(this._onLoadErrorExit, this);
    this.reader.readAsText("./layer.txt");
  },
  _onLoadErrorExit: function () { }
});

GSI.LayersJSON.url2LayerType = function (url) {

  if (Array.isArray(url)) {

    for (var i = 0; i < url.length; i++) {
      if (url[i].match(/\.webm$/) || url[i].match(/\.mp4$/)) return "videooverlay";
    }

    return "";
  }
  if (!url) return "";
  url = (url) ? url.trim() : '';

  if (url.match(/\{tms\}/)) {
    return "tms";
  }

  if (url.match(/photoprot\.php/)) {
    return "kml";
  }

  if (url.match(/\.tif$/) || url.match(/\.tiff$/)) {
    return "geotiff";
  }

  if (url.match(/\.webm$/) || url.match(/\.mp4$/)) {
    return "videooverlay";
  }

  if (url.match(/\.pm\.json$/)) {
    return "pmtiles";
  }

  var ext = "";
  var layerType = "";
  var matchResult = url.match(/.*\.([^.]+$)/);
  // 拡張子
  if (matchResult) ext = matchResult[1]

  // kml
  if (ext == "kml") {
    layerType = "kml";
    return layerType;
  }

  // タイルかどうか
  if (url.match(/(\{x\})/)) {
    switch (ext) {
      case "geojson":
        layerType = "geojson_tile";
        break;
      case "topojson":
        layerType = "topojson_tile";
        break;
      default:
        layerType = "tile";
        break;
    }
  }
  else {
    switch (ext) {
      case "geojson":
      case "topojson":
      case "kml":
        layerType = ext;
        break;
    }
  }

  return layerType;
};

GSI.Utils.infoToLayer = function (info, noFinishMove) {
  var layer = null;
  if (info.layerType == "tile") {
    var fBaseMap = false;
    if (info.parent && info.parent != null && info.parent.title_sys == CONFIG.layerBaseFolderSYS) {
      fBaseMap = true;
    }

    var options = {
      errorTileUrl: ''
    };
    if (info.subdomains && info.subdomains != "") {
      options.subdomains = info.subdomains;
    }
    if ((info.minZoom == 0 || info.minZoom) && info.minZoom != "") options.minZoom = info.minZoom;
    if ((info.maxZoom == 0 || info.maxZoom) && info.maxZoom != "") options.maxZoom = info.maxZoom;
    if (info.maxNativeZoom && info.maxNativeZoom != "") options.maxNativeZoom = info.maxNativeZoom;
    if (info.attribution) options.attribution = info.attribution;
    if (info.bounds && info.bounds != "") options.bounds = L.latLngBounds(info.bounds);
    if (info.id == CONFIG.FREERELIEFID)
      layer = new GSI.ReliefTileLayer(info.url, options);
    else
      layer = new GSI.TileLayer(info.url, options);
  }
  else if (info.layerType == "kml") {
    var options = { async: true, "_map": this.map };

    if ((info.minZoom == 0 || info.minZoom) && info.minZoom != "") options.minZoom = info.minZoom;
    if ((info.maxZoom == 0 || info.maxZoom) && info.maxZoom != "") options.maxZoom = info.maxZoom;
    if (info.attribution) options.attribution = info.attribution;
    if (info.errorTileUrl) options.errorTileUrl = info.errorTileUrl;
    if (info.bounds && info.bounds != "") options.bounds = info.bounds;
    layer = new GSI.KML(info.url, options);
    layer._noFinishMove = noFinishMove;

  }
  else if (info.layerType == "geojson") {
    // GeoJSON
    var options = {};

    if ((info.minZoom == 0 || info.minZoom) && info.minZoom != "") options.minZoom = info.minZoom;
    if ((info.maxZoom == 0 || info.maxZoom) && info.maxZoom != "") options.maxZoom = info.maxZoom;
    if (info.attribution) options.attribution = info.attribution;
    if (info.bounds && info.bounds != "") options.bounds = info.bounds;

    layer = new GSI.GeoJSON(info.url, options);
    layer._noFinishMove = noFinishMove;

  }
  else if (info.layerType == "geojson_tile") {
    // タイルGeoJSON
    var options = { clipTiles: true };
    var options2 = {};

    if (info.subdomains && info.subdomains != "") {
      options.subdomains = info.subdomains;
    }
    if ((info.minZoom == 0 || info.minZoom) && info.minZoom != "") {
      options.minZoom = info.minZoom;
      options._minZoom = info.minZoom;
    }
    if ((info.maxZoom == 0 || info.maxZoom) && info.maxZoom != "") {
      options.maxZoom = info.maxZoom;
      options._maxZoom = info.maxZoom;
    }

    if (info.maxNativeZoom && info.maxNativeZoom != "") {
      options.maxNativeZoom = info.maxNativeZoom;
      options._maxNativeZoom = info.maxNativeZoom;
    }

    if (info.maxCanvasZoom && info.maxCanvasZoom != "") {
      options.maxCanvasZoom = info.maxCanvasZoom;
      options._maxCanvasZoom = info.maxCanvasZoom;
    }

    if (info.attribution) {
      options.attribution = info.attribution;
      options._attribution = info.attribution;
    }
    if (info.bounds && info.bounds != "") {
      options.bounds = info.bounds;
      options._bounds = info.bounds;
    }
    if (info.styleurl && info.styleurl != "") {
      options.styleurl = info.styleurl;
      options._styleurl = info.styleurl;
    }

    layer = new GSI.VectorTileLayer(info.url, options, options2);

  }
  else if (info.layerType == "topojson_tile") {
    // タイルTopoJSON
    var options = { clipTiles: true, isTopoJSON: true };
    var options2 = {};

    if (info.subdomains && info.subdomains != "") {
      options.subdomains = info.subdomains;
    }
    if ((info.minZoom == 0 || info.minZoom) && info.minZoom != "") {
      options.minZoom = info.minZoom;
      options._minZoom = info.minZoom;
    }
    if ((info.maxZoom == 0 || info.maxZoom) && info.maxZoom != "") {
      options.maxZoom = info.maxZoom;
      options._maxZoom = info.maxZoom;
    }

    if ((info.maxNativeZoom) && info.maxNativeZoom != "") {
      options.maxNativeZoom = info.maxNativeZoom;
      options._maxNativeZoom = info.maxNativeZoom;
    }

    if (info.attribution) {
      options.attribution = info.attribution;
      options._attribution = info.attribution;
    }
    if (info.bounds && info.bounds != "") {
      options.bounds = info.bounds;
      options._bounds = info.bounds;
    }

    layer = new GSI.VectorTileLayer(info.url, options, options2);

  }
  else if (info.layerType == "topojson") {
    // TopoJSON
    var options = { layerType: 'topojson' };

    if ((info.minZoom == 0 || info.minZoom) && info.minZoom != "") options.minZoom = info.minZoom;
    if ((info.maxZoom == 0 || info.maxZoom) && info.maxZoom != "") options.maxZoom = info.maxZoom;
    if (info.attribution) options.attribution = info.attribution;
    if (info.bounds && info.bounds != "") ptions.bounds = info.bounds;

    layer = new GSI.GeoJSON(info.url, options);
    layer._noFinishMove = noFinishMove;
  }
  else if (info.layerType == "tms") {
    // TMS
    var options = {};

    if ((info.minZoom == 0 || info.minZoom) && info.minZoom != "") options.minZoom = info.minZoom;
    if ((info.maxZoom == 0 || info.maxZoom) && info.maxZoom != "") options.maxZoom = info.maxZoom;
    if (info.maxNativeZoom && info.maxNativeZoom != "") options.maxNativeZoom = info.maxNativeZoom;
    if (info.attribution) options.attribution = info.attribution;
    if (info.bounds && info.bounds != "") ptions.bounds = info.bounds;

    layer = new GSI.GSITMSLayer(info.url, options);
  }
  else if (info.layerType == "multiLayer") {
    // 複数レイヤ
    layer = new GSI.MultiLayer(info.entries);

  }
  else if (info.layerType == 'geotiff') {

    var options = {};
    if ((info.minZoom == 0 || info.minZoom) && info.minZoom != "") options.minZoom = info.minZoom;
    if ((info.maxZoom == 0 || info.maxZoom) && info.maxZoom != "") options.maxZoom = info.maxZoom;
    if (info.attribution) options.attribution = info.attribution;
    options.crossOrigin = true;
    layer = new GSI.GeoTIFFImageOverlay(info.url, options);
    layer._noFinishMove = noFinishMove;
  }

  else if (info.layerType == "videooverlay") {
    var options = {};
    if ((info.minZoom == 0 || info.minZoom) && info.minZoom != "") options.minZoom = info.minZoom;
    if ((info.maxZoom == 0 || info.maxZoom) && info.maxZoom != "") options.maxZoom = info.maxZoom;
    if (info.attribution) options.attribution = info.attribution;

    options.crossOrigin = true;
    layer = L.videoOverlay(info.url, info.videoBounds, options);
    layer.on("load", L.bind(function () {
      $(this.getElement()).on('click',L.bind(function () {
        this.getElement().play();
      }, this))
    }, layer));
    layer._noFinishMove = noFinishMove;
  }

  else if (info.layerType == "pmtiles") {
    // PMTiles
    var options = {};

    if ((info.minZoom == 0 || info.minZoom) && info.minZoom != "") options.minZoom = info.minZoom;
    if ((info.maxZoom == 0 || info.maxZoom) && info.maxZoom != "") options.maxZoom = info.maxZoom;
    if (info.attribution) options.attribution = info.attribution;
    if (info.bounds && info.bounds != "") options.bounds = info.bounds;

    layer = new GSI.PMTileLayer(info.url, options);
    layer._noFinishMove = noFinishMove;
  }

  return layer;
};

/************************************************************************
 L.Class
 - GSI.MapMouse（地図上のマウス操作制御）
 ************************************************************************/
GSI.MapMouse = L.Evented.extend({
  clickMoveVisible: false,
  clickMoveEnable: true,
  rightClickTime: null,

  options: {
    dblClickInterval: 500,
    rightDblClickInterval: 500
  },
  initialize: function (mapManager, map, options) {
    this._mapManager = mapManager;
    this.map = map;
    this._rightClicMoveVisible = true;

    map.on('contextmenu', function () { });

    this.setClickMoveVisible(this.clickMoveVisible, true);

    map.on('mousedown', L.bind(this.onMouseDown, this));
    map.on('zoomend', L.bind(this.onZoomEnd, this));
    map.on('dblclick', L.bind(this.onMapDblClick, this));
    map.on('drawcancel', L.bind(this.onDrawCancel, this));

    L.setOptions(this, options);

    this.map.doubleClickZoom.enable();
  },
  onZoomEnd: function (e) {
    if (this.map.getZoom() >= 18) {
      this.map.doubleClickZoom.disable();
    }
    else {
      this.map.doubleClickZoom.enable();
    }
  },
  _rightDblClickZoomOut: function (latlng) {
    var zoom = this.map.getZoom();
    if (zoom >= 1) {
      this.map.setZoomAround(latlng, zoom - 1);
    }
  },

  onDrawCancel : function() {
    setTimeout(L.bind(function(){
      this._clearRightClickTimer();
      this.rightClickTime = null;
    },this), 0);
  },

  onMouseDown: function (e) {
    if (e.originalEvent.which == 3) {
      if (this.rightClickTime == null) {
        // 一回目
        var date = new Date();
        this.rightClickTime = date.getTime();
        this._startRightClickTimer(e.latlng);
      }
      else {
        var date = new Date();
        //ダブルクリック判定
        if (date < this.rightClickTime + this.options.rightDblClickInterval) {
          this._rightDblClickZoomOut(e.latlng);
          this.rightClickTime = null;
        }
        else {
          this.rightClickTime = null;
        }
      }
    }
    else {
      this.rightClickTime = null;
    }
  },
  onMapClick: function (e) {
    if (this.clickMoveVisible) {
      this._startClickTimer(e.latlng);

    }
  },
  _move: function (latlng) {
    this.map.panTo(latlng);
  },
  _clearClickTimer: function () {
    if (this._clickTimerId) {
      clearTimeout(this._clickTimerId);
      this._clickTimerId = null;
    }
  },
  _startClickTimer: function (latlng) {
    this._clearClickTimer();
    this._clickTimerId = setTimeout(L.bind(this._move, this, latlng), this.options.dblClickInterval);
  },
  onMapDblClick: function (e) {
    if (!this._clickTimerId) return;

    this._clearClickTimer();
    var zoom = this.map.getZoom();
    if (zoom < 18) {
      if (this.map.options.doubleClickZoom == "center") {
        this.map.setZoom(e.latlng, zoom + 1);
      } else {
        this.map.setZoomAround(e.latlng, zoom + 1);
      }
    }
  },

  setRightClickMoveVisible: function (visible){
    this._rightClicMoveVisible = visible;
  },
  getRightClickMoveVisible: function () {
    return this._rightClicMoveVisible;

  },

  setClickMoveVisible: function (visible, init) {
    this.clickMoveVisible = visible;
    this.refresh();
    this.fire("change", { visible: visible });
  },
  getClickMoveVisible: function () {
    return this.clickMoveVisible;

  },
  refresh: function () {
    if (this.clickMoveVisible && this.clickMoveEnable) {
      if (!this._onMapClick) {
        this._onMapClick = L.bind(this.onMapClick, this);
        this.map.on('click', this._onMapClick);
      }
    }
    else {
      if (this._onMapClick) {
        this.map.off('click', this._onMapClick);
        this._onMapClick = null;
      }
    }
  },
  getClickMoveVisible: function (visible) {
    return this.clickMoveVisible;
  },
  setClickMoveEnable: function (enable) {
    this.clickMoveEnable = enable;
    this.refresh();
  },
  _startRightClickTimer: function (latlng) {
    this._clearRightClickTimer();
    this._RightClickTimerId = setTimeout(L.bind(this._zoom_Out, this, latlng), this.options.dblClickInterval);
  },
  _clearRightClickTimer: function () {
    if (this._RightClickTimerId) {
      clearTimeout(this._RightClickTimerId);
      this._RightClickTimerId = null;
    }
  },
  _zoom_Out: function (latlng) {
    if (this.rightClickTime != null) {
      if ( this._rightClicMoveVisible)
        this._move(latlng);
      
      if(this._mapManager._footer && !this._mapManager._footer.isVisible()){
        this._mapManager._footer.onBtnClick();
      }
    }
    this.rightClickTime = null;
  }
});

/************************************************************************
 L.Evented
 - GSI.MiniMap
 ************************************************************************/
GSI.MiniMap = L.Evented.extend({
  initialize: function (map, options) {
    this.map = map;
  },
  setVisible: function (visible) {
    if (visible) {
      this.show();
    }
    else {
      this.hide();
    }
    this.fire("change");
  },
  getVisible: function () {
    return (this.miniMap ? true : false);
  },
  show: function () {
    if (!this.miniMap) {
      var size = {
        width: 150,
        height: 150
      };
      if (CONFIG.MOBILE) {
        size.width = 80;
        size.height = 80;
      }
      var baseLayer = L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png');
      this.miniMap = new L.Control.MiniMap(baseLayer, { toggleDisplay: false, width: size.width, height: size.height }).addTo(this.map);
    }
  },
  hide: function () {
    if (this.miniMap) {
      this.map.removeControl(this.miniMap);
      this.miniMap = null;
    }
  }
});

/************************************************************************
 L.Class
 - GSI.Modal.BaseClass
 ************************************************************************/
GSI.Modal.instance = null;
GSI.Modal.instanceList = [];
GSI.Modal.blind = null;
GSI.Modal.zIndexOffset = 50000;

GSI.Modal.BaseClass = L.Evented.extend({
  options: {
    closeBtnVisible: true,
    blindClose: true
  },
  container: null,
  initialize: function (options) {
    options = L.setOptions(this, options);
  },
  show: function (options) {

    GSI.Modal.instanceList.push(this);

    options = L.setOptions(this, options);
    this.createBlind();

    if (!this.container) {
      this.container = this.createContainer();
      $(document.body).append(this.container);
    }
    else this.contentFrame.empty();

    if (options && options.width) {
      this.contentFrame.css({ width: options.width + 'px' });
    }
    else {
      this.contentFrame.css({ width: 'auto' });
    }

    if (this.getContent)
      this.contentFrame.append(this.getContent());

    this.adjustWindow();

    if (!GSI.Modal.blind.is(':visible'))
        // 202303 displayをclassで管理する。
//      GSI.Modal.blind.show("fade", { "direction": "both", "easing": "linear" }, "fast");
      GSI.Modal.blind.fadeIn('fast', 'linear').removeClass('gsi_modal_dialog_display');;

    this.container.fadeIn('fast', 'linear').removeClass('gsi_modal_dialog_display');
//    this.container.show("fade", { "direction": "both", "easing": "linear" }, "fast");

    if (!this._onWindowResize) {
      this._onWindowResize = L.bind(this.onWindowResize, this);
      $(window).on("resize", this._onWindowResize);
    }
  },
  onWindowResize: function () {
    this.adjustWindow();
  },
  adjustWindow: function () {
    var windowSize = GSI.Utils.getScreenSize();
    var isVisible = this.container.is(':visible');

    if (!isVisible) {
      this.container.removeClass('gsi_modal_dialog_display');
    }
    this.contentFrame.css({
      "max-width": windowSize.w - 50 + 'px',
      "max-height": windowSize.h - 50 + 'px'
    });

    var w = this.container.outerWidth(true);
    var h = this.container.outerHeight(true);
    this.container.css({
      left: Math.floor((windowSize.w / 2) - (w / 2)) + 'px',
      top: Math.floor((windowSize.h / 2) - (h / 2)) + 'px'
    });

    if (!isVisible) {
      this.container.addClass('gsi_modal_dialog_display');
//      this.container.hide().css({ "visibility": "visible" });
    }
  },
  createContainer: function () {
    var container = $('<div>').hide().addClass(this.options.className ? this.options.className : 'gsi_modal_base').css({ "z-index": GSI.Modal.zIndexOffset + 1 + GSI.Modal.instanceList.length, position: "absolute" });

    this.contentFrame = $('<div>').addClass('gsi_modal_base_content');
    container.append(this.contentFrame);

    if (this.options.closeBtnVisible) {
      this.closeButton = $('<a>')
        .addClass('gsi_modal_base_closebtn')
        .attr({ 'href': 'javascript:void(0);' }).html('×').on('click',
          L.bind(function () {
            this.hide();
          }, this)
        );
      container.append(this.closeButton);
    }

    return container;
  },
  hide: function (noRemoveBlind) {
    if (this._onWindowResize) {
      $(window).off("resize", this._onWindowResize);
      delete this._onWindowResize;
      this._onWindowResize = null;
    }

    for (var i = 0; i < GSI.Modal.instanceList.length; i++) {
      if (GSI.Modal.instanceList[i] == this) {
        GSI.Modal.instanceList.splice(i, 1);
        break;
      }
    }

    if (this.container) this.container.remove();
    if (this.closeButton) this.closeButton.remove();

    delete this.closeButton;
    delete this.container;
    this.closeButton = null;
    this.container = null;

    if (GSI.Modal.instanceList.length <= 0)
      this.removeBlind();
  },
  getBlindClose: function () {
    return this.options.blindClose;

  },
  createBlind: function () {
    if (GSI.Modal.blind) return;

    GSI.Modal.blind = $('<div>')
      .css({
        opacity: 0.3,
        background: "#666",
        position: "absolute",
        left: '0px',
        top: '0px',
        width: '100%',
        height: '100%',
        "z-index": GSI.Modal.zIndexOffset,
        display: "none",
        cursor: "pointer"
      })
      .on('click',function () {
      });

    $(document.body).append(GSI.Modal.blind);
  },
  removeBlind: function () {
    if (GSI.Modal.blind) GSI.Modal.blind.remove();
    delete GSI.Modal.blind;
    GSI.Modal.blind = null;
  }
});

/************************************************************************
 L.Class
 - GSI.Modal.BaseClass
   - GSI.Modal.Dialog
 ************************************************************************/
GSI.Modal.Dialog = GSI.Modal.BaseClass.extend({
  options: {
    positiveButtonText: '決定',
    nagativeButtonText: '中止',
    blindClose: false,
    closeBtnVisible: false,
    className: 'gsi_modal_dialog'
  },
  show: function (options) {
    GSI.Modal.BaseClass.prototype.show.call(this, options);
  },
  getContent: function () {
    this.dialogFrame = $('<div>').addClass('gsi_modal_dialog_frame');
    this.dialogContent = $('<div>').addClass('gsi_modal_dialog_content');
    this.buttonFrame = $('<div>').addClass('gsi_modal_dialog_btn_frame');

    this.positiveButton = $('<a>').attr({ "href": "javascript:void(0);" })
      .html(this.options.positiveButtonText).on('click',L.bind(this.onPositiveButtonClick, this));
    this.negativeButton = $('<a>').attr({ "href": "javascript:void(0);" })
      .html(this.options.nagativeButtonText).on('click',L.bind(this.onNegativeButtonClick, this));

    this.buttonFrame.append(this.positiveButton).append(this.negativeButton);

    this.dialogFrame.append(this.dialogContent);
    this.dialogFrame.append(this.buttonFrame);

    return this.dialogFrame;
  },
  onPositiveButtonClick: function () {
    this.hide();
    this.fire('positive');
  },
  onNegativeButtonClick: function () {
    this.hide();
    this.fire('negative');
  }
});

/************************************************************************
 L.Class
 - GSI.Modal.BaseClass
   - GSI.Modal.Dialog
     - GSI.Modal.FileSelectDialog（ファイル選択ダイアログ）
 ************************************************************************/
/*
GSI.Modal.FileSelectDialog = GSI.Modal.Dialog.extend({
  options: {
    title: "ファイルを選択して下さい"
  },
  getContent: function () {
    var frame = $('<div>');
    var titleFrame = $('<div>').addClass('gsi_modal_fileselect_dlg_title').html(this.options.title);

    var tabFrame = null;

    tabFrame = $('<div>').addClass('gsi_modal_fileselect_dlg_title');
    frame.append(tabFrame);
    tabFrame.append($('<span>').addClass('title').html(this.options.title));

    if (GSI.Utils.hasFileAPI) {
      this.switcher = new GSI.OnOffSwitch();
      this.switcher.on('change', L.bind(function () {
        if (this.switcher.checked()) {
          if (!this.fileFrame.is(':visible')) {
            this.sourceFrame.fadeOut('fast', L.bind(function () {
              this.fileFrame.fadeIn('fast');
            }, this));
          }
        }
        else {
          if (!this.sourceFrame.is(':visible')) {
            this.fileFrame.fadeOut('fast', L.bind(function () {
              this.sourceFrame.fadeIn('fast');
            }, this));
          }
        }
      }, this));

      tabFrame.append(this.switcher.getElement().css({ "float": "right" }));

      this.fileFrame = $('<div>').addClass("gsi_modal_fileselect_dlg_inputframe");
      this.fileInput = $('<input>').attr({ 'type': 'file' });

      this.fileMessage = $('<div>').addClass('message').html('ファイルを選択後「<strong>決定</strong>」ボタンをクリックして下さい');
      this.fileFrame.append(this.fileMessage);
      this.fileFrame.append(this.fileInput);
      frame.append(this.fileFrame);
    }

    this.sourceFrame = $('<div>').addClass("gsi_modal_fileselect_dlg_inputframe").hide();
    this.sourceTextArea = $('<textarea>');

    if (!GSI.Utils.hasFileAPI) {
      this.sourceFrame.show();
    }

    this.sourceMessage = $('<div>').addClass('message').html('ソースを入力後「<strong>決定</strong>」ボタンをクリックして下さい');
    this.sourceFrame.append(this.sourceMessage);
    this.sourceFrame.append(this.sourceTextArea);

    frame.append(this.sourceFrame);

    var dialogFrame = GSI.Modal.Dialog.prototype.getContent.call(this);

    this.dialogContent.append(frame);

    return dialogFrame;
  },
  _onFileLoad: function () {
    this.hide();
    this.fire('positive', { text: this.reader.result });
  },
  _onLoadErrorExit: function () {
    alert('ファイルの読込に失敗しました');
  },
  onPositiveButtonClick: function () {
    var txt = "";
    if (this.fileFrame && this.fileFrame.is(':visible')) {
      var files = this.fileInput.attr('files');
      if (!files) files = this.fileInput.prop('files');

      if (files && files.length > 0) {
        this.reader = new FileReader();
        this.reader.onload = L.bind(this._onFileLoad, this);
        this.reader.onerror = L.bind(this._onLoadErrorExit, this);
        this.reader.readAsText(files[0]);
      }
      else {
        alert('ファイルが選択されていません');
      }
    }
    else {
      txt = this.sourceTextArea.val();
      if ($.trim(txt) != "") {
        this.hide();
        this.fire('positive', { text: txt });
      }
      else {
        alert('ソースが入力されていません');
      }
    }
  },
  onNegativeButtonClick: function () {
    this.hide();
    this.fire('negative');
  }
});
*/
/************************************************************************
 L.Class
 - GSI.Modal.BaseClass
   - GSI.Modal.Dialog
     - GSI.Modal.confirmDialog（免責事項選択ダイアログ）
 ************************************************************************/
GSI.Modal.confirmDialog = GSI.Modal.Dialog.extend({
  options: {
    positiveButtonText: 'ＯＫ',
    nagativeButtonText: 'キャンセル',
    title: "免責事項・ご利用上の注意"
    , message: ""
    , width: 460
  },
  getContent: function () {
    var frame = $('<div>').css({ 'height': '280px', 'overflow': 'auto' }).addClass('gsi_modal_dialog_content');
    var inframe = $('<div>').css({ 'margin': '10px' });
    var liframe1 = $('<div>').css({ 'margin': '5px 18px 0px 0px' });
    var liframe2 = $('<div>').css({ 'margin': '0px 18px 0px 0px' });
    var frmct = $('<div>').html(GSI.TEXT.EVAC.CONFIRMTOP);
    var uol = $('<ol>');
    var li1 = $('<li>').attr({ "value": "1" }).html(GSI.TEXT.EVAC.CONFIRMITEM1);
    var li2 = $('<li>').attr({ "value": "2" }).html(GSI.TEXT.EVAC.CONFIRMITEM2);
    var li3 = $('<li>').attr({ "value": "3" }).html(GSI.TEXT.EVAC.CONFIRMITEM3);
    var atten = $('<div>').html(GSI.TEXT.EVAC.ATTENTION);

    var dol = $('<ol>');
    var dli1 = $('<li>').attr({ "value": "1" }).html(GSI.TEXT.EVAC.DATAITEM1);
    var dli2 = $('<li>').attr({ "value": "2" }).html(GSI.TEXT.EVAC.DATAITEM2);
    var dli3 = $('<li>').attr({ "value": "3" }).html(GSI.TEXT.EVAC.DATAITEM3);
    var dli4 = $('<li>').attr({ "value": "4" }).html(GSI.TEXT.EVAC.DATAITEM5);
    var datten = $('<div>').html(GSI.TEXT.EVAC.ATTENTIONDATA);

    uol.append(li1);
    uol.append(li2);
    uol.append(li3);
    liframe1.append(atten);
    liframe1.append(uol);

    dol.append(dli1);
    dol.append(dli2);
    dol.append(dli3);
    dol.append(dli4);
    liframe2.append(datten);
    liframe2.append(dol);

    inframe.append(frmct);
    inframe.append(liframe1);
    inframe.append(liframe2);

    frame.append(inframe);
    var titleFrame = $('<div>').addClass('gsi_modal_dialog_header').html(this.options.title);

    var dialogFrame = GSI.Modal.Dialog.prototype.getContent.call(this);

    this.dialogContent.append(titleFrame);
    this.dialogContent.append(frame);

    return dialogFrame;
  },
  onPositiveButtonClick: function () {
    this.hide();
    this.fire('positive');
  },
  onNegativeButtonClick: function () {
    this.hide();
    this.fire('negative');
  }
});

/************************************************************************
 L.Class
 - GSI.Modal.BaseClass
   - GSI.Modal.Dialog
     - GSI.Modal.dsloreDialog
 ************************************************************************/
GSI.Modal.dsloreDialog = GSI.Modal.Dialog.extend({
  options: {
    title: '自然災害伝承碑',
    blindClose: false,
    closeBtnVisible: true
  },
  initialize: function (uri) {
    this.options.uri = uri;
    GSI.Modal.BaseClass.prototype.initialize.call(this.options);
  },
  getContent: function () {
    var frame = $('<div>').addClass('gsi_modal_dialog_content');
    var content = this._createContent(this.options.uri);

    frame.append(content);

    // 202303
    this.container.addClass('gsi_modal_dialog_display');
    return frame;
  },
  show: function () {
    GSI.Modal.BaseClass.prototype.show.call(this, this.options);

    GSI.Modal.blind.on('mousedown', L.bind(function () { this.hide(); }, this));
    $(GSI.Modal.blind).on('touchstart', L.bind(function () { this.hide(); }, this));

    $(window).on('resize',L.bind(function () { this.hide(true); }, this));

    this.closeButton.css({ "color": "#fff", "padding-top": "0.3em", "padding-right": "0.3em" });
  },
  createBlind: function () {
    // 202303 displayはclassで管理する。
    if (GSI.Modal.blind) return;

    GSI.Modal.blind = $('<div>')
      .css({
        opacity: 0.4,
        background: "#111",
        position: "absolute",
        left: '0px',
        top: '0px',
        width: '100%',
        height: '100%',
        "z-index": GSI.Modal.zIndexOffset,
        cursor: "pointer"
      })
      .on('click',function () {
      });

      GSI.Modal.blind.addClass('gsi_modal_dialog_display');

    $(document.body).append(GSI.Modal.blind);
  },
  _createContent: function () {
    var ws = GSI.Utils.getScreenSize();
    var ary = this.options.uri.split("\\");
    var imgy = ws.h * 0.6;//0.7は極端に横長にすると縦が不足する
    var imgx = ws.w * 0.7;

    var names = {};
    names["LoreName"] = "碑名";
    names["DisasterName"] = "災害名";
    names["DisasterKind"] = "災害種別";
    names["LoreYear"] = "建立年";
    names["Address"] = "所在地";
    names["DisasterInfo"] = "伝承内容";
    names["Image"] = "概要";
    names["Limitations"] = "制限事項";    

    var title = "";
    var id = "";
    for (var e = 0; e < ary.length; e += 2) {
      if (ary[e] == "LoreName") {
        title = ary[e + 1];
      }
      if (ary[e] == "ID") {
        id = ary[e + 1];
      }
    }

    var tbl = $("<table>").css({ "min-width": "240px", "max-width": "280px" });
    var outertbl = $("<table>").css({ "border": "none" });

    var tr;
    var outertr = $("<tr>").css({ "vertical-align": "top" });
    var titletr = $("<tr>");
    var lefttd = $("<td>").attr({ "align": "center" });
    var righttd = $("<td>").attr({ "align": "center" });
    var titleth = $("<th>").addClass("gsi_dsloreinfodialog_div_table_th");

    var ldiv = $("<div>").addClass('gsi_dsloreinfodialog_inner_div');
    var rdiv = $("<div>").addClass('gsi_dsloreinfodialog_inner_div');
    var titletbl = $("<table>").attr({ "id": "dsloredialog_title" }).css({ "border": "none", "width": "100%" });
    var contdiv = $("<div>").addClass('gsi_dsloreinfodialog_div').css({ "overflow-y": "auto" });
    var iddiv = $("<div>").addClass('gsi_dsloreinfodialog_div');
    var outerdiv = $("<div>").addClass('gsi_dsloreinfodialog_div');

    titletbl.append(titletr.append(titleth.html(title)));
    outerdiv.append(titletbl);

    tr = $("<tr>").append($("<th>").html("概要").attr({ "colspan": 2 }));
    tbl.append(tr);

    for (h in names) {
      for (var j = 0; j < ary.length; j += 2) {
        if (h == ary[j]) {
          if (ary[j] == "Image") {

            var img = $("<img>");

            img.on("load", L.bind(function () {
              if (img[0].clientHeight > imgy) {
                img.css({ "width": "auto", "height": imgy + "px" })
                var limith = document.getElementById("dsloredialog_title").clientHeight;
                contdiv.css({ "max-height": (ws.h - 50 - limith) + "px" })
              }
              this.adjustWindow();
            }, this));

            $(rdiv).append(img.attr({ "src": ary[j + 1] }).css({ "width": imgx, "height": "auto" }));

          }
          else {
            if ((ary[j] != "") && (ary[j + 1] != "")) {
              var c1w, c2w;
              c1w = "80px";
              c2w = "180px";
              //name
              tr = $("<tr>").append($("<td>").css({ "width": c1w }).html(names[ary[j]]));
              //value
              if (ary[j] == "DisasterInfo") {
                var ms = /\[(.*?)\]\((.*?)\)/;
                var mt = ms.exec(ary[j + 1]);
                while (mt != null) {
                  var hit = mt[0];
                  var atag = "<a href='" + mt[2] + "' target=_blank>" + mt[1] + "</a>";
                  ary[j + 1] = ary[j + 1].replace(hit, atag);
                  mt = ms.exec(ary[j + 1]);
                }
              }
              $(tr).append($("<td>").html(ary[j + 1]));

              $(tbl).append(tr);
            }
          }

        }
      }
    }

    ldiv.append(tbl);
    lefttd.append(ldiv);

    iddiv.html("ID:" + id);

    if (ws.h < ws.w) {
      righttd.append(rdiv);
      outertr.append(lefttd);
      outertr.append(righttd);
      outertbl.append(outertr);
      iddiv.css({ "text-align": "left", "bottom": "0.4em", "left": "0.4em" })
      ldiv.css({ "height": (imgy - 30) + "px" });
      ldiv.append(iddiv);
    }
    else {
      iddiv.css({ "text-align": "left" });
      ldiv.append(iddiv);

      $(ldiv).css({ "height": "100px" });
      righttd.append(rdiv);
      outertr.append(righttd);
      outertbl.append(outertr);
      outertr = $("<tr>").append(lefttd);
      outertbl.append(outertr);
    }

    contdiv.append(outertbl);
    outerdiv.append(contdiv);

    return outerdiv;

  },
  onPositiveButtonClick: function () {
    this.hide();
  },
  onNegativeButtonClick: function () {
    this.hide();
  }
});

/************************************************************************
 L.Class
 - GSI.Modal.BaseClass
   - GSI.Modal.LoadingMessage（ローディングメッセージ）
 ************************************************************************/
GSI.Modal.LoadingMessage = GSI.Modal.BaseClass.extend({
  options: {
    blindClose: false,
    closeBtnVisible: false,
    className: 'gsi_modal_loadingmessage_frame'
  },
  show: function (message, options) {
    this.message = message;
    GSI.Modal.BaseClass.prototype.show.call(this, options);
  },
  getContent: function () {
    return $('<div>').addClass('gsi_modal_loadingmessage').html(this.message);

  }
});
GSI.Modal.LoadingMessage.instance = null;

GSI.Modal.LoadingMessage.show = function (message, options) {

  if (!GSI.Modal.LoadingMessage.instance)
    GSI.Modal.LoadingMessage.instance = new GSI.Modal.LoadingMessage(options);
  GSI.Modal.LoadingMessage.instance.show(message, options);
};

GSI.Modal.LoadingMessage.hide = function () {
  if (GSI.Modal.LoadingMessage.instance) GSI.Modal.LoadingMessage.instance.hide();
};

/************************************************************************
 L.Class
 - GSI.Modal.BaseClass
   - GSI.Modal.Message
 ************************************************************************/
GSI.Modal.Message = GSI.Modal.BaseClass.extend({

  show: function (message, options) {
    this.message = message;
    GSI.Modal.BaseClass.prototype.show.call(this, options);
  },
  getContent: function () {
    return $('<div>').html(this.message);

  }
});

GSI.Modal.Message.instance = null;

GSI.Modal.Message.show = function (message, options) {

  if (!GSI.Modal.Message.instance)
    GSI.Modal.Message.instance = new GSI.Modal.Message(options);
  GSI.Modal.Message.instance.show(message, options);
};

GSI.Modal.Message.hide = function () {
  if (GSI.Modal.Message.instance) GSI.Modal.Message.instance.hide();
};

/************************************************************************
 L.Class
 - GSI.OnOffSwitch
 ************************************************************************/
GSI.OnOffSwitch = L.Evented.extend({
  options: {
    className: "filetext",
    checked: true
  },
  classNames: {
    "onoff": "gsi_onoffswitch",
    "filetext": "gsi_onoffswitch_file_text",
    "visible": "gsi_onoffswitch_visible",
    "visibleall": "gsi_onoffswitch_visible_all",
    "usecocotile": "gsi_onoffswitch_usecocotile"

  },
  initialize: function (options) {
    options = L.setOptions(this, options);

    this._create();
  },
  getElement: function () {
    return this.frame;
  },
  getCheckBox: function () {
    return this.input;
  },
  getId: function () {
    return this.id;
  },
  _create: function () {
    var id = 'GSI_OnOffSwitch_' + GSI.Utils.getCurrentID();
    this.id = id;

    this.frame = $("<span>").addClass(this.classNames[this.options.className]);
    this.input = $('<input>').attr({
      'type': 'checkbox',
      'id': id
    }).addClass('checkbox');
    this.frame.append(this.input);
    if (this.options.checked) {
      this.input.prop('checked', true);
    }

    var label = $('<label>').addClass('label').attr({
      'for': id
    });

    var span = $('<span>').addClass('inner');
    label.append(span);

    span = $('<span>').addClass('switch');
    label.append(span);

    this.frame.append(label);

    if (GSI.Utils.Browser.ie && GSI.Utils.Browser.version <= 8) {
      this._initCheckBoxIE8();
      this.frame.on('click',L.bind(this.onFrameClick, this));
    }
    else {
      this.input.on('click',L.bind(function () { this.fire('change'); }, this));
    }
  },
  _initCheckBoxIE8: function () {
    if (this.input.is(":checked")) {
      this.frame.find('.label,.inner').addClass("on_label_inner");
      this.frame.find('.label,.switch').addClass("on_label_switch");
    }
    else {
      this.frame.find('.label,.inner').removeClass("on_label_inner");
      this.frame.find('.label,.switch').removeClass("on_label_switch");
    }
  },
  onFrameClick: function () {
    this.input.prop('checked', !this.input.is(":checked"));
    this._initCheckBoxIE8();
    this.fire('change');
  },
  checked: function (value) {
    if (value == true) {
      this.input.prop({ "checked": true });
    }
    else if (value == false) {
      this.input.prop({ "checked": false });
    }

    if (GSI.Utils.Browser.ie && GSI.Utils.Browser.version <= 8) {
      this._initCheckBoxIE8();
    }

    return this.input.is(':checked');
  }
});

/************************************************************************
 L.Class
 - GSI.ToggleSwitch
 ************************************************************************/
GSI.ToggleSwitch = L.Evented.extend({
  options: {
    className: "toggle",
    checked: true,
    onText: "ON",
    offText: "OFF"
  },
  classNames: {
    "toggle": "gsi_onoffswitch_toggle",
  },
  initialize: function (options) {
    options = L.setOptions(this, options);

    this._create();
  },
  getElement: function () {
    return this.frame;
  },
  getCheckBox: function () {
    return this.input;
  },
  getId: function () {
    return this.id;
  },
  _create: function () {
    var id = 'GSI_ToggleSwitch_' + GSI.Utils.getCurrentID();
    this.id = id;

    this.frame = $("<span>").addClass(this.classNames[this.options.className]);
    this.input = $('<input>').attr({
      'type': 'checkbox',
      'id': id
    }).addClass('checkbox');
    this.frame.append(this.input);
    if (this.options.checked) {
      this.input.prop('checked', true);
    }

    var label = $('<label>').addClass('label').attr({
      'for': id
    });

    var span = $('<span>').addClass('inner');
    label.append(span);

    span = $('<span>').addClass('switch');
    label.append(span);

    this.frame.append(label);

    if (GSI.Utils.Browser.ie && GSI.Utils.Browser.version <= 8) {
      this._initCheckBoxIE8();
      this.frame.on('click',L.bind(this.onFrameClick, this));
    }
    else {
      this.input.on('click',L.bind(function () { this.fire('change'); }, this));
    }
  },
  _initCheckBoxIE8: function () {
    if (this.input.is(":checked")) {
      this.frame.find('.label,.inner').addClass("on_label_inner");
      this.frame.find('.label,.switch').addClass("on_label_switch");
    }
    else {
      this.frame.find('.label,.inner').removeClass("on_label_inner");
      this.frame.find('.label,.switch').removeClass("on_label_switch");
    }
  },
  onFrameClick: function () {
    this.input.prop( 'checked', !this.input.is(":checked"));
    this._initCheckBoxIE8();
    this.fire('change');
  },
  checked: function (value) {
    if (value == true) {
      this.input.prop({ "checked": true });
    }
    else if (value == false) {
      this.input.prop({ "checked": false });
    }

    if (GSI.Utils.Browser.ie && GSI.Utils.Browser.version <= 8) {
      this._initCheckBoxIE8();
    }

    return this.input.is(':checked');
  }
});

/************************************************************************
 L.Class
 - GSI.PagePrinter
 ************************************************************************/
GSI.PagePrinter = L.Evented.extend({
  options: {},

  initialize: function (map, baseLayer, mapLayerList, sakuzuList, options) {
    this._originalMap = map;
    this._originalBaseLayer = baseLayer;
    this._mapLayerList = mapLayerList;
    this._sakuzuList = sakuzuList;

    options = L.setOptions(this, options);
  },
  show: function (sakuzuDialog) {
    this._sakuzuDialog = sakuzuDialog;

    // ポップアップ引継ぎ
    var popupSourceList = [];
    if (this._originalMap._popup) {
      popupSourceList.push(this._originalMap._popup._source);
    }

    if (this._originalMap._popupList) {
      for (var i = 0; i < this._originalMap._popupList.length; i++) {
        popupSourceList.push(this._originalMap._popupList[i]._source);
      }
    }

    if (!this._container) this._create();

    this._initialize();

    // ポップアップ引継ぎ
    for (var i = 0; i < popupSourceList.length; i++) {
      var source = popupSourceList[i]
      var popup = source.getPopup();
      var autoPan = popup.options.autoPan;
      popup.options.autoPan = false;
      source.openPopup();
      popup.options.autoPan = autoPan;
    }
    this._popupSourceList = popupSourceList;
  },
  hide: function () {

    this._prevPaperSize = this._paperSizeSelect.val();

    $(document.body).css({ "overflow": "hidden", "height": "100%" });
    $("html").css({ "overflow": "hidden", "height": "100%" });

    var children = $(document.body).children();
    for (var i = 0; i < children.length; i++) {
      if (this._container && children[i] != this._container[0]) {
        var child = $(children[i]);
        if (child.data('_before_print_visible'))
          child.show();
      }
    }
    var tileList = this._mapLayerList.getTileList();

    for (var i = tileList.length - 1; i >= 0; i--) {
      if (tileList[i]._printInfo._visible) {
        this._map.removeLayer(tileList[i]._visibleInfo.layer);
        if (tileList[i].parent && tileList[i].parent.title_sys != CONFIG.layerBaseFolderSYS) {
          this._originalMap.addLayer(tileList[i]._visibleInfo.layer, null, tileList[i]._visibleInfo.blend);
          GSI.Utils.setMixBlendMode(tileList[i], tileList[i]._visibleInfo.blend);
        }
      }
      tileList[i]._printInfo = null;
    }

    var list = this._mapLayerList.getList();
    for (var i = list.length - 1; i >= 0; i--) {
      if (list[i]._printInfo._visible) {
        this._map.removeLayer(list[i]._visibleInfo.layer);
        this._originalMap.addLayer(list[i]._visibleInfo.layer);
      }
      list[i]._printInfo = null;
    }

    // 作図
    if (this._sakuzuList) {
      this._sakuzuList.eachItems(L.bind(
        function (item) {
          if (!item.getVisible()) return;

          this._map.removeLayer(item._layer);
          this._originalMap.addLayer(item._layer);
        },
        this));
    }

    this._originalMap.invalidateSize(false);
    this._container.fadeOut('fast', L.bind(function () {

      this._map.remove();
      this._map = null;
      this._container.remove();
      this._container = null;
    }, this));

    // ポップアップ戻す
    var popupSourceList = this._popupSourceList;
    for (var i = 0; i < popupSourceList.length; i++) {
      var source = popupSourceList[i]
      var popup = source.getPopup();
      var autoPan = popup.options.autoPan;
      popup.options.autoPan = false;
      source.openPopup();
      popup.options.autoPan = autoPan;
    }

    $(window).trigger('resize',);

  },
  _initialize: function () {
    var paperSizeArr = this._paperSizeSelect.val().split(',');
    var paperSizeVal = paperSizeArr[0];
    var hq = (paperSizeArr.length >= 2 && paperSizeArr[1] == 'hq' ? true : false);
    var paperSize = this.printSize2MapSize(paperSizeVal);

    this._mapContainer.css({ width: paperSize.w + 'px', height: paperSize.h + 'px' });

    this._map = GSI.map(this._mapContainer[0],
      {
        zoomsliderControl: false,
        zoomControl: false,
        attributionControl: false,
        closePopupOnClick: false,
        multipopup: this._originalMap.options.multipopup
      });

    this._map.on('contextmenu', function () { });

    L.control.scale({ imperial: false }).addTo(this._map);
    this._directionSign = new GSI.Control.DirectionSign({ imperial: false });
    this._directionSign.addTo(this._map);

    var fBase = false;
    this._map.setView(this._originalMap.getCenter(), this._originalMap.getZoom());

    // タイル
    var tileList = this._mapLayerList.getTileList();
    for (var i = tileList.length - 1; i >= 0; i--) {
      tileList[i]._printInfo = {};
      var visible = (tileList[i]._visibleInfo._isHidden ? false : true);

      this._originalMap.removeLayer(tileList[i]._visibleInfo.layer);
      if (visible) {
        tileList[i]._printInfo._visible = true;
        if (tileList[i].parent && tileList[i].parent.title_sys == CONFIG.layerBaseFolderSYS) {
          fBase = true;
        }
        else {
          this._map.addLayer(tileList[i]._visibleInfo.layer, null, tileList[i]._visibleInfo.blend);
          GSI.Utils.setMixBlendMode(tileList[i], tileList[i]._visibleInfo.blend);
        }
      }
    }
    this._baseLayer = null;
    if (fBase) {
      this._baseLayer = new GSI.BaseLayer(CONFIG.BASETILES, this._originalBaseLayer.getActiveId());

      this._baseLayer.isGrayScale = this._originalBaseLayer.isGrayScale;
      this._baseLayer.options.opacity = this._originalBaseLayer.options.opacity;
      this._baseLayer.addTo(this._map);
      this._baseLayer.setHighQuality(hq);
    }

    // ファイル
    var list = this._mapLayerList.getList();

    for (var i = list.length - 1; i >= 0; i--) {
      list[i]._printInfo = {};
      var visible = (list[i]._visibleInfo._isHidden ? false : true);

      this._originalMap.removeLayer(list[i]._visibleInfo.layer);

      if (visible) {
        list[i]._printInfo._visible = true;
        this._map.addLayer(list[i]._visibleInfo.layer);
      }
    }

    // 作図
    if (this._sakuzuList) {
      this._sakuzuList.eachItems(L.bind(
        function (item) {
          if (!item.getVisible()) return;

          this._originalMap.removeLayer(item._layer);
          this._map.addLayer(item._layer);
        },
        this));
    }

    // latLngGrid
    if (this.options.latLngGrid.getVisible()) {
      new GSI.LatLngGrid(this._map, {
        condition: CONFIG.LATLNGGRID.CONDITION,
        visible: true,
        lineStyle: CONFIG.LATLNGGRIDSTYLE,
        labelClassName: CONFIG.LATLNGGRIDLABELCLASSNAME
      });
    }

    // utmGrid
    if (this.options.utmGrid.getVisible()) {
      new GSI.UTM.Grid(this._map, {
        condition: CONFIG.UTMGRID.CONDITION,
        visible: true,
        lineStyle: CONFIG.UTMGRIDSTYLE,
        labelClassName: CONFIG.UTMGRIDLABELCLASSNAME
      });
    }

    // tileGrid
    if (this.options.tileGrid.getVisible()) {
      new GSI.TileGrid(this._map, {
        condition: CONFIG.UTMGRID.CONDITION,
        visible: true,
        lineStyle: CONFIG.UTMGRIDSTYLE,
        labelClassName: CONFIG.UTMGRIDLABELCLASSNAME
      });
    }
    // t25000Grid
    if (this.options.t25000Grid.getVisible()) {
      new GSI.TGrid(this._map, {
        condition: CONFIG.UTMGRID.CONDITION,
        visible: true,
        lineStyle: CONFIG.UTMGRIDSTYLE,
        labelClassName: CONFIG.UTMGRIDLABELCLASSNAME
      });
    }
    // // kokudokihonzukaku
    // if (!CONFIG.DISABLE_KOKUDOKIHONZUZUKAKU) {
    //   if (this.options.kokudokihonzukaku.getVisible()) {

    //     new GSI.KihonzukakuGrid(undefined, this._map, undefined, {
    //       visible: true, lineStyle: CONFIG.KOKUDOKIHONZUKAKU_LINESTYLE,
    //       targetNo: this.options.kokudokihonzukaku._targetNo
    //     });
    //   }
    // }

    // chiikiMesh
    if (this.options.chiikiMesh.getVisible()) {
      new GSI.ChiikiMesh(this._map, {
        condition: CONFIG.UTMGRID.CONDITION,
        visible: true,
        lineStyle: CONFIG.UTMGRIDSTYLE,
        labelClassName: CONFIG.UTMGRIDLABELCLASSNAME
      });
    }

    // jihokuLine
    if (this.options.jihokuLine.getVisible()) {
      new GSI.JihokuLine(this._map, {
        visible: true,
        num: CONFIG.JIHOKULINECOUNT,
        lineStyle: CONFIG.JIHOKULINESTYLE
      });
    }

    // toukyoKen
    if (this.options.toukyoKen.getVisible()) {
      var cloneLayer = this.options.toukyoKen.getCloneLayer();
      cloneLayer.addTo(this._map);
    }

    // houiLine
    if (this.options.houiLine.getVisible()) {
      var cloneLayer = this.options.houiLine.getCloneLayer();
      cloneLayer.addTo(this._map);
    }

    if (CONFIG.USEATTRPANEL == true) {
      var x = new GSI.Control.AttrPanel({ position: "bottomright" });
      this._map.addControl(x);
      x.updateContent(this._mapLayerList);
    }

    this._container.fadeIn('fast', L.bind(function () {

      $(document.body).css({ "overflow": "auto", "height": "auto" });
      $("html").css({ "overflow": "auto", "height": "auto" });

      var children = $(document.body).children();
      for (var i = 0; i < children.length; i++) {
        if (children[i] != this._container[0]) {
          var child = $(children[i]);
          if (child.is(":visible")) {
            child.data({ '_before_print_visible': true });
            $(children[i]).hide();
          }
          else {
            child.data({ '_before_print_visible': false });

          }
        }
      }

      this._map.invalidateSize(false);
    }, this));
  },
  _paperSizeChage: function () {
    var paperSizeArr = this._paperSizeSelect.val().split(',');

    var center = this._map.getCenter();
    var zoom = this._map.getZoom();

    var paperSizeVal = paperSizeArr[0];
    var hq = (paperSizeArr.length >= 2 && paperSizeArr[1] == 'hq' ? true : false);
    if (this._baseLayer != null) {
      this._baseLayer.setHighQuality(hq);
    }
    var paperSize = this.printSize2MapSize(paperSizeVal);

    this._mapContainer.css({ width: paperSize.w + 'px', height: paperSize.h + 'px' });
    this._map.invalidateSize();

    $(window).trigger('resize',);

    this._map.setView(center, zoom);

  },
  _qualityChange: function () {
    if (this._baseLayer != null) {
      this._baseLayer.setHighQuality(this._qualityCheck.is(':checked'));
    }
  },

  _create: function () {
    this._container = $('<div>').addClass('gsi_pageprinter');//.click( L.bind( function(){this.hide();},this) );		

    this._headerContainer = $('<div>').addClass('header_container');
    this._mapContainer = $('<div>').addClass('map_container');

    var table = $('<table>');
    var tbody = $('<tbody>');
    var tr = $('<tr>');
    var td = null;

    // タイトル
    td = $('<td>');
    td.append($('<img>').attr({ 'src': 'image/print/title.png' })).css({ 'text-align': 'left' ,width:"150px"});
    tr.append(td);

    var tdtitle = $('<td>');
    
    tdtitle
      .attr({colspan: "3"})
      .css({"text-align":"center"});
      //.addClass('no_print');
    
    var tid = 'gsi_print_title';
    this._title = $("<input>").attr({"type":"textbox", "id":tid}).css({"width":"420px", border:"solid 1px", "white-space":"no-wrap"});
    var labelTitle = $("<span>").attr({ "for": tid }).html("タイトル：").addClass("no_print");
    tr.append(tdtitle.append(labelTitle).append(this._title));
    tbody.append(tr);

    // サイズ選択
    tr = $('<tr>');
    td = $('<td>').attr({colspan:"2"}).css({ width: "240px" ,"text-align":"right"});
    this._paperSizeSelect = $('<select>').addClass('no_print');
    if (CONFIG.USELARGEPAPERSIZE || !CONFIG.PAPERSIZE["A4_portrait"]["large"]) {
      this._paperSizeSelect.append($('<option>').html("A4縦(標準)").val("A4_portrait"));
      this._paperSizeSelect.append($('<option>').html("A4縦(高画質)").val("A4_portrait,hq"));
    }
    if (CONFIG.USELARGEPAPERSIZE || !CONFIG.PAPERSIZE["A4_landscape"]["large"]) {
      this._paperSizeSelect.append($('<option>').html("A4横(標準)").val("A4_landscape"));
      this._paperSizeSelect.append($('<option>').html("A4横(高画質)").val("A4_landscape,hq"));
    }

    if (CONFIG.USELARGEPAPERSIZE || !CONFIG.PAPERSIZE["A3_portrait"]["large"]) {
      this._paperSizeSelect.append($('<option>').html("A3縦(標準)").val("A3_portrait"));
      this._paperSizeSelect.append($('<option>').html("A3縦(高画質)").val("A3_portrait,hq"));
    }

    if (CONFIG.USELARGEPAPERSIZE || !CONFIG.PAPERSIZE["A3_landscape"]["large"]) {
      this._paperSizeSelect.append($('<option>').html("A3横(標準)").val("A3_landscape"));
      this._paperSizeSelect.append($('<option>').html("A3横(高画質)").val("A3_landscape,hq"));
    }

    if (CONFIG.USELARGEPAPERSIZE || !CONFIG.PAPERSIZE["A2_portrait"]["large"]) {
      this._paperSizeSelect.append($('<option>').html("A2縦(標準)").val("A2_portrait"));
      this._paperSizeSelect.append($('<option>').html("A2縦(高画質)").val("A2_portrait,hq"));
    }

    if (CONFIG.USELARGEPAPERSIZE || !CONFIG.PAPERSIZE["A2_landscape"]["large"]) {
      this._paperSizeSelect.append($('<option>').html("A2横(標準)").val("A2_landscape"));
      this._paperSizeSelect.append($('<option>').html("A2横(高画質)").val("A2_landscape,hq"));
    }

    if (CONFIG.USELARGEPAPERSIZE || !CONFIG.PAPERSIZE["A1_portrait"]["large"]) {
      this._paperSizeSelect.append($('<option>').html("A1縦(標準)").val("A1_portrait"));
      this._paperSizeSelect.append($('<option>').html("A1縦(高画質)").val("A1_portrait,hq"));
    }

    if (CONFIG.USELARGEPAPERSIZE || !CONFIG.PAPERSIZE["A1_landscape"]["large"]) {
      this._paperSizeSelect.append($('<option>').html("A1横(標準)").val("A1_landscape"));
      this._paperSizeSelect.append($('<option>').html("A1横(高画質)").val("A1_landscape,hq"));
    }

    if (CONFIG.USELARGEPAPERSIZE || !CONFIG.PAPERSIZE["A0_portrait"]["large"]) {
      this._paperSizeSelect.append($('<option>').html("A0縦(標準)").val("A0_portrait"));
      this._paperSizeSelect.append($('<option>').html("A0縦(高画質)").val("A0_portrait,hq"));
    }

    if (CONFIG.USELARGEPAPERSIZE || !CONFIG.PAPERSIZE["A0_landscape"]["large"]) {
      this._paperSizeSelect.append($('<option>').html("A0横(標準)").val("A0_landscape"));
      this._paperSizeSelect.append($('<option>').html("A0横(高画質)").val("A0_landscape,hq"));
    }

    if (this._prevPaperSize) {
      this._paperSizeSelect.val(this._prevPaperSize);
    }
    else
      this._paperSizeSelect[0].selectedIndex = 0;

    this._paperSizeSelect.on('change',L.bind(this._paperSizeChage, this));
    td.append($('<span>').html('用紙サイズ：').addClass('no_print'));
    td.append(this._paperSizeSelect);
    tr.append(td);

    // 印刷ボタン
    td = $('<td>').css({ width: "64px" });
    var printBtn = $('<button>').html('印刷').addClass('no_print').on('click',L.bind(this.print, this));
    td.append(printBtn);
    tr.append(td);

    // 戻るボタン
    td = $('<td>').css({ width: "120px" });
    var backBtn = $('<button>').css({ 'white-space': 'nowrap' }).html('元の画面に戻る').addClass('no_print').on('click',L.bind(this.hide, this));
    td.append(backBtn);
    tr.append(td);

    tbody.append(tr);

    // attention
    var trinfo = $('<tr>');
    var tdinfo = $('<td>');
    tdinfo.html(GSI.TEXT.PRINTERCOMMENT)
      .attr({ colspan: "4" })
      .css({ "text-align": "left" })
      .addClass('no_print');
    trinfo.append(tdinfo);
    tbody.append(trinfo);

    // direction
    var trdirection = $('<tr>');
    var tddirection = $('<td>');
    tddirection
      .attr({ colspan: "4" })
      .css({ "text-align": "right" })
      .addClass('no_print');

    var id = 'gsi_print_directionsign';

    this._checkDirection = $("<input>")
      .addClass("normalcheck").attr({ "type": "checkbox", "id": id })
      .on("click", L.bind(function () {
        if (this._checkDirection.is(":checked"))
          this._directionSign.show();
        else
          this._directionSign.hide();
      }, this));
    var labelDirection = $("<label>").attr({ "for": id }).html("方位記号を追加");
    tddirection.append(this._checkDirection).append(labelDirection);

    trdirection.append(tddirection);
    tbody.append(trdirection);

    table.append(tbody);

    this._headerContainer.append(table);
    this._container.append(this._headerContainer);
    this._container.append(this._mapContainer);

    this._container.hide();

    $(document.body).append(this._container);
  },
  printSize2MapSize: function (size) {
    return CONFIG.PAPERSIZE[size];
  },
  print: function () {
    GSI.Utils.sendSelectedFunction("print");
    this._titleSet();
    window.print();
    this._titleClear();
  },
  _titleSet: function(){
    var titletext = document.getElementById('gsi_print_title');
    if (titletext != null){
      $(titletext).css({border:"none"});
    }
  },
  _titleClear: function(){
    var titletext = document.getElementById('gsi_print_title');
    if (titletext != null){
      $(titletext).css({border:"solid 1px"});
    }
  }
});

/************************************************************************
 L.Class
 - GSI.PageStateManager
 ************************************************************************/
GSI.PageStateManager = L.Class.extend({

  initialize: function (gsimaps, map, baseLayer, onOffObjects, mapLayerList, mapMenu) {
    this._gsimaps = gsimaps;
    this._map = map;
    this._onOffObjects = onOffObjects;
    this._baseLayer = baseLayer;
    this._mapLayerList = mapLayerList;
    this._mapMenu = mapMenu;
  },
  getPositionQueryString: function () {
    var center = this._map.getCenter().wrap();
    var zoom = this._map.getZoom();

    return "#" + zoom + "/" + (Math.round(center.lat * 1000000) / 1000000) + '/' + (Math.round(center.lng * 1000000) / 1000000);
  },
  getCurrentPathQueryString: function () {
    var path = this._mapMenu.getMapListPanel().getCurrentPath();
    var hit = false;

    if ( path && path != '' ) {
      var mapLayerList = this._gsimaps._mainMap._mapLayerList;
      var tileList = mapLayerList.getTileList();
      for( var i=0; i<tileList.length; i++ ) {
        if ( tileList[i].id == path) {
          hit = true;
          break;
        }
      }
      if ( !hit) {
        var list = mapLayerList.getList();
        for( var i=0; i<list.length; i++ ) {
          if ( list[i].id == path) {
            hit = true;
            break;
          }
        }
      }
    }
    return (path && path != '' && hit ? 'lcd=' + encodeURIComponent(path) : '');
  },
  getCurrentPathQueryString2: function () {
    if (!this._gsimaps._subMap || !this._gsimaps._subMap._mapMenu) return "";

    var path = this._gsimaps._subMap._mapMenu.getMapListPanel().getCurrentPath();

    var hit = false;

    if ( path && path != '' ) {
      var mapLayerList = this._gsimaps._subMap._mapLayerList;
      var tileList = mapLayerList.getTileList();
      for( var i=0; i<tileList.length; i++ ) {
        if ( tileList[i].id == path) {
          hit = true;
          break;
        }
      }
      if ( !hit) {
        var list = mapLayerList.getList();
        for( var i=0; i<list.length; i++ ) {
          if ( list[i].id == path) {
            hit = true;
            break;
          }
        }
      }
    }

    return (path && path != '' && hit ? 'lcd2=' + encodeURIComponent(path) : '');
  },
  getBaseLayerQueryString: function () {
    var ret = "";

    var f = false;
    var tileIdList = this._mapLayerList.getTileList();
    for (var i = tileIdList.length - 1; i >= 0; i--) {
      if (tileIdList[i]._visibleInfo && !tileIdList[i]._visibleInfo._isHidden) {
        if (tileIdList[i].id == this._gsimaps._mainMap._baseLayer.getActiveId()) {
          f = true;
          break;
        }
      }
    }

    if (f) {
      ret = "base=" + encodeURIComponent(this._gsimaps._mainMap._baseLayer.getActiveId());
    }

    return ret;
  },

  getBaseLayerQueryString2: function () {

    var ret = "";

    var f = false;
    var tileIdList = this._gsimaps._subMap._mapLayerList.getTileList();
    for (var i = tileIdList.length - 1; i >= 0; i--) {
      if (tileIdList[i]._visibleInfo && !tileIdList[i]._visibleInfo._isHidden) {
        if (tileIdList[i].id == this._gsimaps._subMap._baseLayer.getActiveId()) {
          f = true;
          break;
        }
      }
    }

    if (f) {
      ret = "base2=" + encodeURIComponent(this._gsimaps._subMap._baseLayer.getActiveId());
    }

    return ret;
  },

  getLayersQueryString: function (options) {
    if (!options) options = {};

    var fGrayScale = true;
    if (options.visibleOnly) {
      fGrayScale = false;
    }

    var hasReliefFree = false;
    var result = '';
    var result_grayscale = '';
    var result_blend = '';
    var tileIdList = [];
    if (!options.noTile) {
      var tileList = this._mapLayerList.getTileList();

      for (var i = 0; i < tileList.length; i++) {
        if (!tileList[i]._isOutside )
          tileIdList.push(tileList[i]);
      }
    }

    for (var i = tileIdList.length - 1; i >= 0; i--) {
      var fList = true;
      if (options.visibleOnly) {
        fList = false;
        if (tileIdList[i]._visibleInfo && !tileIdList[i]._visibleInfo._isHidden) {
          fList = true;

          if (i == tileIdList.length - 1) {
            fGrayScale = true;
          }
        }
      }

      if (fList) {
        flist = true;
        var opacity = ((tileIdList[i]._visibleInfo && (tileIdList[i]._visibleInfo.opacity || tileIdList[i]._visibleInfo.opacity == 0)) ? tileIdList[i]._visibleInfo.opacity : 1);
        var opacityText = (opacity == 0 ? "0" : opacity.toFixed(2));
        if (opacityText != "0") opacityText = opacityText.replace(/0$/g, '');
        result += (result != '' ? '|' : '') + tileIdList[i].id + (opacity != 1 ? ',' + opacityText : '');
        if (tileIdList[i].id == CONFIG.FREERELIEFID) {
          hasReliefFree = true;
        }
        if (i != tileIdList.length - 1) {
          var l = tileIdList[i]._visibleInfo.blend ? "1" : "0";
          result_blend += l;
        }
      }
    }

    var idList = [];
    if (!options.noList) {
      var list = this._mapLayerList.getList();
      for (var i = 0; i < list.length; i++)
        idList.push(list[i]);
    }
    for (var i = idList.length - 1; i >= 0; i--) {
      var fList = true;
      if (options.visibleOnly) {
        fList = false;
        if (idList[i]._visibleInfo && !idList[i]._visibleInfo._isHidden) {
          fList = true;
        }
      }

      if (fList) {
        var opacity = ((idList[i]._visibleInfo && (idList[i]._visibleInfo.opacity || idList[i]._visibleInfo.opacity == 0)) ? idList[i]._visibleInfo.opacity : 1);
        var opacityText = (opacity == 0 ? "0" : opacity.toFixed(2));
        if (opacityText != "0") opacityText = opacityText.replace(/0$/g, '');
        result += (result != '' ? '|' : '') + idList[i].id + (opacity != 1 ? ',' + opacityText : '');
      }
    }

    if (fGrayScale) {
      if (this._gsimaps._mainMap._baseLayer && this._gsimaps._mainMap._baseLayer.getGrayScale()) {
        result_grayscale = "base_grayscale=1";
      }
    }

    if ((result != '') && (result_blend != '')) {
      result_blend = "&blend=" + result_blend;
    }

    var resultReliefData = '';

    if (options.withRelief && hasReliefFree) {
      var currentData = this._gsimaps._mainMap._mapLayerList.getElevationData();
      var text = GSI.ReliefTileLayer.encodeElevationData(currentData);
      resultReliefData = '&relief=' + text;
    }
    if (result != '' || result_grayscale) {
      if (result_grayscale != "") {
        if (result != "") {
          result_grayscale += "&";
        }
      }

      return result_grayscale + "ls=" + encodeURIComponent(result) + result_blend + resultReliefData;
    }
    else {
      return "";
    }
  },

  getLayersQueryString2: function (options) {
    if (!options) options = {};

    var fGrayScale = true;
    if (options.visibleOnly) {
      fGrayScale = false;
    }

    var hasReliefFree = false;
    var result = '';
    var result_grayscale = '';
    var result_blend = '';
    var tileIdList = [];
    if (!options.noTile) {
      var tileList = this._gsimaps._subMap._mapLayerList.getTileList();

      for (var i = 0; i < tileList.length; i++) {
        if (!tileList[i]._isOutside )
          tileIdList.push(tileList[i]);
      }
    }

    for (var i = tileIdList.length - 1; i >= 0; i--) {
      var fList = true;
      if (options.visibleOnly) {
        fList = false;
        if (tileIdList[i]._visibleInfo && !tileIdList[i]._visibleInfo._isHidden) {
          fList = true;

          if (i == tileIdList.length - 1) {
            fGrayScale = true;
          }
        }
      }

      if (fList) {
        flist = true;
        var opacity = ((tileIdList[i]._visibleInfo && (tileIdList[i]._visibleInfo.opacity || tileIdList[i]._visibleInfo.opacity == 0)) ? tileIdList[i]._visibleInfo.opacity : 1);
        var opacityText = (opacity == 0 ? "0" : opacity.toFixed(2));
        if (opacityText != "0") opacityText = opacityText.replace(/0$/g, '');
        result += (result != '' ? '|' : '') + tileIdList[i].id + (opacity != 1 ? ',' + opacityText : '');
        if (tileIdList[i].id == CONFIG.FREERELIEFID) {
          hasReliefFree = true;
        }
        if (i != tileIdList.length - 1) {
          var l = tileIdList[i]._visibleInfo.blend ? "1" : "0";
          result_blend += l;
        }
      }
    }

    var idList = [];
    if (!options.noList) {
      var list = this._gsimaps._subMap._mapLayerList.getList();
      for (var i = 0; i < list.length; i++)
        idList.push(list[i]);
    }
    for (var i = idList.length - 1; i >= 0; i--) {
      var fList = true;
      if (options.visibleOnly) {
        fList = false;
        if (idList[i]._visibleInfo && !idList[i]._visibleInfo._isHidden) {
          fList = true;
        }
      }

      if (fList) {
        var opacity = ((idList[i]._visibleInfo && (idList[i]._visibleInfo.opacity || idList[i]._visibleInfo.opacity == 0)) ? idList[i]._visibleInfo.opacity : 1);
        var opacityText = (opacity == 0 ? "0" : opacity.toFixed(2));
        if (opacityText != "0") opacityText = opacityText.replace(/0$/g, '');
        result += (result != '' ? '|' : '') + idList[i].id + (opacity != 1 ? ',' + opacityText : '');
      }
    }

    if (fGrayScale) {
      if (this._gsimaps._subMap._baseLayer && this._gsimaps._subMap._baseLayer.getGrayScale()) {
        result_grayscale = "base_grayscale2=1";
      }
    }

    if ((result != '') && (result_blend != '')) {
      result_blend = "&blend2=" + result_blend;
    }

    var resultReliefData = '';

    if (options.withRelief && hasReliefFree) {
      var currentData = this._gsimaps._subMap._mapLayerList.getElevationData();
      var text = GSI.ReliefTileLayer.encodeElevationData(currentData);
      resultReliefData = '&relief2=' + text;
    }

    if (result != '' || result_grayscale) {
      if (result_grayscale != "") {
        if (result != "") {
          result_grayscale += "&";
        }
      }

      return result_grayscale + "ls2=" + encodeURIComponent(result) + result_blend + resultReliefData;
    }
    else {
      return "";
    }
  },

  getViewSettingVisible: function (key) {
    var target = this._onOffObjects[key];
    if (!target) return false;
    return target.obj[target.getter]();
  },

  getToukyokenCenter: function() {
    var target = this._onOffObjects[CONFIG.PARAMETERNAMES.TOUKYOKEN];
    if (!target) return undefined;

    if ( target.obj[target.getter]() ) {
      return target.obj.getCenter();
    } else {
      return undefined;
    }

  },
  getHouiLineCenter: function() {
    var target = this._onOffObjects[CONFIG.PARAMETERNAMES.HOUILINE];
    if (!target) return undefined;

    if ( target.obj[target.getter]() ) {
      return target.obj.getCenter();
    } else {
      return undefined;
    }
  },

  getQueryParams: function (options) {
    if (!options) options = {};
    var result = {};

    // hc
    if (!options.hcList) options.hcList = [];
    var hiddenControl = options.hcList.join('');

    if (hiddenControl != '') result.hc = hiddenControl;

    // vs
    if (!options.vsInfo) options.vsInfo = {};
    if (!options.vsInfo.skips) options.vsInfo.skips = {};
    if (!options.vsInfo.visibles) options.vsInfo.visibles = {};
    if (!options.vsInfo.visibles2) options.vsInfo.visibles2 = {};

    var vsInfo = options.vsInfo;
    var viewSetting = '';
    var viewSetting2 = '';

    for (var key in CONFIG.QUERYPARAMETER) {
      var target = this._onOffObjects[key];
      var param = CONFIG.QUERYPARAMETER[key];

      if (!param || vsInfo.skips[key]) continue;

      if (key == 'footer') {
        viewSetting += param.prefix + vsInfo.visibles[key];
        if (vsInfo.visibles2[key] || vsInfo.visibles2[key] == '0')
          viewSetting2 += param.prefix + vsInfo.visibles2[key];
      }
      else if (vsInfo.visibles[key] == true || vsInfo.visibles[key] == false) {
        viewSetting += param.prefix + (vsInfo.visibles[key] ? '1' : '0');
      }
      else {
        if (!target) continue;
        if (key == CONFIG.PARAMETERNAMES.FOOTER) {
          if (target.obj.isVisible()) {
            viewSetting += param.prefix + '1';
          }
          else {
            viewSetting += param.prefix + '0';
          }
          viewSetting += param.prefix + '0';
        }
        else {
          if (target.obj[target.getter]()) {
            viewSetting += param.prefix + '1';
          }
          else {
            viewSetting += param.prefix + '0';
          }
        }
      }
    }

    if (viewSetting != '') {
      result.vs = viewSetting;
    }
    if (viewSetting2 != '') {
      result.vs2 = viewSetting2;
    }

    // d
    var visibleDialogSetting = '';

    if (!options.visibleDialogs) options.visibleDialogs = {};
    for (var key in options.visibleDialogs) {
      if (options.visibleDialogs[key]) {
        visibleDialogSetting += key;
      }
    }

    if (visibleDialogSetting != '') {
      result.d = visibleDialogSetting;
    }

    // d2
    var visibleDialogSetting2 = '';

    if (!options.visibleDialogs2) options.visibleDialogs2 = {};
    for (var key in options.visibleDialogs2) {
      if (options.visibleDialogs2[key]) {
        visibleDialogSetting2 += key;
      }
    }

    if (visibleDialogSetting2 != '') {
      result.d2 = visibleDialogSetting2;
    }

    return result;
  },
  getTileViewSetting: function (options) {
    if (!options) options = {};
    var result = '';

    var tileIdList = [];
    if (!options.noTile) {
      var tileList = this._mapLayerList.getTileList();

      for (var i = 0; i < tileList.length; i++) {
        // 202303 条件を変更
//        if (!tileList[i]._isOutside && !tileList[i]._isComparePhoto)
        if (!tileList[i]._isOutside)
          tileIdList.push(tileList[i]);
      }
    }

    for (var i = tileIdList.length - 1; i >= 0; i--) {
      result += (tileIdList[i]._visibleInfo && tileIdList[i]._visibleInfo._isHidden ? '0' : '1');
    }

    var idList = [];
    if (!options.noList) {
      var list = this._mapLayerList.getList();

      for (var i = 0; i < list.length; i++)
        idList.push(list[i]);
    }
    for (var i = idList.length - 1; i >= 0; i--) {
      result += (idList[i]._visibleInfo && idList[i]._visibleInfo._isHidden ? '0' : '1');
    }

    if (result != '') {
      return "disp=" + result;
    }
    else {
      return "";
    }
  },
  getTileViewSetting2: function (options) {
    if (!options) options = {};
    var result = '';

    var tileIdList = [];
    if (!options.noTile) {
      var tileList = this._gsimaps._subMap._mapLayerList.getTileList();

      for (var i = 0; i < tileList.length; i++) {
        // 202303 条件を変更
//        if (!tileList[i]._isOutside && !tileList[i]._isComparePhoto)
        if (!tileList[i]._isOutside)
          tileIdList.push(tileList[i]);
      }
    }

    for (var i = tileIdList.length - 1; i >= 0; i--) {
      result += (tileIdList[i]._visibleInfo && tileIdList[i]._visibleInfo._isHidden ? '0' : '1');
    }

    var idList = [];
    if (!options.noList) {
      var list = this._gsimaps._subMap._mapLayerList.getList();

      for (var i = 0; i < list.length; i++)
        idList.push(list[i]);
    }
    for (var i = idList.length - 1; i >= 0; i--) {
      result += (idList[i]._visibleInfo && idList[i]._visibleInfo._isHidden ? '0' : '1');
    }

    if (result != '') {
      return "disp2=" + result;
    }
    else {
      return "";
    }
  },

  getFreeReliefQueryString: function () {
    var currentData = this._gsimaps._mainMap._mapLayerList.getElevationData();
    var text = GSI.ReliefTileLayer.encodeElevationData(currentData);

    var defaultDataText = GSI.ReliefTileLayer.getEncodedElevationSampleData();

    if (!text || text == defaultDataText) return "";
    return "reliefdata=" + text;
  },

  getFreeReliefQueryString2: function () {
    var currentData = this._gsimaps._subMap._mapLayerList.getElevationData();
    var text = GSI.ReliefTileLayer.encodeElevationData(currentData);

    var defaultDataText = GSI.ReliefTileLayer.getEncodedElevationSampleData();

    if (!text || text == defaultDataText) return "";
    return "reliefdata2=" + text;
  }
});

/************************************************************************
 L.Class
 - GSI.Searcher（検索）
 ************************************************************************/
GSI.Searcher = L.Class.extend({
  QUERY_NONE: 9,
  QUERY_LATLNG: 2,
  QUERY_LATLNG2: 3,
  QUERY_UTMPOINT: 5,
  QUERY_QUERY: 4,
  QUERY_EXCHANGE: 7,
  QUERY_LATLNGNE: 8,
  QUERY_TILENUM: 10,

  options: {
  },
  initialize: function (map, dialog, formSelector, querySelector, resultSelector, options) {
    this.map = map;
    this.dialog = dialog;
    this.formSelector = formSelector;
    this.querySelector = querySelector;
    // 202303
    // $(this.querySelector).ahPlaceholder({
    //   placeholderAttr: 'placeholder',
    //   likeApple: true
    // }).attr({ "title": CONFIG.TOOLTIP.TOP.QUERY });
    $(this.querySelector).attr({ "title": CONFIG.TOOLTIP.TOP.QUERY });
    $(this.formSelector).on('submit',L.bind(this.onSubmit, this));
    $('#magnifyimage').on('click',L.bind(this.onSubmit, this));
    L.setOptions(this, options);
  },

  onSubmit: function (event) {
    event.preventDefault();

    var query = $(this.querySelector).val();
    if (((query) ? query.trim() : '') == '') return;

    var qType = this.checkQuery(query);

    if (qType == this.QUERY_QUERY) {
      this.searchStart(query);
    }
    else {
      this.clearSearch();
      this.dialog.hide();
      if (qType == this.QUERY_LATLNG || qType == this.QUERY_LATLNG2) {
        var latLng = (qType == this.QUERY_LATLNG ? this.parseLatLngText(query) : this.parseLatLngText2(query));

        if (latLng[0] > 90 || latLng[0] < -90 || latLng[1] > 180 || latLng[1] < -180) {
          alert('緯度経度を正しく入力して下さい\n' +
            '緯度:' + latLng[0] + ' 経度:' + latLng[1]);
        }
        else {
          this.getDemPng(latLng);
        }

      }
      else if (qType == this.QUERY_UTMPOINT) {
        var latLng = GSI.UTM.Utils.point2LatLng(query);

        if (latLng) {
          this.getDemPng([latLng.lat, latLng.lng], CONFIG.SEARCHRESULTCLICKZOOM);
        }
        else {
          alert('UTMポイントを正しく入力して下さい');
        }
      }
      else if (qType == this.QUERY_EXCHANGE) {
        var latLng = this.parseLatLngText3(query);

        if (!latLng) {
          alert('緯度経度を正しく入力して下さい\n');
        }
        else if (latLng[0] > 90 || latLng[0] < -90 || latLng[1] > 180 || latLng[1] < -180) {
          alert('緯度経度を正しく入力して下さい\n' +
            '緯度:' + latLng[0] + ' 経度:' + latLng[1]);
        }
        else {
          this.getDemPng(latLng);
        }
      }
      else if (qType == this.QUERY_LATLNGNE) {
        var latLng = this.parseLatLngText4(query);

        if (!latLng) {
          alert('緯度経度を正しく入力して下さい\n');
        }
        else if (latLng[0] > 90 || latLng[0] < -90 || latLng[1] > 180 || latLng[1] < -180) {
          alert('緯度経度を正しく入力して下さい\n' +
            '緯度:' + latLng[0] + ' 経度:' + latLng[1]);
        }
        else {
          this.getDemPng(latLng);
        }
      }
      else if (qType == this.QUERY_TILENUM) {
        var latLng = null;
        var zoom = null;
        var parts = query.split('/');

        if (parts.length >= 3) {
          try {
            var coords = {
              x: parseInt(parts[1]),
              y: parseInt(parts[2]),
              z: parseInt(parts[0])
            };

            latLng = this.map.unproject(L.point(coords.x * 256 + 128, coords.y * 256 + 128), coords.z);
            zoom = coords.z;
          }
          catch (e) {
            console.log(this.map, e);
          }
        }

        if (latLng) {
          this.getDemPng([latLng.lat, latLng.lng], zoom);
        }
      }
    }

    this.query = query;

    return false;
  },
  clearSearch: function () {
    if (this.chimeiAjax) {
      try { this.chimeiAjax.abort(); } catch (e) { }
      this.chimeiAjax = null;
    }
    this.dialog.clear();
  },
  searchStart: function (q) {

    this.clearSearch();
    this.dialog.show();

    this.chimeiAjax = this.searchChimei(q, "", "");
  },
  setChimeiRusult: function (json) {
    this.dialog.setChimeisResult(json);
  },
  searchChimei: function (q, pref, muni) {
    var constraint = '';
    var url = CONFIG.SERVERAPI.CHIMEI_SEARCH;
    var parameter = { "q": q };

    if (CONFIG.SERVERAPI.CHIMEI_SEARCH_ADDITIONALPARAMS) {
      for (var key in CONFIG.SERVERAPI.CHIMEI_SEARCH_ADDITIONALPARAMS) {
        parameter[key] = CONFIG.SERVERAPI.CHIMEI_SEARCH_ADDITIONALPARAMS[key];
      }
    }
    return $.ajax({
      type: "GET",
      url: url,
      data: parameter,
      dataType: "json",
      timeout: 30000,
      success: L.bind(this.setChimeiRusult, this),
      error: function () {
      }
    });
  },
  checkQuery: function (q) {
    q = (q) ? q.trim() : '';
    q = q.replace(',', ' ');

    if (q == '') {
      return this.QUERY_NONE;
    }
    else if (q.length == 13
      && q.substring(0, 2).match(/^[0-9]+$/)
      && q.substring(2, 4).match(/^[A-Z]+$/)
      && q.substring(5, 13).match(/^[0-9]+$/)) {
      return this.QUERY_UTMPOINT;
    }
    else if (q.match(/^(-|\+)*[0-9]+(\.[0-9]+)*\s+(-|\+)*[0-9]+(\.[0-9]+)*$/)) {
      return this.QUERY_LATLNG;
    }
    else if (q.match(/^(-|\+)*[0-9]+度[\s]+(-|\+)*[0-9]+度$/)
      ||
      q.match(/^(-|\+)*[0-9]+度[0-9]+分[\s]+(-|\+)*[0-9]+度[0-9]+分$/)
      ||
      q.match(/^(-|\+)*[0-9]+度[0-9]+分[0-9]+(\.[0-9]+)*秒[\s]+(-|\+)*[0-9]+度[0-9]+分[0-9]+(\.[0-9]+)*秒$/)
    ) {
      return this.QUERY_LATLNG2;
    }

    else {
      if ((q.match(/^(?:N|S|北緯|南緯|-|\+)*([0-9]{1,3}(?:\.[0-9]+)*)(?:,|\s)(?:E|W|東経|西経|-|\+)*([0-9]{1,3}(?:\.[0-9]+)*)/))
        ||
        (q.match(/^(?:E|W|東経|西経|-|\+)*([0-9]{1,3}(?:\.[0-9]+)*)(?:,|\s)(?:N|S|北緯|南緯|-|\+)*([0-9]{1,3}(?:\.[0-9]+)*)/))) {
        //NE表記
        return this.QUERY_LATLNGNE;
      }
      else if ((q.match(/^(?:N|S|北緯|南緯|-|\+)*([0-9]{1,3}[度°])([0-9]{1,2}['分′])*([0-9]{1,2}(?:\.[0-9]+)*[秒″\"])*(?:,|\s)(?:E|W|東経|西経|-|\+)*([0-9]{1,3}[度°])([0-9]{1,2}['分′])*([0-9]{1,2}(?:\.[0-9]+)*[秒″\"])*$/))
        ||
        (q.match(/^(?:E|W|東経|西経|-|\+)*([0-9]{1,3}[度°])([0-9]{1,2}['分′])*([0-9]{1,2}(?:\.[0-9]+)*[秒″\"])*(?:,|\s)(?:N|S|北緯|南緯|-|\+)*([0-9]{1,3}[度°])([0-9]{1,2}['分′])*([0-9]{1,2}(?:\.[0-9]+)*[秒″\"])*$/))) {
        //°′″表記
        return this.QUERY_EXCHANGE;
      }
      else if (q.match(/^[0-9]+\/[0-9]+\/[0-9]+$/)) {
        return this.QUERY_TILENUM;
      }
      else {
        return this.QUERY_QUERY;
      }
    }
  },
  parseLatLngText2: function (s) {
    s = (s) ? s.trim() : '';
    s = s.replace(',', ' ');
    var latwSign;
    var lngwSign;
    var matchArr = s.match(/^(-|\+)*([0-9]+)度[\s]+(-|\+)*([0-9]+)度$/);

    if (matchArr && matchArr.length > 0) {
      var lat = parseInt((matchArr[1] ? matchArr[1] : "") + matchArr[2]);
      var lng = parseInt((matchArr[3] ? matchArr[3] : "") + matchArr[4]);
      return [lat, lng];
    }

    matchArr = s.match(/^(-|\+)*([0-9]+)度([0-9]+)分[\s]+(-|\+)*([0-9]+)度([0-9]+)分$/);

    if (matchArr && matchArr.length > 0) {
      latwSign = (matchArr[1] && matchArr[1] == "-" ? -1 : 1);
      lngwSign = (matchArr[4] && matchArr[4] == "-" ? -1 : 1);
      var lat = parseInt(matchArr[2]) + (parseFloat(matchArr[3]) / 60.0);
      var lng = parseInt(matchArr[5]) + (parseFloat(matchArr[6]) / 60.0);

      lat = lat * latwSign;
      lng = lng * lngwSign;
      return [lat, lng];
    }

    matchArr = s.match(/^(-|\+)*([0-9]+)度([0-9]+)分([0-9]+)秒[\s]+(-|\+)*([0-9]+)度([0-9]+)分([0-9]+)秒$/);

    if (matchArr && matchArr.length > 0) {
      latwSign = (matchArr[1] && matchArr[1] == "-" ? -1 : 1);
      lngwSign = (matchArr[5] && matchArr[5] == "-" ? -1 : 1);
      var lat = parseInt(matchArr[2]) + (parseFloat(matchArr[3]) / 60.0) + (parseFloat(matchArr[4]) / 3600.0);
      var lng = parseInt(matchArr[6]) + (parseFloat(matchArr[7]) / 60.0) + (parseFloat(matchArr[8]) / 3600.0);

      lat = lat * latwSign;
      lng = lng * lngwSign;
      return [lat, lng];
    }

    matchArr = s.match(/^(-|\+)*([0-9]+)度([0-9]+)分([0-9]+\.[0-9]+)秒[\s]+(-|\+)*([0-9]+)度([0-9]+)分([0-9]+\.[0-9]+)秒$/);

    if (matchArr && matchArr.length > 0) {
      latwSign = (matchArr[1] && matchArr[1] == "-" ? -1 : 1);
      lngwSign = (matchArr[5] && matchArr[5] == "-" ? -1 : 1);
      var lat = parseInt(matchArr[2]) + (parseFloat(matchArr[3]) / 60.0) + (parseFloat(matchArr[4]) / 3600.0);
      var lng = parseInt(matchArr[6]) + (parseFloat(matchArr[7]) / 60.0) + (parseFloat(matchArr[8]) / 3600.0);

      lat = lat * latwSign;
      lng = lng * lngwSign;
      return [lat, lng];
    }

    matchArr = s.match(/^(-|\+)*([0-9]+)度([0-9]+)分([0-9]+(?:\.[0-9]+)*)秒[\s]+(-|\+)*([0-9]+)度([0-9]+)分([0-9]+(?:\.[0-9]+)*)秒$/);

    if (matchArr && matchArr.length > 0) {
      latwSign = (matchArr[1] && matchArr[1] == "-" ? -1 : 1);
      lngwSign = (matchArr[5] && matchArr[5] == "-" ? -1 : 1);
      var lat = parseInt(matchArr[2]) + (parseFloat(matchArr[3]) / 60.0) + (parseFloat(matchArr[4]) / 3600.0);
      var lng = parseInt(matchArr[6]) + (parseFloat(matchArr[7]) / 60.0) + (parseFloat(matchArr[8]) / 3600.0);

      lat = lat * latwSign;
      lng = lng * lngwSign;
      return [lat, lng];
    }

    return null;
  },
  parseLatLngText3: function (s) {
    s = (s) ? s.trim() : '';
    s = s.replace(',', ' ');

    var matchArr = s.match(/^(N|S|北緯|南緯|-|\+)*([0-9]{1,3}[度°])([0-9]{1,2}[分′'])*([0-9]{1,2}(?:\.[0-9]+)*[秒″\"])*(?:,|\s)(E|W|東経|西経|-|\+)*([0-9]{1,3}[度°])([0-9]{1,2}[分′'])*([0-9]{1,2}(?:\.[0-9]+)*[秒″\"])*$/);
    var revflg = false;

    if (!matchArr) {
      matchArr = s.match(/^(E|W|東経|西経|-|\+)*([0-9]{1,3}[度°])([0-9]{1,2}[分′'])*([0-9]{1,2}(?:\.[0-9]+)*[秒″\"])*(?:,|\s)(N|S|北緯|南緯|-|\+)*([0-9]{1,3}[度°])([0-9]{1,2}[分′'])*([0-9]{1,2}(?:\.[0-9]+)*[秒″\"])*$/);
      revflg = true;
    }
    var lath, latm, lats, lonh, lonm, lons;
    if (matchArr && matchArr.length == 9) {
      lath = parseInt(matchArr[2]);
      lonh = parseInt(matchArr[6]);

      latm = matchArr[3] ? parseFloat(matchArr[3]) / 60 : 0;
      lonm = matchArr[7] ? parseFloat(matchArr[7]) / 60 : 0;

      lats = matchArr[4] ? parseFloat(matchArr[4]) / 3600 : 0;
      lons = matchArr[8] ? parseFloat(matchArr[8]) / 3600 : 0;

      var la = lath + latm + lats;
      var lo = lonh + lonm + lons;

      if (matchArr[1] && (matchArr[1] == 'S' || matchArr[1] == 'W' || matchArr[1] == '南緯' || matchArr[1] == '西経' || matchArr[1] == '-')) {
        la = -1 * la;
      }
      if (matchArr[5] && (matchArr[5] == 'S' || matchArr[5] == 'W' || matchArr[5] == '南緯' || matchArr[5] == '西経' || matchArr[5] == '-')) {
        lo = -1 * lo;
      }
      if (revflg) {
        var t = la;
        la = lo;
        lo = t;
      }

      return [la, lo];
    }
    return null;

  },
  parseLatLngText4: function (s) {
    s = (s) ? s.trim() : '';

    var matchArr = s.match(/^(N|S|北緯|南緯|-|\+)*([0-9]{1,3}(?:\.[0-9]+)*)(?:,|\s)(E|W|東経|西経|-|\+)*([0-9]{1,3}(?:\.[0-9]+)*)/)
    var revflg = false;

    if (!matchArr) {
      matchArr = s.match(/^(E|W|東経|西経|-|\+)*([0-9]{1,3}(?:\.[0-9]+)*)(?:,|\s)(N|S|北緯|南緯|-|\+)*([0-9]{1,3}(?:\.[0-9]+)*)/)
      revflg = true;
    }

    var lat, lon;
    try {
      if (matchArr && matchArr.length == 5) {
        lat = parseFloat(matchArr[2]);
        lon = parseFloat(matchArr[4]);
        if (matchArr[1] && (matchArr[1] == 'S' || matchArr[1] == 'W' || matchArr[1] == '南緯' || matchArr[1] == '西経' || matchArr[1] == '-')) {
          lat = -1 * lat;
        }
        if (matchArr[3] && (matchArr[3] == 'S' || matchArr[3] == 'W' || matchArr[3] == '南緯' || matchArr[3] == '西経' || matchArr[3] == '-')) {
          lon = -1 * lon;
        }
        if (revflg) {
          var t = lat;
          lat = lon;
          lon = t;
        }
        return [lat, lon];
      }

      return null;
    }
    catch (e) {
      return null;
    }

  },
  parseLatLngText: function (s) {
    s = (s) ? s.trim() : '';
    s = s.replace(',', ' ');

    var latLng = s.split(' ');

    if (latLng.length < 2) return null;

    try {
      var lat = parseFloat(latLng[0]);
      var lng = parseFloat(latLng[1]);
      result = [lat, lng];

      return result;
    }
    catch (e) {
      return null;
    }
  },
  getDemPng: function (latlng, errorZoom) {
    var lon = latlng[1] * .017453292519943295; // DEG → RAD : lon = (lon / 180) * Math.PI;
    var lat = latlng[0] * .017453292519943295; // DEG → RAD : lat = (lat / 180) * Math.PI;
    var R = 128 / Math.PI;
    var x = R * (lon + Math.PI);
    var y = (-1) * R / 2 * Math.log((1 + Math.sin(lat)) / (1 - Math.sin(lat))) + 128;
    var z = 14;
    var vX_px = x * Math.pow(2, z);
    var vY_px = y * Math.pow(2, z);
    var vX_Tile = Math.floor(vX_px / 256);
    var vY_Tile = Math.floor(vY_px / 256);
    var demUrl = "https://maps.gsi.go.jp/xyz/dem_png/" + z + "/" + vX_Tile + "/" + vY_Tile + ".png";

    if (latlng) {
      var errZoom = errorZoom ? errorZoom : 5;

      var aj = $.ajax({
        type: "GET",
        url: demUrl,
        success: L.Util.bind(this.jumpToPoint, this, latlng, CONFIG.SEARCHRESULTCLICKZOOM),
        error: L.Util.bind(this.jumpToPoint, this, latlng, errZoom),
      });
    }
  },
  jumpToPoint: function (latlng, zoom) {
    this.map.setView(latlng, zoom, { reset: true });
  }
});

/************************************************************************
 L.Control
 - GSI.Control.Button
 ************************************************************************/
GSI.Control.Button = L.Control.extend({
  options: {
    position: 'topleft',
    maxWidth: "300px"
  },
  initialize: function (elem, options) {
    this._button = {};
    this.elem = elem;
    this.options.position = options.position;
    this.setButton(options);
  },
  show: function () {
    if (!this._container) return;
    this._container.style.display = 'block';
  },
  hide: function () {
    if (!this._container) return;
    this._container.style.display = 'none';
  },
  onAdd: function (map) {
    this._map = map;
    var container = L.DomUtil.create('div', '');

    this._container = container;

    this._update();
    return this._container;
  },
  onRemove: function (map) {
  },
  setButton: function (options) {
    var button = {
      'text': options.text,
      'onClick': options.onClick,
      'class': options.className
    };

    this._button = button;
    this._update();
  },
  destroy: function () {
    this._button = {};
    this._update();
  },
  _update: function () {
    if (!this._map) {
      return;
    }

    this._container.innerHTML = '';
    this._makeButton(this._button);

  },
  _makeButton: function (button) {
    var newButton = this.elem;
    this.elem.style.color = '#fff';
    $(this._container).append(newButton);
    L.DomEvent
      .addListener(newButton, 'click', L.DomEvent.stop);
    L.DomEvent.disableClickPropagation(newButton);
    return newButton;

  }
});

/************************************************************************
 L.Control
 - GSI.Control.Spacer
 ************************************************************************/
GSI.Control.Spacer = L.Control.extend({
  options: {
    position: 'bottomleft'
  },
  counter: null,
  initialize: function (options) {
    L.setOptions(this, options);
  },
  setHeight: function (height) {
    $(this._container).css({ height: height + "px" });
  },
  onAdd: function (map) {
    this._map = map;
    this._container = L.DomUtil.create('div');
    $(this._container).css({ margin: 0, padding: 0, height: 0, width: 0 });
    return this._container;
  },
  onRemove: function (map) {
  }
});

/************************************************************************
 L.Control
 - GSI.Control.DirectionSign
 ************************************************************************/
GSI.Control.DirectionSign = L.Control.extend({
  options: {
    position: 'bottomright'
  },
  counter: null,
  initialize: function (options) {
    L.setOptions(this, options);
  },
  show: function () {

    $(this._container).show();
  },

  hide: function () {
    $(this._container).hide();
  },

  onAdd: function (map) {
    this._map = map;
    this._container = L.DomUtil.create('div');
    this._img = L.DomUtil.create("img");
    this._img.src = "./image/print/directionsign.png";
    $(this._container).append($(this._img));

    if (!this.options.visible) {
      this.hide();
    }
    return this._container;
  },
  onRemove: function (map) {
  }
});

/************************************************************************
 L.Control
 - GSI.Control.ZoomGuidePanel
 ************************************************************************/
/*
GSI.Control.ZoomGuidePanel = L.Control.extend({

  options: {
    id : 'zoomGuidePanel',
    position: 'bottomright',
    width: 200,
    height: 50,
  },

  initialize: function (options, posid) {
    L.Util.setOptions(this, options);
    this.posid = posid;
  },

  onAdd: function (map) {
    this._map = map;

    this._container = L.DomUtil.create('div', 'leaflet-control-flatpanel');
    this._container.id = this.options.id + this.posid;
    this._container.style['display'] = 'none';
    var a = L.DomUtil.create('div', 'leaflet-control-crpanel', this._container);
    a.style.borderRadius = '5px 5px 0px 0px';
    a.id = 'zoomGuideMinMax' + this.posid;
    a.innerHTML = GSI.TEXT.ANNAI.MINMAX;
    var b = L.DomUtil.create('div', 'leaflet-control-crpanel', this._container);
    b.innerHTML = GSI.TEXT.ANNAI.MSGTXT;
    var c = L.DomUtil.create('div', 'leaflet-control-crpanel', this._container);
    c.style.borderRadius = '0px 0px 5px 5px';

    var chk = L.DomUtil.create('input', '', c);
    chk.type = 'checkbox';
    chk.id = 'zoomGuideCheckbox' + this.posid;
    $(chk).on('change', L.bind(function (e) {
      var bol = $('#zoomGuideCheckbox' + this.posid).is(":checked");
      GSI.GLOBALS.gsimaps._mainMap._zoomGuide.setVisible(!bol);
    }, this));
    var lbl = L.DomUtil.create('label', '', c);
    lbl.innerHTML = GSI.TEXT.ANNAI.CHKLABEL;
    $(lbl).attr('for', chk.id);
    return this._container;
  }
});
*/

/************************************************************************
 L.Control
 - GSI.Control.CrPanel
 ************************************************************************/
GSI.Control.CopyrightPanel = L.Control.extend({

  options: {

    position: 'bottomright',
    title: '地理院タイル',
    linkurl: 'https://maps.gsi.go.jp/development/ichiran.html',
    width: 110,
    height: 10,
  },

  hideText: 'Hide CopyrightPanel',

  showText: 'Show CopyrightPanel',

  initialize: function (options) {
    L.Util.setOptions(this, options);
  },

  onAdd: function (map) {
    this._map = map;

    //Creating the container and stopping events from spilling through to the main map.
    this._container = L.DomUtil.create('div', 'leaflet-control-flatpanel');

    var alink = L.DomUtil.create('a', 'leaflet-control-crpanel', this._container);

    alink.innerHTML = this.options.title;
    alink.href = this.options.linkurl;
    alink.target = '_blank';

    this._urlPanel = alink;

    return this._container;
  },

  addTo: function (alink) {
    L.Control.prototype.addTo.call(this, alink);
    return this;
  },

  onRemove: function (map) {
    this._miniMap.off('click', this._onMiniMapClick, this);
    this._miniMap.off('touchend', this._onMiniMapClick, this);
  }
});

/************************************************************************
 L.Control
 - GSI.Control.AttrPanel
 ************************************************************************/
GSI.Control.AttrPanel = L.Control.extend({

  options: {

    position: 'bottomright',
    width: 110,
    height: 10,
  },

  hideText: 'Hide AttrPanel',
  showText: 'Show AttrPanel',

  initialize: function (options) {
    L.Util.setOptions(this, options);
    this._elements = [];
  },

  onAdd: function (map) {
    this._map = map;

    //Creating the container and stopping events from spilling through to the main map.
    this._container = L.DomUtil.create('div', 'leaflet-control-flatpanel');

    var spanel = L.DomUtil.create("span", 'leaflet-control-attrpanel', this._container);
    spanel.innerHTML = "";

    this._Panel = spanel;

    return this._container;
  },

  addTo: function (attr) {
    L.Control.prototype.addTo.call(this, attr);
    return this;
  },
  clearElement: function () {
    this._elements = [];
  },
  updateContent: function (mapLayerList) {
    var updateCount = 0;
    this.clearElement();
    if (!mapLayerList) {
      this._container.style.display = 'none';
    }
    else {
      var tl = mapLayerList.getTileList();
      var ll = mapLayerList.getList();

      for (var i = 0; i < tl.length; i++) {
        if (tl[i].attribution) {
          this.addElement(tl[i].attribution);
          updateCount++;
        }
      }
      for (var i = 0; i < ll.length; i++) {
        if (ll[i].attribution) {
          this.addElement(ll[i].attribution);
          updateCount++;
        }
      }
      if (updateCount < 1) {
        this._container.style.display = 'none';
      }
      else {
        this._container.style.display = 'block';
      }
    }
  },
  addElement: function (el) {
    if ((!el) || (el == "")) {
      return;
    }
    for (var i = 0; i < this._elements.length; i++) {
      if (this._elements[i] == el) {
        return;
      }
    }
    this._elements.push(el);
    var newel = this._elements.join("|");
    this._Panel.innerHTML = newel;
  },

  removeElement: function (el) {
    if ((!el) || (el == "")) {
      return;
    }

    for (var i = 0; i < this._elements.length; i++) {
      if (this._elements[i] == el) {
        this._elements.splice(i, 1);
        break;
      }
    }

    var newel = this._elements.join("|");
    this._Panel.innerHTML = newel;
  },
  setElement: function (el) {
    if ((!el) || (el == "")) {
      this._Panel.innerHTML = "";
    }
    else {
      this._Panel.innerHTML = el;
    }
  }
});

/************************************************************************
 L.DivIcon
 - GSI.DivIcon
 ************************************************************************/
GSI.DivIcon = L.DivIcon.extend({
  options: {
    iconSize: null,
    className: 'gsi-div-icon',
    html: false
  },
  createIcon: function (oldIcon) {

    var div = L.DivIcon.prototype.createIcon.call(this, oldIcon);
    return div;
  }
});

GSI.divIcon = function (options) {
  return new GSI.DivIcon(options);
};

/************************************************************************
 L.Icon
 - GSI.Icon
 ************************************************************************/
GSI.Icon = L.Icon.extend({

  options: {
    html: ''
  },

  createIcon: function (oldIcon) {
    var img = L.Icon.prototype.createIcon.call(this, oldIcon);
    $(img).css({ 'margin': 0 });
    var div = $((oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'));

    div.empty();
    div.append(img);
    this._setIconStyles(div[0], 'icon');

    this._createLabel(div);
    this._div = div;
    return div[0];
  },
  _createLabel: function (div) {
    if (this.options._name == null || this.options._name == '') {
      this._label = null;
    }
    else {
      this._label = $("<div>").addClass("gsi-iconlabel-class").html(this.options._name).css({ "position": "absolute" });
      if (this.options.labelSize)
        this._label.addClass(this.options.labelSize);
      var size = L.point(this.options['iconSize']);
      if (!size) {
        size = {};
        size.x = 12;
        size.y = 12;
      }

      $("body").append(this._label);
      this._label.css({
        top: (size.y + 3) + 'px',
        left: (size.x / 2) - (this._label.outerWidth() / 2) + 'px'
      });
      this._label.remove();

      if (!this.options.labelVisible) {
        this._label.hide();
      }
      div.append(this._label);
    }
  },
  setLabelText: function (text) {
    this.options._name = text;
    if (this._label) this._label.remove();
    this._createLabel(this._div);
  },
  setLabelVisible: function (visible) {
    this.options.labelVisible = visible;
    if (this._label) {
      if (this.options.labelVisible) this._label.slideDown(200);
      else this._label.slideUp(200);
    }
  },

  setLabelSize: function (size) {
    this.options.labelSize = size;
    if (this._label) this._label.remove();
    this._createLabel(this._div);
  }
});

L.icon = function (options) {
  return new GSI.Icon(options);
};

GSI.Edit.DragMarker = L.Marker.Touch.extend({
  _initInteraction: function () {
    if (!this.options.interactive) { return; }

    L.DomUtil.addClass(this._icon, 'leaflet-interactive');

    this.addInteractiveTarget(this._icon);

    if (GSI.MarkerDrag) {
      var draggable = this.options.draggable;
      if (this.dragging) {
        draggable = this.dragging.enabled();
        this.dragging.disable();
      }

      this.dragging = new GSI.MarkerDrag(this);

      if (draggable) {
        this.dragging.enable();
      }
    }
  }
});

/************************************************************************
 L.Edit.SimpleShape
 ************************************************************************/
L.Edit.SimpleShape.prototype.initialize = function (shape, options) {
  // if touch, switch to touch icon
  if (GSI.Utils.Browser.touch) {
    this.options.moveIcon = this.options.touchMoveIcon;
    this.options.resizeIcon = this.options.touchResizeIcon;
  }

  this._shape = shape;
  L.Util.setOptions(this, options);
};

/************************************************************************
 L.Edit.Circle
 - GSI.Edit.Circle
 - GSI.Edit.CircleMarker
 ************************************************************************/
GSI.Edit.Circle = L.Edit.Circle.extend({
  includes: L.Evented.prototype || L.Mixin.Events,

  _resize: function (latlng) {
    L.Edit.Circle.prototype._resize.call(this, latlng);

    var result = GSI.Draw.convertRadius(this._shape.getRadius(), latlng, "m");

    this.fire("change", result);
  },

  _createMarker: function (latlng, icon) {
    // Extending L.Marker in TouchEvents.js to include touch.
    var marker = new GSI.Edit.DragMarker(latlng, {
      draggable: true,
      icon: icon,
      zIndexOffset: 10
    });

    this._bindMarker(marker);

    this._markerGroup.addLayer(marker);

    return marker;
  }
});

GSI.Edit.CircleMarker = L.Edit.Circle.extend({
  includes: L.Evented.prototype || L.Mixin.Events,

  initialize: function (layer, options) {
    L.Edit.Circle.prototype.initialize.call(this, layer, options);

    this.map = options.map;
    this.layer = layer;

    this._onZoomEnd = L.bind(this.onZoomEnd, this);
    this.map.on('zoomend', this._onZoomEnd);
  },

  _getPixelDistance: function (latlng1, latlng2) {

    var p1 = this._map.latLngToContainerPoint(latlng1);
    var p2 = this._map.latLngToContainerPoint(latlng2);
    var a = p1.x - p2.x;
    var b = p1.y - p2.y;
    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));

  },

  _resize: function (latlng) {
    var moveLatLng = this._moveMarker.getLatLng();
    var radius = this._getPixelDistance(moveLatLng, latlng);
    this._shape.setRadius(radius);

    this.fire("change", { radius: radius.toFixed(0) });
  },
  _move: function (latlng) {
    L.Edit.Circle.prototype._move.call(this, latlng);
    var vRadius = this._shape.getRadius();
    this._shape.setRadius(vRadius);
  },
  disable: function () {
    L.Edit.Circle.prototype.disable.call(this);
    this.map.off('zoomend', this._onZoomEnd);
  },
  onZoomEnd: function () {
    var vRadius = this._shape.getRadius();

    this._shape.setRadius(vRadius);
    for (var i = 0, l = this._resizeMarkers.length; i < l; i++) {
      this._unbindMarker(this._resizeMarkers[i]);
      this._map.removeLayer(this._resizeMarkers[i]);
    }
    this._unbindMarker(this._moveMarker);
    this._map.removeLayer(this._moveMarker);

    this._moveMarker = null;
    this._resizeMarkers = null;

    this._createMoveMarker();
    this._createResizeMarker();
  },

  _createMarker: function (latlng, icon) {
    // Extending L.Marker in TouchEvents.js to include touch.
    var marker = new GSI.Edit.DragMarker(latlng, {
      draggable: true,
      icon: icon,
      zIndexOffset: 10
    });

    this._bindMarker(marker);

    this._markerGroup.addLayer(marker);

    return marker;
  }
});

/************************************************************************
 L.FeatureGroup
 - GSI.KML
 ************************************************************************/
GSI.KML = L.FeatureGroup.extend({
  options: {
    async: true
  },
  opacitySetter: new GSI.LayerOpacitySetter(),
  initialize: function (kml, options) {
    L.Util.setOptions(this, options);
    this._kml = kml;
    this._layers = {};
  },
  load: function () {
    if (this._kml) {
      this.addKML(this._kml, this.options, this.options.async);
    }
  },
  loadXML: function (url, cb, options, async) {
    if (async === undefined) async = this.options.async;
    if (options === undefined) options = this.options;

    if (this.options._map) {
      var bounds = this.options._map.getBounds();
      url = url.replace('{left}', bounds.getWest());
      url = url.replace('{top}', bounds.getNorth());
      url = url.replace('{right}', bounds.getEast());
      url = url.replace('{bottom}', bounds.getSouth());
    }

    $.support.cors = true;
    this.ajax = $.ajax({
      type: "GET",
      dataType: "xml",
      url: url,
      success: L.Util.bind(this._onKMLLoad, this),
      error: L.Util.bind(this._onKMLLoadError, this),
      async: async

    });
  },
  onAdd: function (map) {
    this._map = map;
    this._map.on('zoomend', this._onZoomChange, this);
    this._onZoomChange();
  },
  onRemove: function (map) {
    if (map) map.off('zoomend', this._onZoomChange, this);
    this.eachLayer(map.removeLayer, map);
    this._map = null;
    this._layerAdded = false;
  },
  _onZoomChange: function () {
    if (!this._map) return;
    var zoom = this._map.getZoom();

    if (
      (this.options.minZoom && this.options.minZoom > zoom)
      ||
      (this.options.maxZoom && this.options.maxZoom < zoom)
    ) {
      this._layerAdded = false;
      this.eachLayer(this._map.removeLayer, this._map);
    }
    else {
      if (!this._layerAdded) {
        this._layerAdded = true;
        this.eachLayer(this._map.addLayer, this._map);
      }
    }
  },
  _onKMLLoadError: function (e) {
    this.fire('loaded');
  },
  _onKMLLoad: function (result) {
    var data = null;
    if (!result) return;

    if (result.data) {
      try {
        if (window.ActiveXObject) {
          data = new ActiveXObject("Microsoft.XMLDOM");
          data.async = false;
          data.loadXML((result.data) ? result.data.trim() : '');
        }
        else if (window.DOMParser) {
          data = new DOMParser().parseFromString(
            (result.data) ? result.data.trim() : '',
            "application/xml"
          );
        }
      }
      catch (e) {
        data = null;
      }
    }
    else data = result;

    if (!data) {
      this.fire('loaded');
    }
    else {
      try {
        this._addKML(data, this.options);
      }
      catch (e) {
        this.fire('loaded');
      }
    }
  },
  addKML: function (url, options, async) {
    var _this = this;
    this.fire('loadstart');

    try {
      this.loadXML(url, null, options, async);
    }
    catch (e) {
      this.fire('loaded');
    }
  },
  setMarkerZIndex: function (zIndex) {

    this.options.zIndexOffset = zIndex;
    L.FeatureGroup.prototype.setMarkerZIndex.call(this, this.options.zIndexOffset);
  },
  _addKML: function (xml, options) {

    try {
      var layers = GSI.KML.parseKML(xml, this);

      if (!layers || !layers.length) {
        this.fire('loaded');
        return;
      }
      for (var i = 0; i < layers.length; i++) {
        this.fire('addlayer', {
          layer: layers[i]
        });

        this.addLayer(layers[i]);
      }

      if (this.options.zIndexOffset) {
        this.setMarkerZIndex(this.options.zIndexOffset);
      }

      this.latLngs = GSI.KML.getLatLngs(xml);
      if (this.opacity) {
        this.setOpacity(this.opacity);
      }
    }
    catch (e) { }
    try {
      this.fire('loaded');
    } catch (e) { }
    this._onZoomChange();
  },
  setOpacity: function (opacity) {
    this.opacity = opacity;

    this.eachLayer(L.bind(function (layer) {

      this.opacitySetter.setOpacity(layer, this.opacity);

    }, this));
  },
  latLngs: []
});

L.Util.extend(GSI.KML, {

  parseKML: function (xml, obj) {

    var style = this.parseStyle(xml);
    this.parseStyleMap(xml, style);
    style.geodesic = (obj && obj.options && obj.options.geodesic ? true : false);

    var el = xml.getElementsByTagName('Folder');
    var layers = [], l;
    for (var i = 0; i < el.length; i++) {
      if (!this._check_folder(el[i])) { continue; }
      l = this.parseFolder(el[i], style);
      if (l) { layers.push(l); }
    }
    el = xml.getElementsByTagName('Placemark');
    for (var j = 0; j < el.length; j++) {
      if (!this._check_folder(el[j])) { continue; }
      l = this.parsePlacemark(el[j], xml, style);
      if (l) { layers.push(l); }
    }
    return layers;
  },
  // Return false if e's first parent Folder is not [folder]
  // - returns true if no parent Folders
  _check_folder: function (e, folder) {

    e = (e.parentElement ? e.parentElement : e.parentNode);

    while (e && e.tagName !== 'Folder') {
      e = (e.parentElement ? e.parentElement : e.parentNode);
    }
    return !e || e === folder;
  },
  parseStyle: function (xml) {
    var style = {};
    var sl = xml.getElementsByTagName('Style');

    var attributes = {
      color: true, width: true, Icon: true, href: true,
      hotSpot: true, scale: true
    };

    function _parse(xml) {
      var options = {};
      for (var i = 0; i < xml.childNodes.length; i++) {
        var e = xml.childNodes[i];
        var key = e.tagName;

        if (!attributes[key]) { continue; }
        if (key === 'hotSpot') {
          for (var j = 0; j < e.attributes.length; j++) {
            options[e.attributes[j].name] = e.attributes[j].nodeValue;
          }
        } else {
          var value = e.childNodes[0].nodeValue;
          if (key === 'color') {

            if (value && value.length > 0 && value.charAt(0) == "#") {
              options.color = value;
              options.opacity = 1;
            }
            else {
              options.color = '#' + value.substring(6, 8) + value.substring(4, 6) + value.substring(2, 4);
              options.opacity = parseInt(value.substring(0, 2), 16) / 255.0;
            }
          } else if (key === 'width') {
            options.weight = parseInt(value);
          } else if (key === 'Icon') {
            ioptions = _parse(e);
            if (ioptions.href) { options.href = ioptions.href; }
          } else if (key === 'href') {
            options.href = value;
          } else if (key === 'scale') {
            options.scale = value;
          }
        }
      }
      return options;
    }

    for (var i = 0; i < sl.length; i++) {
      var e = sl[i], el;
      var options = {}, poptions = {}, ioptions = {};
      el = e.getElementsByTagName('LineStyle');
      if (el && el[0]) { options = _parse(el[0]); }
      el = e.getElementsByTagName('PolyStyle');
      if (el && el[0]) { poptions = _parse(el[0]); }
      if (poptions.color) { options.fillColor = poptions.color; }
      if (poptions.opacity || poptions.opacity == 0) { options.fillOpacity = poptions.opacity; }
      el = e.getElementsByTagName('IconStyle');
      if (el && el[0]) { ioptions = _parse(el[0]); }
      if (ioptions.href) {
        // save anchor info until the image is loaded
        options.icon = {
          iconUrl: ioptions.href,
          shadowUrl: null,
          iconAnchorRef: { x: ioptions.x, y: ioptions.y },
          iconAnchorType: { x: ioptions.xunits, y: ioptions.yunits },
          _iconScale: ioptions.scale
        };
      }
      style['#' + e.getAttribute('id')] = options;
    }
    return style;
  },
  parseStyleMap: function (xml, existingStyles) {
    var sl = xml.getElementsByTagName('StyleMap');

    for (var i = 0; i < sl.length; i++) {
      var e = sl[i], el;
      var smKey = '', smStyleUrl = '';

      el = e.getElementsByTagName('key');
      if (el && el[0]) { smKey = el[0].textContent; }
      el = e.getElementsByTagName('styleUrl');
      if (el && el[0]) { smStyleUrl = el[0].textContent; }

      if (smKey === 'normal') {
        existingStyles['#' + e.getAttribute('id')] = existingStyles[smStyleUrl];
      }
    }

    return;
  },
  parseFolder: function (xml, style) {
    var el, layers = [], l;
    el = xml.getElementsByTagName('Folder');
    for (var i = 0; i < el.length; i++) {
      if (!this._check_folder(el[i], xml)) { continue; }
      l = this.parseFolder(el[i], style);
      if (l) { layers.push(l); }
    }
    el = xml.getElementsByTagName('Placemark');
    for (var j = 0; j < el.length; j++) {
      if (!this._check_folder(el[j], xml)) { continue; }
      l = this.parsePlacemark(el[j], xml, style);
      if (l) { layers.push(l); }
    }
    if (!layers.length) { return; }
    return new L.FeatureGroup(layers);
  },
  parsePlacemark: function (place, xml, style) {
    var i, j, el, options = {};
    el = place.getElementsByTagName('styleUrl');
    for (i = 0; i < el.length; i++) {
      var url = el[i].childNodes[0].nodeValue;
      for (var a in style[url]) {
        options[a] = style[url][a];
      }
    }
    options.geodesic = style.geodesic;
    var layers = [];
    var parse = ['LineString', 'Polygon', 'Point'];

    var name, tbl = '', descr = '';
    el = place.getElementsByTagName('name');
    if (el.length && el[0].childNodes.length) {
      name = el[0].childNodes[0].nodeValue;
    }
    for (j in parse) {
      // for jshint
      if (true) {
        var tag = parse[j];
        if (tag && typeof tag == 'string') {
          el = place.getElementsByTagName(tag);
          for (i = 0; i < el.length; i++) {
            var l = this['parse' + tag](el[i], xml, options, name);
            if (l) { layers.push(l); }
          }
        }
      }
    }

    if (!layers.length) {
      return;
    }
    var layer = layers[0];
    if (layers.length > 1) {
      layer = new L.FeatureGroup(layers);
    }

    el = place.getElementsByTagName('description');
    for (i = 0; i < el.length; i++) {
      for (j = 0; j < el[i].childNodes.length; j++) {
        descr = descr + el[i].childNodes[j].nodeValue;
      }
    }

    layer._information = {
      title: (name && name != '' ? name : null),
      description: (descr && descr != '' ? descr : null),
      table: null
    };

    if (layer._information.description) {
      // parse table tag
      var parser = $('<div>').html(layer._information.description);

      var table = parser.children('table');

      if (table.length > 0) {
        var tr = $(table[0]).find('tr');

        if (tr.length <= 0) {
          tr = $(table[0]).chidlren('tbody').children('tr');
        }
        for (var i = 0; i < tr.length; i++) {
          var td = $(tr[i]).children('td');
          if (td.length == 2) {
            if (!layer._information.table) layer._information.table = [];
            var value = $(td[1]).html();
            value = value.replace(/\<br\>/ig, "\n");
            layer._information.table.push({ key: $(td[0]).html().replace(/\<br\>/ig, "\n"), value: value });
          }
          else {
            layer._information.table = null;
            break;
          }
        }
      }

      delete parser;
      parser = null;
    }

    if (layer._information.table) layer._information.description = null;

    if ((name && name != '') || (descr && descr != '')) {
      layer.bindPopup((name && name != '' ? '<h2>' + GSI.Utils.encodeHTML(name) + '</h2>' : '') + (descr && descr != '' ? descr : ''),
        {
          maxWidth: 5000
        });
    }

    return layer;
  },
  parseCoords: function (xml) {
    var el = xml.getElementsByTagName('coordinates');
    return this._read_coords(el[0]);
  },
  parseLineString: function (line, xml, options) {
    var coords = this.parseCoords(line);
    if (!coords.length) { return; }
    return new L.Polyline(coords, options);
  },
  parsePoint: function (line, xml, options, name) {
    var el = line.getElementsByTagName('coordinates');
    if (!el.length) {
      return;
    }

    if (options.icon) {
      options = $.extend({}, options);
      options.icon._name = name;
      options.icon = new GSI.KMLIcon(options.icon);
    }
    var ll = el[0].childNodes[0].nodeValue.split(',');

    return new GSI.KMLMarker(new L.LatLng(ll[1], ll[0], ll.length >= 3 ? parseInt(ll[2]) : null), options);
  },
  parsePolygon: function (line, xml, options) {
    var el, polys = [], inner = [], i, coords;
    el = line.getElementsByTagName('outerBoundaryIs');
    for (i = 0; i < el.length; i++) {
      coords = this.parseCoords(el[i]);
      if (coords) {
        polys.push(coords);
      }
    }
    el = line.getElementsByTagName('innerBoundaryIs');
    for (i = 0; i < el.length; i++) {
      coords = this.parseCoords(el[i]);
      if (coords) {
        inner.push(coords);
      }
    }
    if (!polys.length) {
      return;
    }
    if (options.fillColor) {
      options.fill = true;
    }
    if (polys.length === 1) {
      return new L.Polygon(polys.concat(inner), options);
    }
    return new L.MultiPolygon(polys, options);
  },
  getLatLngs: function (xml) {
    var el = xml.getElementsByTagName('coordinates');
    var coords = [];
    for (var j = 0; j < el.length; j++) {
      // text might span many childNodes
      coords = coords.concat(this._read_coords(el[j]));
    }
    return coords;
  },
  _read_coords: function (el) {
    var text = '', coords = [], i;
    for (i = 0; i < el.childNodes.length; i++) {
      text = text + el.childNodes[i].nodeValue;
    }
    text = text.split(/[\s\n]+/);
    for (i = 0; i < text.length; i++) {
      var ll = text[i].split(',');
      if (ll.length < 2) {
        continue;
      }

      if (ll.length >= 3 && ll[2] != "" && ll[2] != 0)
        latLng = new L.LatLng(ll[1], ll[0], parseFloat(ll[2]));
      else
        latLng = new L.LatLng(ll[1], ll[0]);

      coords.push(latLng);
    }
    return coords;
  }
});

GSI.KMLIcon = L.Icon.extend({

  createIcon: function (oldIcon) {
    var img = this._createIcon('icon');

    $(img).css({ 'margin': 0 });
    var div = $((oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'));
    this._div = div;
    div.append($(img));
    this._setIconStyles(div[0], 'icon');

    div.addClass("leaflet-clickable");
    if (img.width && img.width > 0) {
      this._onIconImageLoaded(img);

    }
    else {
      $(img).css({ 'visibility': 'hidden' }).on('load', L.bind(this._onIconImageLoaded, this, img));
    }

    return div[0];
  },
  _onIconImageLoaded: function (img) {
    var scale = (this.options._iconScale ? this.options._iconScale : 1);
    var w = Math.round(img.width * scale);
    var h = Math.round(img.height * scale);
    this.options.iconSize = [w, h];
    var anchorX = null;
    var anchorY = null;
    if (this.options.iconAnchorRef && this.options.iconAnchorRef.x) {
      anchorX = Math.round(w * this.options.iconAnchorRef.x);
    }
    else {
      anchorX = Math.round(w / 2);
    }

    if (this.options.iconAnchorRef && this.options.iconAnchorRef.y) {
      anchorY = Math.round(h * this.options.iconAnchorRef.y);
    }
    else {
      anchorY = Math.round(h / 2);
    }
    this.options.iconAnchor = [anchorX, anchorY];

    img.style.width = w + 'px';
    img.style.height = h + 'px';

    this._setIconStyles(this._div[0], "icon");

    L.DomUtil.addClass(this._div[0], 'leaflet-clickable');
    img.style.visibility = 'visible';
    this._createLabel(this._div);
  },

  _setIconStyles: function (img, name) {
    var options = this.options;
    var sizeOption = options[name + 'Size'];

    if (typeof sizeOption === 'number') {
      sizeOption = [sizeOption, sizeOption];
    }

    var size = L.point(sizeOption),
      anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
        size && size.divideBy(2, true));

    $(img).addClass('leaflet-marker-' + name + ' ' + (options.className || ''));

    if (anchor) {
      img.style.marginLeft = (-anchor.x) + 'px';
      img.style.marginTop = (-anchor.y) + 'px';
    }

    if (size) {
      img.style.width = size.x + 'px';
      img.style.height = size.y + 'px';
    }
  },

  _createLabel: function (div) {
    if (this.options._name == null || this.options._name == '') {
      this._label = null;
    }
    else {
      this._label = $("<div>").addClass("gsi-iconlabel-class").html(this.options._name).css({ "position": "absolute" });
      if (this.options.labelSize)
        this._label.addClass(this.options.labelSize);

      var size = L.point(this.options['iconSize']);
      if (!size) {
        size = {};
        size.x = 12;
        size.y = 12;
      }

      $("body").append(this._label);
      this._label.css({
        top: (size.y + 3) + 'px',
        left: (size.x / 2) - (this._label.outerWidth() / 2) + 'px'
      });
      this._label.remove();

      if (!this.options.labelVisible) {
        this._label.hide();
      }
      div.append(this._label);
    }
  },
  setLabelText: function (text) {
    this.options._name = text;
    if (this._label) this._label.remove();
    this._createLabel(this._div);
  },
  setLabelVisible: function (visible) {
    this.options.labelVisible = visible;
    if (this._label) {
      if (this.options.labelVisible) this._label.slideDown(200);
      else this._label.slideUp(200);
    }
  },
  setLabelSize: function (size) {
    this.options.labelSize = size;
    if (this._label) this._label.remove();
    this._createLabel(this._div);
  }
});

GSI.KMLMarker = L.Marker.extend({
  options: {
    icon: new GSI.KMLIcon.Default(),
    clickable: true
  }
});

/************************************************************************
 GSI.MultiLayer
 ************************************************************************/
GSI.MultiLayer = L.LayerGroup.extend({
  initialize: function (entries, options) {
    this._entries = entries;
    L.LayerGroup.prototype.initialize.call(this, []);
  },

  load: function () {
    this.clearLayers();
    if (!this._entries) {
      return;
    }

    for (var i = 0; i < this._entries.length; i++) {
      var info = this._entries[i];

      if (window.location.protocol == "https:")
        info.url = info.url.replace("http://", "https://");
      info.layerType = GSI.LayersJSON.url2LayerType(info.url);

      var layer = GSI.Utils.infoToLayer(info);
      info._layer = layer;
      if (!layer) continue;

      layer._info = info;
      if (info.layerType == "tile") {

        layer.isGrayScale = this.isGrayScale;
        layer.highQuality = this.highQuality;
        layer._tileOnLoad = this._tileOnLoad;
        layer.createTile = this.createTile;
        layer._resetTile = this._resetTile;
        layer.grayscaleIE1011 = this.grayscaleIE1011;
        layer._getZoomForUrl = this._getZoomForUrl;

        this.addLayer(layer, true);
      }
      else if (info.layerType == "kml") {
        // KML
        layer.on("loadstart", L.bind(this.onLayerLoadStart, this, layer, "KML"));
        layer.on("loaded", L.bind(this.onLayerLoad, this, layer));
        layer.load();
        this.addLayer(layer, true);
      }
      else if (info.layerType == "geojson") {
        // GeoJSON
        layer.on("loadstart", L.bind(this.onLayerLoadStart, this, layer, "GeoJSON"));
        layer.on("load", L.bind(function (e) { this.onLayerLoad(e.src) }, this));
        layer.load();
        this.addLayer(layer);
      }
      else if (info.layerType == "geojson_tile") {
        // タイルGeoJSON
        this.addLayer(layer, true);
      }
      else if (info.layerType == "topojson_tile") {
        // タイルTopoJSON
        this.addLayer(layer, true);
      }
      else if (info.layerType == "topojson") {
        // TopoJSON
        layer.on("loadstart", L.bind(this.onLayerLoadStart, this, layer, "TopoJSON"));
        layer.on("load", L.bind(function (e) { this.onLayerLoad(e.src) }, this));
        layer.load();
        this.addLayer(layer);
      }
      else if (info.layerType == "tms") {
        // TMS
        this.addLayer(layer, true);
      }
      else if (info.layerType == "geotiff") {
        // GEOTIFF
        this.addLayer(layer, true);
      }
      else if (info.layerType == "videooverlay") {
        // VideoOverlay
        this.addLayer(layer, true);
      }
      else if (info.layerType == "pmtiles") {
        // PMTiles
        this.addLayer(layer, true);
      }
    }

  },

  onLayerLoadStart: function () {

  },

  onLayerLoad: function () {

  },

  redraw : function() {
    var layers = this.getLayers();
    for( var i=0; i<layers.length; i++ ) {
      var l = layers[i];
      l.isGrayScale = this.isGrayScale;
      l.highQuality = this.highQuality;
      if ( l.redraw) l.redraw();
    }
  },
  _resetView : function() {
    var layers = this.getLayers();
    for( var i=0; i<layers.length; i++ ) {
      var l = layers[i];
      if ( l._resetView) l._resetView();
    }
  },
  _setView : function(center, zoom) {
    var layers = this.getLayers();
    for( var i=0; i<layers.length; i++ ) {
      var l = layers[i];
      if ( l._setView) l._setView(center,zoom);
    }
  },

  setOpacity: function (opacity) {
    this._opacity = opacity;

    var layers = this.getLayers();

    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      if (layer.setOpacity) {
        var op = opacity;
        if (layer._info && layer._info.opacity != undefined) {
          op *= layer._info.opacity;
        }
        layer.setOpacity(op);

      }
    }
  },

  _getZoomForUrl: function () {

    var zoom = this._tileZoom,
      maxZoom = this.options.maxZoom,
      zoomReverse = this.options.zoomReverse,
      zoomOffset = this.options.zoomOffset;

    if (this.highQuality) {
      zoom++;
      if (zoom > 18) {
        zoom = 18;
        this.options.tileSize = 256;
      }
      else {
        this.options.tileSize = 128;
      }
    }
    else
      this.options.tileSize = 256;

    if (zoomReverse) {
      zoom = maxZoom - zoom;
    }

    return zoom + zoomOffset;
  },

  _tileOnLoad: function (done, tile) {
    var layer = this;
    var img = tile;

    if (layer && layer.isGrayScale && img.src !== L.Util.emptyImageUrl) {
      $(img).addClass("grayscale");
      if (GSI.Utils.Browser.ie) {
        if (GSI.Utils.Browser.version >= 10) {
          if (!$(img).data("_src") && img.src.indexOf("data:") < 0) {
            $(img).data({ "_src": this.src });
            img.src = this.grayscaleIE1011(img);
          }
        }
        else {
          $(img).css({ 'filter': 'gray', opacity: layer.opacity });
        }
      }
    }

    L.TileLayer.prototype._tileOnLoad.call(this, done, tile);
  },
  grayscaleIE1011: function (img)
  {
    var size = this.getTileSize();

    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    canvas.width = size.x;
    canvas.height = size.y;
    ctx.drawImage(img, 0, 0);
    var imgPixels = ctx.getImageData(0, 0, canvas.width, canvas.height);

    for (var y = 0; y < imgPixels.height; y++) {
      for (var x = 0; x < imgPixels.width; x++) {
        var i = (y * 4) * imgPixels.width + x * 4;
        var avg = (imgPixels.data[i] + imgPixels.data[i + 1] + imgPixels.data[i + 2]) / 3;
        imgPixels.data[i] = avg;
        imgPixels.data[i + 1] = avg;
        imgPixels.data[i + 2] = avg;
      }
    }
    ctx.putImageData(imgPixels, 0, 0, 0, 0, imgPixels.width, imgPixels.height);

    return canvas.toDataURL();
  },
  createTile: function (coords, done) {
    var tile = L.TileLayer.prototype.createTile.call(this, coords, done);

    if (this.isGrayScale) {
      if (GSI.Utils.Browser.ie && GSI.Utils.Browser.version >= 10)
        $(tile).attr({ 'crossOrigin': 'Anonymous' });
      $(tile).addClass("grayscale");
      if (GSI.Utils.Browser.ie && GSI.Utils.Browser.version < 10) {
        $(tile).css({ 'filter': 'gray', opacity: this.opacity });
      }
    }
    return tile;
  },
  _resetTile: function (tile) {
    $(tile).data({ "_src": null });
  }
});

/************************************************************************
 L.LayerGroup
 ************************************************************************/
L.LayerGroup.prototype.setMarkerZIndex = function (offset) {
  this._setMarkerZIndex(this, offset);
};

L.LayerGroup.prototype._setMarkerZIndex = function (layer, offset) {
  if (layer.setZIndexOffset) {
    layer.setZIndexOffset(offset);
  }
  else if (layer.setZIndex){
    layer.setZIndex(offset)
  }
  else if (layer.getLayers) {
    var layers = layer.getLayers();
    for (var i = 0; i < layers.length; i++) {
      this._setMarkerZIndex(layers[i], offset);
    }
  }
};

/************************************************************************
 L.Marker
 - GSI.CenterCrossMarker（中心マーク）
 ************************************************************************/
GSI.CenterCrossMarker = L.Marker.extend({
  _initIcon: function () {
    var options = this.options,
      map = this._map,
      animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),
      classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';

    var icon = options.icon.createIcon(this._icon),
      addIcon = false;

    // if we're not reusing the icon, remove the old one and init new one
    if (icon !== this._icon) {
      if (this._icon) {
        this._removeIcon();
      }
      addIcon = true;

      if (options.title) {
        icon.title = options.title;
      }

      if (options.alt) {
        icon.alt = options.alt;
      }
    }

    L.DomUtil.addClass(icon, classToAdd);

    if (options.keyboard) {
      icon.tabIndex = '0';
    }

    this._icon = icon;

    this._initInteraction();

    if (options.riseOnHover) {
      L.DomEvent
        .on(icon, 'mouseover', this._bringToFront, this)
        .on(icon, 'mouseout', this._resetZIndex, this);
    }

    var newShadow = options.icon.createShadow(this._shadow),
      addShadow = false;

    if (newShadow !== this._shadow) {
      this._removeShadow();
      addShadow = true;
    }

    if (newShadow) {
      L.DomUtil.addClass(newShadow, classToAdd);
    }
    this._shadow = newShadow;

    if (options.opacity < 1) {
      this._updateOpacity();
    }

    var panes = this._map._panes;

    if (addIcon) {
      panes.gsiObjectsPane.appendChild(this._icon);
    }

    if (newShadow && addShadow) {
      panes.objectsPane.appendChild(this._shadow);
    }
  },
  _removeIcon: function () {
    if (this.options.riseOnHover) {
      L.DomEvent
        .off(this._icon, 'mouseover', this._bringToFront)
        .off(this._icon, 'mouseout', this._resetZIndex);
    }

    this._map._panes.gsiObjectsPane.removeChild(this._icon);

    this._icon = null;
  },
  _removeShadow: function () {
    if (this._shadow) {
      this._map._panes.objectsPane.removeChild(this._shadow);
    }
    this._shadow = null;
  }
});

/************************************************************************
 L.Popup
 ・_updateLayout上書き
 ・tableのwidth指定時修正
 ************************************************************************/
L.Popup.prototype._updateLayout = function () {
  var container = this._contentNode,
    style = container.style;

  var table = $(container).find("table");
  var tableWidth = null;

  if (table.length > 0) {
    tableWidth = table.attr('width');
    if (!tableWidth) {
      tableWidth = table[0].style.width;
    }

  }

  style.width = '';
  if (!tableWidth) style.whiteSpace = 'nowrap';

  var width = container.offsetWidth;
  width = Math.min(width, this.options.maxWidth);
  width = Math.max(width, this.options.minWidth);

  style.width = (width + 1) + 'px';
  style.whiteSpace = '';

  style.height = '';

  var height = container.offsetHeight,
    maxHeight = this.options.maxHeight,
    scrolledClass = 'leaflet-popup-scrolled';

  if (maxHeight && height > maxHeight) {
    style.height = maxHeight + 'px';
    L.DomUtil.addClass(container, scrolledClass);
  } else {
    L.DomUtil.removeClass(container, scrolledClass);
  }

  this._containerWidth = this._container.offsetWidth;
};

/************************************************************************
 L.TileLayer
  - GSI.BaseLayer（地図）
 ************************************************************************/
GSI.BaseLayer = L.Layer.extend({
  baseLayerList: null,
  activeIndex: 0,
  isGrayScale: false,
  opacity: 1,
  highQuality: false,
  initialize: function (baseLayerList, defaultMap, defaultMapGrayScale) {

    this.highQuality = false;
    this.activeIndex = 0;
    this.activeIndexPre = -1;
    if (defaultMap) {
      for (var i = 0; i < baseLayerList.length; i++) {
        if (baseLayerList[i].id == defaultMap) {
          this.activeIndex = i;
          break;
        }
      }
    }
    this.baseLayerList = baseLayerList;
    options = L.setOptions(this, {});
    options.minZoom = 2;

    this.setActiveIndex(this.activeIndex);
    this.setGrayScale(defaultMapGrayScale);

    if (!L.android) {
      this.on('tileunload', this._onTileRemove);
    }
  },

  getOpacity: function (opacity) {
    return this.opacity;
  },
  setOpacity: function (opacity) {
    this.opacity = opacity;
    this.options.opacity = opacity;
    if ( this._layer ) {
      this._layer.setOpacity( opacity );
    }
  },

  getAttribution: function () {
    if (this.baseLayerList[this.activeIndex].attribution) {
      return this.baseLayerList[this.activeIndex].attribution;
    }
    return "";
  },
  getActiveId: function () {
    return this.baseLayerList[this.activeIndex].id;
  },
  getActiveIndex: function () {
    return this.activeIndex;
  },
  setActiveId: function (id) {
    for (var i = 0; i < this.baseLayerList.length; i++) {
      if (this.baseLayerList[i].id == id) {
        this.setActiveIndex(i);
      }
    }
  },
  setActiveIndex: function (idx) {
    if (this.activeIndexPre == -1 || this.activeIndexPre != idx) {
      this.activeIndex = idx;

      var url = this.baseLayerList[idx].url;
      var options = {};

      if (this.baseLayerList[idx].subdomains) {
        options.subdomains = this.baseLayerList[idx].subdomains;
      }
      options.maxNativeZoom = this.baseLayerList[idx].maxNativeZoom;

      if (this.baseLayerList[idx].maxZoom) {
        options.maxZoom = this.baseLayerList[idx].maxZoom;
      } else {
        options.maxZoom = 18;
      }

      if (this.baseLayerList[idx].minZoom) {
        options.minZoom = this.baseLayerList[idx].minZoom;
      }
      if (!options.maxNativeZoom) options.maxNativeZoom = 18;

      var errorTileUrl = "image/map/no-data.png";
      if (errorTileUrl) {
        errorTileUrl = this.baseLayerList[idx].errorTileUrl;
      }
      options.errorTileUrl = errorTileUrl;

      if ( this._layer && this._map) {
        this._map.removeLayer(this._layer);
      }

      if ( this.baseLayerList[idx].type == "LayerGroup") {

        this._layer = new GSI.MultiLayer( this.baseLayerList[idx].entries);
        this._layer.isGrayScale = this.isGrayScale;
        this._layer.highQuality = this.highQuality;
        this._layer.setOpacity( this.options.opacity ? this.options.opacity : this.opacity );
        this._layer.load();
      } else {
        this._layer = L.tileLayer(url, options);

        this._layer.isGrayScale = this.isGrayScale;
        this._layer.highQuality = this.highQuality;
        this._layer.setOpacity( this.options.opacity ? this.options.opacity : this.opacity );

        this._layer._clampZoom = this._clampZoom;
        this._layer._tileOnLoad = this._tileOnLoad;
        this._layer.createTile = this.createTile;
        this._layer._resetTile = this._resetTile;
        this._layer.grayscaleIE1011 = this.grayscaleIE1011;
        this._layer._getZoomForUrl = this._getZoomForUrl;

      }

      if (this._map) {
        this._layer.addTo( this._map);
        this._layer._setView(this._map.getCenter(), this._map.getZoom());
      }
    }
    this.activeIndexPre = this.activeIndex;
  },

	_clampZoom: function (zoom) {
		var options = this.options;

    if ( undefined !== options.maxZoom && zoom > options.maxZoom ) {
      return zoom;
    }

		if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
			return options.minNativeZoom;
		}

		if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
			return options.maxNativeZoom;
		}

		return zoom;
  },

  onAdd  : function(map) {
    if ( this._layer  && !this._layer._map) {

      this._layer.isGrayScale = this.isGrayScale;

      this._layer.highQuality = this.highQuality;
      this._layer.setOpacity(  this.options.opacity ? this.options.opacity :this.opacity );
      this._layer.addTo( this._map);
    }
  },

  onRemove : function() {
    if ( this._layer ) this._layer.remove( this._map);

  },

  getGrayScale: function () {
    return this.isGrayScale;
  },
  setGrayScale: function (isGrayScale) {

    if (this.isGrayScale != isGrayScale) {
      this.isGrayScale = isGrayScale;
      if ( this._layer ) {
        this._layer.isGrayScale = this.isGrayScale;
        this._layer.redraw();
      }
    }
  },

  setHighQuality: function (on) {
    this.highQuality = on;
    if (this._map) {
      if ( this._layer ) {
        this._layer.highQuality = this.highQuality;
        this._layer.redraw();
        this._layer._resetView();
      }
    }
  },
  getHighQuality: function () {
    return this.highQuality;
  },

  _getZoomForUrl: function () {

    var zoom = this._tileZoom,
      maxZoom = this.options.maxZoom,
      zoomReverse = this.options.zoomReverse,
      zoomOffset = this.options.zoomOffset;

    if (this.highQuality) {
      zoom++;
      if (zoom > 18) {
        zoom = 18;
        this.options.tileSize = 256;
      }
      else {
        this.options.tileSize = 128;
      }
    }
    else
      this.options.tileSize = 256;

    if (zoomReverse) {
      zoom = maxZoom - zoom;
    }
    return zoom + zoomOffset;
  },

  _tileOnLoad: function (done, tile) {
    var layer = this;
    var img = tile;

    if (layer && layer.isGrayScale && img.src !== L.Util.emptyImageUrl) {
      $(img).addClass("grayscale");
      if (GSI.Utils.Browser.ie) {
        if (GSI.Utils.Browser.version >= 10) {
          if (!$(img).data("_src") && img.src.indexOf("data:") < 0) {
            $(img).data({ "_src": this.src });
            img.src = this.grayscaleIE1011(img);
          }
        }
        else {
          $(img).css({ 'filter': 'gray', opacity: layer.opacity });
        }
      }
    }

    L.TileLayer.prototype._tileOnLoad.call(this, done, tile);
  },
  grayscaleIE1011: function (img)
  {
    var size = this.getTileSize();

    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    canvas.width = size.x;
    canvas.height = size.y;
    ctx.drawImage(img, 0, 0);
    var imgPixels = ctx.getImageData(0, 0, canvas.width, canvas.height);

    for (var y = 0; y < imgPixels.height; y++) {
      for (var x = 0; x < imgPixels.width; x++) {
        var i = (y * 4) * imgPixels.width + x * 4;
        var avg = (imgPixels.data[i] + imgPixels.data[i + 1] + imgPixels.data[i + 2]) / 3;
        imgPixels.data[i] = avg;
        imgPixels.data[i + 1] = avg;
        imgPixels.data[i + 2] = avg;
      }
    }
    ctx.putImageData(imgPixels, 0, 0, 0, 0, imgPixels.width, imgPixels.height);

    return canvas.toDataURL();
  },
  createTile: function (coords, done) {

    var tile = L.TileLayer.prototype.createTile.call(this, coords, done);

    if (this.isGrayScale) {
      if (GSI.Utils.Browser.ie && GSI.Utils.Browser.version >= 10)
        $(tile).attr({ 'crossOrigin': 'Anonymous' });
      $(tile).addClass("grayscale");
      if (GSI.Utils.Browser.ie && GSI.Utils.Browser.version < 10) {
        $(tile).css({ 'filter': 'gray', opacity: this.opacity });
      }
    }
    return tile;
  },
  _resetTile: function (tile) {
    $(tile).data({ "_src": null });
  }
});

/************************************************************************
 L.TileLayer
  - GSI.GSITMSLayer
 ************************************************************************/
GSI.GSITMSLayer = L.TileLayer.extend({
  initialize: function (url, options) {
    var urlParts = url.split('{tms}');
    this._url = urlParts[0];
    this._ext = urlParts[1];

    L.setOptions(this, options);
  },
  _zeroPad: function (num, len) {
    var result = "" + num;
    while (result.length < len) {
      result = "0" + result;
    }
    return result;
  },
  getTileUrl: function (tilePoint) {
    var z = tilePoint.z;
    var x = this._zeroPad(tilePoint.x, 7);
    var y = this._zeroPad(tilePoint.y, 7);

    var dir = '';
    for (var i = 0; i < 6; i++) {
      var xi = x.substr(i, 1);
      var yi = y.substr(i, 1);
      dir += "/" + xi + yi;
    }

    var url = L.Util.template(this._url, { s: this._getSubdomain(tilePoint) });
    return url + z + dir + "/" + x + y + this._ext;
  }
});

/************************************************************************
 L.TileLayer
  - GSI.TileLayer
 ************************************************************************/
GSI.TileLayer = L.TileLayer.extend({
  setOptions: function (options) {
    options = L.setOptions(this, options);

    // detecting retina displays, adjusting tileSize and zoom levels
    if (options.detectRetina && retina && options.maxZoom > 0) {

      options.tileSize = Math.floor(options.tileSize / 2);

      if (!options.zoomReverse) {
        options.zoomOffset++;
        options.maxZoom--;
      } else {
        options.zoomOffset--;
        options.minZoom++;
      }

      options.minZoom = Math.max(0, options.minZoom);
    }

    if (typeof options.subdomains === 'string') {
      options.subdomains = options.subdomains.split('');
    }
  },

  // update 2020-11-24
  _update : function (center) {
		if ( this._map.getZoom() > this.options.maxZoom ) { return; }
    return L.TileLayer.prototype._update.apply(this,center);
  }
});

/************************************************************************
 L.Class
 - GSI.GeoJSON
 ************************************************************************/
GSI.GeoJSON = L.Layer.extend({
  opacity: 1,
  opacitySetter: new GSI.LayerOpacitySetter(),

  initialize: function (url, options) {
    this.url = url;
    options = L.setOptions(this, options);
  },
  load: function () {
    this.fire("loadstart", { "src": this });
    try {
      this._cerateLayer();
    }
    catch (e) {
      this.fire("load", { "src": this });
      return;
    }

    this._loadTimerId = setTimeout(L.bind(this._loadStart, this), 200);

  },
  _loadStart: function () {
    if (this._loadTimerId) {
      clearTimeout(this._loadTimerId);
      this._loadTimerId = null;
    }
    try {
      this._load();
    }
    catch (e) {
      this.fire("load", { "src": this });
    }
  },
  onPointToLayer: function (feature, latlng) {
    if (!feature.properties) return L.marker(latlng, { icon: L.icon({ iconUrl: CONFIG.SAKUZU.SYMBOL.URL + CONFIG.SAKUZU.SYMBOL.DEFAULTICON, iconSize: [20, 20], iconAnchor: [10, 10] }) });

    var marker = null;
    if (feature.properties["_markerType"]) {
      var markerType = feature.properties["_markerType"];
      switch (markerType) {
        case "DivIcon":
          var iconSize = feature.properties["_iconSize"];
          var iconAnchor = feature.properties["_iconAnchor"];
          var html = feature.properties["_html"];
          var className = feature.properties["_className"];

          var options = {};
          if (iconSize) options.iconSize = iconSize;
          if (iconAnchor) options.iconAnchor = iconAnchor;
          if (html) options.html = html;
          if (className) options.className = className;

          marker = L.marker(latlng, { icon: GSI.divIcon(options) });
          break;

        case "CircleMarker":
          var options = {};
          for (var key in feature.properties) {
            if (!feature.properties[key]) continue;
            if (key != "" && key.charAt(0) == '_' && key != "_markerType") {
              var value = feature.properties[key];
              key = key.slice(1);
              options[key] = value;
            }
          }
          marker = L.circleMarker(latlng, options);
          marker.setRadius(options['radius']);
          break;
        case "Circle":
          var options = {};
          for (var key in feature.properties) {
            if (!feature.properties[key]) continue;
            if (key != "" && key.charAt(0) == '_' && key != "_markerType") {
              var value = feature.properties[key];
              key = key.slice(1);
              options[key] = value;
            }
          }
          marker = L.circle(latlng, options['radius'], options);
          break;

      }
    }

    if (!marker) {
      if (!feature.properties["_iconUrl"])
        return L.marker(latlng, { icon: L.icon({ iconUrl: CONFIG.SAKUZU.SYMBOL.URL + CONFIG.SAKUZU.SYMBOL.DEFAULTICON, iconSize: [20, 20], iconAnchor: [10, 10] }) });
      var iconUrl = feature.properties["_iconUrl"];
      var iconSize = feature.properties["_iconSize"];
      var iconAnchor = feature.properties["_iconAnchor"];
      var className = feature.properties["_className"];
      var name = feature.properties["name"];
      var scale = iconSize[0] / CONFIG.SAKUZU.SYMBOL.ICONSIZE[0];

      var iconOptions = {};
      if (iconUrl) iconOptions.iconUrl = iconUrl;
      if (iconSize) iconOptions.iconSize = iconSize;
      if (iconAnchor) iconOptions.iconAnchor = iconAnchor;
      if (className) iconOptions.className = className;
      if (scale) iconOptions._iconScale = scale;
      if (name) iconOptions._name = name;
      marker = L.marker(latlng, { icon: L.icon(iconOptions) });
    }

    return marker;
  },
  onStyle: function (feature) {
    if (!feature.properties) return null;

    var style = null;
    var iconStyleKeys = {
      "_markerType": true,
      "_iconUrl": true,
      "_iconSize": true,
      "_iconAnchor": true,
      "_html": true,
      "_radius": true
    };

    for (var key in feature.properties) {
      if (!feature.properties[key] && feature.properties[key] != 0) continue;

      if (key != "" && key.charAt(0) == '_') {
        if (iconStyleKeys[key]) {
          continue;
        }
        else {
          var value = feature.properties[key];
          key = key.slice(1);
          if (!style) style = {};
          style[key] = value;
        }
      }
    }
    return style;
  },
  onEachFeature: function (feature, layer) {
    if (!feature.properties) return;

    var popupContent = '';

    if (feature.properties['name']) {
      popupContent += '<h2>' + GSI.Utils.encodeHTML(feature.properties['name']) + '</h2>';
    }

    if (feature.properties['description']) {
      popupContent += feature.properties['description'];
    }
    else {
      var table = '';
      for (var key in feature.properties) {
        var featureValue = feature.properties[key] ? feature.properties[key] : "";

        if (key != "" && key != 'name' && !CONFIG.GEOJSONSPECIALKEYS[key]) {

          if (key && key.replace)
            key = key.replace(/\n/g, "<br>");
          if (featureValue && featureValue.replace)
            featureValue = featureValue.replace(/\n/g, "<br>");

          table +=
            "<tr>" +
            "<td>" + key + "</td>" +
            "<td>" + featureValue + "</td>" +
            "</tr>";
        }
      }

      if (table != '') {
        table = '<table>' + table + '</table>';
        popupContent += table;
      }
    }

    if (popupContent != '') {
      layer.bindPopup(popupContent,
        {
          maxWidth: 5000
        });
    }
  },
  onLoadError: function () {
    this.fire("load", { "src": this });
  },

  setMarkerZIndex: function (zIndex) {
    this.options.zIndexOffset = zIndex;
    if (this.layer && this.layer.setMarkerZIndex)
      this.layer.setMarkerZIndex(this.options.zIndexOffset)
  },
  addData: function (json) {
    try {
      if (!this.layer) this._cerateLayer();
      if (json.type == 'Topology') {
        json = omnivore.topojson.parse(json);
        this.layer.addData(json);
      }
      else {
        this.layer.addData(json);
      }

      if (this.options.zIndexOffset && this.layer.setMarkerZIndex)
        this.layer.setMarkerZIndex(this.options.zIndexOffset)

    }
    catch (e) {

      console.log(e);
    }
    this.opacitySetter.setOpacity(this.layer, this.opacity);
  },
  onLoad: function (result) {
    var data = null;

    if (!result) return;
    if (result.data) data = result.data;
    else data = result;

    var jsonData = null;

    try {
      jsonData = eval("(" + data + ")");
    }
    catch (e) {
      jsonData = data;
    }

    this.addData(jsonData);

    this.fire("load", { "src": this });
  },
  getBounds: function () {
    return (this.layer ? this.layer.getBounds() : null);
  },
  _cerateLayer: function () {
    var geoJSONOptions = {};

    geoJSONOptions.style = L.bind(this.onStyle, this);
    geoJSONOptions.onEachFeature = L.bind(this.onEachFeature, this);
    geoJSONOptions.pointToLayer = L.bind(this.onPointToLayer, this);
    geoJSONOptions.geodesic = this.options.geodesic;
    this.layer = new L.GeoJSON(null, geoJSONOptions);

    if (!this._layerAdded && this._map) {
      var zoom = this._map.getZoom();

      if (this.options.minZoom && this.options.minZoom > zoom) return;
      if (this.options.maxZoom && this.options.maxZoom < zoom) return;

      this._map.addLayer(this.layer);
      this._layerAdded = true;
    }
  },
  _loadFromFile: function () { },
  _load: function () {
    this.ajax = $.ajax({
      type: "GET",
      dataType: "text",
      url: this.url,
      success: L.Util.bind(this.onLoad, this),
      error: L.Util.bind(this.onLoadError, this)
    });
  },
  _onZoomChange: function () {
    if (!this.layer) return;
    var zoom = this._map.getZoom();

    if (
      (this.options.minZoom && this.options.minZoom > zoom)
      ||
      (this.options.maxZoom && this.options.maxZoom < zoom)
    ) {
      this._layerAdded = false;
      this._map.removeLayer(this.layer);
    }
    else {
      if (!this._layerAdded) {
        this._layerAdded = true;
        this._map.addLayer(this.layer);
      }
    }
  },
  onAdd: function (map) {
    this._map = map;
    this._map.on('zoomend', this._onZoomChange, this);

    if (this.layer) {
      var zoom = this._map.getZoom();

      if (this.options.minZoom && this.options.minZoom > zoom) return;
      if (this.options.maxZoom && this.options.maxZoom < zoom) return;

      this._layerAdded = true;
      map.addLayer(this.layer);
    }
  },
  onRemove: function (map) {
    if (map) map.off('zoomend', this._onZoomChange, this);
    if (this.layer) {
      map.removeLayer(this.layer);
      this._layerAdded = false;
    }

    this._map = null;
  },
  setOpacity: function (opacity) {
    this.opacity = opacity;
    this.opacitySetter.setOpacity(this.layer, opacity);
  },
  getLayers: function () {
    if (this.layer) {
      return this.layer.getLayers();
    }
    else return null;
  },
  addLayer: function (layer) {
    if (this.layer) {
      this.layer.addLayer(layer);
    }
  },
  removeLayer: function (layer) {
    if (this.layer) {
      this.layer.removeLayer(layer);
    }
  }
});

/************************************************************************
  postMessage
 ************************************************************************/
window.addEventListener('message', function (event) {
  if (L.Browser.ie){
    return;
  }
  var d = event.data;

  // 20190703
  setTimeout(function () {
    if (GSI.GLOBALS.gsimaps._mainMap && GSI.GLOBALS.gsimaps._mainMap._map)
      GSI.GLOBALS.gsimaps._mainMap._map.invalidateSize();
    if (GSI.GLOBALS.gsimaps._subMap && GSI.GLOBALS.gsimaps._subMap._map)
      GSI.GLOBALS.gsimaps._subMap._map.invalidateSize();

  }, 1);
  // 20190703

  if ((typeof d.sakuzuList === 'undefined') ||
    (typeof d.queryString === 'undefined') ||
    (typeof d.LayerJS === 'undefined') ||
    (typeof d.baseUrl === 'undefined') ||
    (typeof d.location === 'undefined')) {
    return;
  }

  try {
    GSI.ClientMode.queryString = "";

    if (d.sakuzuList != null) { GSI.ClientMode.sakuzuList = d.sakuzuList; }
    if (d.queryString != null) {
      GSI.ClientMode.queryString = d.queryString;
      if (GSI.ClientMode.queryString.indexOf("#") != -1) {
        var nPos = (GSI.ClientMode.queryString.match(new RegExp("/", "g")) || []).length;
        if (nPos == 0) { GSI.ClientMode.queryString = GSI.ClientMode.queryString.replace("#", "#//"); }
        else if (nPos == 1) { GSI.ClientMode.queryString = GSI.ClientMode.queryString.replace("#", "#/"); }
        GSI.ClientMode.queryString = GSI.ClientMode.queryString.replace("#//", "#//&")

        var vUrl = GSI.ClientMode.queryString.split("#");
        var vUrl_Args = "";
        var vUrl_Hash = "";
        if (vUrl.length == 2) {
          vUrl_Args = vUrl[0].replace("?", "");
          vUrl_Hash = vUrl[1];
        }
        if (vUrl_Hash.indexOf("/&") == -1) {
          var nOpt = vUrl_Hash.indexOf("&");
          vUrl_Hash = vUrl_Hash.slice(0, nOpt) + "/" + vUrl_Hash.slice(nOpt, vUrl_Hash.length);
          var vHash = vUrl_Hash.split("/");
          if (vHash.length >= 3) {
            var z = vHash[0];
            var lat = vHash[1];
            var lon = vHash[2];
            vUrl_Hash = "";
            if (lat != "" && lon != "") {
              vUrl_Hash += "ll=" + lat + "," + lon;
            }
            if (z != "") {
              vUrl_Hash += "&z=" + z;
            }
            if (vHash.length >= 4) {
              vUrl_Hash += vHash[3];
            }
          }
        }

        GSI.ClientMode.queryString = vUrl_Args;
        if (GSI.ClientMode.queryString != "") {
          GSI.ClientMode.queryString += "&";
        }
        GSI.ClientMode.queryString += vUrl_Hash;
      }
    }

    GSI.ClientMode.queryString += location.hash;

    var queryParams = new GSI.QueryParams({ queryString: GSI.ClientMode.queryString });
    GSI.GLOBALS.gsimaps = new GSI.GSIMaps(queryParams);

  }
  catch (e) {
    console.log(e);
  }
}, false);

var ctrlSettin = "";
var viewSetting = "";
var startUpCenter = "";
var startUpZoom = "";
/*
GSI.BookmarkPanel = L.Class.extend({

  initialize: function (map, buttonElement) {
    this._map = map;
    this._buttonElement = buttonElement;
    this._hideHandler = L.bind(this._hideProc, this);
  },

  show: function () {
    this._create();
    this._urlTextarea.val(window.location.href);
    this._container.slideDown(200);
    this._urlTextarea.click();

    this._map.on("mousedown", this._hideHandler);
    $("body").on('mousedown', this._hideHandler);
  },

  toggle: function () {
    if (this._container && this._container.is(":visible"))
      this.hide();
    else
      this.show();
  },

  _hideProc: function (e) {
    if (e.latlng)
      this.hide();
    else {
      if (
        this._buttonElement != e.target
        && this._container[0] != e.target
        && this._container.find(e.target).length <= 0) {
        this.hide();
      }

    }
  },

  hide: function () {
    this._container.slideUp(200);

    this._map.off("mousedown", this._hideHandler);
    $("body").off('mousedown', this._hideHandler);
  },
  _appendBookmark: function () {
    var url = this._urlTextarea;
    if (window.sidebar && window.sidebar.addPanel) { // Mozilla Firefox Bookmark
      window.sidebar.addPanel(url, '');
    } else if (window.external && ('AddFavorite' in window.external)) { // IE Favorite
      window.external.AddFavorite(url, document.title);
    } else { // webkit - safari/chrome
      alert('ブラウザ付属のブックマーク機能をご利用ください。' + (navigator.userAgent.toLowerCase().indexOf('mac') != - 1 ? '【 Command 】' : '【 Ctrl 】') + ' + 【 D 】ボタンを押すとブックマークできます。');
    }
  },

  _create: function () {
    if (this._container) return;

    this._container = $("<div>").addClass("gsi_bookmark_panel").hide();
    var h3 = $("<h3>").html("表示している地図の状態を再現するURL");
    this._container.append(h3);

    var msg = $("<div>").addClass("message").html("※外部データ・作図情報は反映されません。");
    this._container.append(msg);

    this._urlTextarea = $("<textarea>")
      .focus(function () {
        $(this).select();
      })
      .click(function () {
        $(this).select();
        return false;
      });
    this._container.append(this._urlTextarea);

    msg = $("<div>").addClass("message").html("ブラウザのお気に入りに登録したい場合は、上記のURLをコピーして登録して下さい。");
    this._container.append(msg);

    //twitter, Facebookへのリンクをクリップボタン内に格納
    gsi_bookmark_panel_twitter = $("<img>").attr('src', './image/system/twitter.png');
    gsi_bookmark_panel_twitter = gsi_bookmark_panel_twitter.attr('id', 'bookmark_title_twitter');
    gsi_bookmark_panel_twitter = gsi_bookmark_panel_twitter.css('cursor', 'pointer');
    gsi_bookmark_panel_twitter = gsi_bookmark_panel_twitter.on('click', function () {
      GSI.SHARE.showTwitter();
    });
    this._container.append(gsi_bookmark_panel_twitter);

    gsi_bookmark_panel_facebook = $("<img>").attr('src', './image/system/facebook.png');
    //    gsi_bookmark_panel_facebook = gsi_bookmark_panel_facebook.attr('id', 'title_facebook');
    gsi_bookmark_panel_facebook = gsi_bookmark_panel_facebook.css('cursor', 'pointer');
    gsi_bookmark_panel_facebook = gsi_bookmark_panel_facebook.on('click', function () {
      GSI.SHARE.showFacebook();
    });
    this._container.append(gsi_bookmark_panel_facebook);

    $("body").append(this._container);

  }
});
*/
function GeoTiffList() {

  var sakuzuList = GSI.GLOBALS.gsimaps._sakuzuList;
  if ( !sakuzuList ) return [];

  return sakuzuList.getGeotiffList();
}

function Vectors() {
  var ret = null;

  oMapLayers = GSI.GLOBALS.gsimaps._sakuzuList;
  if (oMapLayers != null) {
    var oData = oMapLayers.getData();
    var nMax = oData.length;
    if (nMax > 0) {
      ret = oData;
    }
  }
  return ret;
};

function showHelp() {
  var windowSize = GSI.Utils.getScreenSize();
  if (GSI.GLOBALS.HelpDialog && GSI.GLOBALS.HelpDialog.getVisible()) {
    GSI.GLOBALS.HelpDialog.hide();
  }
  GSI.GLOBALS.HelpDialog = new GSI.HelpDialog(GSI.GLOBALS.map, GSI.GLOBALS.mapMouse, { left: "center", top: 45, effect: CONFIG.EFFECTS.DIALOG });
  GSI.GLOBALS.HelpDialog.show();
};

/*******************************************************

 GSI.MapToImage
    画像保存

*******************************************************/
GSI.MapToImage = {};
GSI.MapToImage = L.Evented.extend({
  options: {
    drawControls: true
  },

  initialize: function (gsimaps, map, list, options) {
    L.setOptions(this, options);
    this._map = map;
    this._gsimaps = gsimaps;
    this._list = list;

  },

  setList: function (list) {
    this._list = list;
  },

  start: function () {
    for (var i = 0; i < this._list.length; i++) {

      var item = this._list[i];
      var layer = item.layer;
      if (!layer) {
        item.loaded = true;
        continue;
      }

      if (item.type == "geojson") {
        item.drawLayer = new GSI.MapToImage.VectorTileLayer(this._map, layer, { opacity: item.opacity, pixelBounds: this.options.pixelBounds });
      }
      if (item.type == "kml") {
        item.drawLayer = new GSI.MapToImage.VectorTileLayer(this._map, layer, { opacity: item.opacity, pixelBounds: this.options.pixelBounds });
      }

      else if (item.type == "geojson_tile") {
        item.drawLayer = new GSI.MapToImage.VectorTileLayer(this._map, layer, { opacity: item.opacity, pixelBounds: this.options.pixelBounds });
      }
      else if (item.type == "geotiff" || item.type == "videooverlay") {
        item.drawLayer = new GSI.MapToImage.OverlayLayer(this._map, layer, { opacity: item.opacity, pixelBounds: this.options.pixelBounds });
      }
      else if ( layer instanceof GSI.ComparePhotoLayer) {
        item.drawLayer = new GSI.MapToImage.TileLayer(this._map, layer._layer, {
          opacity: item.opacity,
          grayscale: item.grayscale,
          blend: item.blend, pixelBounds: this.options.pixelBounds
        });
      }
      else if (item.type == "tile") {

        if (layer instanceof GSI.ReliefTileLayer) {

          item.drawLayer = new GSI.ReliefTileLayer.MapToImageLayer(this._map, layer, {
            opacity: item.opacity,
            grayscale: item.grayscale,
            blend: item.blend, pixelBounds: this.options.pixelBounds
          });
        }
        else {
          item.drawLayer = new GSI.MapToImage.TileLayer(this._map, layer, {
            opacity: item.opacity,
            grayscale: item.grayscale,
            blend: item.blend, pixelBounds: this.options.pixelBounds
          });
        }
      }
      else if (item.type == "system") {
        item.drawLayer = layer;
      }
      else {
        item.loaded = true;
      }
      if (!item.drawLayer) continue;
      item.loaded = false;

    }

    for (var i = 0; i < this._list.length; i++) {

      var item = this._list[i];

      if (!item.drawLayer) continue;

      if (item.drawLayer.on) {
        item.drawLayer.off("loaded").on("loaded", L.bind(this._onLoad, this, item));
      }

      if (item.drawLayer.refreshQueue) {
        item.drawLayer.refreshQueue();
      }

      if (item.drawLayer.load) {
        item.drawLayer.load();
      }
      else
        item.loaded = true;

    }

    if (!this._drawn) this._onLoad({});
  },

  _onLoad: function (item) {

    item.loaded = true;
    var loaded = true;
    for (var i = 0; i < this._list.length; i++) {
      if (!this._list[i].loaded) { loaded = false; break; }
    }
    if (loaded) {
      this._drawn = true;
      this._drawMapImage();
    }
  },

  _drawMapImage: function () {
    var size = (this.options.pixelBounds ? this.options.pixelBounds.getSize() : this._map.getSize());

    size.x = Math.floor(size.x);
    size.y = Math.floor(size.y);

    var imageSize = {
      width: size.x,
      height: size.y
    };

    this._mapCanvas = $("<canvas>").attr({
        "width": size.x,
        "height": size.y
      });
    this._mapTexture = this._mapCanvas[0].getContext("2d");
    this._mapTexture.fillStyle = "rgb(255, 255, 255)";
    this._mapTexture.fillRect(0, 0, size.x, size.y);
    for (var i = this._list.length - 1; i >= 0; i--) {
      if (this._list[i].drawLayer) {
        if (this._list[i].type == "system")
          this._list[i].drawLayer.drawPath(this._mapTexture, this.options.latLngBounds, this.options.pixelBounds);
        else {
          this._list[i].drawLayer.draw(this._mapTexture);
        }
      }
    }
    this._markerPaneToCanvas();

  },

  _drawDIVMarker: function (marker, origin, pixelBounds) {
    var result = false;

    var div = marker.children("div");

    var radius = div.css("border-radius") || div.css("-moz-border-radius") || div.css("-webkit-border-radius");
    if (radius) {
      radius = (radius) ? radius.trim() : '';
      var parts = radius.split(" ");
      if (parts.length > 0)
        radius = parseInt(parts[0]);
      else
        radius = 0;
    }
    else
      radius = 0;

    var left = 0;
    var top = 0;
    //transform: translate3d(1023px, -112px, 0px); opacity: 1;
    if (L.Browser.any3d) {
      var matches = marker[0].style[L.DomUtil.TRANSFORM].match(/([+-]*\d+)[\D]*\,[^+-\d]*([+-]*\d+)[\D]*/);
      if (matches) {
        left = parseFloat(matches[1]) + (origin.x - pixelBounds.min.x);
        top = parseFloat(matches[2]) + (origin.y - pixelBounds.min.y);
      }
    } else {
      left = parseInt(marker[0].style.left) + (origin.x - pixelBounds.min.x);
      top = parseInt(marker[0].style.top) + (origin.y - pixelBounds.min.y);
    }

    var margin = {
      left: 0,
      top: 0
    };

    var opacity = div.css("opacity");
    if (!opacity) opacity = 1;

    if (marker.css("margin-left")) margin.left = parseFloat(marker.css("margin-left"));
    if (marker.css("margin-top")) margin.top = parseFloat(marker.css("margin-top"));
    if (marker.css("margin")) {
      var parts = ((marker.css("margin")) ? marker.css("margin").trim() : '').split(" ");
      if (parts.length > 0) margin.top = parseFloat((parts[0]) ? parts[0].trim() : '');
      if (parts.length > 3) margin.left = parseFloat((parts[3]) ? parts[3].trim() : '');

    }
    if (((div.html()) ? div.html().trim() : '') == '') {

      var bgColor = "#000";
      if (div.css("background-color")) bgColor = div.css("background-color");
      else if (div.css("background")) bgColor = div.css("background");
      var size = {
        w: div.outerWidth(),
        h: div.outerHeight()
      };

      if (radius) {

        this._mapTexture.beginPath();
        this._mapTexture.arc(left, top, size.w / 2, 0, Math.PI * 2, false);
        this._mapTexture.save();
        this._mapTexture.fillStyle = bgColor;
        this._mapTexture.globalAlpha = opacity;
        this._mapTexture.fill();
        this._mapTexture.restore();
      }
      else {
        this._mapTexture.fillStyle = bgColor;
        this._mapTexture.globalAlpha = opacity;
        this._mapTexture.fillRect(left + margin.left, top + margin.top, size.w, size.h);
      }
      result = true;
    }
    else {
      var cssText = (div.prop("style") ? div.prop("style").cssText : "");

      var fontSize = div.css("font-size") || '12px';
      var fontWeight = div.css("font-weight") || '';
      var fontStyle = div.css("font-style") || '';
      var textShadow = div.css("text-shadow") || div.css("-ms-text-shadow") || '';
      if (textShadow) {
        var matches = textShadow.match(/(rgb\([\d\s,]+\))/);
        if (matches) textShadow = matches[1];
        else {
          matches = textShadow.match(/(#[a-f|A-F|\d]+)/);
          if (matches) textShadow = matches[1];
          else textShadow = '';
        };
      }
      else textShadow = '';
      var color = div.css("color") || "#000";
      var fontFamily = div.css("font-family");
      if (!fontFamily || fontFamily == '') fontFamily = "'Meiryo','メイリオ','ヒラギノ角ゴ Pro W3','sans-serif'";
      var text = div.text();
      var transformOrign = div.css("transform-origin");
      var lineHeight = div.css("line-height");
      var transform = div.css("transform")
        || div.css("-moz-transform") || div.css("-o-transform")
        || div.css("-ms-transform") || div.css("-webkit-transform");
      var rotate = 0;
      if (transform) {
        var matches = transform.match(/rotate\((.+?)deg/);
        if (matches) rotate = parseFloat(matches[1]);
        else {
          var matches = cssText.match(/rotate\((.+?)deg/);
          if (matches) rotate = parseFloat(matches[1]);
        }
      }

      var angle90 = div.css("writing-mode")
        || div.css("-moz-writing-mode") || div.css("-o-writing-mode")
        || div.css("-ms-writing-mode") || div.css("-webkit-writing-mode");
      if (angle90) angle90 = (angle90) ? angle90.trim() : '';
      else {
        var matches = cssText.match(/vertical-rl/);
        if (matches) angle90 = "vertical-rl";
      }

      var textAlign = "left";
      var textBaseline = "top";

      if (transformOrign && transformOrign != "") {
        transformOrign = (transformOrign) ? transformOrign.trim() : '';;
        var parts = transformOrign.split(" ");
        if (parts.length == 1) {
          if (parts[0] == "right" || parts[0] == "bottom") {
            textAlign = "right";
            textBaseline = "bottom";
          }
          else if (parts[0] == "center") {

            textAlign = "center";
            textBaseline = "middle";
          }
          else {
            textAlign = "left";
            textBaseline = "top";
          }

        }
        else if (parts.length >= 2) {
          if (parts[0] == "right" || parts[0] == "bottom")
            textAlign = "right";
          else if (parts[0] == "center")
            textAlign = "center";
          else
            textAlign = "left";

          if (parts[1] == "right" || parts[1] == "bottom")
            textBaseline = "bottom";
          else if (parts[1] == "center")
            textBaseline = "middle";
          else
            textBaseline = "top";

        }

      }

      if (lineHeight && lineHeight.match(/px/)) {
        lineHeight = parseFloat(lineHeight);
      }
      else
        lineHeight = null;

      var parts = fontFamily.split(',');
      fontFamily = "";
      for (var k = 0; k < parts.length; k++) {
        fontFamily += (fontFamily == "" ? "" : ",") + "'" + ((parts[k]) ? parts[k].trim() : '').replace(/[\'\"]/g, "") + "'";
      }

      this._mapTexture.font = (fontStyle != "" ? fontStyle + " " : "") + fontWeight + " " + fontSize + " " + fontFamily + "";
      this._mapTexture.globalAlpha = opacity;

      if (angle90 == "mode:tb-rl" || angle90 == "vertical-rl") {
        return this._drawDIVMarkerTategaki(left, top, margin, text, color, textShadow, textAlign, textBaseline, rotate, lineHeight);
      }

      this._mapTexture.textAlign = textAlign;
      this._mapTexture.textBaseline = textBaseline;

      var metrics = this._mapTexture.measureText(text, left + margin.left, top + margin.top);
      var lineWidth = metrics.width;

      if (lineHeight != null) {
        this._mapTexture.textAlign = "top";
        top += (lineHeight / 2);
      }

      if (rotate != 0) {
        this._mapTexture.save();
        this._mapTexture.translate(left + margin.left, top + margin.top);
        this._mapTexture.rotate(rotate * Math.PI / 180);
        if (textShadow && textShadow != '') {
          this._mapTexture.lineWidth = 4;
          this._mapTexture.strokeStyle = textShadow;
          this._mapTexture.strokeText(text, 0, 0);
        }

        this._mapTexture.fillStyle = color;
        this._mapTexture.fillText(text, 0, 0);
        this._mapTexture.restore();
      }
      else {

        var text = div.html();
        text = text.replace(/\<br[\s]*[\/]*\>/ig, "\n");
        text = text.replace(/\<.*\>/ig, "");
        this._mapTexture.save();
        this._mapTexture.rotate(0);

        var bgColor = undefined;
        if (div.css("background-color")) bgColor = div.css("background-color");
        else if (div.css("background")) bgColor = div.css("background");
        var textHeight = this._getTextHeight(text, this._mapTexture);

        var lines = text.split(/\n/g);
        var lineCount = 0;
        lineWidth = 0;
        for (var i = 0; i < lines.length; i++) {
          var line = lines[i];
          if (line == "") continue;
          var w = this._mapTexture.measureText(line).width;
          if (w > lineWidth) lineWidth = w;
          lineCount++;
        }
        this._mapTexture.restore();
        if (bgColor) {
          var textPadding = Math.floor(textHeight / 4);
          this._mapTexture.fillStyle = bgColor;
          this._mapTexture.fillRect(
            left + margin.left,
            top + margin.top - (textPadding),
            lineWidth,
            textHeight * (lineCount) + (textPadding * 2));
        }

        var lineIndex = 0;
        for (var i = 0; i < lines.length; i++) {
          if (lines[i] == "") continue;
          this._mapTexture.save();
          this._mapTexture.translate(left + margin.left, top + margin.top + (lineIndex * textHeight));
          this._mapTexture.textBaseline = textBaseline;
          if (textShadow && textShadow != '') {
            this._mapTexture.lineWidth = 4;
            this._mapTexture.strokeStyle = textShadow;
            this._mapTexture.strokeText(lines[i], 0, 0);
          }
          this._mapTexture.fillStyle = color;
          this._mapTexture.fillText(lines[i], 0, 0);
          this._mapTexture.restore();
          lineIndex++;
        }
      }
      result = true;

    }
    return result;
  },

  _getTextHeight: function (text, texture) {
    var canvas = $("<canvas>")[0];
    canvas.height = 256;

    var ctx = canvas.getContext("2d");

    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.font = texture.font;

    var width = ctx.measureText(text).width + 2;
    canvas.width = width;
    canvas.height = 256;
    ctx = canvas.getContext("2d");
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.font = texture.font;
    var textHeight = this._getTextHeight2(text, ctx, canvas.width, canvas.height) + 4;
    return textHeight;
  },

  _getTextHeight2: function (text, ctx, width, height) {
    ctx.fillText(text, 0, 0);

    var pixels = ctx.getImageData(0, 0, width, height);
    var data = pixels.data;
    var textHeight = 0;
    var maxRow = -1;
    var minRow = height;
    for (var i = 0, len = data.length; i < len; i += 4) {
      var r = data[i], g = data[i + 1], b = data[i + 2], alpha = data[i + 3];
      if (alpha > 0) {
        var row = Math.floor((i / 4) / width);
        if (row > maxRow) {
          maxRow = row;
        }
        if (row < minRow) minRow = row;
      }
    }

    return maxRow;
  },

  _drawDIVMarkerTategaki: function (left, top, margin, text, color, textShadow, textAlign, textBaseline, rotate, lineHeight) {
    var texture = this._mapTexture;
    var canvas = null;

    if (rotate != 0) {
      canvas = document.createElement("canvas");
      texture = canvas.getContext('2d');
      texture.font = this._mapTexture.font;
      texture.globalAlpha = this._mapTexture.globalAlpha;
    }

    var isDrawShadow = !!(textShadow && textShadow != '');
    if (isDrawShadow) {
      texture.lineWidth = 4;
      texture.strokeStyle = textShadow;
    }
    var result = false;
    var metric = texture.measureText("あ");
    var charHeight = metric.width;

    texture.textAlign = "center";
    texture.textBaseline = "top";

    texture.fillStyle = color;
    var x = (!canvas ? left + margin.left : 0) + (charHeight / 2);
    var y = (!canvas ? top + margin.top : 0);
    for (var i = 0; i < text.length; i++) {
      var c = text.charAt(i);

      if (c == "（" || c == "(") {
        c = "(";
        texture.save();
        texture.textBaseline = "middle";
        texture.translate(
          x,
          y + charHeight - texture.measureText(c).width / 2);
        texture.rotate(90 * Math.PI / 180);

        if (isDrawShadow)
          texture.strokeText(c, 0, 0);
        texture.fillText(c, 0, 0);
        texture.restore();
      }
      else if (c == "）" || c == ")") {
        c = ")";
        texture.save();
        texture.textBaseline = "middle";
        texture.translate(x,
          y + charHeight / 2);
        texture.rotate(90 * Math.PI / 180);
        if (isDrawShadow)
          texture.strokeText(c, 0, 0);
        texture.fillText(c, 0, 0);
        texture.restore();
      }
      else {

        texture.save();
        if (isDrawShadow)
          texture.strokeText(c, x, y);
        texture.fillText(c, x, y);

        texture.restore();
      }
      y += charHeight;

    }

    if (canvas) {
      //texture
      this._mapTexture.save();
      this._mapTexture.translate(left + margin.left, top + margin.top);
      this._mapTexture.rotate(rotate * Math.PI / 180);
      this._mapTexture.drawImage(canvas, 0, 0);
      this._mapTexture.restore();
    }

    result = true;
    return result;
  },

  _markerPaneToCanvas: function () {
    var size = (this.options.pixelBounds ? this.options.pixelBounds.getSize() : this._map.getSize());

    size.x = Math.floor(size.x);
    size.y = Math.floor(size.y);

    var markerPane = $(".leaflet-marker-pane").clone();

    var images = markerPane.find("img");

    images.each(function () {
      this.crossOrigin = "anonymous";

      var url = this.src.replace(/cyberjapandata.gsi.go.jp/, "maps.gsi.go.jp");

      if (url.indexOf('//maps.gsi.go.jp/') != -1) {
        url = url.replace('https://', '//');
        url = url.replace('http://', '//');
      }

      this.src = url;
    });

    var origin = this._map.getPixelOrigin();
    var pixelBounds = (this.options.pixelBounds ? this.options.pixelBounds : this._map.getPixelBounds());

    var markers = markerPane.children();
    for (var i = 0; i < markers.length; i++) {
      var marker = $(markers[i]);
      if (marker.prop("tagName") == "DIV" && marker.find("img").length <= 0) {
        // if (this._drawDIVMarker(marker, origin, pixelBounds))
        //   marker.remove();
      }
    }

    if (origin.x - pixelBounds.min.x == 0 && top + (origin.y - pixelBounds.min.y) == 0) {

    } else {
      var elems = markerPane.find("*");

      for (var i = 0; i < elems.length; i++) {
        var el = elems[i];
        var transform = el.style[L.DomUtil.TRANSFORM];
        var left = 0;
        var top = 0;
        if (L.Browser.any3d) {

          var matches = el.style[L.DomUtil.TRANSFORM].match(/([+-]*\d+)[\D]*\,[^+-\d]*([+-]*\d+)[\D]*/);
          if (matches) {
            left = parseFloat(matches[1]);
            top = parseFloat(matches[2]);

            var point = new L.Point(left + (origin.x - pixelBounds.min.x), top + (origin.y - pixelBounds.min.y));
            el.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(point);
          }
        } else {
          el.style.left = parseInt(el.style.left) + (origin.x - pixelBounds.min.x) + "px";
          el.style.top = parseInt(el.style.top) + (origin.y - pixelBounds.min.y) + "px";
        }

      }
    }

    var dummy = $("<div>").addClass("maptoimage-dummy").css({ "z-index": 0, "width": "1px", "height": "1px", "position": "absolute" });
    $("body").append(dummy);

    dummy.append(markerPane);
    var outerthis = this;
    html2canvas(markerPane[0], {
      logging: false,
      userCORS: true,
      allowTaint: false,
      width: size.x,
      height: size.y,
      backgroundColor: "transparent"
    }).then(function(canvas){
      outerthis._onMarkerRendered(canvas);
    });

  },
  _popupPaneToCanvas: function () {
    var size = (this.options.pixelBounds ? this.options.pixelBounds.getSize() : this._map.getSize());

    size.x = Math.floor(size.x);
    size.y = Math.floor(size.y);

    var popupPane = $(".leaflet-popup-pane").clone();

    if (popupPane.children().length <= 0) {
      this._balloonToCanvas();
      return;
    }

    var images = popupPane.find("img");
    images.each(function () {
      this.crossOrigin = "anonymous";
      var url = this.src.replace(/cyberjapandata.gsi.go.jp/, "maps.gsi.go.jp");

      if (url.indexOf('//maps.gsi.go.jp/') != -1) {
        url = url.replace('https://', '//');
        url = url.replace('http://', '//');
      }

    });

    var mapPane = $(".leaflet-map-pane");
    popupPane.find(".leaflet-popup").remove();

    var origin = this._map.getPixelOrigin();
    var pixelBounds = (this.options.pixelBounds ? this.options.pixelBounds : this._map.getPixelBounds());

    if (origin.x - pixelBounds.min.x == 0 && top + (origin.y - pixelBounds.min.y) == 0) {

    } else {
      var elems = popupPane.find("*");

      for (var i = 0; i < elems.length; i++) {
        var el = elems[i];

        if ($(el).hasClass("nomaptoimage")) {
          $(el).remove();
          continue;
        }
        var transform = el.style[L.DomUtil.TRANSFORM];
        var left = 0;
        var top = 0;
        if (L.Browser.any3d) {

          var matches = el.style[L.DomUtil.TRANSFORM].match(/([+-]*[\d\.]+)[\D]*\,[^+-\d]*([+-]*[\d\.]+)[\D]*/);
          if (matches) {
            left = parseFloat(matches[1]);
            top = parseFloat(matches[2]);

            var point = new L.Point(left + (origin.x - pixelBounds.min.x), top + (origin.y - pixelBounds.min.y));
            el.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(point);

          }
        } else {
          left = parseFloat(el.style.left);
          top = parseFloat(el.style.top);
        }

      }
    }

    var dummy = $("<div>").addClass("maptoimage-dummy").css({ "z-index": 0, "width": "1px", "height": "1px", "position": "absolute" });
    $("body").append(dummy);

    dummy.append(popupPane);
    var outerthis = this;
    html2canvas(popupPane[0], {
      logging: false,
      userCORS: true,
      allowTaint: false,
      width: size.x,
      height: size.y,
      backgroundColor: "transparent"
    }).then(function(canvas){
      outerthis._onPopupRendered(canvas);
    });
  },

  _onMarkerRendered: function (canvas) {
    var size = (this.options.pixelBounds ? this.options.pixelBounds.getSize() : this._map.getSize());
    size.x = Math.floor(size.x);
    size.y = Math.floor(size.y);

    this._mapTexture.drawImage(canvas, 0, 0, size.x, size.y,
      0, 0,
      size.x, size.y);
    $(".maptoimage-dummy").remove();

    if (this.options.drawControls)
      this._centerCrossToCanvas();

    this._popupPaneToCanvas();

  },

  _onPopupRendered: function (canvas) {
    var size = (this.options.pixelBounds ? this.options.pixelBounds.getSize() : this._map.getSize());
    size.x = Math.floor(size.x);
    size.y = Math.floor(size.y);
    this._mapTexture.drawImage(canvas, 0, 0, size.x, size.y,
      0, 0,
      size.x, size.y);
    $(".maptoimage-dummy").remove();
    this._balloonToCanvas();

  },

  _balloonToCanvas: function () {
    var size = (this.options.pixelBounds ? this.options.pixelBounds.getSize() : this._map.getSize());
    size.x = Math.floor(size.x);
    size.y = Math.floor(size.y);

    var popupPane = $(".leaflet-popup-pane").clone();
    var baloons = popupPane.find(".leaflet-popup");
    var baloonsOrig = $(".leaflet-popup-pane .leaflet-popup");

    if (baloons.length <= 0) {
      if (this.options.drawControls)
        this._miniMapToCanvas();
      else
        this._scaleToCanvas();
      return;
    }

    var images = popupPane.find("img");
    images.each(function () {
      this.crossOrigin = "anonymous";
      var src = this.src.replace(/cyberjapandata.gsi.go.jp/, "maps.gsi.go.jp");

    });

    this._baloons = [];
    var containerPos = $(this._map.getContainer()).offset();

    if (this.options.pixelBounds) {
      var mapBounds = this._map.getPixelBounds();
      var pixelBounds = this.options.pixelBounds;
      containerPos.top += (pixelBounds.min.y - mapBounds.min.y);
      containerPos.left += (pixelBounds.min.x - mapBounds.min.x);
    }
    for (var i = 0; i < baloons.length; i++) {
      var pos = $(baloonsOrig[i]).offset();
      pos.top -= containerPos.top;
      pos.left -= containerPos.left;

      this._baloons.push(
        {
          elem: baloons[i],
          pos: pos,
          arrowHeight: $(baloonsOrig[i]).find(".leaflet-popup-tip-container .leaflet-popup-tip").outerHeight()
        });
    }

    this._drawNextBalloon();

  },

  _drawNextBalloon: function () {
    var baloon = $(this._baloons[0].elem);

    var closeBtn = baloon.find("a.leaflet-popup-close-button").css({
      position: "absolute",
      top: 0,
      right: 0,
      padding: "4px 4px 0 0",
      "text-align": "center",
      width: "18px",
      height: "14px",
      font: "16px/14px Tahoma, Verdana, sans-serif",
      color: "#c3c3c3",
      "text-decoration": "none",
      "font-weight": "bold",
      background: "transparent"
    }).remove();

    var xx = baloon.find(".leaflet-popup-content-wrapper").remove();
    baloon.find(".leaflet-popup-tip-container").remove();
    xx.removeClass("leaflet-popup-content-wrapper");
    xx.css({'background':'#ffffff','color':'#333','padding':'1px','text-align':'left','border-radius':'12px'});
    baloon.find(".leaflet-popup-tip-container").remove();
    baloon.append(xx);

    var dummy = $("<div>").addClass("maptoimage-dummy").css({ "z-index": 0, "width": "1px", "height": "1px", "position": "absolute" });
    $("body").append(dummy);

    dummy.append(baloon[0]);

    var iframes = dummy.find("iframe");

    for (var i = 0; i < iframes.length; i++) {
      var w = $(iframes[i]).outerWidth();
      var h = $(iframes[i]).outerHeight();

      $(iframes[i]).parent().append($("<div>").css({ width: w + "px", height: h + "px", background: "#333" }));
      $(iframes[i]).hide();
    }

    this._baloons[0].width = baloon.outerWidth();
    this._baloons[0].height = baloon.outerHeight();

    baloon.css({
      "transform": "none",
      "left": 0,
      "top": 0
    });

    var outerthis =this;
    html2canvas(baloon[0], {
      logging: false,
      userCORS: true,
      allowTaint: true,
      width: this._baloons[0].width,
      height: this._baloons[0].height,
      backgroundColor: "transparent"
    }).then(function(canvas){
      outerthis._onBalloonRendered(canvas);
    });
  },

  _onBalloonRendered: function (canvas) {

    this._mapTexture.shadowBlur = 20;
    this._mapTexture.shadowColor = "rgba(0, 0, 0, 0.5)";

    this._mapTexture.drawImage(canvas,
      0, 0,
      this._baloons[0].width, this._baloons[0].height,
      this._baloons[0].pos.left, this._baloons[0].pos.top,
      this._baloons[0].width, this._baloons[0].height);

    this._mapTexture.shadowBlur = 0;
    this._mapTexture.shadowColor = "rgba(0, 0, 0, 0)";

    var pos = {
      x: 0,
      y: 0
    };

    pos.x = this._baloons[0].pos.left + (this._baloons[0].width / 2);
    pos.y = this._baloons[0].pos.top + this._baloons[0].height;

    this._mapTexture.beginPath();
    this._mapTexture.moveTo(
      parseInt(pos.x - 14),
      parseInt(pos.y - 1)
    );

    this._mapTexture.lineTo(
      parseInt(pos.x + 14),
      parseInt(pos.y - 1)
    );

    this._mapTexture.lineTo(
      parseInt(pos.x),
      parseInt(pos.y - 1 + 14)
    );

    this._mapTexture.closePath();
    this._mapTexture.save();
    this._mapTexture.fillStyle = "#fff";
    this._mapTexture.globalAlpha = 1;
    this._mapTexture.fill();
    this._mapTexture.restore();

    $(".maptoimage-dummy").remove();
    this._baloons.shift();

    if (this._baloons.length <= 0) {
      if (this.options.drawControls)
        this._miniMapToCanvas();
      else
        this._scaleToCanvas();

    }
    else
      this._drawNextBalloon();

  },

  _miniMapToCanvas: function () {
    var size = (this.options.pixelBounds ? this.options.pixelBounds.getSize() : this._map.getSize());

    size.x = Math.floor(size.x);
    size.y = Math.floor(size.y);

    if (this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.MINIMAP].obj.getVisible()) {
      var miniMap = this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.MINIMAP].obj.miniMap;
      var tileLayer = new GSI.MapToImage.TileLayer(miniMap._miniMap, miniMap._layer);
      tileLayer.on("loaded", L.bind(this._onMiniMapLoad, this, { tileLayer: tileLayer, miniMap: miniMap }));
      tileLayer.refreshQueue();
      tileLayer.load();

    }
    else
      this._scaleToCanvas();

  },

  _onMiniMapLoad: function (data) {
    var size = data.miniMap._miniMap.getSize();
    var imageSize = {
      width: size.x,
      height: size.y
    };

    var canvas = $("<canvas>").attr({
        "width": size.x,
        "height": size.y
      });
    texture = canvas[0].getContext("2d");
    texture.fillStyle = "rgb(255, 255, 255)";
    texture.fillRect(0, 0, size.x, size.y);

    data.tileLayer.draw(texture);
    var miniMapContainer = $(".leaflet-control-container .leaflet-control-minimap").clone();
    miniMapContainer.empty();

    var dummy = $("<div>").addClass("maptoimage-dummy").css({ "z-index": 0, "width": "1px", "height": "1px", "position": "absolute" });
    $("body").append(dummy);

    dummy.append(miniMapContainer);
    var outerthis = this;
    var canvas2 = canvas[0];
    html2canvas(miniMapContainer[0], {
      logging: false,
      userCORS: true,
      allowTaint: false,
      width: size.x + 4,
      height: size.y + 4
    }).then(function (canvas) {
      var offset = $(outerthis._map.getContainer()).offset();
      var pos = $(".leaflet-control-container .leaflet-control-minimap").offset();
      pos.left -= offset.left;
      pos.top -= offset.top;

      if ($("#footer").is(":visible"))
        pos.top += $("#footer").outerHeight();

      var min = null;
      var max = null;

      for (var i = 0; i < data.miniMap._aimingRect._parts[0].length; i++) {
        if (!min) min = $.extend({}, data.miniMap._aimingRect._parts[0][i]);
        else {
          if (min.x > data.miniMap._aimingRect._parts[0][i].x) min.x = data.miniMap._aimingRect._parts[0][i].x;
          if (min.y > data.miniMap._aimingRect._parts[0][i].y) min.y = data.miniMap._aimingRect._parts[0][i].y;
        }
        if (!max) max = $.extend({}, data.miniMap._aimingRect._parts[0][i]);
        else {
          if (max.x < data.miniMap._aimingRect._parts[0][i].x) max.x = data.miniMap._aimingRect._parts[0][i].x;
          if (max.y < data.miniMap._aimingRect._parts[0][i].y) max.y = data.miniMap._aimingRect._parts[0][i].y;
        }
      }

      var w = max.x - min.x;
      var h = max.y - min.y;
      var texture = canvas2.getContext("2d");
      texture.moveTo(parseInt(size.x / 2 - w / 2), parseInt(size.y / 2 - h / 2));
      texture.lineTo(parseInt(size.x / 2 + w / 2), parseInt(size.y / 2 - h / 2));
      texture.lineTo(parseInt(size.x / 2 + w / 2), parseInt(size.y / 2 + h / 2));
      texture.lineTo(parseInt(size.x / 2 - w / 2), parseInt(size.y / 2 + h / 2));
      texture.closePath();
      texture.save();
      texture.lineWidth = 2;
      texture.strokeStyle = data.miniMap._aimingRect.options.color;
      texture.fillStyle = data.miniMap._aimingRect.options.color;

      texture.globalAlpha = data.miniMap._aimingRect.options.fillOpacity;
      texture.fill();
      texture.globalAlpha = data.miniMap._aimingRect.options.opacity;
      texture.stroke();
      texture.restore();

      outerthis._mapTexture.shadowBlur = 10;
      outerthis._mapTexture.shadowColor = "rgba(0, 0, 0, 0.5)";

      outerthis._mapTexture.drawImage(canvas, pos.left, pos.top);
      outerthis._mapTexture.drawImage(canvas2, pos.left + 2, pos.top + 2);

      $(".maptoimage-dummy").remove();
      outerthis._scaleToCanvas();
    });

  },

  _scaleToCanvas: function (canvas) {
    if (!this.options.drawControls) {
      this._finish();
      return;
    }

    var mapSize = this._map.getSize();
    var scaleBar = $($(".leaflet-control-scale")[0]);

    var size = {
      w: scaleBar.outerWidth(),
      h: scaleBar.outerHeight()
    };

    var offset = $(this._map.getContainer()).offset();
    var pos = scaleBar.offset();
    if ($("#footer").is(":visible"))
      pos.top += $("#footer").outerHeight();
    pos.left = offset.left;
    pos.left = 5;
    pos.top = mapSize.y - size.h - 5;
    size.w -= 2;
    size.h -= 2;

    this._mapTexture.fillStyle = "#fff";
    this._mapTexture.globalAlpha = 0.5;
    this._mapTexture.fillRect(pos.left, pos.top, size.w, size.h);
    if (this._mapTexture.setLineDash !== undefined)
      this._mapTexture.setLineDash([]);
    else if (this._ctx.mozDash !== undefined)
      this._mapTexture.mozDash = [];

    this._mapTexture.beginPath();
    this._mapTexture.moveTo(pos.left, pos.top);
    this._mapTexture.lineTo(pos.left, pos.top + size.h);
    this._mapTexture.lineTo(pos.left + size.w, pos.top + size.h);
    this._mapTexture.lineTo(pos.left + size.w, pos.top);
    this._mapTexture.save();
    this._mapTexture.globalAlpha = 1;
    this._mapTexture.lineWidth = 2;
    this._mapTexture.strokeStyle = "#777";
    this._mapTexture.stroke();

    this._mapTexture.font = "normal 11px 'Lucida Grande','Hiragino Kaku Gothic ProN', 'ヒラギノ角ゴ ProN W3', 'Meiryo', 'メイリオ', 'sans-serif'";

    this._mapTexture.fillStyle = "#333";
    this._mapTexture.textAlign = "left";
    this._mapTexture.textBaseline = "middle";
    this._mapTexture.fillText(scaleBar.text(),
      pos.left + 6, pos.top + size.h / 2);

    this._mapTexture.restore();

    this._finish();

  },

  _centerCrossToCanvas: function () {
    var size = (this.options.pixelBounds ? this.options.pixelBounds.getSize() : this._map.getSize());

    size.x = Math.floor(size.x);
    size.y = Math.floor(size.y);

    if (this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.CENTERCROSS].obj.getVisible()) {
      this._mapTexture.beginPath();

      this._mapTexture.moveTo(parseInt(size.x / 2) - 16, parseInt(size.y / 2));
      this._mapTexture.lineTo(parseInt(size.x / 2) + 16, parseInt(size.y / 2));

      this._mapTexture.moveTo(parseInt(size.x / 2), parseInt(size.y / 2) - 16);
      this._mapTexture.lineTo(parseInt(size.x / 2), parseInt(size.y / 2) + 16);

      this._mapTexture.save();
      this._mapTexture.globalAlpha = 1;

      this._mapTexture.lineWidth = 3;
      this._mapTexture.strokeStyle = "#222";

      this._mapTexture.stroke();

      this._mapTexture.restore();
    }
  },

  _finish: function () {

    this.fire("finish", { canvas: this._mapCanvas });
  }
});

GSI.MapToImage.TileLayer = L.Evented.extend({

  initialize: function (map, layer, options) {
    L.setOptions(this, options);
    this._map = map;
    this._layer = layer;

  },

  _getTileSize: function () {
    var zoom = this._map.getZoom();
    var zoomN = this._layer.options.maxNativeZoom;
    var tileSize = this._layer.options.tileSize;

    if (zoomN && zoom > zoomN) {
      tileSize = Math.round(this._map.getZoomScale(zoom) / this._map.getZoomScale(zoomN) * tileSize);
    }

    return tileSize;
  },

  refreshQueue: function () {
    var bounds = (this.options.pixelBounds ? this.options.pixelBounds : this._map.getPixelBounds());
    var zoom = this._map.getZoom();
    if (zoom > this._layer.options.maxZoom || zoom < this._layer.options.minZoom) {
      return;
    }

    var tileSize = this._getTileSize();

    var tileBounds = L.bounds(
      bounds.min.divideBy(tileSize)._floor(),
      bounds.max.divideBy(tileSize)._floor());
    this._queue = [],
      center = tileBounds.getCenter();

    this._tiles = {};
    var j, i, point;

    for (j = tileBounds.min.y; j <= tileBounds.max.y; j++) {
      for (i = tileBounds.min.x; i <= tileBounds.max.x; i++) {
        point = new L.Point(i, j);
        this._queue.push(point);
        this._tiles[point.x + ":" + point.y] = point;
      }
    }

  },

  _getZoomForUrl: function () {

    var options = this._layer.options,
      zoom = this._map.getZoom();

    if (options.zoomReverse) {
      zoom = options.maxZoom - zoom;
    }

    zoom += options.zoomOffset;

    return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
  },

  _getWrapTileNum: function () {
    var crs = this._map.options.crs;
    var s = crs.scale(this._map.getZoom());
    var size = L.point(s, s);

    return size.divideBy(this._getTileSize())._floor();
  },

  _adjustTilePoint: function (tilePoint) {

    var limit = this._getWrapTileNum();

    // wrap tile coordinates
    if (!this.options.continuousWorld && !this.options.noWrap) {
      tilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;
    }

    tilePoint.z = this._getZoomForUrl();
  },

  load: function () {
    if (!this._queue){
      this.fire('loaded');
      return;
    }

    var zoom = this._getZoomForUrl();
    var tileSize = this._getTileSize();
    var origin = this._map.getPixelOrigin();
    var pixelBounds = (this.options.pixelBounds ? this.options.pixelBounds : this._map.getPixelBounds());
    var loadCounter = 0;

    for (var i = 0; i < this._queue.length; i++) {
      var tilePoint = this._queue[i];

      var tilePoint2 = $.extend({}, tilePoint);

      this._adjustTilePoint(tilePoint2);

      if (this._layer.options.bounds) {
        var
          nwPoint = tilePoint.multiplyBy(tileSize),
          sePoint = nwPoint.add([tileSize, tileSize]),
          nw = this._map.unproject(nwPoint),
          se = this._map.unproject(sePoint);

        if (!this._layer.options.continuousWorld && !this._layer.options.noWrap) {
          nw = nw.wrap();
          se = se.wrap();
        }

        if (!this._layer.options.bounds.intersects([nw, se])) {
          tilePoint._noimage = true;
          delete this._tiles[tilePoint.x + ":" + tilePoint.y];
          continue;
        }
      }

      var tilePos = this._getTilePos(tilePoint2, tileSize);
      tilePos = tilePoint.multiplyBy(tileSize).subtract(origin);
      tilePos.x += (origin.x - pixelBounds.min.x);
      tilePos.y += (origin.y - pixelBounds.min.y);

      tilePoint.img = $("<img>").css({
        width: tileSize + "px",
        height: tileSize + "px"
      }).attr({ "crossorigin": "anonymous" });
      tilePoint.img[0].setAttribute("crossorigin", "anonymous");
      tilePoint.size = tileSize;
      tilePoint.pos = tilePos;
      tilePoint.img.on("load", L.bind(this._onTileLoad, this, tilePoint));
      tilePoint.img.on("error", L.bind(this._onTileLoadError, this, tilePoint));

      var url = this.getTileUrl(tilePoint2);
      if (url.match(/^\/\/maps.gsi.go.jp/i)) {
        url = "https:" + url;
      }
      if (CONFIG.ISPREVIEWSITE && url.match(/^\/maps.gsi.go.jp/i)) {
        url = "https:" + url;
      }

      tilePoint.img.attr({ "src": url });

      loadCounter++;
    }

    if (loadCounter <= 0) {
      this._tileLoaded();
    }
  },

  _tileLoaded: function () {
    var length = 0;
    for (var key in this._tiles) length++;

    if (length <= 0) {
      this.fire("loaded");
    }
  },

  _onTileLoad: function (tilePoint) {
    delete this._tiles[tilePoint.x + ":" + tilePoint.y];
    this._tileLoaded();
  },
  _onTileLoadError: function (tilePoint) {
    tilePoint._noimage = true;
    delete this._tiles[tilePoint.x + ":" + tilePoint.y];
    this._tileLoaded();
  },

  _getSubdomain: function (tilePoint) {
    var index = Math.abs(tilePoint.x + tilePoint.y) % this._layer.options.subdomains.length;
    return this._layer.options.subdomains[index];
  },
  getTileUrl: function (tilePoint) {
    return L.Util.template(this._layer._url.replace(/cyberjapandata.gsi.go.jp/, "maps.gsi.go.jp"), L.extend({
      s: this._getSubdomain(tilePoint),
      z: tilePoint.z,
      x: tilePoint.x,
      y: tilePoint.y
    }, this.options));
  },

  _getTilePos: function (tilePoint, tileSize) {
    var origin = this._map.getPixelOrigin();

    return tilePoint.multiplyBy(tileSize).subtract(origin);
  },

  draw: function (texture) {
    var grayScaleCanvas = null;
    if (!this._queue) return;
    texture.globalAlpha = (this.options.opacity ? this.options.opacity : 1.0);
    for (var i = 0; i < this._queue.length; i++) {
      var tilePoint = this._queue[i];
      if (tilePoint._noimage) continue;

      if (this.options.grayscale) {

        if (!grayScaleCanvas)
          grayScaleCanvas = document.createElement("canvas");
        if (grayScaleCanvas.getContext) {
          grayScaleCanvas.width = Math.ceil(tilePoint.size);
          grayScaleCanvas.height = Math.ceil(tilePoint.size);
          var ctx = grayScaleCanvas.getContext("2d");
          ctx.drawImage(tilePoint.img[0], 0, 0, 256, 256, 0, 0, tilePoint.size, tilePoint.size);
          var imageData = ctx.getImageData(0, 0, tilePoint.size, tilePoint.size);
          pixelData = imageData.data;
          for (var y = 0; y < grayScaleCanvas.height; y++) {
            for (var x = 0; x < grayScaleCanvas.width; x++) {
              // (x,y)ピクセルの明度
              var j = (y * 4 * grayScaleCanvas.width) + (x * 4);

              var R = pixelData[j];
              var G = pixelData[j + 1];
              var B = pixelData[j + 2];

              //グレースケールに変換
              var grayScale = (R * 0.3) + (G * 0.59) + (B * .11);
              pixelData[j] = grayScale;
              pixelData[j + 1] = grayScale;
              pixelData[j + 2] = grayScale;
              //pixelData[j + 3] = 32;
            }
          }
          ctx.putImageData(imageData, 0, 0, 0, 0, imageData.width, imageData.height);

          texture.drawImage(grayScaleCanvas, 0, 0, grayScaleCanvas.width, grayScaleCanvas.height,
            tilePoint.pos.x, tilePoint.pos.y,
            tilePoint.size, tilePoint.size);

        }
      }
      else {
        if (this.options.blend) {
          texture.globalCompositeOperation = "multiply";
          texture.drawImage(tilePoint.img[0], 0, 0, 256, 256,
            tilePoint.pos.x, tilePoint.pos.y,
            tilePoint.size, tilePoint.size);
          texture.globalCompositeOperation = "source-over";
        }
        else {
          texture.drawImage(tilePoint.img[0], 0, 0, 256, 256,
            tilePoint.pos.x, tilePoint.pos.y,
            tilePoint.size, tilePoint.size);

        }
      }
    }
    texture.globalAlpha = 1.0;
  }
});

GSI.MapToImage.OverlayLayer = L.Evented.extend({

  initialize: function (map, layer, options) {
    L.setOptions(this, options);
    this._map = map;
    this._layer = layer;

  },

  load: function () {
    this.fire("loaded");
  },

  draw: function (texture) {
    var image = this._layer.getImage();
    var bounds = this._layer.getBounds();
    var pixelBounds = (this.options.pixelBounds ? this.options.pixelBounds : this._map.getPixelBounds());

    var zoom = this._map.getZoom();

    var imageTopLeft = this._map.project(bounds.getNorthWest(), zoom);
    var imageBottomRight = this._map.project(bounds.getSouthEast(), zoom);

    var topLeft = pixelBounds.getTopLeft();

    var opacity = (this.options.opacity ? this.options.opacity : 1);
    texture.globalAlpha = opacity;
    texture.drawImage(image,
      0, 0, image.width, image.height,
      imageTopLeft.x - topLeft.x, imageTopLeft.y - topLeft.y,
      imageBottomRight.x - imageTopLeft.x, imageBottomRight.y - imageTopLeft.y);

  }
});

GSI.MapToImage.VectorTileLayer = L.Evented.extend({

  initialize: function (map, layer, options) {
    L.setOptions(this, options);
    this._map = map;
    this._layer = layer;

  },

  load: function () {
    this.fire("loaded");
  },

  draw: function (texture) {
    if (this._layer instanceof GSI.VectorTileLayer) {
      var canvasList = $(this._layer._container).find("canvas");
      for (var key in this._layer._tiles) {
        var geoJSON = this._layer._tiles[key].geoJSON;
        if (!geoJSON) continue;
        for (var i = 0; i < geoJSON.length; i++)
          this._drawLayer(texture, geoJSON[i], this._layer._tiles[key]._tilePoint, this._layer.options);
      }
    }

    this._drawLayer(texture, this._layer.geojsonLayer ? this._layer.geojsonLayer : (this._layer.layer ? this._layer.layer : this._layer));
  },
  _drawLayer: function (texture, layer, tilePoint, layerOptions) {
    if (!layer) return;
    if (layer.getLayers) {
      var layers = layer.getLayers();

      for (var i = 0; i < layers.length; i++) {
        this._drawLayer(texture, layers[i], tilePoint, layerOptions);
      }
      return;
    }
    this._drawPath(texture, layer, tilePoint, layerOptions);
  },

  _updateStyle: function (texture, layer) {
    if (!layer._parts && (!layer._radius || !layer._point)) return;
    var options = layer.options;
    if (options.stroke) {
      texture.lineWidth = options.weight;
      texture.strokeStyle = options.color;

      if (options.lineCap &&
        (options.lineCap == "butt" ||
          options.lineCap == "round" ||
          options.lineCap == "square")
      ) {
        texture.lineCap = options.lineCap;
      }
      else
        texture.lineCap = "butt";
      texture.lineJoin = 'round';
    }
    if (options.fill) {
      texture.fillStyle = options.fillColor || options.color;
    }
  },

  _drawPath: function (texture, layer, tilePoint, layerOptions) {

    if (layer.options.visible == false) return;

    var origin = this._map.getPixelOrigin();
    var pixelBounds = (this.options.pixelBounds ? this.options.pixelBounds : this._map.getPixelBounds());
    var options = layer.options;
    var dashArray = null;

    var offset = {
      x: 0,
      y: 0
    };
    var scale = 1;
    if (tilePoint) {
      var zoom = this._map.getZoom();
      var dz = zoom - layerOptions.maxNativeZoom;
      var tileSize = layerOptions.tileSize;
      var tz = zoom;
      if (dz > 0) { tileSize = tileSize * Math.pow(2, dz); tz = tz - dz; }

      offset.x = tilePoint.x * tileSize - pixelBounds.min.x - layerOptions.canvasDx * scale;
      offset.y = tilePoint.y * tileSize - pixelBounds.min.y - layerOptions.canvasDy * scale;
    }
    else {
      offset.x = (origin.x - pixelBounds.min.x);
      offset.y = (origin.y - pixelBounds.min.y);
    }

    if (options.dashArray) {
      if (options.dashArray instanceof Array)
        dashArray = $.extend([], options.dashArray);
      else {
        var dashParts = options.dashArray.split(',');
        dashArray = [];
        for (var i = 0; i < dashParts.length; i++) {
          dashArray.push(parseInt(dashParts[i]));
        }
      }
      if (dashArray.length < 2) dashArray = null;
    }

    if (!layer._parts) {

      if (layer._radius && layer._point) {
        var p = layer._point;
        texture.beginPath();
        texture.arc(
          (scale * p.x) + offset.x,
          (scale * p.y) + offset.y,
          layer._radius, 0, Math.PI * 2, false);
        texture.closePath();

        texture.save();

        this._updateStyle(texture, layer);
        var opacity = (this.options.opacity ? this.options.opacity : 1);

        if (layer.options.fill) {
          texture.globalAlpha = (layer.options.fillOpacity || layer.options.fillOpacity == 0 ? layer.options.fillOpacity : 0) * opacity;
          texture.fill();
        }
        if (layer.options.stroke) {
          texture.globalAlpha = (layer.options.opacity || layer.options.opacity == 0 ? layer.options.opacity : 1);
          texture.stroke();
        }
        texture.restore();
      }
    }
    else {

      var i, j, len2, point, drawMethod;
      var vp = this._map._pathViewport;

      var isPolygon = (layer instanceof L.Polygon || layer instanceof L.Circle);

      var parts = (layer._rings ? layer._rings : layer._parts);
      var len = parts.length;
      var buffTexture = null;
      var canvas = null;

      var isMultiPolygon = false;

      if (isPolygon) {
        if (layer.feature && layer.feature.geometry.type == "MultiPolygon") {
          isMultiPolygon = true;
        }
      }

      if (isMultiPolygon) {

        for (i = 0; i < len; i++) {

          if (L.LineUtil.isFlat(parts[i])) {
            this._drawPolygonPath(texture, layer, isPolygon, [parts[i]], offset, scale, dashArray);
          } else {

            if (parts[i].length > 1) {
              buffTexture = texture;
              canvas = document.createElement("canvas");
              canvas.width = texture.canvas.width;
              canvas.height = texture.canvas.height;

              texture = canvas.getContext("2d");
            }
            this._drawPolygonPath(texture, layer, isPolygon, parts[i], offset, scale, dashArray);

            if (buffTexture) {

              buffTexture.drawImage(canvas, 0, 0, canvas.width, canvas.height);

              delete texture;
              texture = buffTexture;

            }
          }
        }
      } else {

        if (len > 1) {
          buffTexture = texture;
          canvas = document.createElement("canvas");
          canvas.width = texture.canvas.width;
          canvas.height = texture.canvas.height;

          texture = canvas.getContext("2d");
        }
        this._drawPolygonPath(texture, layer, isPolygon, parts, offset, scale, dashArray);
        if (buffTexture) {

          buffTexture.drawImage(canvas, 0, 0, canvas.width, canvas.height);

          delete texture;
          texture = buffTexture;

        }
      }

    }
  },

  _drawPolygonPath: function (texture, layer, isPolygon, parts, offset, scale, dashArray) {

    var len2 = 0;
    var i = 0;
    var j = 0;
    var len = parts.length;
    var point = null;

    for (i = 0; i < len; i++) {

      var fromPoint = null;
      var firstPoint = null;
      var lastPoint = null;

      if (parts[i].length > 2 &&
        (parts[i][0].x != parts[i][parts[i].length - 1].x || parts[i][0].y != parts[i][parts[i].length - 1].y)) {
        lastPoint = parts[i][0];
      }

      texture.beginPath();

      for (j = 0, len2 = parts[i].length; j < len2; j++) {

        point = parts[i][j];

        var toPoint = {
          x: (scale * point.x) + offset.x,
          y: (scale * point.y) + offset.y
        };

        if (j == 0) {
          firstPoint = toPoint;
          texture.moveTo(toPoint.x, toPoint.y);
        }
        else {
          if (dashArray && !isPolygon)
            GSI.Utils.dotLineTo(texture, fromPoint.x, fromPoint.y,
              toPoint.x, toPoint.y, dashArray);
          else {
            if (texture.setLineDash !== undefined)
              texture.setLineDash([]);
            else if (texture.mozDash !== undefined)
              texture.mozDash = [];
            texture.lineTo(toPoint.x, toPoint.y);
          }
        }

        fromPoint = toPoint;
      }

      if (lastPoint && isPolygon) {

        var toPoint = {
          x: (scale * lastPoint.x) + offset.x,
          y: (scale * lastPoint.y) + offset.y
        };
        if (texture.setLineDash !== undefined)
          texture.setLineDash([]);
        else if (texture.mozDash !== undefined)
          texture.mozDash = [];
        texture.lineTo(toPoint.x, toPoint.y);
      }
      if (isPolygon) {
        texture.closePath();
      }

      texture.save();

      if (isPolygon && i > 0) {
        texture.globalCompositeOperation = 'destination-out';
        texture.globalAlpha = 1;
        texture.fill();
        texture.globalCompositeOperation = 'source-over';
      }

      this._updateStyle(texture, layer);
      var opacity = (this.options.opacity ? this.options.opacity : 1);

      if (i == 0 && layer.options.fill) {
        texture.globalAlpha = (layer.options.fillOpacity || layer.options.fillOpacity == 0 ? layer.options.fillOpacity : 0) * opacity;
        texture.fill();
      }
      if (layer.options.stroke) {
        texture.globalAlpha = (layer.options.opacity || layer.options.opacity == 0 ? layer.options.opacity : 1);
        texture.stroke();
      }
      texture.restore();

    }
  }
});

GSI.MapToImageWindow = L.Evented.extend({

  initialize: function (map, options) {
    L.setOptions(this, options);
    this._map = map;
  },

  show: function (f) {
    if (!this._blind) {
      this._blind = $("<div>").addClass("window_blind");
      this._msg = $("<div>").css({
        "position": "absolute",
        "left": "50%",
        "top": "50%",
        "margin-left": "-90px",
        "padding-left": "34px",
        "display": "none",
        "color": "#fff",
        "z-index": 999999,
        "line-height": "32px",
        "background-image": "url(image/system/loading002.gif)",
        "background-position": "0px 50%",
        "background-repeat": "no-repeat"
      }).html("画像を生成しています");
      $("body").append(this._blind).append(this._msg);
    }

    this._blind.fadeIn(300);
    this._msg.fadeIn(300, f);

  },

  _makeWorldFileText: function () {
    var size = (this.options.pixelBounds ? this.options.pixelBounds.getSize() : this._map.getSize());

    var bounds = (this.options.pixelBounds ? this.options.latLngBounds : this._map.getBounds());

    var project = function (latlng) { // (LatLng) -> Point
      var MAX_LATITUDE = 85.0511287798;
      var d = L.LatLng.DEG_TO_RAD,
        max = MAX_LATITUDE,
        lat = Math.max(Math.min(max, latlng.lat), -max),
        x = latlng.lng * d,
        y = lat * d;

      y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));

      return new L.Point(x, y);
    };

    var northWest = project(
      bounds.getNorthWest()
    );
    var southEast = project(
      bounds.getSouthEast()
    );

    var lt = {
      lng: northWest.x * 6378137.0,
      lat: northWest.y * 6378137.0
    };
    var rb = {
      lng: southEast.x * 6378137.0,
      lat: southEast.y * 6378137.0
    };
    var txt = "";
    txt += ((rb.lng - lt.lng) / size.x) + "\n";
    txt += "0\n";
    txt += "0\n";
    txt += -((rb.lng - lt.lng) / size.x) + "\n";
    txt += lt.lng + "\n";
    txt += lt.lat;
    return txt;
  },

  getDownloadImageCanvas: function () {

    var size = {
      x: parseInt(this._canvas.width),
      y: parseInt(this._canvas.height)
    };

    var result = $("<canvas>")
      .attr({
        "width": size.x,
        "height": size.y
      })[0];
    var ctx = result.getContext('2d');

    var src = this._canvas.getContext('2d').getImageData(0, 0, size.x, size.y);
    ctx.putImageData(src, 0, 0);

    if (this._drawCreditCheck.is(":checked")) {
      var text = "地理院地図";
      ctx.font = "normal 21px 'メイリオ','ヒラギノ角ゴ Pro W3'";

      ctx.strokeStyle = '#000';
      ctx.lineWidth = 4;
      ctx.lineJoin = 'round';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'bottom';

      ctx.globalAlpha = 0.8;
      ctx.strokeText(text, size.x - 6, size.y - 6);
      ctx.globalAlpha = 1;
      ctx.fillText(text, size.x - 6, size.y - 6);
    }

    if (this._drawScalelineCheck.is(":checked")
    && $('#gsi_maptoimage_scaleline_check_div').css("display") != "none"
    && ($('#gsi_maptoimagedialog_modeselect_area').is(":checked") || $('#gsi_maptoimagedialog_modeselect_size').is(":checked"))) {
      var area = $('.leaflet-control-scale.leaflet-control');
      var text = $('.leaflet-control-scale-line').text();

      ctx.strokeStyle = "#777";
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.moveTo(5, size.y -22);
      ctx.lineTo(5, size.y -7);
      ctx.lineTo(3 + area.width(), size.y -7);
      ctx.lineTo(3 + area.width(), size.y -22);
      ctx.stroke();

      ctx.globalAlpha = 0.5;
      ctx.fillStyle = "#fff";
      ctx.fillRect(6, size.y -22, area.width() - 4, area.height() - 3);

      ctx.font = "normal 11px 'メイリオ','ヒラギノ角ゴ Pro W3'";
      ctx.fillStyle = "#333";
      ctx.globalAlpha = 1;
      ctx.lineWidth = 0.5;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      ctx.fillText(text, 10, size.y - 9);
    }

    return result;

  },

  setCanvas: function (canvas) {
    this._canvas = canvas;
    this._worldFileText = this._makeWorldFileText();

    this._msg.hide();
    this._fileName = 'img' + GSI.Utils.getTimeStampString();

    if (!this._frame) {
      this._frame = $("<div>").addClass("gsi_maptoimage_window");

      this._text = $("<div>").addClass("gsi_maptoimage_window_text").html(GSI.TEXT.MAPTOIMAGE.WINDOW_MSG);
      this._frame.append(this._text);

      this._closeBtn = $("<a>").addClass("close_btn").attr({ "href": "javascript:void(0);" }).html("×").on('click',L.bind(function () { this.hide(); }, this));
      this._frame.append(this._closeBtn);

      var checkFrame = $("<div>").addClass("gsi_maptoimage_window_check_frame");

      var id = 'gsi_maptoimage_credit_check';
      var fDiv =$('<div>');
      this._drawCreditCheck = $("<input>").addClass("normalcheck").attr({ "type": "checkbox", "id": id }).prop({ "checked": "checked" });

      var label = $("<label>").attr({ "for": id }).html("画像に「地理院地図」クレジットを表示");

      var sId = 'gsi_maptoimage_scaleline_check';
      var sDiv =$('<div>').attr({"id": sId + "_div"}).css("display","none");
      if ($('#gsi_maptoimagedialog_modeselect_area').is(":checked") || $('#gsi_maptoimagedialog_modeselect_size').is(":checked")){
        sDiv.css("display","");
      }
      this._drawScalelineCheck = $("<input>").addClass("normalcheck").attr({ "type": "checkbox", "id": sId }).prop({ "checked": "checked" });

      var sLabel = $("<label>").attr({ "for": sId }).html("画像にスケールバーを表示");

      fDiv.append(this._drawCreditCheck);
      fDiv.append(label);
      checkFrame.append(fDiv);
      sDiv.append(this._drawScalelineCheck);
      sDiv.append(sLabel);
      checkFrame.append(sDiv);

      this._frame.append(checkFrame);

      var buttonFrame = $("<div>").addClass("gsi_maptoimage_window_button_frame");
      this._dlImageButton = $("<a>").attr({ "href": "javascript:void(0);" }).html(GSI.TEXT.MAPTOIMAGE.WINDOW_SAVEIMGBTN).on('click',L.bind(function () {
        var canvas = this.getDownloadImageCanvas();

        GSI.Utils.saveFile("image/png", this._fileName + ".png", this._makeImage(canvas.toDataURL()));

      }, this));
      this._dlWorldButton = $("<a>").attr({ "href": "javascript:void(0);" }).html(GSI.TEXT.MAPTOIMAGE.WINDOW_SAVEPGWBTN).on('click',L.bind(function () {

        var blob = new Blob([this._worldFileText], { "type": "text/plain" })

        GSI.Utils.saveFile("text/plain", this._fileName + ".pgw", blob);

      }, this));
      buttonFrame.append(this._dlImageButton).append(this._dlWorldButton);

      var messageFrame = $("<div>").addClass("gsi_maptoimage_window_text2").html(GSI.TEXT.MAPTOIMAGE.WINDOW_MSG2);

      this._dlWorldMessage = messageFrame.find(".worldfile-msg");

      this._frame.append(buttonFrame);
      this._frame.append(messageFrame);

      $("body").append(this._frame);
    }

    if ( this.options.disableWorldFile ) {
      this._dlWorldButton.hide();
      this._dlWorldMessage.hide();
    } else {
      this._dlWorldButton.show();
      this._dlWorldMessage.show();
    }

    this._blind.fadeIn(200);
    this._frame.fadeIn(200);

  },

  _makeImage: function (v) {
    var o = null;
    var base64 = v.split(',');
    if (base64.length > 1) {
      var data = window.atob(base64[1]);
      var data_n = data.length;
      if (data_n > 0) {
        var data_buff = new ArrayBuffer(data_n);
        var data_blob = new Uint8Array(data_buff);

        var i = 0;

        for (i = 0; i < data_n; i++) {
          data_blob[i] = data.charCodeAt(i);
        }
        o = new Blob([data_blob], { type: 'image/png' });
      }
    }
    return o;
  },

  hide: function () {
    if (this._frame) this._frame.fadeOut(200);
    if (this._blind) this._blind.fadeOut(200);
  }
});

/*************************************************
 L.TileLayer boundsのバグ修正
*************************************************/
L.TileLayer.prototype._tileShouldBeLoaded = function (tilePoint) {
  if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
    return false; // already loaded
  }

  var options = this.options;

  if (!options.continuousWorld) {
    var limit = this._getWrapTileNum();

    // don't load if exceeds world bounds
    if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||
      tilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }
  }

  if (options.bounds) {
    var tileSize = this._getTileSize(), //options.tileSize,
      nwPoint = tilePoint.multiplyBy(tileSize),
      sePoint = nwPoint.add([tileSize, tileSize]),
      nw = this._map.unproject(nwPoint),
      se = this._map.unproject(sePoint);

    // TODO temporary hack, will be removed after refactoring projections
    // https://github.com/Leaflet/Leaflet/issues/1618
    if (!options.continuousWorld && !options.noWrap) {
      nw = nw.wrap();
      se = se.wrap();
    }

    if (!options.bounds.intersects([nw, se])) { return false; }
  }

  return true;
};

/*************************************************
 距離の計算
*************************************************/
GSI.Utils.DistanceCalculator = {};
GSI.Utils.DistanceCalculator.calc = function (from, to) {
  try {
    var PI = 3.14159265358979;
    var params = {};

    // ラジアンへ
    params.phi1 = from.lat * PI / 180;
    params.lamb1 = from.lng * PI / 180; if (params.lamb1 < 0) params.lamb1 += PI * 2;
    params.phi2 = to.lat * PI / 180;
    params.lamb2 = to.lng * PI / 180; if (params.lamb2 < 0) params.lamb2 += PI * 2;

    // 計算
    params.lamb = params.lamb2 - params.lamb1;
    if (params.lamb > PI) params.lamb -= PI * 2;
    else if (params.lamb < -PI) params.lamb += PI * 2;

    if (params.lamb >= 0) params.seihan = 0;
    else if (params.lamb < 0) {
      params.seihan = 1;
      params.lamb = Math.abs(params.lamb);
    }

    // 楕円体原子 GRS80
    var daen = 2;
    var a = 6378137;
    var rf = 298.257222101;
    params.f = 1. / rf;

    params.a = a;
    params.lambd = PI - params.lamb;
    if (params.seihan == 0) {
      params.delta = params.phi2 - params.phi1;
      params.sigma = params.phi1 + params.phi2;
      params.u1 = Math.atan((1 - params.f) * Math.tan(params.phi1));
      params.u2 = Math.atan((1 - params.f) * Math.tan(params.phi2));
    }
    else if (params.seihan == 1) {
      params.delta = params.phi1 - params.phi2;
      params.sigma = params.phi1 + params.phi2;
      params.u1 = Math.atan((1 - params.f) * Math.tan(params.phi2));
      params.u2 = Math.atan((1 - params.f) * Math.tan(params.phi1));
    }

    params.sigmad = params.u1 + params.u2;
    params.deltad = params.u2 - params.u1;
    params.xi = Math.cos(params.sigmad / 2.);
    params.xid = Math.sin(params.sigmad / 2.);
    params.eta = Math.sin(params.deltad / 2.);
    params.etad = Math.cos(params.deltad / 2.);
    params.x = Math.sin(params.u1) * Math.sin(params.u2);
    params.y = Math.cos(params.u1) * Math.cos(params.u2);
    params.c__ = params.y * Math.cos(params.lamb) + params.x;
    params.d__1 = 1 - params.f;
    params.ep = params.f * (2 - params.f) / (params.d__1 * params.d__1);
    var zoneInfo = {
      zone: 0,
      theta: null
    };

    var dms2r = GSI.Utils.DistanceCalculator._dms2r;

    // Zoneの判断
    if (params.c__ >= 0) {
      zoneInfo.zone = 1;
      zoneInfo.theta = params.lamb * (params.f * params.y + 1);
    }
    else if (params.c__ < 0 && params.c__ >= -Math.cos(dms2r(PI, 30000) * Math.cos(params.u1))) {
      zoneInfo.zone = 2;
      zoneInfo.theta = params.lambd;
    }
    else if (params.c__ < -Math.cos(dms2r(PI, 30000) * Math.cos(params.u1))) {
      zoneInfo.zone = 3;
      GSI.Utils.DistanceCalculator._zone3(PI, params, zoneInfo);
    }

    params.theta = zoneInfo.theta;

    var distance = 0;
    if (zoneInfo.zone >= 1 && zoneInfo.zone <= 321) {
      distance = GSI.Utils.DistanceCalculator._zone1(PI, params, zoneInfo);
    }
    else if (zoneInfo.zone == 322) {
      distance = GSI.Utils.DistanceCalculator._zone322(PI, params, zoneInfo);
    }
    else if (zoneInfo.zone == 323) {
      distance = GSI.Utils.DistanceCalculator._zone323(PI, params, zoneInfo);
    }
  }
  catch (ex) {
    console.log(ex);
  }

  return distance;
};

GSI.Utils.DistanceCalculator._dms2r = function (PI, dms) {
  var dd, mm, ss, deg, hugou;

  if (dms > 0) {
    hugou = 1.;
  } else if (dms < 0) {
    hugou = -1;
  }
  dd = parseFloat(parseInt(Math.abs(dms) / 10000));
  mm = parseFloat(parseInt((Math.abs(dms) - dd * 10000) / 100));
  ss = Math.abs(dms) - dd * 10000 - mm * 100;
  deg = hugou * (dd + mm / 60 + ss / 3600);
  return deg * PI / 180.;
};

GSI.Utils.DistanceCalculator._zone1 = function (PI, params, zoneInfo) {
  var d__1, d__2, d__3, d__4, d__5;

  var zero_ = function (a) {
    if (Math.abs(a) < 1e-14) return 1e-14;
    else return a;
  };
  /* Local variables */
  var g, h__;
  var i__;
  var n0, aa, bb, dd, ee, ff, gg, jj, kk, zeta;
  //extern doublereal zero_(doublereal *);
  var dalp2, alpha, zetad, alpha2, sgamma, rgamma;
  //extern /* Subroutine */ int hanten_(void);
  var ssigma;
  //extern /* Subroutine */ int handan1_(void), handan2_(void);

  /*     θの計算 */
  for (i__ = 1; i__ <= 100; ++i__) {
    if (zoneInfo.zone == 1) {
      d__1 = params.eta;
      d__2 = Math.cos(params.theta / 2.);
      d__3 = params.xi;
      d__4 = Math.sin(params.theta / 2.);
      g = Math.sqrt(d__1 * d__1 * (d__2 * d__2) + d__3 * d__3 * (d__4 * d__4));
      d__1 = params.etad;
      d__2 = Math.cos(params.theta / 2.);
      d__3 = params.xid;
      d__4 = Math.sin(params.theta / 2.);
      h__ = Math.sqrt(d__1 * d__1 * (d__2 * d__2) + d__3 * d__3 * (d__4 * d__4));
    }
    else {
      d__1 = params.eta;
      d__2 = Math.sin(params.theta / 2.);
      d__3 = params.xi;
      d__4 = Math.cos(params.theta / 2.);
      g = Math.sqrt(d__1 * d__1 * (d__2 * d__2) + d__3 * d__3 * (d__4 * d__4));
      d__1 = params.etad;
      d__2 = Math.sin(params.theta / 2.);
      d__3 = params.xid;
      d__4 = Math.cos(params.theta / 2.);
      h__ = Math.sqrt(d__1 * d__1 * (d__2 * d__2) + d__3 * d__3 * (d__4 * d__4));
    }
    ssigma = Math.atan(g / zero_(h__)) * 2;
    jj = g * 2 * h__;
    d__1 = h__;
    d__2 = g;
    kk = d__1 * d__1 - d__2 * d__2;
    sgamma = params.y * Math.sin(params.theta) / zero_(jj);
    d__1 = sgamma;
    rgamma = 1 - d__1 * d__1;
    zeta = rgamma * kk - params.x * 2;
    zetad = zeta + params.x;
    d__1 = params.f;
    dd = params.f * 0.25 * (params.f + 1) - d__1 * d__1 * 0.1875 * rgamma;
    d__1 = zeta;
    d__2 = rgamma;
    ee = (1 - dd * rgamma) * params.f * sgamma * (ssigma + dd * jj * (
      zeta + dd * kk * (d__1 * d__1 * 2 - d__2 * d__2)));
    if (zoneInfo.zone == 1) {
      ff = params.theta - params.lamb - ee;
    }
    else {
      ff = params.theta - params.lambd + ee;
    }
    if (Math.abs(ff) < 1e-14) {
      break;
    }
    d__1 = sgamma;
    d__2 = sgamma;
    d__3 = params.f;
    gg = params.f * (d__1 * d__1) * (1 - dd * 2 * rgamma) + params.f *
      zetad * (ssigma / zero_(jj)) * (1 - dd * rgamma + params.f *
        0.5 * (d__2 * d__2)) + d__3 * d__3 * 0.25 * zeta * zetad;
    d__1 = 1 - gg;
    params.theta -= ff / zero_(d__1);
  }

  /*     方位角の計算(zone=[1],[2,31,321]) */

  if (zoneInfo.zone == 1) {
    alpha = Math.atan(params.xi * Math.tan(params.theta / 2.) / zero_(params.eta));
    dalp2 = Math.atan(params.xid * Math.tan(params.theta / 2.) / zero_(params.etad));
  }
  else {
    alpha = Math.atan(params.etad * Math.tan(params.theta / 2.) / zero_(params.xid));
    dalp2 = Math.atan(params.eta * Math.tan(params.theta / 2.) / zero_(params.xi));
  }
  if (alpha <= -1e-14 && params.lamb > 0.) {
    alpha += PI;
  }
  else if (alpha >= 1e-14 && params.lamb < 0.) {
    alpha += PI;
  }
  else if (alpha <= -1e-14 && params.lamb < 0.) {
    alpha += PI * 2;
  }

  var result = {};

  result.alpha1 = alpha - dalp2;
  if (zoneInfo.zone == 1) {
    alpha2 = alpha + dalp2;
  } else {
    alpha2 = PI - alpha - dalp2;
  }
  result.alp21 = PI + alpha2;
  if (result.alp21 < 0) {
    result.alp21 += PI * 2;
  } else if (result.alp21 >= PI * 2) {
    result.alp21 -= PI * 2;
  }

  if (Math.abs(params.lamb) < 1e-14) {
    GSI.Utils.DistanceCalculator._handan1(PI, params, zoneInfo, result);
  }
  if ((d__1 = Math.abs(params.lamb) - PI, Math.abs(d__1)) < 1e-14) {
    GSI.Utils.DistanceCalculator._handan2(PI, params, zoneInfo, result);
  }

  GSI.Utils.DistanceCalculator._hanten(PI, params, zoneInfo, result);

  /*     測地線長の計算(zone=[1],[2,31,321]) */
  d__1 = Math.sqrt(params.ep * rgamma + 1) + 1;
  n0 = params.ep * rgamma / (d__1 * d__1);
  d__1 = n0;
  aa = (n0 + 1) * (d__1 * d__1 * 1.25 + 1);
  d__1 = n0;
  d__2 = Math.sqrt(params.ep * rgamma + 1) + 1;
  bb = params.ep * (1 - d__1 * d__1 * .375) / (d__2 * d__2);
  d__1 = rgamma;
  d__2 = zeta;
  d__3 = kk;
  d__4 = rgamma;
  d__5 = zeta;
  result.s = (1 - params.f) * params.a * aa * (ssigma - bb * jj * (zeta -
    bb * .25 * (kk * (d__1 * d__1 - d__2 * d__2 * 2) - bb *
      0.16666666666666666 * zeta * (1 - d__3 * d__3 * 4) * (d__4 * d__4 *
        3 - d__5 * d__5 * 4))));
  return result.s;
};

GSI.Utils.DistanceCalculator._zone3 = function (PI, params, zoneInfo) {
  var d__1, d__2, d__3, d__4;

  d__1 = Math.cos(params.u1);
  d__2 = Math.sin(params.u1);
  d__3 = params.f;
  d__4 = Math.sin(params.u1), d__4 *= d__4;
  zoneInfo.rr = params.f * PI * (d__1 * d__1) * (1 - params.f * 0.25
    * (params.f + 1) * (d__2 * d__2) + d__3 * d__3 * 0.1875 * (d__4 *
      d__4));
  zoneInfo.d1 = params.lambd * Math.cos(params.u1) - zoneInfo.rr;
  zoneInfo.d2 = Math.abs(params.sigmad) + zoneInfo.rr;
  zoneInfo.q = params.lambd / (params.f * PI);
  zoneInfo.f1 = params.f * .25 * (params.f * .5 + 1);

  d__1 = zoneInfo.q;
  zoneInfo.gamma0 = zoneInfo.q + zoneInfo.f1 * zoneInfo.q - zoneInfo.f1 * (d__1 * (d__1 * d__1));
  if (Math.abs(params.sigma) >= 1e-14) {
    zoneInfo.zone = 31;
    GSI.Utils.DistanceCalculator._zone31(PI, params, zoneInfo);
  }
  else if (Math.abs(params.sigma) < 1e-14) {
    zoneInfo.zone = 32;
    GSI.Utils.DistanceCalculator._zone32(PI, params, zoneInfo);
  }
  return 0;
}

GSI.Utils.DistanceCalculator._zone31 = function (PI, params, zoneInfo) {
  var d__1, d__2, d__3;

  var j, k, j1, aa0, bb0, psi, psid;
  var psidd;

  var zero_ = function (a) {
    if (Math.abs(a) < 1e-14) return 1e-14;
    else return a;
  };

  aa0 = Math.atan(zoneInfo.d1 / zero_(zoneInfo.d2));
  d__2 = zoneInfo.d1;
  d__3 = zoneInfo.d2;
  d__1 = Math.sqrt(d__2 * d__2 + d__3 * d__3);
  bb0 = Math.asin(zoneInfo.rr / zero_(d__1));
  psi = aa0 + bb0;
  d__1 = Math.cos(params.u1);
  j = zoneInfo.gamma0 / zero_(d__1);
  k = (zoneInfo.f1 + 1) * Math.abs(params.sigmad) * (1 - params.f * params.y) / (params.f * PI * zero_(params.y));
  d__1 = cos(psi);
  j1 = j / (k / zero_(d__1) + 1);
  psid = Math.asin(j1);
  d__1 = Math.cos(params.u2);
  psidd = Math.asin(Math.cos(params.u1) / zero_(d__1) * j1);
  d__1 = Math.cos(params.deltad / 2.0);
  params.theta = Math.atan(Math.tan((psid + psidd) / 2.0) * Math.sin(Math.abs(params.sigmad) / 2.0) / zero_(d__1)) * 2;
  return 0;
};

GSI.Utils.DistanceCalculator._zone32 = function (PI, params, zoneInfo) {
  if (zoneInfo.d1 >= 1e-14) {
    zoneInfo.zone = 321;
    GSI.Utils.DistanceCalculator._zone321(PI, params, zoneInfo);
  } else if (abs(zoneInfo.d1) < 1e-14) {
    zoneInfo.zone = 322;
  } else if (zoneInfo.d1 <= -1e-14) {
    zoneInfo.zone = 323;
  }
  return 0;
};

GSI.Utils.DistanceCalculator._zone321 = function (PI, params, zoneInfo) {
  params.theta = params.lambd;
  return 0;
};

/*************************************************
 Zone3(b2)における方位角，距離の計算
*************************************************/
GSI.Utils.DistanceCalculator._zone322 = function (PI, params, zoneInfo) {
  var d__1;
  var n0, aa, alpha2, rgamma;
  var result = {};

  result.alpha1 = PI / 2.;
  alpha2 = PI / 2.;
  result.alp21 = PI * 1.5;
  GSI.Utils.DistanceCalculator._hanten(PI, params, zoneInfo, result);
  d__1 = Math.sin(params.u1);
  rgamma = d__1 * d__1;
  d__1 = Math.sqrt(params.ep * rgamma + 1) + 1;
  n0 = params.ep * rgamma / (d__1 * d__1);
  d__1 = n0;
  aa = (n0 + 1) * (d__1 * d__1 * 1.25 + 1);
  result.s = (1 - params.f) * params.a * aa * PI;
  return result.s;
};

/*************************************************
 Zone3(b3)における方位角，距離の計算
*************************************************/
GSI.Utils.DistanceCalculator._zone323 = function (PI, params, zoneInfo) {
  var d__1;
  var i__;
  var m, n, w, n0, aa, dd, alpha2, rgamma, sgamma;
  for (i__ = 1; i__ <= 100; ++i__) {
    d__1 = zoneInfo.gamma0;
    rgamma = 1 - d__1 * d__1;
    d__1 = params.f;
    dd = params.f * .25 * (params.f + 1) - d__1 * d__1 * 0.1875 * rgamma;
    sgamma = zoneInfo.q / (1 - dd * rgamma);
    if ((d__1 = zoneInfo.gamma0 - sgamma, Math.abs(d__1)) < 1e-14) {
      break;
    }
    zoneInfo.gamma0 = sgamma;
  }
  m = 1 - zoneInfo.q / cos(params.u1);
  n = dd * rgamma / (1 - dd * rgamma);
  w = m - n + m * n;
  var result = {};

  if (w <= 0.) {
    result.alpha1 = PI / 2.0;
  } else {
    result.alpha1 = PI / 2.0 - Math.asin(Math.sqrt(w / 2.0)) * 2;
  }
  alpha2 = PI - result.alpha1;
  result.alp21 = PI + alpha2;
  GSI.Utils.DistanceCalculator._hanten(PI, params, zoneInfo, result);
  d__1 = Math.sqrt(params.ep * rgamma + 1) + 1;
  n0 = params.ep * rgamma / (d__1 * d__1);
  d__1 = n0;
  aa = (n0 + 1) * (d__1 * d__1 * 1.25 + 1);
  result.s = (1 - params.f) * params.a * aa * PI;
  return result.s;
};

/*************************************************
 経度差0度の方位角の判断
*************************************************/
GSI.Utils.DistanceCalculator._handan1 = function (PI, params, zoneInfo, result) {
  if (params.delta >= 0.) {
    result.alpha1 = 0.;
    result.alp21 = PI;
  } else if (params.delta < 0.) {
    result.alpha1 = PI;
    result.alp21 = 0.;
  }
  return 0;
};

/*************************************************
 経度差180度の方位角の判断
*************************************************/
GSI.Utils.DistanceCalculator._handan2 = function (PI, params, zoneInfo, result) {
  if (params.sigma >= 0) {
    result.alpha1 = 0;
    result.alp21 = 0;
  } else if (params.sigma < 0) {
    result.alpha1 = PI;
    result.alp21 = PI;
  }
  return 0;
};

/*************************************************
 方位角の反転
*************************************************/
GSI.Utils.DistanceCalculator._hanten = function (PI, params, zoneInfo, result) {
  if (params.seihan == 1) {
    var alphax = result.alpha1;
    result.alpha1 = result.alp21;
    result.alp21 = alphax;
  }
  return 0;
} /* hanten_ */

GSI.SHARE = {};

/*************************************************
 Twitter投稿画面表示
*************************************************/
GSI.SHARE.showTwitter = function () {
  var url = 'https://twitter.com/share?' +
    'url=' + encodeURIComponent(window.location.href) + '&' +
    'via=' + encodeURIComponent('gsi_cyberjapan') + '&' +
    'related=' + 'gsi_cyberjapan' + '&' +
    'hashtags=' + '' + '&' +
    'text=' + encodeURIComponent('地理院地図で見る');
  window.open(url);
};

/*************************************************
 Facebook投稿画面表示
*************************************************/
GSI.SHARE.showFacebook = function () {

  var url = 'https://www.facebook.com/sharer/sharer.php?u=' + encodeURIComponent(window.location.href);

  window.open(url);
};

/*************************************************
 L.Label 1.2.0対応

*************************************************/
L.Label.prototype._layerAdd = L.Layer.prototype._layerAdd;
L.Label.prototype.remove = function () {
  if (this._map)
    this._map.removeLayer(this);

};

L.DomUtil.getTranslateString = function (point) {
  // on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate
  // makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care
  // (same speed either way), Opera 12 doesn't support translate3d

  var is3d = L.Browser.webkit3d,
    open = 'translate' + (is3d ? '3d' : '') + '(',
    close = (is3d ? ',0' : '') + ')';

  return open + point.x + 'px,' + point.y + 'px' + close;
};

L.Map.mergeOptions({
  touchExtend: true
});

/**
 * @class L.Map.TouchExtend
 * @aka TouchExtend
 */
L.Map.TouchExtend = L.Handler.extend({

  doubleTap: false,
  delay: 250,
  touch: null,
  trackedTouches: [],

  // @method initialize(): void
  // Sets TouchExtend private accessor variables
  initialize: function (map) {
    this._map = map;
    this._container = map._container;
    this._pane = map._panes.overlayPane;
  },

  // @method addHooks(): void
  // Adds dom listener events to the map container
  addHooks: function () {
    L.DomEvent.on(this._container, 'touchstart', this._onTouchStart, this);
    L.DomEvent.on(this._container, 'touchend', this._onTouchEnd, this);
    L.DomEvent.on(this._container, 'touchmove', this._onTouchMove, this);
    if (this._detectIE()) {
      L.DomEvent.on(this._container, 'MSPointerDown', this._onTouchStart, this);
      L.DomEvent.on(this._container, 'MSPointerUp', this._onTouchEnd, this);
      L.DomEvent.on(this._container, 'MSPointerMove', this._onTouchMove, this);
      L.DomEvent.on(this._container, 'MSPointerCancel', this._onTouchCancel, this);

    } else {
      L.DomEvent.on(this._container, 'touchcancel', this._onTouchCancel, this);
      L.DomEvent.on(this._container, 'touchleave', this._onTouchLeave, this);
    }
  },

  // @method removeHooks(): void
  // Removes dom listener events from the map container
  removeHooks: function () {
    L.DomEvent.off(this._container, 'touchstart', this._onTouchStart);
    L.DomEvent.off(this._container, 'touchend', this._onTouchEnd);
    L.DomEvent.off(this._container, 'touchmove', this._onTouchMove);
    if (this._detectIE()) {
      L.DomEvent.off(this._container, 'MSPointerDowm', this._onTouchStart);
      L.DomEvent.off(this._container, 'MSPointerUp', this._onTouchEnd);
      L.DomEvent.off(this._container, 'MSPointerMove', this._onTouchMove);
      L.DomEvent.off(this._container, 'MSPointerCancel', this._onTouchCancel);
    } else {
      L.DomEvent.off(this._container, 'touchcancel', this._onTouchCancel);
      L.DomEvent.off(this._container, 'touchleave', this._onTouchLeave);
    }
  },

  _touchEvent: function (e, type) {
    // #TODO: fix the pageX error that is do a bug in Android where a single touch triggers two click events
    // _filterClick is what leaflet uses as a workaround.
    // This is a problem with more things than just android. Another problem is touchEnd has no touches in
    // its touch list.
    var touchEvent = {};
    if (typeof e.touches !== 'undefined') {
      if (!e.touches.length) {
        return;
      }
      touchEvent = e.touches[0];
    } else if (e.pointerType === 'touch') {
      touchEvent = e;
      if (!this._filterClick(e)) {
        return;
      }
    } else {
      return;
    }

    var containerPoint = this._map.mouseEventToContainerPoint(touchEvent),
      layerPoint = this._map.mouseEventToLayerPoint(touchEvent),
      latlng = this._map.layerPointToLatLng(layerPoint);

    this._map.fire(type, {
      latlng: latlng,
      layerPoint: layerPoint,
      containerPoint: containerPoint,
      pageX: touchEvent.pageX,
      pageY: touchEvent.pageY,
      originalEvent: e
    });
  },

  /** Borrowed from Leaflet and modified for bool ops **/
  _filterClick: function (e) {
    var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),
      elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

    // are they closer together than 500ms yet more than 100ms?
    // Android typically triggers them ~300ms apart while multiple listeners
    // on the same event should be triggered far faster;
    // or check if click is simulated on the element, and if it is, reject any non-simulated events
    if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
      L.DomEvent.stop(e);
      return false;
    }
    L.DomEvent._lastClick = timeStamp;
    return true;
  },

  // android chromeでダブルタッチに対応

  _onTouchStartDoubleTouch: function (e) {
    if (!L.Browser.touch || !(L.Browser.pointer && L.Browser.chrome)) return;

    var count;

    if (L.Browser.pointer) {
      this.trackedTouches.push(e.pointerId);
      count = this.trackedTouches.length;
    } else {
      count = e.touches.length;
    }
    if (count > 1) {
      return;
    }

    var now = Date.now(),
      delta = now - (this.last || now);

    this.touch = e.touches ? e.touches[0] : e;
    this.doubleTap = (delta > 0 && delta <= this.delay);
    this.last = now;
  },

  _onTouchEndDoubleTouch: function (e) {
    if (!L.Browser.touch || !(L.Browser.pointer && L.Browser.chrome)) return;

    if (L.Browser.pointer) {
      var idx = this.trackedTouches.indexOf(e.pointerId);
      if (idx === -1) {
        return;
      }
      this.trackedTouches.splice(idx, 1);
    }

    if (this.doubleTap) {
      if (L.Browser.pointer) {
        // work around .type being readonly with MSPointer* events
        var newTouch = {},
          prop;

        // jshint forin:false
        for (var i in this.touch) {
          prop = this.touch[i];
          if (typeof prop === 'function') {
            newTouch[i] = prop.bind(this.touch);
          } else {
            newTouch[i] = prop;
          }
        }
        this.touch = newTouch;
      }
      this.touch.type = 'dblclick';

      var touchEvent = {};

      var containerPoint = this._map.mouseEventToContainerPoint(this.touch),
        layerPoint = this._map.mouseEventToLayerPoint(this.touch),
        latlng = this._map.layerPointToLatLng(layerPoint);

      if (!$(e.target).hasClass("leaflet-editing-icon")) {
        this._map.fire("dblclick", {
          latlng: latlng,
          layerPoint: layerPoint,
          containerPoint: containerPoint,
          pageX: this.touch.pageX,
          pageY: this.touch.pageY,
          originalEvent: e
        });
      }
      last = null;
    }
  },

  // ここまでandroid chromeでダブルタッチに対応

  _onTouchStart: function (e) {
    if (!this._map._loaded) {
      return;
    }

    this._onTouchStartDoubleTouch(e);

    var type = 'touchstart';
    this._touchEvent(e, type);

  },

  _onTouchEnd: function (e) {
    if (!this._map._loaded) {
      return;
    }
    this._onTouchEndDoubleTouch(e);

    var type = 'touchend';
    this._touchEvent(e, type);
  },

  _onTouchCancel: function (e) {
    if (!this._map._loaded) {
      return;
    }

    this._onTouchEndDoubleTouch(e);
    var type = 'touchcancel';
    if (this._detectIE()) {
      type = 'pointercancel';
    }
    this._touchEvent(e, type);
  },

  _onTouchLeave: function (e) {
    if (!this._map._loaded) {
      return;
    }

    var type = 'touchleave';
    this._touchEvent(e, type);
  },

  _onTouchMove: function (e) {
    if (!this._map._loaded) {
      return;
    }

    var type = 'touchmove';
    this._touchEvent(e, type);
  },

  _detectIE: function () {
    var ua = window.navigator.userAgent;

    var msie = ua.indexOf('MSIE ');
    if (msie > 0) {
      // IE 10 or older => return version number
      return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
    }

    var trident = ua.indexOf('Trident/');
    if (trident > 0) {
      // IE 11 => return version number
      var rv = ua.indexOf('rv:');
      return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
    }

    var edge = ua.indexOf('Edge/');
    if (edge > 0) {
      // IE 12 => return version number
      return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
    }

    // other browser
    return false;
  }
});

L.Map.addInitHook('addHandler', 'touchExtend', L.Map.TouchExtend);

L.Marker.Touch = L.Marker.extend({

  _initInteraction: function () {
    if (!this.addInteractiveTarget) {
      // 0.7.x support
      return this._initInteractionLegacy();
    }
    // TODO this may need be updated to re-add touch events for 1.0+
    return L.Marker.prototype._initInteraction.apply(this);
  },

  // This is an exact copy of https://github.com/Leaflet/Leaflet/blob/v0.7/src/layer/marker/Marker.js
  // with the addition of the touch events
  _initInteractionLegacy: function () {

    if (!this.options.clickable) {
      return;
    }

    // TODO refactor into something shared with Map/Path/etc. to DRY it up

    var icon = this._icon,
      events = ['dblclick',
        'mousedown',
        'mouseover',
        'mouseout',
        'contextmenu',
        'touchstart',
        'touchend',
        'touchmove'];
    if (this._detectIE) {
      events.concat(['MSPointerDown',
        'MSPointerUp',
        'MSPointerMove',
        'MSPointerCancel']);
    } else {
      events.concat(['touchcancel']);
    }

    L.DomUtil.addClass(icon, 'leaflet-clickable');
    L.DomEvent.on(icon, 'click', this._onMouseClick, this);
    L.DomEvent.on(icon, 'keypress', this._onKeyPress, this);
    for (var i = 0; i < events.length; i++) {
      L.DomEvent.on(icon, events[i], this._fireMouseEvent, this);
    }

    if (L.Handler.MarkerDrag) {
      this.dragging = new L.Handler.MarkerDrag(this);

      if (this.options.draggable) {
        this.dragging.enable();
      }
    }
  },

  _detectIE: function () {
    var ua = window.navigator.userAgent;

    var msie = ua.indexOf('MSIE ');
    if (msie > 0) {
      // IE 10 or older => return version number
      return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
    }

    var trident = ua.indexOf('Trident/');
    if (trident > 0) {
      // IE 11 => return version number
      var rv = ua.indexOf('rv:');
      return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
    }

    var edge = ua.indexOf('Edge/');
    if (edge > 0) {
      // IE 12 => return version number
      return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
    }

    // other browser
    return false;
  }
});

/************************************************************************

 Leaflet.Geodesic内の内部メソッド用

 ************************************************************************/
GSI.Utils.Geodesic = {
  LINESTEPS: 100,
  INTERSECT_LNG: INTERSECT_LNG,
  _geodesic: L.geodesic([], { wrap: false, steps: 100 })
};

GSI.Utils.Geodesic.vincentyInverse = function (p1, p2) {
  return GSI.Utils.Geodesic._geodesic._vincenty_inverse(p1, p2);
};

GSI.Utils.Geodesic.intersection = function (p1, brng1, p2, brng2) {
  return GSI.Utils.Geodesic._geodesic._intersection(p1, brng1, p2, brng2);
};

GSI.Utils.Geodesic.vincentyDirect = function (p1, initialBearing, distance, wrap) {
  return GSI.Utils.Geodesic._geodesic._vincenty_direct(p1, initialBearing, distance, wrap);
};

GSI.Utils.Geodesic.createLine = function (latlngs, steps) {
  GSI.Utils.Geodesic._geodesic.options.steps = steps;

  GSI.Utils.Geodesic._geodesic.setLatLngs(latlngs);
  return GSI.Utils.Geodesic._geodesic._latlngs;
};

GSI.Utils.getTooltipText = function (key1, key2) {
  if (!CONFIG.TOOLTIP) return "";
  var result = CONFIG.TOOLTIP[key1];
  if (!result) return "";
  result = result[key2];
  if (!result) return "";
  return result;
};

L.extend(L.LatLng, {
  DEG_TO_RAD: Math.PI / 180,
  RAD_TO_DEG: 180 / Math.PI,
  MAX_MARGIN: 1.0E-9 // max margin of error for the "equals" check
});

/************************************************************************
 L.Control
 - GSI.Control.MapSplitControl
 　2画面解除等のコントロール
 ************************************************************************/
GSI.Control.MapSplitControl = L.Control.extend({
  includes: L.Evented.prototype || L.Mixin.Events,
  options: {
    position: 'topright',
    maxWidth: "300px",
    "caption": "2画面解除"
  },
  initialize: function (options) {
    this._sync = (options.sync == false ? false : true);
    L.setOptions(this, options);
  },
  onAdd: function (map) {
    this._map = map;
    var container = L.DomUtil.create('div', '');

    this._container = container;

    this._update();
    return this._container;
  },
  onRemove: function (map) {
  },

  _update: function () {
    if (!this._map) {
      return;
    }

    this._frame = $("<div>").addClass("gsi_spilitcontrol_container");
    if (CONFIG.MOBILE) this._frame.addClass("mobile");

    $(this._container).empty().append(this._frame);
    this._splitEndButton = $("<a>").addClass("normalbutton")
      .attr({ "href": "javascript:void(0)" }).html(this.options.caption);

    this._splitEndButton.on('click',L.bind(function () {

      try {

        $("body").tooltip("destroy").tooltip({
          "show": { duration: 300 },
          "hide": { duration: 200 },
          "open": function (evt, ui) {
          },
          "position": { my: "right top+10", at: "center bottom", collision: "flipfit" }
        });

      }catch(ex) {
      }
      this.fire("stop");
    }, this));

    this._frame.append(this._splitEndButton);

    L.DomEvent.addListener(this._splitEndButton[0], 'click', L.DomEvent.stop);
    L.DomEvent.disableClickPropagation(this._splitEndButton[0]);

    this._syncSwitch = new GSI.OnOffSwitch({ className: 'onoff', checked: this._sync, title: "aaa" });

    var div = $("<div>").addClass("switchframe");
    var label = $("<label>").addClass("switchlabel").attr({ "for": this._syncSwitch.getId() }).html("連動");

    div.append(label).append(this._syncSwitch.getElement());
    this._syncSwitch.on("change", L.bind(function (e) {
      this._sync = this._syncSwitch.checked();

      this.fire("syncchange", { sync: this._sync });
    }, this));
    this._frame.append(div);

    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.SPLITWINDOW) {
      this._splitEndButton.attr({ "title": CONFIG.TOOLTIP.SPLITWINDOW.STOP });
      label.attr({ "title": CONFIG.TOOLTIP.SPLITWINDOW.SYNC });
      this._syncSwitch.getElement().attr({ "title": CONFIG.TOOLTIP.SPLITWINDOW.SYNC });
    }

    L.DomEvent.disableClickPropagation(label[0]);
    L.DomEvent.disableClickPropagation(this._syncSwitch.getElement()[0]);

  },

  set: function (on) {
    this._syncSwitch.checked(on);
    this._sync = this._syncSwitch.checked();
    this.fire("syncchange", { sync: this._sync });
  },

  setTopMargin : function() {
    $( this._frame ).css({"margin-top":"90px"})
  },

  removeTopMargin : function() {
    $( this._frame ).css({"margin-top":"0"});
  }
});

/************************************************************************
 L.Control
 - GSI.Control.MapCompareControl
 　比較解除等のコントロール
 ************************************************************************/
GSI.Control.MapCompareControl = L.Control.extend({
  includes: L.Evented.prototype || L.Mixin.Events,
  options: {
    position: 'topright',
    maxWidth: "300px",
    "caption": "比較解除"
  },
  initialize: function (options) {
    L.setOptions(this, options);
  },
  onAdd: function (map) {
    this._map = map;
    var container = L.DomUtil.create('div', '');

    this._container = container;

    this._update();
    return this._container;
  },
  onRemove: function (map) {
  },

  _update: function () {
    if (!this._map) {
      return;
    }

    this._frame = $("<div>").addClass("gsi_spilitcontrol_container");
    $(this._container).empty().append(this._frame);
    this._splitEndButton = $("<a>").addClass("normalbutton")
      .attr({ "href": "javascript:void(0)" }).html(this.options.caption);

    this._splitEndButton.on('click',L.bind(function () {

      $("body").tooltip("destroy").tooltip({
        "show": { duration: 300 },
        "hide": { duration: 200 },
        "open": function (evt, ui) {
        },
        "position": { my: "right top+10", at: "center bottom", collision: "flipfit" }
      });
      this.fire("stop");
    }, this));

    this._frame.append(this._splitEndButton);

    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.STACKWINDOW) {
      this._splitEndButton.attr({ "title": CONFIG.TOOLTIP.STACKWINDOW.STOP });
    }
    L.DomEvent.addListener(this._splitEndButton[0], 'click', L.DomEvent.stop);
    L.DomEvent.disableClickPropagation(this._splitEndButton[0]);

  }
});

/************************************************************************
 L.Polygon
 - GSI.PathFrameRectangle（作図編集で編集・削除アイコンボタン表示用）
 ************************************************************************/
GSI.PathFrameRectangle = L.Polygon.extend({
  options: {
    color: "#666666",
    weight: 2,
    fill: false,
    opacity: 0.6,
    dashArray: [3, 3]
  },

  initialize: function (path, options) {
    this._targetPath = path;

    this._targetPathClickHandler = L.bind(function () {
      this._editBtnClick();
    }, this);

    L.Polygon.prototype.initialize.call(this, [], options);
  },

  // オブジェクトを囲う４角形
  _getTargetBounds: function (map) {
    return GSI.PathFrameRectangle.createTargetBounds(map, this._targetPath);

  },

  // 追加時
  onAdd: function (map) {
    L.Polygon.prototype.onAdd.call(this, map);
    this.setLatLngs(this.geLatLngs(map));
    var zoom = map.getZoom();

    var bounds = this._getTargetBounds(map);

    var east = map.project(bounds.getNorthEast(), zoom);
    var west = map.project(bounds.getNorthWest(), zoom);

    if (!(this._targetPath instanceof L.Marker) && east.x - west.x > 66) {

      this._editBtnMarker = L.marker(bounds.getNorthEast(), {
        icon: L.divIcon({ iconSize: [30, 30], iconAnchor: [64, - 2], className: 'gsi_pathframerectangle_editbtn', html: "" }),
        zIndexOffset: 4000
      }).on("click", L.bind(this._editBtnClick, this));

      this._removeBtnMarker = L.marker(bounds.getNorthEast(), {
        icon: L.divIcon({ iconSize: [30, 30], iconAnchor: [32, - 2], className: 'gsi_pathframerectangle_removebtn', html: "" }),
        zIndexOffset: 4000
      }).on("click", L.bind(this._removeBtnClick, this));

    }
    else {
      var pos = L.latLng(bounds.getNorth(), bounds.getCenter().lng);

      this._editBtnMarker = L.marker(pos, {
        icon: L.divIcon({ iconSize: [30, 30], iconAnchor: [31, 32], className: 'gsi_pathframerectangle_editbtn', html: "" }),
        zIndexOffset: 4000
      }).on("click", L.bind(this._editBtnClick, this));

      this._removeBtnMarker = L.marker(pos, {
        icon: L.divIcon({ iconSize: [30, 30], iconAnchor: [-1, 32], className: 'gsi_pathframerectangle_removebtn', html: "" }),
        zIndexOffset: 4000
      }).on("click", L.bind(this._removeBtnClick, this));

    }

    map.addLayer(this._editBtnMarker);
    map.addLayer(this._removeBtnMarker);
    if (this._addInnerBtnMarker) map.addLayer(this._addInnerBtnMarker);

    this._initMarkerHelp(this._editBtnMarker, "編集");
    this._initMarkerHelp(this._removeBtnMarker, "削除");
    this._initMarkerHelp(this._addInnerBtnMarker, "中抜ポリゴンを作成");

    if (
      (this._targetPath instanceof L.CircleMarker && !(this._targetPath instanceof L.Circle))
      || (this._targetPath instanceof L.Marker)
    ) {
      this._zoomEndHandler = L.bind(function () {
        this._refresh();
      }, this);
      map.on("zoomend", this._zoomEndHandler);
    }

    this._targetPath.on("click", this._targetPathClickHandler);
  },

  _initMarkerHelp: function (marker, text) {
    if (!marker) return;

    marker.on("mouseover", L.bind(function (marker, text) {
      if (!marker._label) {
        marker._label = $("<div>").addClass("gsi-iconlabel-class").html(text).css({ "position": "absolute" });
        $("body").append(marker._label);
        var w = marker._label.outerWidth();
        var h = marker._label.outerHeight();
        marker._label.remove();

        marker._label.css({ "top": "30px", "left": "50%", "margin-left": -parseInt(w / 2) + "px" });
        $(marker._icon).append(marker._label);
      }

    }, this, marker, text));
    marker.on("mouseout", L.bind(function (marker) {
      if (marker._label) marker._label.remove();
      marker._label = null;
    }, this, marker, text));
  },

  // 生成しなおし
  _refresh: function () {
    if (!this._editBtnMarker) return;

    var bounds = this._getTargetBounds(this._map);
    var zoom = this._map.getZoom();

    this.setLatLngs(this.geLatLngs(this._map));

    var east = this._map.project(bounds.getNorthEast(), zoom);
    var west = this._map.project(bounds.getNorthWest(), zoom);

    if (east.x - west.x > 66) {
      this._editBtnMarker.setLatLng(bounds.getNorthEast());
      this._removeBtnMarker.setLatLng(bounds.getNorthEast());
      if (this._addInnerBtnMarker) this._addInnerBtnMarker.setLatLng(bounds.getNorthEast());
      if (this._removeInnerBtnMarker) this._removeInnerBtnMarker.setLatLng(bounds.getNorthEast());
    }
    else {
      var pos = L.latLng(bounds.getNorth(), bounds.getCenter().lng);
      this._editBtnMarker.setLatLng(pos);
      this._removeBtnMarker.setLatLng(pos);
      if (this._addInnerBtnMarker) this._addInnerBtnMarker.setLatLng(pos);
      if (this._removeInnerBtnMarker) this._removeInnerBtnMarker.setLatLng(pos);
    }
  },

  // 編集アイコンクリック
  _editBtnClick: function (e) {

    this.fire("requestedit");
    try {
      L.DomEvent.stop(e);
    }
    catch (e) { }
  },

  // 削除アイコンクリック
  _removeBtnClick: function () {
    this.fire("requestremove");
  },

  // 中抜きポリゴン追加ボタンクリック
  _addInnerBtnClick: function () {
    this.fire("requestaddinner");

  },

  // 中抜きポリゴン削除ボタンクリック
  _removeInnerBtnClick: function () {

  },

  // 地図から削除時
  onRemove: function (map) {
    if (this._zoomEndHandler) map.off("zoomend", this._zoomEndHandler);
    this._zoomEndHandle = null;

    this._targetPath.off("click", this._targetPathClickHandler);
    map.removeLayer(this._removeBtnMarker);
    map.removeLayer(this._editBtnMarker);
    delete this._editBtnMarker;
    delete this._removeBtnMarker;

    if (this._addInnerBtnMarker) {
      map.removeLayer(this._addInnerBtnMarker);
      delete this._addInnerBtnMarker;
    }
    this._editBtnMarker = null;
    this._removeBtnMarker = null;
    this._addInnerBtnMarker = null;

    L.Polygon.prototype.onRemove.call(this, map);
  },

  geLatLngs: function (map) {
    if (!this._targetPath) return [];

    var bounds = this._getTargetBounds(map);

    var result = [];

    if (bounds) {
      result.push(bounds.getNorthWest());
      result.push(bounds.getSouthWest());
      result.push(bounds.getSouthEast());
      result.push(bounds.getNorthEast());
      result.push(bounds.getNorthWest());
    }

    return result;
  }
});

GSI.PathFrameRectangle.createTargetBounds = function (map, path) {
  var bounds = null;
  if (path.getBounds)
    bounds = path.getBounds();
  else if (path instanceof L.CircleMarker) {
    var radius = path.getRadius();
    var center = path.getLatLng();
    var zoom = map.getZoom();
    var p = map.project(center, zoom);

    var lt = map.unproject(L.point(p.x - radius - 5, p.y - radius - 5), zoom);
    var rb = map.unproject(L.point(p.x + radius + 5, p.y + radius + 5), zoom);

    bounds = L.latLngBounds(lt, rb);
  }
  else if (path instanceof L.Marker) {
    var center = path.getLatLng();
    var w = 50;
    var h = 50;
    var anchorX = 25;
    var anchorY = 25;
    if (path.options.icon && path.options.icon.options.iconUrl && path.options.icon.options.iconSize) {
      w = path.options.icon.options.iconSize[0] + 8;
      h = path.options.icon.options.iconSize[1] + 8;
    }
    else if (path._icon) {
      w = $(path._icon).outerWidth(false) + 8;
      h = $(path._icon).outerHeight(false) + 8;
    }

    if (path.options.icon && path.options.icon.options.iconAnchor) {
      anchorX = path.options.icon.options.iconAnchor[0] + 4;
      anchorY = path.options.icon.options.iconAnchor[1] + 4;
    }
    else if (path.options.icon && (path.options.icon.options.html || path.options.icon.options.html != '')) {
      anchorX = 4;
      anchorY = 4;
    }
    else {
      anchorX = Math.round(w / 2);
      anchorY = Math.round(h / 2);
    }
    var centerPoint = map.latLngToContainerPoint(center);

    var left = centerPoint.x - anchorX;
    var top = centerPoint.y - anchorY;

    var right = centerPoint.x + (w - anchorX);
    var bottom = centerPoint.y + (h - anchorY);

    var southWest = map.containerPointToLatLng(L.point(left, bottom));
    var northEast = map.containerPointToLatLng(L.point(right, top));

    bounds = L.latLngBounds(southWest, northEast);
  }
  return bounds;
};

/*******************************************************

 GSI.ReliefTileLayer
    自分で作る色別標高図用レイヤー

*******************************************************/
GSI.ReliefTileLayer = L.TileLayer.extend({

  options: {
    transparentGradate: false
  },

  // 初期化
  initialize: function (url, options) {

    this._elevationData = null;
    L.TileLayer.prototype.initialize.call(this, url, options);

    this._drawer = new GSI.ReliefTileLayer.TileDrawer();
  },

  // データ設定
  setElevationData: function (data) {
    this._elevationData = this._initializeElevationData(data);
    this._drawer.setElevationData(this._elevationData);
    this.redraw();
  },

  // データ初期化
  _initializeElevationData: function (data) {
    if (!data || !data.colors) return null;

    var result = {
      gradate: data.gradate,
      useHillshademap: data.useHillshademap,
      colors: []
    };

    for (var i = 0; i < data.colors.length; i++) {
      var c = data.colors[i];
      if (c.color !== null && typeof c.color === "string") {
          var color = GSI.ReliefTileLayer.colorStringToRGBA(c.color);

        c.color = color;
      }
      result.colors.push(c);
    }

    result.colors.sort(function (a, b) {
      if (!a.h && a.h != 0) return 1;
      if (!b.h && b.h != 0) return -1;
      if (a.h < b.h) return -1;
      if (a.h > b.h) return 1;
      return 0;
    });

    return result;
  },

  // 現在の色別標高図用データ取得
  getElevationData: function () {
    return this._elevationData;

  },


  // タイル生成
  createTile: function (coords, done) {

    if (!this._elevationData) {
      return L.TileLayer.prototype.createTile.call(this, coords, done);
    }
    var tile = document.createElement('canvas');
    tile.width = 256;
    tile.height = 256;

    this._loadTile(tile, coords, done);

    return tile;
  },

  // タイル読み込み
  _loadTile: function (tile, coords, done) {
    // 以前、読み込み中タイルがもう一度読み込みさせようとしていましたが、
    // その場合、読み込み中タイルが表示されなくなるため、
    // 現在は同じタイルが読み込まれる可能性があるが、読み込み中タイルをチェックせずに読み込むようにしています。

    var loader = new GSI.FreeReliefDEMLoader(this._map, coords.x, coords.y, coords.z, this._demUrlList, {
        overZooming: true,
      useHillshademap: this._elevationData.useHillshademap,
      hillshademapUrl: this._hillshademapUrl

    });
    loader._params = {
      tile: tile,
      coords: coords,
      done: done
    };

    loader.on("load", L.bind(function (e) {
      var obj = e.target;

      this._drawer.draw(obj._params.tile, obj.getData(), obj.getHillshademapImage());
      obj._params.done(null, obj._params.tile);

    }, this));

    loader.load();
  }
});

// デフォルトデータ
GSI.ReliefTileLayer._sampleData =
{
  gradate: false,
  useHillshademap: false,
  colors: [
    {
      "h": 5,
      "color": "#0000FF"
    },
    {
      "h": 10,
      "color": "#0095FF"
    },
    {
      "h": 50,
      "color": "#00EEFF"
    },
    {
      "h": 100,
      "color": "#91FF00"
    },
    {
      "h": 500,
      "color": "#FFFF00"
    },
    {
      "h": 1500,
      "color": "#FF8C00"
    },
    {
      "h": null,
      "color": "#FF4400"
    }
  ]
};

// #000000→内部利用するRGBA形式に変換
GSI.ReliefTileLayer.colorStringToRGBA = function (c) {
  var toHex = function (v) {
    return '0x' + (('0000' + v.toString(16).toUpperCase()).substr(-4));
  };
  if (c !== null && typeof c === "string") {
    var color = {
      r: 0, g: 0, b: 0, a: 0
    };

    try {
      if (c.substring(0, 1) == "#" && c.length == 7) {
        color.r = parseInt(toHex(c.substring(1, 3)));
        color.g = parseInt(toHex(c.substring(3, 5)));
        color.b = parseInt(toHex(c.substring(5, 7)));
        color.a = 255;
      }
      else if (c.substring(0, 1) != "#" && c.length == 6) {
        color.r = parseInt(toHex(c.substring(0, 2)));
        color.g = parseInt(toHex(c.substring(2, 4)));
        color.b = parseInt(toHex(c.substring(4, 6)));
        color.a = 255;
      }
    }
    catch (e) { }

    c = color;
  }

  return c;
};

// データのURL用エンコード
GSI.ReliefTileLayer.encodeElevationData = function (data) {
  if (!data) return;

  var result = "";

  for (var i = 0; i < data.colors.length; i++) {
    var c = data.colors[i];

    var hText = "";
    if (c.h || c.h == 0)
      hText = c.h.toString(16);
    var colorText = ""

    if (c && c.color) {
      if (typeof c.color === "string") {
        if (c.color.charAt(0) == "#")
          colorText = c.color.slice(1);
        else
          colorText = c.color;
      }
      else {

        colorText =
          ("00" + c.color.r.toString(16).toUpperCase()).substr(-2)
          + ("00" + c.color.g.toString(16).toUpperCase()).substr(-2)
          + ("00" + c.color.b.toString(16).toUpperCase()).substr(-2);
      }
    }

    result += (result == "" ? "" : "G") + hText + "G" + colorText;

  }

  var flags = (data.desc ? "1" : "0") + (data.gradate ? "1" : "0") + (data.useHillshademap ? "1" : "0");
  result = parseInt(flags, 2) + result;
  return result.toUpperCase();
};

// URL用データから内部データへ変換
GSI.ReliefTileLayer.decodeElevationDataText = function (txt) {
  if (txt == "0G000000") return null;

  var result = {};
  try {

    var flags = parseInt(txt.charAt(0)).toString(2);
    flags = ('000' + flags).slice(-3);

    result.desc = (flags.charAt(0) == "1" ? true : false);
    result.gradate = (flags.charAt(1) == "1" ? true : false);
    result.useHillshademap = (flags.charAt(2) == "1" ? true : false);

    txt = txt.slice(1);

    var parts = txt.split("G");
    result.colors = [];
    for (var i = 0; i < parts.length; i += 2) {
      var item = {};

      if (parts[i] == "") {
        item.h = null;
      }
      else {
        if (parts[i].match(/\.8$/)) {
          var g = parts[i].indexOf(".");

          var dec = parseInt(parts[i].substr(0, g), 16);
          var pt = 0;
          for (var a = 0; a < parts[i].substr(g + 1).length; a++) {
            pt = pt + parts[i].charAt(a + g + 1) / Math.pow(16, a + 1);
          }
          item.h = dec + pt;
        }
        else {
          item.h = parseInt(parts[i], 16);
        }
      }

      if (parts[i + 1] == "")
        item.color = null;
      else
        item.color = GSI.ReliefTileLayer.colorStringToRGBA("#" + parts[i + 1]);

      if (isNaN(item.h)) return null;

      result.colors.push(item);
    }

  }
  catch (e) {
    console.log(e);
    result = null;
  }

  return result;
};

// 初期データ取得
GSI.ReliefTileLayer.getElevationSampleData = function () {
  return $.extend(true, {}, GSI.ReliefTileLayer._sampleData);
};

GSI.ReliefTileLayer.getEncodedElevationSampleData = function () {
  return GSI.ReliefTileLayer._encodedSampleData;
};

GSI.ReliefTileLayer._encodedSampleData =
  GSI.ReliefTileLayer.encodeElevationData(GSI.ReliefTileLayer._sampleData);

/*******************************************************

 GSI.ReliefTileLayer.TileDrawer
    タイル描画

*******************************************************/
GSI.ReliefTileLayer.TileDrawer = L.Class.extend({

  options: {
    transparentGradate: false
  },

  // 初期化
  initialize: function () {

  },

  setElevationData: function (data) {
    this._elevationData = data;
  },

  // 高さから色取得
  _hToColor: function (h) {
    if (h == null) return null;

    var colors = this._elevationData.colors;
    var prev = null;
    var current = null;

    for (var i = 0; i < colors.length; i++) {
      var color = colors[i];

      if (!color.h && color.h != 0) continue;
      if (color.h >= h) {
        if (i > 0) {
          current = colors[i];
          if (i > 0) prev = colors[i - 1];
        }
        else {
          current = colors[0];

        }
        break;
      }
    }

    if (!current) return colors[colors.length - 1].color;
    if (!prev) return current.color;

    if (!this._elevationData.gradate) {
      return current.color;
    }

    var p = (h - prev.h) / (current.h - prev.h);

    var result = {
      r: 0, g: 0, b: 0, a: 0
    };
    if (current.color && prev.color) {
      result = {
        r: Math.round(prev.color.r + ((current.color.r - prev.color.r) * p)),
        g: Math.round(prev.color.g + ((current.color.g - prev.color.g) * p)),
        b: Math.round(prev.color.b + ((current.color.b - prev.color.b) * p)),
        a: 255
      };
    }
    else if (!current.color && prev.color) {
      if (this.options.transparentGradate) {
        result = {
          r: prev.color.r,
          g: prev.color.g,
          b: prev.color.b,
          a: Math.round(255 + (-255 * p)),
        };
      }
    }
    else if (current.color && !prev.color) {
      if (this.options.transparentGradate) {
        result = {
          r: current.color.r,
          g: current.color.g,
          b: current.color.b,
          a: Math.round(255 * p),
        };
      }
      else {
        result = {
          r: current.color.r,
          g: current.color.g,
          b: current.color.b,
          a: 255,
        };
      }
    }
    if (result.r > 255) result.r = 255;
    if (result.g > 255) result.g = 255;
    if (result.b > 255) result.b = 255;
    if (result.a > 255) result.a = 255;
    return result;
  },

  // Canvasへ描画
  draw: function (dstCanvas, demData, hillshadeMapImage) {
    if (!this._elevationData || !demData) return;

    var destCtx = dstCanvas.getContext('2d');
    var destData = destCtx.createImageData(256, 256);
    var hillshadeData = null;
    var hillshadeScale = 1;
    var hillshadePoint = null;

    if (hillshadeMapImage) {
      var hillshadeCanvas = GSI.ReliefTileLayer.TileDrawer.getCanvas();
      var hillshadeCtx = hillshadeCanvas.getContext('2d');
      hillshadeCtx.clearRect(0, 0, 256, 256);
      hillshadeCtx.beginPath();
      hillshadeCtx.drawImage(hillshadeMapImage, 0, 0);
      hillshadeData = hillshadeCtx.getImageData(0, 0, 256, 256).data;
      hillshadeScale = hillshadeMapImage._scale;
      hillshadePoint = hillshadeMapImage._point;

    }

    var idx = 0, destIdx = 0, hillshadeIdx = 0, color, hillshadeColor = { r: 0, g: 0, b: 0, a: 0 };
    for (var y = 0; y < 256; ++y) {
      for (var x = 0; x < 256; ++x) {
        color = this._hToColor(demData[idx]);

        if (color) {
          if (hillshadeData) {
            if (hillshadeScale != 1) {
              var x2 = Math.floor((hillshadePoint.x + x) / hillshadeScale);
              var y2 = Math.floor((hillshadePoint.y + y) / hillshadeScale);
              hillshadeIdx = (y2 * 256 * 4) + (x2 * 4);
            }
            else
              hillshadeIdx = (y * 256 * 4) + (x * 4);
            hillshadeColor.r = hillshadeData[hillshadeIdx];
            hillshadeColor.g = hillshadeData[hillshadeIdx + 1];
            hillshadeColor.b = hillshadeData[hillshadeIdx + 2];
            hillshadeColor.a = hillshadeData[hillshadeIdx + 3];
            if (hillshadeColor.a > 0) {
              destData.data[destIdx] = Math.round(color.r * (hillshadeColor.r / 255));
              destData.data[destIdx + 1] = Math.round(color.g * (hillshadeColor.g / 255));
              destData.data[destIdx + 2] = Math.round(color.b * (hillshadeColor.b / 255));
              destData.data[destIdx + 3] = Math.round(color.a * (hillshadeColor.a / 255));
            }
            else {
              destData.data[destIdx] = color.r;
              destData.data[destIdx + 1] = color.g;
              destData.data[destIdx + 2] = color.b;
              destData.data[destIdx + 3] = color.a;
            }
          }
          else {

            destData.data[destIdx] = color.r;
            destData.data[destIdx + 1] = color.g;
            destData.data[destIdx + 2] = color.b;
            destData.data[destIdx + 3] = color.a;
          }
        }
        else {
          destData.data[destIdx] = 0;
          destData.data[destIdx + 1] = 0;
          destData.data[destIdx + 2] = 0;
          destData.data[destIdx + 3] = 0;
        }

        destIdx += 4;
        idx++;
      }
    }

    destCtx.putImageData(destData, 0, 0);

  }
});

// 描画時作業用Canvas取得
GSI.ReliefTileLayer.TileDrawer.getCanvas = function () {
  if (!GSI.ReliefTileLayer.TileDrawer._canvas) {
    GSI.ReliefTileLayer.TileDrawer._canvas = document.createElement('canvas');
    GSI.ReliefTileLayer.TileDrawer._canvas.width = 256;
    GSI.ReliefTileLayer.TileDrawer._canvas.height = 256;
  }
  return GSI.ReliefTileLayer.TileDrawer._canvas;
}

/*******************************************************

 GSI.ReliefTileLayer.MapToImageLayer
    画像保存用

*******************************************************/
GSI.ReliefTileLayer.MapToImageLayer = L.Evented.extend({

  // 初期化
  initialize: function (map, layer, options) {
    L.setOptions(this, options);
    this._map = map;
    this._layer = layer;
    this._tiles = {};
    this._queue = [];

    this._drawer = new GSI.ReliefTileLayer.TileDrawer();
    this._drawer.setElevationData(this._layer._elevationData);

  },

  // 描画
  draw: function (texture) {

    var bounds = (this.options.pixelBounds ? this.options.pixelBounds : this._map.getPixelBounds());
    var zoom = this._map.getZoom();
    for (var key in this._tiles) {
      var tile = this._tiles[key];

      if (!tile.el || tile.el == true) continue;

      texture.globalCompositeOperation = (this.options.blend ? "multiply" : "source-over");

      texture.globalAlpha = (this.options.opacity || this.options.opacity == 0.0 ? this.options.opacity : 1);

      var pos = tile.coords;
      texture.drawImage(tile.el, pos.x * 256 - bounds.min.x, pos.y * 256 - bounds.min.y, 256, 256);

    }

    texture.globalCompositeOperation = "source-over";
    texture.globalAlpha = 1;

  },

  // 読み込み
  load: function () {
    this._requests = {};

    for (var i = 0; i < this._queue.length; i++) {
      var coords = this._queue[i];
      var key = coords.x + ":" + coords.y + ":" + coords.z;

      var loader = new GSI.DEMLoader(this._map, coords.x, coords.y, coords.z, this._layer._demUrlList, {
        overZooming: true,
        useHillshademap: this._layer._elevationData.useHillshademap,
        hillshademapUrl: this._layer._hillshademapUrl

      });

      loader.on("load", L.bind(function (e) {

        var obj = e.target;
        obj._loaded = true;

        this._checkLoaded();

      }, this));

      this._requests[key] = {
        el: null,
        loader: loader
      };

    }

    for (var key in this._requests) {
      this._requests[key].loader.load();
    }
    if (this._queue.length <= 0)
      this.fire("loaded");
  },

  // 読み込み完了チェック
  _checkLoaded: function () {
    var loaded = true;
    for (var key in this._requests) {
      var req = this._requests[key];

      if (req.loader._loaded) {
        if (!this._tiles[key].el) {
          var tile = document.createElement("canvas");
          tile.width = 256;
          tile.height = 256;
          this._tiles[key].el = tile;
          this._drawer.draw(tile, req.loader.getData(), req.loader.getHillshademapImage());

        }
      }
      else
        loaded = false;
    }

    if (loaded) this.fire("loaded");
  },

  // 読み込みキューを整形
  refreshQueue: function () {
    var bounds = (this.options.pixelBounds ? this.options.pixelBounds : this._map.getPixelBounds());
    var zoom = this._map.getZoom();
    if (zoom > this._layer.options.maxZoom || zoom < this._layer.options.minZoom) {
      return;
    }

    var tileSize = 256;

    var tileBounds = L.bounds(
      bounds.min.divideBy(tileSize)._floor(),
      bounds.max.divideBy(tileSize)._floor());
    this._queue = [],
      center = tileBounds.getCenter();

    this._tiles = {};
    var j, i, point;

    for (j = tileBounds.min.y; j <= tileBounds.max.y; j++) {
      for (i = tileBounds.min.x; i <= tileBounds.max.x; i++) {
        point = new L.Point(i, j);

        var coords = {
          x: point.x,
          y: point.y,
          z: zoom,
        };
        var key = point.x + ":" + point.y + ":" + zoom;

        var tile = this._layer._tiles[key];

        this._queue.push(coords);

        this._tiles[key] = {
          coords: coords,
          el: null
        };
      }
    }
  }
});

/*******************************************************

GSI.GeoTIFFImageOverlay
    Geotiff表示用レイヤ

*******************************************************/
L.ImageOverlay.prototype.getImage = function () {
  return this.getElement();
};

// 画像保存用Image取得
L.VideoOverlay.prototype.getImage = function () {
  var canvas = document.createElement("canvas");
  var elem = this.getElement();

  canvas.width = elem.videoWidth;
  canvas.height = elem.videoHeight;

  var ctx = canvas.getContext("2d");

  ctx.drawImage(elem, 0, 0);

  try {
    ctx.getImageData(0, 0, 1, 1);
  }
  catch (e) {
    canvas = document.createElement("canvas");
    canvas.width = elem.videoWidth;
    canvas.height = elem.videoHeight;
    ctx = canvas.getContext("2d");
    ctx.fillStyle = "#000000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  return canvas;
};

GSI.GeoTIFFImageOverlay = L.ImageOverlay.extend({

  // 初期化
  initialize: function (url, options) {
    this._url = url;
    this._bounds = null;

    L.setOptions(this, options);
  },

  setBlendEnable: function (flg) {
    this._blend = flg;

    if (this._image) {
      $(this._image).css({ "mix-blend-mode": "multiply" });
    }
  },

  // URL設定
  setUrl: function (url) {
    this._url = url;

    if (this._image) {
      this._image.src = url;
    }
    return this;
  },
  // 再生成
  _reset: function () {
    if (!this._bounds) return;
    var image = this._image,
      bounds = new L.Bounds(
        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
      size = bounds.getSize();

    L.DomUtil.setPosition(image, bounds.min);

    image.style.width = size.x + 'px';
    image.style.height = size.y + 'px';
  },
  // Tiff取得
  _initImage: function () {
    var img = this._image = L.DomUtil.create('canvas',
      'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : '') +
      (this.options.className || ''));

    img.onselectstart = L.Util.falseFn;
    img.onmousemove = L.Util.falseFn;

    // @event load: Event
    // Fired when the ImageOverlay layer has loaded its image
    this._reqest = new XMLHttpRequest();
    this._reqest.open('GET', this._url, true);
    this._reqest.responseType = 'arraybuffer';
    this._reqest.onload = L.bind(function (e) {
      if (this._reqest.readyState === 4) {
        if (this._reqest.status === 200) {
          this._setImage(this._reqest.response);
          this._reset();
        } else {
          this._overlayOnError();
          this.fire("loaded");
        }
      }
    }, this);

    if (this.options.zIndex) {
      this._updateZIndex();
    }

    this._reqest.send();
  },

  // Tiff解析後表示
  _getEPSG: function (txt) {
    /*
    "IMAGINE GeoTIFF Support
Copyright 1991 - 2006 by Leica Geosystems Geospatial Imaging, LLC. All Rights Reserved
@(#)$RCSfile: egtf.c $ IMAGINE 9.1 $Revision: 22.0 $ $Date: 2006/05/24 17:16:00 EST $
Unable to match Ellipsoid (Datum) to a GeographicTypeGeoKey value
Ellipsoid = GRS 1980
Datum = JGD2000"
*/
    var result = 4326;
    var m = txt.match(/Datum[\s]*=[\s]*(.+)/i);
    if (m) {
      switch (m[1]) {
        case "JGD2000":
          result = 2451;
          break;
        case "GRS 1980":
          result = 4019;

          break;

      }
    }

    return result;
  },

  _setImage: function (data) {

    var parser = GeoTIFF.parse(data);
    var image = parser.getImage();
    var geoKeys = image.getGeoKeys();
    var meta = image.getFileDirectory();
    var lng = meta.ModelTiepoint[3];
    var lat = meta.ModelTiepoint[4];
    var lngScale = meta.ModelPixelScale[0];
    var latScale = meta.ModelPixelScale[1];
    var imgW = meta.ImageWidth;
    var imgH = meta.ImageLength;

    var epsg = geoKeys.ProjectedCSTypeGeoKey || geoKeys.GeographicTypeGeoKey;
    if (epsg == 32767) {
      epsg = this._getEPSG(geoKeys.GeogCitationGeoKey);
    }

    var lat2 = lat - (latScale * imgH);
    var lng2 = lng + (lngScale * imgW);
    if (epsg != 4326) {

      var to = new Proj4js.Proj('EPSG:4326');
      var from = new Proj4js.Proj('EPSG:' + epsg);
      var formPoint = new Proj4js.Point(lng, lat);
      var toPoint = Proj4js.transform(from, to, formPoint);

      lat = toPoint.y;
      lng = toPoint.x;

      formPoint = new Proj4js.Point(lng2, lat2);
      toPoint = Proj4js.transform(from, to, formPoint);

      lat2 = toPoint.y;
      lng2 = toPoint.x;
    }

    this._bounds = L.latLngBounds([[lat, lng], [lat2, lng2]]);

    if (!this._image) {
      this._image = L.DomUtil.create('canvas',
        'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : '') +
        (this.options.className || ''));
    }

    image.readRGB(L.bind(function (samplesperPixcel, raster) {
      var canvas = this._image;
      canvas.style.position = "absolute";
      //canvas.style.zIndex = 1111111;

      canvas.width = image.getWidth();
      canvas.height = image.getHeight();
      var ctx = canvas.getContext("2d");
      var imageData = ctx.createImageData(image.getWidth(), image.getHeight());
      var data = imageData.data;
      var o = 0;
      var inc = (samplesperPixcel == 4 ? 4 : 3);
      for (var i = 0; i < raster.length; i += inc) {
        data[o] = raster[i];
        data[o + 1] = raster[i + 1];
        data[o + 2] = raster[i + 2];
        data[o + 3] = (inc == 4 ? raster[i + 3] : 255);
        o += 4;
      }
      ctx.putImageData(imageData, 0, 0);
    }, this, meta.SamplesPerPixel));

    this.fire("loaded");
  }
});

/*******************************************************

GSI.LayerTreeSearcher
    レイヤ検索

*******************************************************/
/*
GSI.LayerTreeSearcher = L.Evented.extend({

  options: {
    serchNum: 200
  },

  // 初期化
  initialize: function (input, mapManager) {
    L.setOptions(this, {});
    this._targetInput = input;
    this._mapManager = mapManager;
    this._queryString = "";

  },

  // 検索開始
  start: function () {
    if (!this._state)
      this._state = {};

    this._firstCheck = true;
    this._check();
  },

  // 検索ワード解析
  _parseQuery: function (q) {
    var result = $.trim(q).split(/\s+/);

    var noData = true;
    for (var i = 0; i < result.length; i++) {
      if (result[i] != "") {
        noData = false;
        break;
      }
    }

    return (noData ? [] : result);
  },

  // 検索ワードが一致するか
  _queryEquals: function (q1, q2) {
    if (!q1 && q2) return false;
    if (q1.length != q2.length) return false;

    for (var i = 0; i < q1.length; i++) {
      if (q1[i] != q2[i]) return false;
    }

    return true;

  },

  // 検索ワード入力欄変更チェック
  _check: function () {
    if (this._checkTimerId) clearTimeout(this._checkTimerId);
    this._checkTimerId = null;

    var q = this._targetInput.val();
    var queryList = this._parseQuery(this._targetInput.val());

    if (!this._queryEquals(this._state.queryList, queryList)) {
      this._state.queryList = queryList;
      this._search();
    }
    else if (this._firstCheck && this._state.result) {
      this.fire("focus");
      this._firstCheck = false;
    }

    this._checkTimerId = setTimeout(L.bind(function () {

      this._check();
    }, this), 500);
  },

  // 検索ワード入力欄変更チェック解除
  stop: function () {
    if (this._checkTimerId) clearTimeout(this._checkTimerId);
    this._checkTimerId = null;
  },

  // 検索開始
  _search: function () {
    this._stopSearch();
    if (this._state.queryList.length <= 0) {
      // 検索クリア
      delete this._state["result"];
      this.fire("clear");
      return;
    }
    this._state.result = [];
    this._state.resultHash = {};

    this._state.convertedQueryList = [];
    for (var i = 0; i < this._state.queryList.length; i++) {
      this._state.convertedQueryList.push(this._convertSearchString(this._state.queryList[i]));
    }

    if (!this._layerList) {
      this._layerList = [];
      this._createLayerList(this._layerList, this._mapManager._layersJSON.tree);
    }

    this._searching = true;
    this.fire("start");
    this._searchIndex = -1;
    this._searchNext();
  },

  // 検索終了
  _stopSearch: function () {

    if (this._loadEntriesRequest)
      this._loadEntriesRequest.abort();
    this._loadEntriesRequest = null;

    if (this._searchTimerId) clearTimeout(this._searchTimerId);
    this._searchTimerId = null;
    delete this._state["result"];

    if (this._searching)
      this.fire("finish", {});

    this._searching = false;
  },

  // layer情報等を検索用に整形
  _convertSearchItem: function (item) {

    if (!item._forSearch)
      item._forSearch = {};

    if (!item._forSearch.title)
      item._forSearch.title = this._convertSearchString(item.title);

    if (!item.tag || item.tag == "") return;
    var tags = $.trim(item.tag).split(/\s+/);
    if (!item._forSearch.tags) {
      item._forSearch.tags = [];
      for (var i = 0; i < tags.length; i++) {
        item._forSearch.tags.push(this._convertSearchString(tags[i]));
      }
    }
  },

  // 大文字小文字等区別しないように文字列を整形
  _convertSearchString: function (src) {

    src = src.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });
    var req;
    reg = /[！＂＃＄％＆＇（）＊＋，－．／：；＜＝＞？＠［＼］＾＿｀｛｜｝]/g;
    src = src.replace(reg, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    }).replace(/[‐－―]/g, '-');

    src = src.replace(/[～?]/g, '~');
    src = src.replace(/　/g, ' ');

    reg = new RegExp('(' + Object.keys(GSI.LayerTreeSearcher.hanKanaMap).join('|') + ')', 'g');
    src = src
      .replace(reg, function (match) {
        return GSI.LayerTreeSearcher.hanKanaMap[match];
      })
      .replace(/ﾞ/g, '゛')
      .replace(/ﾟ/g, '゜');

    return src.toLowerCase();
  },

  // 現在の検索ワードとヒットするか
  _hitCheck: function (item) {
    var queryList = [];

    for (var i = 0; i < this._state.convertedQueryList.length; i++) {
      queryList.push({
        q: this._state.convertedQueryList[i],
        hit: false
      });
    }

    // 親のチェック
    if (item.type != "LayerGroup" && item.parent) {

      for (var i = 0; i < queryList.length; i++) {
        var q = queryList[i]
        if (!item.parent._forSearch.title || !q.q) continue;
        if (item.parent._forSearch.title.indexOf(q.q) >= 0) {
          q.hit = true;
          continue;
        }
        if (item.parent._forSearch.tags) {
          for (var j = 0; j < item.parent._forSearch.tags.length; j++) {
            if (item.parent._forSearch.tags[j].indexOf(q.q) >= 0) {
              q.hit = true;
              break;
            }
          }
        }
      }
    }
    // チェック
    for (var i = 0; i < queryList.length; i++) {
      var q = queryList[i]
      if (!item._forSearch.title || !q.q) continue;
      if (item._forSearch.title.indexOf(q.q) >= 0) {
        q.hit = true;
        continue;
      }
      if (item._forSearch.tags) {
        for (var j = 0; j < item._forSearch.tags.length; j++) {
          if (item._forSearch.tags[j].indexOf(q.q) >= 0) {
            q.hit = true;
            break;
          }
        }
      }
    }

    var hit = true;
    for (var i = 0; i < queryList.length; i++) {
      if (!queryList[i].hit) {
        hit = false;
      }
    }

    if (!hit && item.layerType == "multiLayer" && item.entries) {
      for (var i = 0; i < item.entries.length; i++) {

        this._convertSearchItem(item.entries[i]);
        if (this._hitCheck(item.entries[i])) {

          hit = true;
          break;
        }
      }
    }

    return hit;
  },

  // 次を検索
  _searchNext: function () {
    if (this._searchTimerId) clearTimeout(this._searchTimerId);
    this._searchTimerId = null;

    this._searchIndex++;

    if (this._searchIndex >= this._layerList.length) {
      // 終了
      if (this._searching)
        this.fire("finish", { result: this._state.result });

      this._searching = false;
      return;
    }

    var len = this._layerList.length;
    var end = this._searchIndex + this.options.serchNum;
    var hitList = [];

    for (var i = this._searchIndex; i < end && i < this._layerList.length; i++) {

      var item = this._layerList[i];
      this._convertSearchItem(item);
      item._forSearch.hit = false;

      if (item.src && item.src != "" && !item.entries) {

        if (!this._loadEntries(item)) {
          this.fire("hit", { list: hitList, result: this._state.result });
          return;
        }
      }

      if (this._hitCheck(item)) {

        if (!this._state.result) {
          this._state.result = [];
          this._state.resultHash = {};
        }

        if (!item.id || item.id == "" || !this._state.resultHash[item.id]) {
          this._state.resultHash[item.id] = item;
          if (item.type == "LayerGroup" || !item.parent || !this._state.resultHash[item.parent.id]) {
            this._state.result.push(item);
            hitList.push(item);
          }

        }
        else
          this._state.resultHash[item.id] = item;
      }
      else
        item._forSearch.hit = false;

      this._searchIndex++;
    }

    this._searchIndex--;

    this.fire("hit", { list: hitList, result: this._state.result });

    this._searchTimerId = setTimeout(L.bind(this._searchNext, this), 100);

  },

  // 読み込んだlayersJsonをパース
  _parseLayers: function (data, item) {
    var json = JSON.parse(data);
    if (json.layers) {
      for (var i = 0; i < json.layers.length; i++) {
        json.layers[i].parent = item;
        json.layers[i].src_url = item.src_url;
      }

      item.entries = json.layers;
      this._mapManager._layersJSON._initializeTree(item.entries, item);
    }

    var list = [];
    this._createLayerList(list, item.entries, item);

    for (var i = list.length - 1; i >= 0; i--) {
      this._layerList.splice(this._searchIndex + 1, 0, list[i]);
    }
  },

  // srcがあれば読み込み
  _loadEntries: function (item) {

    if (!item.src_ && item.src.indexOf('./') == 0) {
      var path = item.src_url.substring(0, item.src_url.lastIndexOf('/'));
      item.src_ = true;
      item.src = path + "/" + item.src.substr(2);
    }

    if (GSI.GLOBALS.layersJSONCache &&
      GSI.GLOBALS.layersJSONCache[item.src]) {
      this._parseLayers(GSI.GLOBALS.layersJSONCache[item.src], item);

      return true;
    }

    this._loadEntriesRequest = $.ajax({
      type: "GET",
      url: item.src,
      dataType: "text",
      cache: true
    })
      .done(L.bind(function (item, data) {

        if (!GSI.GLOBALS.layersJSONCache) GSI.GLOBALS.layersJSONCache = {};
        GSI.GLOBALS.layersJSONCache[item.src] = data;
        this._parseLayers(data, item);

        this._searchIndex--;
      }, this, item))
      .fail(L.bind(function (item, data) {
        // スキップ
      }, this, item))
      .always(L.bind(function () {

        this._searchNext();

      }, this));

    return false;
  },

  // 検索しやすいようレイヤー一覧作成
  _createLayerList: function (result, list, parent) {
    if (!list) return;

    for (var i = 0; i < list.length; i++) {
      var item = list[i];
      result.push(item);
      if (!item.parent) item.parent = parent;

      if (item["type"] == "LayerGroup" && item.layerType != "multiLayer") {
        this._createLayerList(result, item.entries, item);
      }
    }
  }
});

// 半角全角の対応表
GSI.LayerTreeSearcher.hanKanaMap = {
  'ｶﾞ': 'ガ', 'ｷﾞ': 'ギ', 'ｸﾞ': 'グ', 'ｹﾞ': 'ゲ', 'ｺﾞ': 'ゴ',
  'ｻﾞ': 'ザ', 'ｼﾞ': 'ジ', 'ｽﾞ': 'ズ', 'ｾﾞ': 'ゼ', 'ｿﾞ': 'ゾ',
  'ﾀﾞ': 'ダ', 'ﾁﾞ': 'ヂ', 'ﾂﾞ': 'ヅ', 'ﾃﾞ': 'デ', 'ﾄﾞ': 'ド',
  'ﾊﾞ': 'バ', 'ﾋﾞ': 'ビ', 'ﾌﾞ': 'ブ', 'ﾍﾞ': 'ベ', 'ﾎﾞ': 'ボ',
  'ﾊﾟ': 'パ', 'ﾋﾟ': 'ピ', 'ﾌﾟ': 'プ', 'ﾍﾟ': 'ペ', 'ﾎﾟ': 'ポ',
  'ｳﾞ': 'ヴ', 'ﾜﾞ': '?', 'ｦﾞ': '?',
  'ｱ': 'ア', 'ｲ': 'イ', 'ｳ': 'ウ', 'ｴ': 'エ', 'ｵ': 'オ',
  'ｶ': 'カ', 'ｷ': 'キ', 'ｸ': 'ク', 'ｹ': 'ケ', 'ｺ': 'コ',
  'ｻ': 'サ', 'ｼ': 'シ', 'ｽ': 'ス', 'ｾ': 'セ', 'ｿ': 'ソ',
  'ﾀ': 'タ', 'ﾁ': 'チ', 'ﾂ': 'ツ', 'ﾃ': 'テ', 'ﾄ': 'ト',
  'ﾅ': 'ナ', 'ﾆ': 'ニ', 'ﾇ': 'ヌ', 'ﾈ': 'ネ', 'ﾉ': 'ノ',
  'ﾊ': 'ハ', 'ﾋ': 'ヒ', 'ﾌ': 'フ', 'ﾍ': 'ヘ', 'ﾎ': 'ホ',
  'ﾏ': 'マ', 'ﾐ': 'ミ', 'ﾑ': 'ム', 'ﾒ': 'メ', 'ﾓ': 'モ',
  'ﾔ': 'ヤ', 'ﾕ': 'ユ', 'ﾖ': 'ヨ',
  'ﾗ': 'ラ', 'ﾘ': 'リ', 'ﾙ': 'ル', 'ﾚ': 'レ', 'ﾛ': 'ロ',
  'ﾜ': 'ワ', 'ｦ': 'ヲ', 'ﾝ': 'ン',
  'ｧ': 'ァ', 'ｨ': 'ィ', 'ｩ': 'ゥ', 'ｪ': 'ェ', 'ｫ': 'ォ',
  'ｯ': 'ッ', 'ｬ': 'ャ', 'ｭ': 'ュ', 'ｮ': 'ョ',
  '｡': '。', '､': '、', 'ｰ': 'ー', '｢': '「', '｣': '」', '･': '・'
};

GSI.LayerTreeSearcher.ResultDialog = GSI.Dialog.extend({

  initialize: function (dialogManager, cocoTileLayer, options) {
    this._cocoTileLayer = cocoTileLayer;

    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);

    this.container.css({ "border": "1px solid #333" });
    this.headerFrame
      .addClass("gsi_layertreesearcher_resultdialog_header");
  },

  show: function () {
    GSI.Dialog.prototype.show.call(this);

  },
  afterShow: function () {
    this._dragEnd();
  },
  _dragEnd: function (e, ui) {
    this.headerFrame.css({ "color": "#333", "background-color": "#FFF" });
    GSI.Dialog.prototype._dragEnd.call(this, e, ui);
  },

  hide: function () {
    GSI.Dialog.prototype.hide.call(this);
    this.fire("hide");
  },
  createHeader: function () {
    return $('<span>').html('　　');
  },
  createContent: function () {

    this.frame = $('<div>').addClass("gsi_layertreesearcher_resultdialog_content");

    this._resultFrame = $("<div>").addClass("resultframe");
    this._resultListUL = $("<ul>").hide();

    this._resultFrame.append(this._resultListUL);
    this.frame.append(this._resultFrame);
    return this.frame;
  },

  clearSearch: function () {
    this._resultListUL.empty().hide();
    this.hide();
  },

  startSearch: function () {
    this._resultListUL.empty().hide();
    this.setTitle("検索中", "./image/system/loading003.gif");
    this.show();
  },

  showResultList: function () {
    this._resultListUL.show();
  },

  appendResult: function (list, all) {
    var cocoVisible = this._cocoTileLayer.getVisible();
    if (all && all.length > 0) this.showResultList();
    for (var i = 0; i < list.length; i++) {
      this._resultListUL.append(this._makeSearchResultItem(list[i]));
    }

    this.setTitle(
      "検索中" + (cocoVisible ? "(表示範囲) " : "") + ":" + (all ? this._resultListUL.find("li").not(".nococotile").length + "件" : ""),
      "./image/system/loading003.gif");

  },
  refreshResult: function () {
    var cocoVisible = this._cocoTileLayer.getVisible();
    var ul = this._resultListUL;

    var liList = ul.find("li");

    for (var i = 0; i < liList.length; i++) {
      var li = $(liList[i]);
      var item = li.data("item");
      if (!cocoVisible || !item.cocotile || item.hasTile)
        li.removeClass("nococotile");
      else
        li.addClass("nococotile");
    }
  },
  finishSearch: function () {

    var cocoVisible = this._cocoTileLayer.getVisible();
    var ul = this._resultListUL;
    var num = ul.find("li").not(".nococotile").length;
    this.setTitle("検索結果" + (cocoVisible ? "(表示範囲) " : "") + ":" + num + "件",
      "./image/system/info.png");

  },
  setTitle: function (title, img) {
    if (img) {

      this.headerTitle.css({
        "padding-left": "22px",
        "background-image": "url(" + img + ")",
        "background-position": "2px 50%",
        "background-repeat": "no-repeat"
      });
    }
    else {
      this.headerTitle.css({ "padding-left": "2px" });
    }
    this.headerTitle.html(title);
  },

  _makePankzu: function (target) {

    if (target._appendInfo) target = target._appendInfo;

    target = target.parent;
    var result = '';
    while (target) {
      result = target.title + (result == '' ? '' : '&gt;') + result;
      target = target.parent;
    }

    return result;
  },
  _makeSearchResultItem: function (item) {

    var cocoVisible = this._cocoTileLayer.getVisible();
    var li = $("<li>");

    li.data({ "item": item });

    if (!cocoVisible || !item.cocotile || item.hasTile)
      li.removeClass("nococotile");
    else
      li.addClass("nococotile");

    var a = $("<a>").attr({ "href": "javascript:void(0);" });

    var div = $("<div>").addClass("pankuzu").html(this._makePankzu(item));

    a.append(div);

    div = $("<div>").addClass("title").html(item.title);

    a.append(div);

    li.append(a);

    a.click(L.bind(function (item) {

      this.onItemClick(null, item)
      this._hideSearchResult();
    }, this, item));

    return li;
  }
});
*/
/*******************************************************

    ベクトルタイルCanvas描画

*******************************************************/

GSI.Canvas = {};

GSI.Canvas.Polyline = L.Polyline.extend({

  _isCanvas: true,

  _containsPoint: function (p, closed) {
    var i, j, k, len, len2, dist, part,
      w = this.options.weight / 2;
    if (!this._parts) return;

    if (L.Browser.touch) {
      w += 10; // polyline click tolerance on touch devices
    }

    for (i = 0, len = this._parts.length; i < len; i++) {
      part = this._parts[i];
      for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
        if (!closed && (j === 0)) {
          continue;
        }

        dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);

        if (dist <= w) {
          return true;
        }
      }
    }
    return false;
  }
});

GSI.Canvas.Polygon = L.Polygon.extend({

  _isCanvas: true,
  _containsPointPolyline: function (p, closed) {
    var i, j, k, len, len2, dist, part,
      w = this.options.weight / 2;
    if (!this._parts) return false;

    if (L.Browser.touch) {
      w += 10; // polyline click tolerance on touch devices
    }

    for (i = 0, len = this._parts.length; i < len; i++) {
      part = this._parts[i];
      for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
        if (!closed && (j === 0)) {
          continue;
        }

        dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);

        if (dist <= w) {
          return true;
        }
      }
    }
    return false;
  },

  _containsPoint: function (p) {
    var inside = false,
      part, p1, p2,
      i, j, k,
      len, len2;

    // TODO optimization: check if within bounds first

    if (!this._parts) return false;

    if (this._containsPointPolyline(p, true)) {
      // click on polygon border
      return true;
    }

    // ray casting algorithm for detecting if point is in polygon

    for (i = 0, len = this._parts.length; i < len; i++) {
      part = this._parts[i];

      for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
        p1 = part[j];
        p2 = part[k];

        if (((p1.y > p.y) !== (p2.y > p.y)) &&
          (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
          inside = !inside;
        }
      }
    }

    return inside;
  }
});

GSI.Canvas.PathProcs = {
  redraw: function () {
    if (this._map) {
      this.projectLatlngs();
      this._requestUpdate();
    }
    return this;
  },

  setStyle: function (style) {
    L.setOptions(this, style);

    return this;

  },

  onRemove: function (map) {

    map._pathRoot.removeChild(this._container);

    // Need to fire remove event before we set _map to null as the event hooks might need the object
    this.fire('remove');

    if (L.Browser.vml) {
      this._container = null;
      this._stroke = null;
      this._fill = null;
    }

    map.off({
      'viewreset': this.projectLatlngs,
      'moveend': this._updatePath
    }, this);

    if (L.Browser.canvas) {
      if (this.options.clickable) {
        this._map.off('click', this._onClick, this);
        this._map.off('mousemove', this._onMouseMove, this);
      }

      this._requestUpdate();
    }
    this._map = null;

  },

  _requestUpdate: function () {
    if (this._map && !L.Path._updateRequest) {
      L.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);
    }
  },

  _fireMapMoveEnd: function () {
    L.Path._updateRequest = null;
    this.fire('moveend');
  },

  _initElements: function () {

    if (L.Browser.canvas) {
      this._map._initPathRoot();
      this._ctx = this._map._canvasCtx;
    }

    return L.Polyline.prototype._initElements.call(this);
  },

  _updateStyle: function (scale) {
    if (L.Browser.canvas) {

      var options = this.options;
      if (options.stroke) {
        this._ctx.lineWidth = options.weight * (scale ? scale : 1);
        this._ctx.strokeStyle = options.color;
        if (options.lineCap &&
          (options.lineCap == "butt" ||
            options.lineCap == "round" ||
            options.lineCap == "square")
        ) {
          this._ctx.lineCap = options.lineCap;
        }
        else
          this._ctx.lineCap = "butt";
      }
      if (options.fill) {
        this._ctx.fillStyle = options.fillColor || options.color;
      }

    }
    else
      return L.Polyline.prototype._updateStyle.call(this);

  },

  _drawPolygonHole: function (offset) {

    var isPolygon = (this instanceof L.Polygon);

    if (!isPolygon || this._parts.length <= 1) return;

    var dashArray = null;
    var options = this.options;
    if (options.dashArray) {
      if (Array.isArray(options.dashArray))
        dashArray = $.extend([], options.dashArray);
      else {
        var dashParts = options.dashArray.split(',');
        dashArray = [];
        for (var i = 0; i < dashParts.length; i++) {
          dashArray.push(parseInt(dashParts[i]));
        }
      }
      if (dashArray.length < 2) dashArray = null;
    }

    if (!offset) offset = { x: 0, y: 0 };

    var i, j, len, len2, point;
    var ctx = this._ctx;
    for (i = 1, len = this._parts.length; i < len; i++) {
      ctx.beginPath();
      for (j = 0, len2 = this._parts[i].length; j < len2; j++) {
        point = this._parts[i][j];
        if (j == 0)
          ctx.moveTo(point.x - offset.x, point.y - offset.y);
        else {
          ctx.lineTo(point.x - offset.x, point.y - offset.y);
        }
      }
      ctx.closePath();
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.globalAlpha = 1;
      ctx.fill();

      if (options.stroke) {
        ctx.globalCompositeOperation = 'source-over';
        ctx.lineWidth = options.weight;
        ctx.strokeStyle = options.color;
        if (options.lineCap &&
          (options.lineCap == "butt" ||
            options.lineCap == "round" ||
            options.lineCap == "square")
        ) {
          ctx.lineCap = options.lineCap;
        }
        else
          ctx.lineCap = "butt";
        ctx.globalAlpha = options.opacity;
        ctx.stroke();

      }

      ctx.restore();
    }
  },
  _drawPath: function (offset) {
    var options = this.options;
    var dashArray = null;
    var isPolygon = (this instanceof L.Polygon);
    if (options.dashArray) {
      if (Array.isArray(options.dashArray))
        dashArray = $.extend([], options.dashArray);
      else {
        var dashParts = options.dashArray.split(',');
        dashArray = [];
        for (var i = 0; i < dashParts.length; i++) {
          dashArray.push(parseInt(dashParts[i]));
        }
      }
      if (dashArray.length < 2) dashArray = null;
    }
    var i, j, len, len2, point, drawMethod;

    if (!offset) offset = { x: 0, y: 0 };

    len = (this._parts.length > 0 ? 1 : 0);
    if (!isPolygon) len = this._parts.length;
    for (i = 0; i < len; i++) {
      this._ctx.beginPath();
      for (j = 0, len2 = this._parts[i].length; j < len2; j++) {
        point = this._parts[i][j];
        var toPoint = {
          x: point.x - offset.x,
          y: point.y - offset.y
        };

        if (j == 0) {
          this._ctx.moveTo(toPoint.x, toPoint.y);
        }
        else {
          if (dashArray && !isPolygon)
            GSI.Utils.dotLineTo(this._ctx, fromPoint.x, fromPoint.y,
              toPoint.x, toPoint.y, dashArray);
          else {
            if (this._ctx.setLineDash !== undefined)
              this._ctx.setLineDash([]);
            else if (this._ctx.mozDash !== undefined)
              this._ctx.mozDash = [];
            this._ctx.lineTo(toPoint.x, toPoint.y);
          }
        }

        fromPoint = toPoint;

      }
      // TODO refactor ugly hack
      if (isPolygon) {
        this._ctx.closePath();

      }
    }
  },

  _checkIfEmpty: function () {
    return !this._parts.length;
  },

  _latLngTileToPoint: function (tilePoint, canvasDx, canvasDy, zoom, tileSize, resolution, originShift, latLng) {

    var X = latLng.lng * (Math.PI / 180);
    var Y = Math.log(Math.tan(Math.PI / 4 + latLng.lat * (Math.PI / 180) / 2));
    var tx = (X + originShift) / (tileSize * resolution);
    var ty = (Y + originShift) / (tileSize * resolution);
    ty = Math.pow(2, zoom) - ty;
    tx = (tx - tilePoint.x) * tileSize + canvasDx;
    ty = (ty - tilePoint.y) * tileSize + canvasDy;
    return L.point(tx, ty);
  },

  projectLatlngs: function (tilePoint, canvasDx, canvasDy, zoom, tileSize, resolution, originShift) {
    if (!originShift) return;

    this._originalPoints = [];

    if (L.LineUtil.isFlat(this._latlngs)) {
      for (var i = 0, len = this._latlngs.length; i < len; i++) {
        this._originalPoints[i] = this._latLngTileToPoint(
          tilePoint, canvasDx, canvasDy, zoom, tileSize, resolution, originShift, this._latlngs[i]);
      }
    }
    else {
      for (var i = 0, len = this._latlngs.length; i < len; i++) {
        this._originalPoints[i] = [];
        for (var j = 0, len2 = this._latlngs[i].length; j < len2; j++) {
          this._originalPoints[i][j] = this._latLngTileToPoint(
            tilePoint, canvasDx, canvasDy, zoom, tileSize, resolution, originShift, this._latlngs[i][j]);
        }
      }
    }
  },
  _updatePath: function (offset) {
    if (!this._map) { return; }
    if (this.options.visible == false) return;

    if (L.LineUtil.isFlat(this._latlngs))
      this._parts = [this._originalPoints];
    else
      this._parts = this._originalPoints;

    this._simplifyPoints();

    if (this._checkIfEmpty()) { return; }

    var ctx = this._ctx, options = this.options;

    try { this._drawPath(offset); } catch (e) { console.log(e); }
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    this._updateStyle();

    if (options.fill) {
      ctx.globalAlpha = options.fillOpacity;
      ctx.fill();
    }

    if (options.stroke) {
      ctx.globalAlpha = options.opacity;
      ctx.stroke();
    }

    ctx.restore();

    //中抜き
    try { this._drawPolygonHole(offset); } catch (e) { console.log(e); }

  },

  _onClick: function (e) {
    if (this._containsPoint(e.layerPoint)) {
      this.fire('click', e);
    }
  },

  _onMouseMove: function (e) {
    if (!this._map || !this._map._pathRoot || this._map._animatingZoom) { return; }

    // TODO don't do on each move
    if (this._containsPoint(e.layerPoint)) {
      this._map._pathRoot.style.cursor = 'pointer';
      this._mouseInside = true;
      this.fire('mouseover', e);

    } else if (this._mouseInside) {
      this._map._pathRoot.style.cursor = '';
      this._mouseInside = false;
      this.fire('mouseout', e);
    }
  }
};

GSI.Canvas.Polyline.include(GSI.Canvas.PathProcs);
GSI.Canvas.Polygon.include(GSI.Canvas.PathProcs);

GSI.Canvas.MultiPolyline = L.FeatureGroup.extend({
  initialize: function (latlngs, options) {
    this._isCanvas = true;
    this._layers = {};
    this._options = options;
    this.setLatLngs(latlngs);
  },

  setLatLngs: function (latlngs) {
    var i = 0,
      len = latlngs.length;

    this.eachLayer(function (layer) {
      if (i < len) {
        layer.setLatLngs(latlngs[i++]);
      } else {
        this.removeLayer(layer);
      }
    }, this);

    while (i < len) {
      var layer = new GSI.Canvas.Polyline(latlngs[i++], this._options);
      this.addLayer(layer);
    }

    return this;
  },

  getLatLngs: function () {
    var latlngs = [];

    this.eachLayer(function (layer) {
      latlngs.push(layer.getLatLngs());
    });

    return latlngs;
  }
});

GSI.Canvas.MultiPolygon = L.FeatureGroup.extend({
  initialize: function (latlngs, options) {
    this._isCanvas = true;
    this._layers = {};
    this._options = options;
    this.setLatLngs(latlngs);
  },

  setLatLngs: function (latlngs) {
    var i = 0,
      len = latlngs.length;

    this.eachLayer(function (layer) {
      if (i < len) {
        layer.setLatLngs(latlngs[i++]);
      } else {
        this.removeLayer(layer);
      }
    }, this);

    while (i < len) {
      var layer = new GSI.Canvas.Polygon(latlngs[i++], this._options);
      this.addLayer(layer);
    }

    return this;
  },

  getLatLngs: function () {
    var latlngs = [];

    this.eachLayer(function (layer) {
      latlngs.push(layer.getLatLngs());
    });

    return latlngs;
  }
});
GSI.Canvas.multiPolyline = function (latlngs, options) {
  return new GSI.Canvas.MultiPolyline(latlngs, options);
};

GSI.Canvas.multiPolygon = function (latlngs, options) {
  return new GSI.Canvas.MultiPolygon(latlngs, options);
};

L.DivIcon.prototype._setIconStyles = function (img, name) {
  var options = this.options,
    size = L.point(options[name + 'Size']),
    anchor;

  var div = $(img).children("div");

  if (div.length > 0 && div.find("img").length <= 0) {
    // 斜体時に右端がかけるので無理矢理大きく
    var cssText = (div.prop("style") ? div.prop("style").cssText : "");
    var angle90 = div.css("writing-mode")
      || div.css("-moz-writing-mode") || div.css("-o-writing-mode")
      || div.css("-ms-writing-mode") || div.css("-webkit-writing-mode");
    if (angle90) angle90 = (angle90) ? angle90.trim() : '';
    else {
      var matches = cssText.match(/vertical-rl/);
      if (matches) angle90 = "vertical-rl";
    }

    var fontStyle = div.css("font-style") || "normal";

    if (size && angle90 && angle90 != "" && (fontStyle != "" && fontStyle != "normal")) {
      if (size) size = L.point(12, 12);//{x:12, y:12};
      if (div.css("font-size")) {
        size.x = Math.ceil(parseInt(div.css("font-size")) * 1.5);
      } else
        size.x = 300;
    }
  }

  if (name === 'shadow') {
    anchor = L.point(options.shadowAnchor || options.iconAnchor);
  } else {
    anchor = L.point(options.iconAnchor);
  }

  if (!anchor && size) {
    anchor = size.divideBy(2, true);
  }

  img.className = 'leaflet-marker-' + name + ' ' + options.className;

  if (anchor) {
    img.style.marginLeft = (-anchor.x) + 'px';
    img.style.marginTop = (-anchor.y) + 'px';
  }

  if (size) {
    img.style.width = size.x + 'px';
    img.style.height = size.y + 'px';
  }
};

GSI.Canvas.GeoJSON = L.GeoJSON.extend({

  addData: function (geojson) {
    var features = L.Util.isArray(geojson) ? geojson : geojson.features,
      i, len, feature;

    if (features) {
      for (i = 0, len = features.length; i < len; i++) {
        // Only add this if geometry or geometries are set and not null
        feature = features[i];
        if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
          this.addData(features[i]);
        }
      }
      return this;
    }

    var options = this.options;

    if (options.filter && !options.filter(geojson)) { return; }

    var layer = GSI.Canvas.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);

    layer.feature = L.GeoJSON.asFeature(geojson);

    layer.defaultOptions = layer.options;
    this.resetStyle(layer);

    if (options.onEachFeature) {
      options.onEachFeature(geojson, layer);
    }

    return this.addLayer(layer);
  }
});

GSI.Canvas.GeoJSON.coordsToLatLng = function (coords) { // (Array[, Boolean]) -> LatLng
  return new L.LatLng(coords[1], coords[0], coords[2]);
};

GSI.Canvas.GeoJSON.coordsToLatLngs = function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array
  var latlng, i, len,
    latlngs = [];

  for (i = 0, len = coords.length; i < len; i++) {
    latlng = levelsDeep ?
      GSI.Canvas.GeoJSON.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
      (coordsToLatLng || GSI.Canvas.GeoJSON.coordsToLatLng)(coords[i]);

    latlngs.push(latlng);
  }

  return latlngs;
};

GSI.Canvas.GeoJSON.geometryToLayer = function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {
  var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
    coords = geometry.coordinates,
    layers = [],
    latlng, latlngs, i, len;

  coordsToLatLng = coordsToLatLng || this.coordsToLatLng;

  switch (geometry.type) {
    case 'Point':
      latlng = coordsToLatLng(coords);
      return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

    case 'MultiPoint':
      for (i = 0, len = coords.length; i < len; i++) {
        latlng = coordsToLatLng(coords[i]);
        layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
      }
      return new L.FeatureGroup(layers);

    case 'LineString':
      latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);
      return new GSI.Canvas.Polyline(latlngs, vectorOptions);

    case 'Polygon':

      if (coords.length === 2 && !coords[1].length) {
        throw new Error('Invalid GeoJSON object.');
      }
      latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
      return new GSI.Canvas.Polygon(latlngs, vectorOptions);

    case 'MultiLineString':

      latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);

      return new GSI.Canvas.MultiPolyline(latlngs, vectorOptions);

    case 'MultiPolygon':
      latlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);
      return new GSI.Canvas.MultiPolygon(latlngs, vectorOptions);

    case 'GeometryCollection':
      for (i = 0, len = geometry.geometries.length; i < len; i++) {

        layers.push(this.geometryToLayer({
          geometry: geometry.geometries[i],
          type: 'Feature',
          properties: geojson.properties
        }, pointToLayer, coordsToLatLng, vectorOptions));
      }
      return new L.FeatureGroup(layers);

    default:
      throw new Error('Invalid GeoJSON object.');
  }
};

GSI.Canvas.geoJson = function (geojson, options) {
  return new GSI.Canvas.GeoJSON(geojson, options);
};

/************************************************************************
 GSI.AddrLoader
************************************************************************/
GSI.AddrLoader = L.Evented.extend({

  initialize: function (map, options) {
    this._url = 'https://cyberjapandata.gsi.go.jp/xyz/lv01_plg/14/{x}/{y}.geojson';
  },

  cancel: function () {
    if (this._request) {
      this._request.abort();
      this._request = null;
    }
  },

  destroy: function () {
    this.clearEvents();
    this.cancel();
  },

  load: function (pos) {
    this.cancel();

    var tileInfo = this._getTileInfo(pos.lat, pos.lng, 14);

    var url = this._url;
    url = url.replace("{x}", tileInfo.x).replace("{y}", tileInfo.y)

    $.ajax({
      type: "GET",
      dataType: "JSON",
      url: url
    })
      .done(L.bind(this._onLoad, this, url, pos, tileInfo))
      .fail(L.bind(this._onLoadError, this, pos, tileInfo));

  },

  _onLoad: function (url, pos, tileInfo, e) {
    this._request = null;
    var data = e;

    var hitFeature = null;
    if (data && data.features) {
      var targetPos = [pos.lng, pos.lat];
      for (var i = 0; i < data.features.length; i++) {
        var feature = data.features[i];
        if (!feature.geometry || !feature.geometry.coordinates) continue;

        var coords = feature.geometry.coordinates;
        if (feature.geometry.type != "MultiPolygon") {
          coords = [coords];
        }

        for (var j = 0; j < coords.length; j++) {
          var ret = null;

          ret = this._isPointInPolygon(targetPos, coords[j][0]);
          if (ret) {
            for (var k = 1; k < coords[j].length; k++) {
              // くりぬきポリゴン内なら×
              var ret2 = this._isPointInPolygon(targetPos, coords[j][k]);
              if (ret2) {
                ret = false;
                break;
              }
            }
            if (ret) {
              hitFeature = feature;
              break;
            }
          }
        }
        if (hitFeature) break;
      }

    }

    var title = "";
    var titleYomi = null;
    var titleEng = null;
    if (hitFeature) {

      var properties = hitFeature.properties;
      try {
        title = properties["pref"] + properties["muni"];
        if (properties["LV01"]){
          title += properties["LV01"];
        }

        //読み
        titleYomi = properties["pref_kana"] + properties["muni_kana"];
        if (properties["Lv01_kana"]){
          titleYomi += properties["Lv01_kana"];
        }

      } catch (ex) {
        console.log(ex);
      }

    }
    this.fire("load", { "feature": hitFeature, "title": title, "titleYomi": titleYomi, "titleEng": titleEng });
  },

  _isPointInPolygon: function (point, polygon) {
    var wn = 0;

    for (var i = 0; i < polygon.length - 1; i++) {
      if ((polygon[i][1] <= point[1]) && (polygon[i + 1][1] > point[1])) {
        var vt = (point[1] - polygon[i][1]) / (polygon[i + 1][1] - polygon[i][1]);
        if (point[0] < (polygon[i][0] + (vt * (polygon[i + 1][0] - polygon[i][0])))) {

          ++wn;

        }
      }
      else if ((polygon[i][1] > point[1]) && (polygon[i + 1][1] <= point[1])) {
        var vt = (point[1] - polygon[i][1]) / (polygon[i + 1][1] - polygon[i][1]);
        if (point[0] < (polygon[i][0] + (vt * (polygon[i + 1][0] - polygon[i][0])))) {

          --wn;

        }
      }
    }
    return (wn != 0);

  },

  _onLoadError: function (tileInfo, e) {
    this.fire("load", {});
  },

  _getTileInfo: function (lat, lng, z) {
    var lng_rad = lng * Math.PI / 180;
    var R = 128 / Math.PI;
    var worldCoordX = R * (lng_rad + Math.PI);
    var pixelCoordX = worldCoordX * Math.pow(2, z);
    var tileCoordX = Math.floor(pixelCoordX / 256);

    var lat_rad = lat * Math.PI / 180;
    var worldCoordY = - R / 2 * Math.log((1 + Math.sin(lat_rad)) / (1 - Math.sin(lat_rad))) + 128;
    var pixelCoordY = worldCoordY * Math.pow(2, z);
    var tileCoordY = Math.floor(pixelCoordY / 256);

    return {
      x: tileCoordX,
      y: tileCoordY,
      pX: Math.floor(pixelCoordX - tileCoordX * 256),
      pY: Math.floor(pixelCoordY - tileCoordY * 256)
    };

  }
});

/************************************************************************
 L.Class
 - GSI.MapLayerList（表示レイヤー管理）
 ************************************************************************/
GSI.MapLayerList = L.Evented.extend({
  initialize: function (gsimaps, mapManager, map, options) {
    this.tileList = [];
    this.list = [];
    this._gsimaps = gsimaps;
    this._mapManager = mapManager;
    this._elevationData = GSI.ReliefTileLayer.getElevationSampleData();
    this.map = map;
    options = L.setOptions(this, options);
  },

  getElevationData: function () {
    return (this._elevationData ? $.extend(true, {}, this._elevationData) : null);
  },

  setElevationData: function (data) {
    if (!data)
      this._elevationData = data;
    else
      this._elevationData = $.extend(true, {}, data);
    for (var i = 0; i < this.tileList.length; i++) {
      var info = this.tileList[i];
      if (info._visibleInfo && info._visibleInfo.layer && info._visibleInfo.layer.setElevationData)
        info._visibleInfo.layer.setElevationData(this._elevationData);
    }

  },

  getOutsideTileList : function() {

    var result = [];
    for (var i = 0; i < this.tileList.length; i++) {
      if (this.tileList[i]._isOutside) {
        result.push(this.tileList[i]);
      }
    }
    return result;

  },

  hasOutsideTile : function() {

    var hasOutsideTile = false;
    for (var i = 0; i < this.tileList.length; i++) {
      if (this.tileList[i]._isOutside) {
        hasOutsideTile = true;
        break;
      }
    }
    return hasOutsideTile;

  },

  hasComparePhotoTile : function() {

    var result = false;
    for (var i = 0; i < this.tileList.length; i++) {
      if (this.tileList[i]._isComparePhoto) {
        result = true;
        break;
      }
    }
    return result;

  },

  appendKML: function (info) {
    if (this.exists(info)) return;
    this.map.addLayer(info._visibleInfo.layer, true);
    this.list.unshift(info);
    this._initZIndex(this.list);
  },
  appendList: function (infoList, isHide) {

    for (var i = 0; i < infoList.length; i++) {
      this.append(infoList[i], true, isHide);
    }
  },

  // 202303 isHideを追加
  appendComparePhoto : function(layerInfo, isHide) {
    if ( this.hasComparePhotoTile() ) return;

    var info = $.extend({
      id: CONFIG.COMPAREPHOTO_ID,
      title: "時系列表示"
    },{});
    info._visibleInfo = {};
    info._visibleInfo.opacity = 1.0;
    info._isComparePhoto = true;
    info._visibleInfo.layer = new GSI.ComparePhotoLayer(this._mapManager,false, undefined, layerInfo);
    if (isHide) info._visibleInfo._isHidden = true;

    info._visibleInfo.layer.on("change", L.bind(function(info){
      var title = info._visibleInfo.layer.getActiveTitle();
      var layerInfo = info._visibleInfo.layer.getLayerInfo();
      if ( layerInfo.minZoom && layerInfo.minZoom > this.map.getZoom() ) {
        title = null;
      }
      info.title = (title ? "時系列表示("+ title + ")" : "時系列表示" );
      this.fire('change');
    },this, info));

    var title = info._visibleInfo.layer.getActiveTitle();
    if ( layerInfo.minZoom && layerInfo.minZoom > this.map.getZoom() ) {
      title = null;
    }
    if ( title ) info.title += "("+ title + ")";

    this.map.addLayer(info._visibleInfo.layer, true, info._visibleInfo.blend);
    GSI.Utils.setMixBlendMode(info, info._visibleInfo.blend);
    this.tileList.unshift(info);
    this._initZIndex(this.tileList);

    // 202303 hideの場合は非表示
    if (isHide) {
      this._mapManager.getMap().removeLayer(info._visibleInfo.layer);
    }

    this.fire('change');

  },

  appendOutSideTile: function (url, caption, layerOptions) {
    if (!layerOptions) layerOptions = {};
    var info = $.extend({
      id: "o_u_t_s_i_d_e_" + GSI.Utils.getNextOutsideTileNo(),
      title: caption,
      url: url
    }, layerOptions);
    info._visibleInfo = {};
    info._visibleInfo.opacity = 1.0;
    info._isOutside = true;

    var options = {
      errorTileUrl: '',
    };
    if (layerOptions.subdomains && layerOptions.subdomains != "") {
      options.subdomains = layerOptions.subdomains;
    }
    if ((layerOptions.minZoom == 0 || layerOptions.minZoom) && layerOptions.minZoom != "") options.minZoom = layerOptions.minZoom;
    if ((layerOptions.maxZoom == 0 || layerOptions.maxZoom) && layerOptions.maxZoom != "") options.maxZoom = layerOptions.maxZoom;
    if (layerOptions.maxNativeZoom && layerOptions.maxNativeZoom != "") options.maxNativeZoom = layerOptions.maxNativeZoom;
    if (layerOptions.attribution) options.attribution = layerOptions.attribution;
    if (layerOptions.bounds && layerOptions.bounds != "") options.bounds = layerOptions.bounds;
    if (layerOptions.tms) options.tms = layerOptions.tms;

    //options.tms = true;
    info._visibleInfo.layer = new GSI.TileLayer(info.url, options);

    this.map.addLayer(info._visibleInfo.layer, true, info._visibleInfo.blend);
    GSI.Utils.setMixBlendMode(info, info._visibleInfo.blend);
    this.tileList.unshift(info);
    this._initZIndex(this.tileList);

    this.fire('change');
  },

  updateTileLayer: function (info) {
    for (var i = 0; i < this.tileList.length; i++) {
      if (info == this.tileList[i]) {
        var options = $.extend(true, {}, info._visibleInfo.layer.options);
        delete options["minZoom"];
        delete options["maxZoom"];
        delete options["maxNativeZoom"];
        delete options["tms"];

        if ((info.minZoom == 0 || info.minZoom) && info.minZoom != "") options.minZoom = info.minZoom;
        if ((info.maxZoom == 0 || info.maxZoom) && info.maxZoom != "") options.maxZoom = info.maxZoom;
        if (info.maxNativeZoom && info.maxNativeZoom != "") options.maxNativeZoom = info.maxNativeZoom;

        options.tms = info.tms;

        info._visibleInfo.layer.setOptions(options);
        info._visibleInfo.layer.setUrl(info.url);
      }
    }
    this.fire('change');
  },

  _showConfirm: function (id, title, msg, info, noFinishMove, isHide, blend) {
    if (GSI._confirmOkList && GSI._confirmOkList[id]) {
      this.append(info, noFinishMove, isHide, 1, blend);
      return;
    }
    if (!GSI._confirmList) GSI._confirmList = [];

    var len = GSI._confirmList.length;

    GSI._confirmList.push({
      "id": id,
      "msg": msg,
      "title": title,
      "info": info,
      "noFinishMove": noFinishMove,
      "isHide": isHide,
      "blend": blend,
      "$this": this
    });

    if (len <= 0) {
      this._showNextConfirm();
    }

  },

  _showNextConfirm: function () {
    if (GSI._confirmList.length <= 0) return;

    var confirm = GSI._confirmList[0];

    var $this = confirm["$this"];
    if (GSI._confirmOkList && GSI._confirmOkList[confirm.id]) {
      $this.append(confirm.info, confirm.noFinishMove, confirm.isHide, 1, confirm.blend);
      GSI._confirmList.shift();
      $this._showNextConfirm();
      return;
    }

    jConfirm(confirm.msg, confirm.title, L.bind(function (confirm, r) {
      GSI._confirmList.shift();

      if (r) {

        this.append(confirm.info, confirm.noFinishMove, confirm.isHide, 1, confirm.blend);
        if (!GSI._confirmOkList) GSI._confirmOkList = {};
        GSI._confirmOkList[confirm.id] = true;
      }

      this._showNextConfirm();
    }, $this, confirm));
  },

  append: function (info, noFinishMove, isHide, Confirm_FLAG, blend) {
    
    if (this.exists(info)) return;
    info._appendInfo = null;

    if (this._mapManager._layersJSON.layersHash[info.id] &&
      this._mapManager._layersJSON.layersHash[info.id] != info &&
      !this._mapManager._layersJSON.layersHash[info.id].isMultiLayerChild) {
      var oldInfo = info;
      info = this._mapManager._layersJSON.layersHash[info.id];
      info._appendInfo = oldInfo;
    }

    // 時系列表示
    if ( info.id == CONFIG.COMPAREPHOTO_ID ) {
      this.appendComparePhoto(info, isHide);
      return;
    }

    // 確認画面が必要なレイヤー
    if (Confirm_FLAG == null) {
      var hit = false;
      for (var confirmId in CONFIG.CONFIRM_LAYERS) {
        var confirmItem = CONFIG.CONFIRM_LAYERS[confirmId];
        if (confirmItem.layers && confirmItem.layers.indexOf(info.id) >= 0) {
          this._showConfirm(confirmId, confirmItem.title, confirmItem.message, info, noFinishMove, isHide, confirmItem.withBlend ? blend : undefined);
          hit = true;
        }
      }

      if (hit) return;
    }
    info._visibleInfo = {};
    info._visibleInfo.opacity = (info.initialOpacity ? info.initialOpacity : 1.0);
    if (isHide) info._visibleInfo._isHidden = true;

    if ((blend === undefined) || (blend == null)) {
      info._visibleInfo.blend = false;
    }
    else {
      info._visibleInfo.blend = (blend == "1" ? true : false);
    }
    info.initialOpacity = null;

    info._visibleInfo.layer = GSI.Utils.infoToLayer(info, noFinishMove);

    if (info._visibleInfo.layer) {
      if (info._visibleInfo.layer.setElevationData)
        info._visibleInfo.layer.setElevationData(this._elevationData);

      if ( info.parent && info.parent != null && info.parent.title_sys == CONFIG.layerBaseFolderSYS ) {

        if (!info._visibleInfo._isHidden) {
          info._visibleInfo.grayscale = this._mapManager._baseLayer.isGrayScale;
          this._mapManager._baseLayer.setActiveId(info.id);
          // 202303
          this._mapManager._map.addLayer(this._mapManager._baseLayer);
        }
        else {
          // 202303
          this._mapManager.getMap().removeLayer(this._mapManager._baseLayer);
        }
        this.tileList.push(info);
        this._initZIndex(this.tileList);

      } else if (info.layerType == "tile" ) {
        if (!info._visibleInfo._isHidden) {
          this.map.addLayer(info._visibleInfo.layer, true, info._visibleInfo.blend);
          GSI.Utils.setMixBlendMode(info, info._visibleInfo.blend);
        }
        this.tileList.unshift(info);

        this._initZIndex(this.tileList);
      }
      else if (info.layerType == "kml") {
        // KML
        info._visibleInfo.layer.on("loadstart", L.bind(this.onLayerLoadStart, this, info._visibleInfo.layer, "KML"));
        info._visibleInfo.layer.on("loaded", L.bind(this.onLayerLoad, this, info._visibleInfo.layer));
        info._visibleInfo.layer.load();

        if (!info._visibleInfo._isHidden) this.map.addLayer(info._visibleInfo.layer, true);

        this.list.unshift(info);
        this._initZIndexOffset(this.list, 10000);
      }
      else if (info.layerType == "geojson") {
        // GeoJSON
        info._visibleInfo.layer.on("loadstart", L.bind(this.onLayerLoadStart, this, info._visibleInfo.layer, "GeoJSON"));
        info._visibleInfo.layer.on("load", L.bind(function (e) { this.onLayerLoad(e.src) }, this));
        info._visibleInfo.layer.load();

        if (!info._visibleInfo._isHidden) this.map.addLayer(info._visibleInfo.layer);

        this.list.unshift(info);
        this._initZIndexOffset(this.list, 10000);

      }
      else if (info.layerType == "geojson_tile") {
        // タイルGeoJSON
        if (!info._visibleInfo._isHidden) this.map.addLayer(info._visibleInfo.layer, true);

        this.list.unshift(info);
        this._initZIndexOffset(this.list, 10000);
      }
      else if (info.layerType == "topojson_tile") {
        // タイルTopoJSON
        if (!info._visibleInfo._isHidden) this.map.addLayer(info._visibleInfo.layer, true);
        this.list.unshift(info);
        this._initZIndexOffset(this.list, 10000);
      }
      else if (info.layerType == "topojson") {
        // TopoJSON
        info._visibleInfo.layer.on("loadstart", L.bind(this.onLayerLoadStart, this, info._visibleInfo.layer, "TopoJSON"));
        info._visibleInfo.layer.on("load", L.bind(function (e) { this.onLayerLoad(e.src) }, this));
        info._visibleInfo.layer.load();
        if (!info._visibleInfo._isHidden) this.map.addLayer(info._visibleInfo.layer);

        this.list.unshift(info);
        this._initZIndexOffset(this.list, 10000);
      }
      else if (info.layerType == "tms") {
        // TMS

        if (!info._visibleInfo._isHidden) this.map.addLayer(info._visibleInfo.layer, true);
        this.tileList.unshift(info);
        this._initZIndex(this.tileList);
      }
      else if (info.layerType == "multiLayer") {
        // 複数レイヤ
        info._visibleInfo.layer.on("loadstart", L.bind(this.onLayerLoadStart, this, info._visibleInfo.layer, "MultiLayer"));
        info._visibleInfo.layer.on("load", L.bind(function (e) { this.onLayerLoad(e.src) }, this));
        info._visibleInfo.layer.load();
        if (!info._visibleInfo._isHidden) this.map.addLayer(info._visibleInfo.layer);

        this.list.unshift(info);
        this._initZIndexOffset(this.list, 10000);

      }
      else if (info.layerType == "geotiff") {
        // GEOTIFF
        if (!info._visibleInfo._isHidden) this.map.addLayer(info._visibleInfo.layer, true);

        info._visibleInfo.layer.on("loadstart", L.bind(this.onLayerLoadStart, this, info._visibleInfo.layer, "KML"));
        info._visibleInfo.layer.on("loaded", L.bind(this.onLayerLoad, this, info._visibleInfo.layer));

        this.list.unshift(info);
        this._initZIndexOffset(this.list, 10000);
      }
      else if (info.layerType == "videooverlay") {
        // VideoOverlay
        if (!info._visibleInfo._isHidden) this.map.addLayer(info._visibleInfo.layer, true);

        this.list.unshift(info);
        this._initZIndexOffset(this.list, 10000);
        this.onLayerLoad(info._visibleInfo.layer);
      }
      else if (info.layerType == "pmtiles") {
        // PMTiles
        info._visibleInfo.layer.on("loadstart", L.bind(this.onLayerLoadStart, this, info._visibleInfo.layer, "PMTiles"));
        info._visibleInfo.layer.on("load", L.bind(function (e) { this.onLayerLoad(e.src) }, this));

        if (!info._visibleInfo._isHidden) this.map.addLayer(info._visibleInfo.layer);

        this.list.unshift(info);
        this._initZIndexOffset(this.list, 10000);
      }
    }

    if (info._visibleInfo.layer) {
      if (info.parent && info.parent != null && info.parent.title_sys == CONFIG.layerBaseFolderSYS) {
        this._mapManager._baseLayer.setOpacity(info._visibleInfo.opacity);
      }
      else {
        if (info._visibleInfo.layer.setOpacity) {
          info._visibleInfo.layer.setOpacity(info._visibleInfo.opacity);
        }
        else {
          var opacitySetter = new GSI.LayerOpacitySetter();
          opacitySetter.setOpacity(info._visibleInfo.layer, info._visibleInfo.opacity);
        }
      }
    }

    this.fire('change');
  },
  _showLoading: function (title) {
    if (!this._showLoadingInc || this._showLoadingInc == 0) {
      this._showLoadingInc = 0;
      GSI.Modal.LoadingMessage.show('ファイルを読み込んでいます...');
    }
    this._showLoadingInc++;
  },
  _hideLoading: function () {
    this._showLoadingInc--;
    if (this._showLoadingInc <= 0)
      GSI.Modal.LoadingMessage.hide();
  },
  onLayerLoadStart: function (layer, title) {
    this._showLoading(title);
  },
  onLayerLoad: function (layer) {
    if (!layer._noFinishMove && layer.getBounds) {
      try {
        this.map.fitBounds(layer.getBounds());
      }
      catch (e) { }
    }
    this._hideLoading();
  },
  _initZIndexOffset: function (list, offset) {
    var zIndex = offset;

    for (var i = list.length - 1; i >= 0; i--) {
      var info = list[i];
      if (info._visibleInfo.layer) {
        if (info._visibleInfo.layer.setMarkerZIndex) {
          info._visibleInfo.layer.setMarkerZIndex(zIndex);
          zIndex += 1;
        }
      }
    }
  },
  _initZIndex: function (list) {
    var zIndex = 100;
    for (var i = list.length - 1; i >= 0; i--) {
      var info = list[i];
      if (info._visibleInfo.layer) {
        if (info._visibleInfo.layer.setZIndex) {
          info._visibleInfo.layer.setZIndex(zIndex);
          zIndex++;
        }
      }
    }
  },
  refreshTileList: function (list) {
    this.tileList = list;
    this._initZIndex(this.tileList);
  },
  exists: function (info) {
    var tile = CONFIG.LAYERTYPELIST[info.layerType];
    if (!tile) return false;

    if (tile.isTileImage) {
      for (var i = 0; i < this.tileList.length; i++) {
        if (this.tileList[i] == info) return true;

      }
      for (var i = 0; i < this.tileList.length; i++) {
        if (this.tileList[i].id == info.id) return true;

      }

    }
    else {
      for (var i = 0; i < this.list.length; i++) {
        if (this.list[i] == info) return true;
      }
      for (var i = 0; i < this.list.length; i++) {
        if (this.list[i].id == info.id) return true;
      }

      if ( info.isMultiLayer ) {
        for (var i = 0; i < this.tileList.length; i++) {
          if (this.tileList[i] == info) return true;

        }
        for (var i = 0; i < this.tileList.length; i++) {
          if (this.tileList[i].id == info.id) return true;

        }
      }
    }

    return false;
  },
  remove: function (info) {
    var tile = CONFIG.LAYERTYPELIST[info.layerType];

    var targetInfo = null;
    if ((tile && tile.isTileImage) || info._isOutside || info._isComparePhoto) {
      for (var i = 0; i < this.tileList.length; i++) {
        if (this.tileList[i] == info) {
          targetInfo = info;
          this.tileList.splice(i, 1);
          break;
        }
      }

      if (!targetInfo) {
        for (var i = 0; i < this.tileList.length; i++) {
          if (this.tileList[i].id == info.id) {
            targetInfo = this.tileList[i];
            this.tileList.splice(i, 1);
            break;
          }
        }
      }
    }
    else {
      for (var i = 0; i < this.list.length; i++) {
        if (this.list[i] == info) {
          targetInfo = info;
          this.list.splice(i, 1);
          break;
        }
      }

      if (!targetInfo) {
        for (var i = 0; i < this.list.length; i++) {
          if (this.list[i].id == info.id) {
            targetInfo = this.list[i];
            this.list.splice(i, 1);
            break;
          }
        }
      }

      if (!targetInfo) {
        for (var i = 0; i < this.tileList.length; i++) {
          if (this.tileList[i].id == info.id) {
            targetInfo = this.tileList[i];
            this.tileList.splice(i, 1);
            break;
          }
        }
      }
    }

    if (targetInfo) {
      this.map.removeLayer(targetInfo._visibleInfo.layer);
      targetInfo._visibleInfo = null;
    }
    this.fire('change');
  },

  destroy: function () {
    this.off();
    this.clear();
  },
  clear: function () {
    for (var i = 0; i < this.list.length; i++) {
      var info = this.list[i];
      this.map.removeLayer(info._visibleInfo.layer);
      info._visibleInfo = null;
    }
    this.list = [];

    for (var i = 0; i < this.tileList.length; i++) {
      var info = this.tileList[i];
      this.map.removeLayer(info._visibleInfo.layer);
      info._visibleInfo = null;
    }
    this.tileList = [];

    this.fire('change');
  },
  getTileList: function () {
    return this.tileList;
  },
  getList: function () {
    return this.list;
  },
  getTotalCount: function () {
    return (this.tileList ? this.tileList.length : 0)
      + (this.list ? this.list.length : 0);
  }
});

/************************************************************************
 L.Layer
 - GSI.VectorTileLayer
   ベクトルタイル
 ************************************************************************/
GSI.VectorTileLayer = L.Layer.extend({
  _requests: {},
  _keyLayers: {},

  _opacity: 1,
  _useCanvas: false,

  options: {
    minZoom: 0,
    maxZoom: 18,
    tileSize: 256,
    subdomains: 'abc',
    tileSize: 256,
    canvasSize: 512,
    maxDz: 4,
    canvasDx: 20,
    canvasDy: 20,
    attribution: '',
    zoomOffset: 0,
    opacity: 1,
    zIndex: 1,
    unloadInvisibleTiles: L.Browser.mobile,
    updateWhenIdle: L.Browser.mobile,
    async: false
  },

  initialize: function (url, options, geojsonOptions, isNormalNativeZoom) {
    this._url = url;
    this.geojsonOptions = $.extend({}, geojsonOptions);
    this._isNormalNativeZoom = isNormalNativeZoom;

    options.clipTiles = false;
    this._styleLoading = true;
    options = L.setOptions(this, options);
    this._useCanvas = (this.options.styletype == 'canvas');

    if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

      options.tileSize = Math.floor(options.tileSize / 2);
      options.zoomOffset++;

      if (options.minZoom > 0) {
        options.minZoom--;
      }
      this.options.maxZoom--;
    }

    if (options.bounds) {
      options.bounds = L.latLngBounds(options.bounds);
    }

    this._url = url;

    var subdomains = this.options.subdomains;

    if (typeof subdomains === 'string') {
      this.options.subdomains = subdomains.split('');
    }

    this.geojsonLayer = new L.GeoJSON(null, this.geojsonOptions);
    if (options.skipLoadStyle) {
      this._styleLoading = false;
    }

    else
      this._loadStyle(url, options.styleurl);
  },

  onAdd: function (map) {

    this._map = map;
    this._map._panes.overlayPane.style.cursor = '';
    this._animated = map._zoomAnimated;

    // create a container div for tiles
    this._initContainer();

    // set up events
    map.on({
      'viewreset': this._reset,
      'zoomend': this._reset,
      'moveend': this._update
    }, this);

    if (this._animated) {
      map.on({
        'zoomanim': this._animateZoom,
        'zoomend': this._endZoomAnim
      }, this);
    }

    if (!this.options.updateWhenIdle) {
      this._limitedUpdate = this.limitExecByInterval(this._update, 150, this);
      map.on('move', this._limitedUpdate, this);
    }

    if (!GSI.VectorTileLayer._layers)
      GSI.VectorTileLayer._layers = [];

    GSI.VectorTileLayer._layers.push(this);
    if (GSI.VectorTileLayer._layers.length == 1) {
      this._map.on('mousemove', GSI.VectorTileLayer._onGeoJSONMouseMove);
      this._map.on('click', GSI.VectorTileLayer._onGeoJSONClick);
    }

    this._map.on('moveend', this._onMapMoved, this);

    map.addLayer(this.geojsonLayer);

    this._reset();
    this._update();
  },

  addTo: function (map) {
    map.addLayer(this);
    return this;
  },

  onRemove: function (map) {
    this._map.off('moveend', this._onMapMoved, this);

    this._clearPopup();
    this._map._panes.overlayPane.style.cursor = '';
    map.removeLayer(this.geojsonLayer);

    for (var i = 0; i < GSI.VectorTileLayer._layers.length; i++) {
      if (GSI.VectorTileLayer._layers[i] == this) {
        GSI.VectorTileLayer._layers.splice(i, 1);
        break;
      }
    }
    if (GSI.VectorTileLayer._layers.length == 0) {

      this._map.off('mousemove', GSI.VectorTileLayer._onGeoJSONMouseMove);
      this._map.off('click', GSI.VectorTileLayer._onGeoJSONClick);
    }

    this._container.parentNode.removeChild(this._container);

    map.off({
      'viewreset': this._reset,
      'zoomend': this._reset,
      'moveend': this._update
    }, this);

    if (this._animated) {
      map.off({
        'zoomanim': this._animateZoom,
        'zoomend': this._endZoomAnim
      }, this);
    }

    if (!this.options.updateWhenIdle) {
      map.off('move', this._limitedUpdate, this);
    }

    this._container = null;
    this._map = null;
  },

  bringToFront: function () {
    var pane = this._map._panes.tilePane;

    if (this._container) {
      pane.appendChild(this._container);
      this._setAutoZIndex(pane, Math.max);
    }

    return this;
  },

  bringToBack: function () {
    var pane = this._map._panes.tilePane;

    if (this._container) {
      pane.insertBefore(this._container, pane.firstChild);
      this._setAutoZIndex(pane, Math.min);
    }

    return this;
  },

  getAttribution: function () {
    return this.options.attribution;
  },

  getContainer: function () {
    return this._container;
  },

  setOpacity: function (opacity) {
    this.options.opacity = opacity;

    if (this._map) {
      this._updateOpacity();
    }

    return this;
  },

  setZIndex: function (zIndex) {
    this.options.zIndex = zIndex;
    this._updateZIndex();

    return this;
  },

  setUrl: function (url, noRedraw) {
    this._url = url;

    if (!noRedraw) {
      this.redraw();
    }

    return this;
  },

  redraw: function () {
    if (this._map) {
      this._reset({ hard: true });
      this._update();
    }

    for (var i in this._tiles) {
      this._redrawTile(this._tiles[i]);
    }
    return this;
  },

  _updateZIndex: function () {
    if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
      this._container.style.zIndex = this.options.zIndex;
    }
  },

  _setAutoZIndex: function (pane, compare) {

    var layers = pane.children,
      edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min
      zIndex, i, len;

    for (i = 0, len = layers.length; i < len; i++) {

      if (layers[i] !== this._container) {
        zIndex = parseInt(layers[i].style.zIndex, 10);

        if (!isNaN(zIndex)) {
          edgeZIndex = compare(edgeZIndex, zIndex);
        }
      }
    }

    this.options.zIndex = this._container.style.zIndex =
      (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);
  },

  _updateOpacity: function () {
    var i,
      tiles = this._tiles;

    if (L.Browser.ielt9) {
      for (i in tiles) {
        L.DomUtil.setOpacity(tiles[i], this.options.opacity);
      }
    } else {
      L.DomUtil.setOpacity(this._container, this.options.opacity);
    }
  },

  _initContainer: function () {
    var tilePane = this._map._panes.overlayPane;

    if (!this._container) {
      this._container = L.DomUtil.create('div', 'leaflet-layer');

      this._updateZIndex();

      if (this._animated) {
        var className = 'leaflet-tile-container';
        this._bgBuffer = L.DomUtil.create('div', className, this._container);
        this._tileContainer = L.DomUtil.create('div', className, this._container);

      } else {
        this._tileContainer = this._container;
      }

      tilePane.insertBefore(this._container, tilePane.firstChild);

      if (this.options.opacity < 1) {
        this._updateOpacity();
      }
    }
  },

  _reset: function (e) {

    if ((e && e.hard) || this._map.getZoom() < this.options.minZoom || this._map.getZoom() > this.options.maxZoom) {
      this._clearPopup();
    }
    this.geojsonLayer.clearLayers();
    this._keyLayers = {};
    this._removeOldClipPaths();

    for (var i in this._requests) {
      if (this._requests[i] && this._requests[i].abort)
        this._requests[i].abort();
    }
    this._requests = {};
    if ((e && e.hard) || this._map.getZoom() < this.options.minZoom || this._map.getZoom() > this.options.maxZoom) {
      if (this._bgBuffer) this._clearBgBuffer();
    }

    for (var key in this._tiles) {
      this.fire('tileunload', { tile: this._tiles[key] });
    }

    this._tiles = {};
    this._tilesToLoad = 0;

    if (this.options.reuseTiles) {
      this._unusedTiles = [];
    }

    this._tileContainer.innerHTML = '';

    if (this._animated && e && e.hard) {
      this._clearBgBuffer();
    }

    this._initContainer();
  },

  _getTileSize: function () {
    var map = this._map,
      zoom = map.getZoom() + this.options.zoomOffset,
      zoomN = this.options.maxNativeZoom,
      tileSize = this.options.tileSize;

    if (zoomN && zoom > zoomN) {
      tileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);
    }

    return tileSize;
  },

  _removeOldClipPaths: function () {
    for (var clipPathId in this._clipPathRectangles) {
      var clipPathZXY = clipPathId.split('_').slice(1);
      var zoom = parseInt(clipPathZXY[0], 10);
      if (zoom !== this._map.getZoom()) {
        var rectangle = this._clipPathRectangles[clipPathId];
        this._map.removeLayer(rectangle);
        var clipPath = document.getElementById(clipPathId);
        if (clipPath !== null) {
          clipPath.parentNode.removeChild(clipPath);
        }
        delete this._clipPathRectangles[clipPathId];
      }
    }
  },

  _recurseLayerUntilPath: function (func, layer) {
    if (layer instanceof L.Path) {
      func(layer);
    }
    else if (layer instanceof L.LayerGroup) {
      // Recurse each child layer
      layer.getLayers().forEach(this._recurseLayerUntilPath.bind(this, func), this);
    }
  },

  _clipLayerToTileBoundary: function (layer, tilePoint) {
    // Only perform SVG clipping if the browser is using SVG
    if (!L.Path.SVG) { return; }
    if (!this._map) { return; }

    if (!this._map._pathRoot) {
      this._map._pathRoot = L.Path.prototype._createElement('svg');
      this._map._panes.overlayPane.appendChild(this._map._pathRoot);
    }
    var svg = this._map._pathRoot;

    // create the defs container if it doesn't exist
    var defs = null;
    if (svg.getElementsByTagName('defs').length === 0) {
      defs = document.createElementNS(L.Path.SVG_NS, 'defs');
      svg.insertBefore(defs, svg.firstChild);
    }
    else {
      defs = svg.getElementsByTagName('defs')[0];
    }

    // Create the clipPath for the tile if it doesn't exist
    var clipPathId = 'tileClipPath_' + tilePoint.z + '_' + tilePoint.x + '_' + tilePoint.y;
    var clipPath = document.getElementById(clipPathId);
    if (clipPath === null) {
      clipPath = document.createElementNS(L.Path.SVG_NS, 'clipPath');
      clipPath.id = clipPathId;

      // Create a hidden L.Rectangle to represent the tile's area
      var tileSize = this.options.tileSize,
        nwPoint = tilePoint.multiplyBy(tileSize),
        sePoint = nwPoint.add([tileSize, tileSize]),
        nw = this._map.unproject(nwPoint),
        se = this._map.unproject(sePoint);
      this._clipPathRectangles[clipPathId] = new L.Rectangle(new L.LatLngBounds([nw, se]), {
        opacity: 0,
        fillOpacity: 0,
        clickable: false,
        noClip: true
      });
      this._map.addLayer(this._clipPathRectangles[clipPathId]);

      // Add a clip path element to the SVG defs element
      // With a path element that has the hidden rectangle's SVG path string
      var path = document.createElementNS(L.Path.SVG_NS, 'path');
      var pathString = this._clipPathRectangles[clipPathId].getPathString();
      path.setAttribute('d', pathString);
      clipPath.appendChild(path);
      defs.appendChild(clipPath);
    }

    // Add the clip-path attribute to reference the id of the tile clipPath
    this._recurseLayerUntilPath(function (pathLayer) {
      pathLayer._container.setAttribute('clip-path', 'url(#' + clipPathId + ')');
    }, layer);
  },

  _update: function () {

    if (this._map && this._map._panTransition && this._map._panTransition._inProgress) { return; }
    if (this._tilesToLoad < 0) { this._tilesToLoad = 0; }

    if (!this._map) { return; }

    var map = this._map,
      bounds = map.getPixelBounds(),
      zoom = map.getZoom(),
      tileSize = this._getTileSize();

    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
      return;
    }

    var tileBounds = L.bounds(
      bounds.min.divideBy(tileSize)._floor(),
      bounds.max.divideBy(tileSize)._floor());

    this._addTilesFromCenterOut(tileBounds);
    if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {
      this._removeOtherTiles(tileBounds);
    }

    this._center = this._map.getCenter();
    this._zoom = this._map.getZoom();

  },

  _addTilesFromCenterOut: function (bounds) {
    var queue = [],
      center = bounds.getCenter();

    var j, i, point;

    for (j = bounds.min.y; j <= bounds.max.y; j++) {
      for (i = bounds.min.x; i <= bounds.max.x; i++) {
        point = new L.Point(i, j);

        if (this._tileShouldBeLoaded(point)) {
          queue.push(point);
        }
      }
    }

    var tilesToLoad = queue.length;

    if (tilesToLoad === 0) { return; }

    // load tiles in order of their distance to center
    queue.sort(function (a, b) {
      return a.distanceTo(center) - b.distanceTo(center);
    });

    var fragment = document.createDocumentFragment();

    // if its the first batch of tiles to load
    if (!this._tilesToLoad) {
      this.fire('loading');
    }

    this._tilesToLoad += tilesToLoad;

    for (i = 0; i < tilesToLoad; i++) {
      this._addTile(queue[i], fragment);
    }

    this._tileContainer.appendChild(fragment);
  },

  _tileShouldBeLoaded: function (tilePoint) {
    if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
      return false; // already loaded
    }

    var options = this.options;

    if (!options.continuousWorld) {
      var limit = this._getWrapTileNum();

      // don't load if exceeds world bounds
      if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||
        tilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }
    }

    if (options.bounds) {
      var tileSize = options.tileSize,
        nwPoint = tilePoint.multiplyBy(tileSize),
        sePoint = nwPoint.add([tileSize, tileSize]),
        nw = this._map.unproject(nwPoint),
        se = this._map.unproject(sePoint);

      // TODO temporary hack, will be removed after refactoring projections
      // https://github.com/Leaflet/Leaflet/issues/1618
      if (!options.continuousWorld && !options.noWrap) {
        nw = nw.wrap();
        se = se.wrap();
      }

      if (!options.bounds.intersects([nw, se])) { return false; }
    }

    return true;
  },

  _removeOtherTiles: function (bounds) {
    var kArr, x, y, key;

    for (key in this._tiles) {
      kArr = key.split(':');
      x = parseInt(kArr[0], 10);
      y = parseInt(kArr[1], 10);

      // remove tile if it's out of bounds
      if (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {
        this._removeTile(key);
      }
    }
  },

  _removeTile: function (key) {

    var tile = this._tiles[key];
    this._clearTilePopup(tile);
    this.fire('tileunload', { tile: tile, url: tile.src });

    if (this.options.reuseTiles) {
      L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');
      this._unusedTiles.push(tile);

    } else if (tile.parentNode === this._tileContainer) {

      this._tileContainer.removeChild(tile);
    }

    if (!L.Browser.android) {
      tile.onload = null;
      tile.src = L.Util.emptyImageUrl;
    }

    if (this._requests[key] && this._requests[i].abort) {
      this._requests[i].abort();
    }

    delete this._requests[key];
    delete this._tiles[key];
  },

  _getTileUrls: function (tilePoint, zoom, dz) {
    var x = "";
    var y = "";
    if (!tilePoint._children) tilePoint._children = [];
    if (dz < 0 && !this._isNormalNativeZoom) {
      var num = Math.pow(2, Math.abs(dz));
      for (var i = 0; i < num; i++) {
        x = i + Math.floor(tilePoint.x / Math.pow(2, dz));
        for (var ii = 0; ii < num; ii++) {
          y = ii + Math.floor(tilePoint.y / Math.pow(2, dz));
          tilePoint._children.push({
            url: L.Util.template(this._url, L.extend({
              s: this._getSubdomain(tilePoint),
              z: zoom,
              x: x,
              y: y
            }, this.options)),
            key: x + ":" + y + ":" + zoom,
            x: x,
            y: y,
            z: zoom
          });
        }
      }
    }
    else {
      tilePoint._children.push({
        url: this.getTileUrl(tilePoint),
        key: tilePoint.x + ":" + tilePoint.y + ":" + tilePoint.z,
        x: tilePoint.x,
        y: tilePoint.y,
        z: tilePoint.z
      });
    }
    return;
  },
  setPrintMode: function (printMode) {
    this._printMode = printMode;
    this._reset({ hard: true });
  },

  _addTile: function (tilePoint, container) {
    var tilePos = this._getTilePos(tilePoint);

    var mapZoom = this._map.getZoom();

    // get unused tile - or create a new tile
    var tile = (!this._useCanvas ? { style: {}, className: "" } : this._getTile());
    tile.datum = null;
    tile.processed = false;
    /*
    Chrome 20 layouts much faster with top/left (verify with timeline, frames)
    Android 4 browser has display issues with top/left and requires transform instead
    (other browsers don't currently care) - see debug/hacks/jitter.html for an example
    */

    if (this._useCanvas) {
      tilePos.x -= parseInt(this.options.canvasDx * tile._scale);
      tilePos.y -= parseInt(this.options.canvasDy * tile._scale);
      tile._dX = parseInt(this.options.canvasDx * tile._scale);
      tile._dY = parseInt(this.options.canvasDy * tile._scale);
      tile._current = {
        x: 0,
        y: 0
      };
      tile._defaultTilePos = tilePos;
      var maxTilePoint = $.extend({}, tilePoint);
      maxTilePoint.x += 1;
      maxTilePoint.y += 1;
      var maxTilePos = this._getTilePos(maxTilePoint);

    }

    L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);

    this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;

    this._loadTile(tile, tilePoint);

    if (this._useCanvas) {
      if (tile.parentNode !== this._tileContainer) {
        container.appendChild(tile);
      }
    }
  },

  _getZoomForUrl: function () {

    var options = this.options,
      zoom = this._map.getZoom();

    if (options.zoomReverse) {
      zoom = options.maxZoom - zoom;
    }

    zoom += options.zoomOffset;

    return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
  },

  _getTilePos: function (tilePoint) {
    var origin = this._map.getPixelOrigin(),
      tileSize = this._getTileSize();

    return tilePoint.multiplyBy(tileSize).subtract(origin);
  },

  // image-specific code (override to implement e.g. Canvas or SVG tile layer)

  getTileUrl: function (tilePoint) {
    return L.Util.template(this._url, L.extend({
      s: this._getSubdomain(tilePoint),
      z: tilePoint.z,
      x: tilePoint.x,
      y: tilePoint.y
    }, this.options));
  },

  getCRSSize: function (zoom) {
    var s = this._map.options.crs.scale(zoom);
    return L.point(s, s);
  },
  _getWrapTileNum: function () {
    var size = this.getCRSSize(this._map.getZoom());
    return size.divideBy(this._getTileSize())._floor();
  },

  _adjustTilePoint: function (tilePoint) {

    var limit = this._getWrapTileNum();

    // wrap tile coordinates
    if (!this.options.continuousWorld && !this.options.noWrap) {
      tilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;
    }

    if (this.options.tms) {
      tilePoint.y = limit.y - tilePoint.y - 1;
    }

    tilePoint.z = this._getZoomForUrl();
  },

  _getSubdomain: function (tilePoint) {
    var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
    return this.options.subdomains[index];
  },

  _getTile: function () {
    if (this.options.reuseTiles && this._unusedTiles.length > 0) {
      var tile = this._unusedTiles.pop();
      this._resetTile(tile);
      return tile;
    }
    return this._createTile();
  },

  // Override if data stored on a tile needs to be cleaned up before reuse
  _resetTile: function (/*tile*/) { },

  _createTile: function () {
    var tile = L.DomUtil.create('canvas', 'leaflet-tile');
    tile.onselectstart = tile.onmousemove = L.Util.falseFn;
    if (!this._useCanvas) {
      tile.width = tile.height = this._getTileSize();
      return;
    }
    var zoom = this._map.getZoom();
    var dz = zoom - this.options.maxNativeZoom;
    var tileSize = (this._printMode ? this.options.canvasSize : this.options.tileSize);
    var tz = zoom;
    if (dz >= this.options.maxDz) { tileSize = tileSize * Math.pow(2, this.options.maxDz); tz = tz - dz; }
    else if (dz > 0) { tileSize = tileSize * Math.pow(2, dz); tz = tz - dz; }

    if (dz >= this.options.maxDz) {
      var tileSize2 = (dz > 0 ? this.options.tileSize * Math.pow(2, dz) : this.options.tileSize);
      var tileSize3 = (this._printMode ? this.options.canvasSize : this.options.tileSize);
      if (dz > 0) tileSize3 = tileSize3 * Math.pow(2, dz);

      tile._scale = tileSize2 / tileSize3;
      tile.style.width = tileSize + this.options.canvasDx * (2 * tile._scale) + "px";
      tile.style.height = tileSize + this.options.canvasDx * (2 * tile._scale) + "px";
      tile._realTileSize = tileSize3;
      tile._tileSize = tileSize;

    }
    else {
      var tileSize2 = (dz > 0 ? this.options.tileSize * Math.pow(2, dz) : this.options.tileSize);
      tile._scale = tileSize2 / tileSize;
      tile.style.width = tileSize2 + this.options.canvasDx * (2 * tile._scale) + "px";
      tile.style.height = tileSize2 + this.options.canvasDx * (2 * tile._scale) + "px";
    }
    tile.width = tileSize + this.options.canvasDx * 2;
    tile.height = tileSize + this.options.canvasDy * 2;

    return tile;
  },

  _clearTilePopup: function (tile) {
    if (!this._popup) return;

    var geoJSON = tile.geoJSON;
    if (!geoJSON) return;
    for (var i = 0; i < geoJSON.length; i++) {
      if (geoJSON instanceof L.FeatureGroup) {
        var layers = geoJSON.getLayers();
        for (var j = 0; j < layers.length; j++) {
          if (layers[j]._popup == this._popup)
            this._map.closePopup(this._popup);
        }
      }
      if (geoJSON[i]._popup == this._popup)
        this._map.closePopup(this._popup);
    }
  },

  _clearPopup: function () {
    this._map.closePopup(this._popup);
    this._popup = null;

  },

  _loadTile: function (tile, tilePoint) {
    tile._layer = this;
    var key = tilePoint.x + ":" + tilePoint.y + ":" + tilePoint.z;
    tile._tilePoint = tilePoint;

    if (!this.options.async) {
      this.tileDrawn(tile);
    }

    this._adjustTilePoint(tilePoint);

    var layer = this;

    var zoom = this._map.getZoom();
    var dz = zoom - this.options.maxNativeZoom;
    if (this._useCanvas) {

      this._getTileUrls(tilePoint, this.options.maxNativeZoom, dz);
    }
    else {
      this._getTileUrls(tilePoint, zoom, 0);
    }

    if (!tile.datum) tile.datum = {};
    this.tileDrawn(tile);

    for (var i = 0; i < tilePoint._children.length; i++) {

      var data = this._getTileCache(tilePoint._children[i].key);
      if (data) {
        tilePoint._children[i].loaded = true;
        var json = JSON.parse(data);

        if (this.geojsonOptions && this.geojsonOptions.onGeoJSONLoad) {
          this.geojsonOptions.onGeoJSONLoad(json);
        }
        tile.datum[tilePoint._children[i].key] = json;
        layer._tileLoaded(tile, tilePoint, tilePoint._children[i].key);
        continue;
      }

      var req = $.ajax({
        type: "GET",
        dataType: "text",
        url: tilePoint._children[i].url,
        async: true,
        success: L.Util.bind(function (data) {
          try {
            this["$this"]._addTileCahce(this.child.key, data);
            this.child.loaded = true;
            var json = JSON.parse(data);
            if (this["$this"].geojsonOptions && this["$this"].geojsonOptions.onGeoJSONLoad) {
              this["$this"].geojsonOptions.onGeoJSONLoad(json);
            }
            this.tile.datum[this.child.key] = json;
            this.layer._tileLoaded(this.tile, this.tilePoint, this.child.key);
          } catch (e) {
            this.child.loaded = true;
            this.layer._tileLoaded(this.tile, this.tilePoint, this.child.key);
          }
        },
          { layer: layer, tile: tile, tilePoint: tilePoint, child: tilePoint._children[i], "$this": this }
        ),
        error: L.Util.bind(function (data) {
          this.child.loaded = true;
          this.layer._tileLoaded(this.tile, this.tilePoint, this.child.key);
        },
          { layer: layer, tile: tile, tilePoint: tilePoint, child: tilePoint._children[i] }
        )
      });
      this._requests[key] = req;

    }
  },

  _getTileCache: function (key) {
    if (!this._tileCacheList) return null;

    var idx = undefined;
    for (var i = 0; i < this._tileCacheList.length; i++) {
      if (this._tileCacheList[i].key == key) {
        idx = i;
        break;
      }
    }
    if (idx == undefined) return null;
    var item = this._tileCacheList[idx];
    this._tileCacheList.splice(idx, 1);
    this._tileCacheList.push(item);
    return item.data;
  },

  _addTileCahce: function (key, data) {

    if (!this._tileCacheList) {
      this._tileCacheList = [];
    }
    var idx = undefined;
    for (var i = 0; i < this._tileCacheList.length; i++) {
      if (this._tileCacheList[i].key == key) {
        idx = i;
        break;
      }
    }

    if (idx != undefined) {
      this._tileCacheList.splice(idx, 1);
    }
    this._tileCacheList.push({ key: key, data: data });

    while (this._tileCacheList.length > 200) {
      this._tileCacheList.shift();
    }
  },

  _tileLoaded: function (tile, tilePoint, childKey) {

    if (tile && tile.datum[childKey] && this.options.isTopoJSON) {
      tile.datum[childKey] = omnivore.topojson.parse(tile.datum[childKey]);
    }

    var loaded = true;
    if (tilePoint) {
      for (var j = 0; j < tilePoint._children.length; j++) {
        if (!tilePoint._children[j].loaded)
          loaded = false;
      }
    }

    if (!tile) return null;

    if (tile.datum[childKey]) {
      try {
        var addedLayers = [];

        var addedLayer = this.addTileData(addedLayers, tile, tile.datum[childKey], tilePoint);
        if (!tile.geoJSON) tile.geoJSON = [];
        for (var i = 0; i < addedLayers.length; i++) {
          tile.geoJSON.push(addedLayers[i]);
        }

        if (!this._styleLoading) {
          this._updateTilePosition(tile);
          this.drawTile(tile, tilePoint, addedLayer, null, false, tile._current);
        }
      } catch (e) {
      }

    }
    this.tileDrawn(tile);

    if (this._opacity != 1) this.setOpacity(this._opacity);

    if (this.geojsonLayer) {
      if (this.options.zIndexOffset && this.geojsonLayer.setMarkerZIndex) {
        this.geojsonLayer.setMarkerZIndex(this.options.zIndexOffset)
      }
    }
  },

  limitExecByInterval: function (fn, time, context) {
    var lock, execOnUnlock;

    return function wrapperFn() {
      var args = arguments;

      if (lock) {
        execOnUnlock = true;
        return;
      }

      lock = true;

      setTimeout(function () {
        lock = false;

        if (execOnUnlock) {
          wrapperFn.apply(context, args);
          execOnUnlock = false;
        }
      }, time);

      fn.apply(context, args);
    };
  },

  _tileOnLoad: function () {
    var layer = this._layer;

    //Only if we are loading an actual image
    if (this.src !== L.Util.emptyImageUrl) {
      L.DomUtil.addClass(this, 'leaflet-tile-loaded');

      layer.fire('tileload', {
        tile: this,
        url: this.src
      });
    }

    layer._tileLoaded();
  },

  _tileOnError: function () {
    var layer = this._layer;

    layer.fire('tileerror', {
      tile: this,
      url: this.src
    });

    var newUrl = layer.options.errorTileUrl;
    if (newUrl) {
      this.src = newUrl;
    }

    layer._tileLoaded();
  },

  _clampZoom: function (zoom) {
    var options = this.options;

    if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
      return options.minNativeZoom;
    }

    if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
      return options.maxNativeZoom;
    }

    return zoom;
  },

  _animateZoom: function (e) {

    if (!this._useCanvas) return;

    $(this._container).css({ visibility: "hidden" });
  },

  getScaleString: function (scale, origin) {

    var preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),
      scaleStr = ' scale(' + scale + ') ';

    return preTranslateStr + scaleStr;
  },

  _endZoomAnim: function () {
    $(this._container).css({ visibility: "visible" });

    var front = this._tileContainer,
      bg = this._bgBuffer;

    front.style.visibility = '';
    front.parentNode.appendChild(front); // Bring to fore

    // force reflow
    L.Util.falseFn(bg.offsetWidth);

    this._animating = false;
  },

  _clearBgBuffer: function () {
    var map = this._map;

    if (map && !map._animatingZoom && !map.touchZoom._zooming) {
      this._bgBuffer.innerHTML = '';
      this._bgBuffer.style[L.DomUtil.TRANSFORM] = '';
    }
  },

  _prepareBgBuffer: function () {

    var front = this._tileContainer,
      bg = this._bgBuffer;

    // if foreground layer doesn't have many tiles but bg layer does,
    // keep the existing bg layer and just zoom it some more

    var bgLoaded = this._getLoadedTilesPercentage(bg),
      frontLoaded = this._getLoadedTilesPercentage(front);

    if (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {

      front.style.visibility = 'hidden';
      this._stopLoadingImages(front);
      return;
    }

    // prepare the buffer to become the front tile pane
    bg.style.visibility = 'hidden';
    bg.style[L.DomUtil.TRANSFORM] = '';

    // switch out the current layer to be the new bg layer (and vice-versa)
    this._tileContainer = bg;
    bg = this._bgBuffer = front;

    this._stopLoadingImages(bg);

    //prevent bg buffer from clearing right after zoom
    clearTimeout(this._clearBgBufferTimer);
  },

  _getLoadedTilesPercentage: function (container) {
    var tiles = container.getElementsByTagName('img'),
      i, len, count = 0;

    for (i = 0, len = tiles.length; i < len; i++) {
      if (tiles[i].complete) {
        count++;
      }
    }
    return count / len;
  },

  // stops loading all tiles in the background layer
  _stopLoadingImages: function (container) {
    var tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),
      i, len, tile;

    for (i = 0, len = tiles.length; i < len; i++) {
      tile = tiles[i];

      if (!tile.complete) {
        tile.onload = L.Util.falseFn;
        tile.onerror = L.Util.falseFn;
        tile.src = L.Util.emptyImageUrl;

        tile.parentNode.removeChild(tile);
      }
    }
  },

  _redrawTile: function (tile) {
    this.drawTile(tile, tile._tilePoint, this._map._zoom);
  },

  tileDrawn: function (tile) {
    this._tileOnLoad.call(tile);
  },

  _initEvents: function () { },

  setMarkerZIndex: function (zIndex) {
    this.options.zIndexOffset = zIndex;
    if (this.geojsonLayer && this.geojsonLayer.setMarkerZIndex)
      this.geojsonLayer.setMarkerZIndex(this.options.zIndexOffset)
  },

  setStyleText: function (styleText) {
    try {
      var data = eval("(" + styleText + ")");
      if (data.geojsonOptions) this.geojsonOptions = data.geojsonOptions;
      for (var key in this._tiles) {
        var tile = this._tiles[key];
        if (!tile.geoJSON) continue;
        for (var j = 0; j < tile.geoJSON.length; j++) {
          tile.geoJSON[j].options = this.geojsonOptions;
        }
      }
      if (data.options) {
        if (this.options._minZoom)
          data.options.minZoom = this.options._minZoom;

        if (this.options._maxZoom)
          data.options.maxZoom = this.options._maxZoom;

        if (this.options._maxNativeZoom)
          data.options.maxNativeZoom = this.options._maxNativeZoom;

        if (this.options._attribution)
          data.options.attribution = this.options._attribution;
        if (this.options._bounds)
          data.options.bounds = this.options._bounds;
        this._useCanvas = (data.options.styletype == 'canvas');

        L.setOptions(this, data.options);
      }
    }
    catch (e) {

    }
    if (this.geojsonLayer) {
      this.geojsonLayer.setStyle(this.geojsonOptions);
    }

    this._styleLoading = false;
    this._updateTileStyles();

  },

  _onStyleLoad: function (result) {
    try {
      var data = null;
      if (!result) return;
      if (result.data) {
        data = result.data;
      }
      else data = result;
      data = eval("(" + data + ")");
      if (data.geojsonOptions) this.geojsonOptions = data.geojsonOptions;
      if (this._tiles) {
        for (var i = 0; i < this._tiles.length; i++) {
          var tile = this._tiles[i];
          if (!tile.geoJSON) continue;
          for (var j = 0; j < tile.geoJSON.length; j++) {
            tile.geoJSON[i].options = this.geojsonOptions;
          }
        }
      }
      if (data.options) {
        if (this.options._minZoom)
          data.options.minZoom = this.options._minZoom;

        if (this.options._maxZoom)
          data.options.maxZoom = this.options._maxZoom;

        if (this.options._maxNativeZoom)
          data.options.maxNativeZoom = this.options._maxNativeZoom;

        if (this.options._attribution)
          data.options.attribution = this.options._attribution;
        if (this.options._bounds)
          data.options.bounds = this.options._bounds;
        this._useCanvas = (data.options.styletype == 'canvas');

        L.setOptions(this, data.options);
      }
    }
    catch (e) {
    }

    if (this.geojsonLayer) {
      this.geojsonLayer.options = $.extend({}, this.geojsonOptions);
    }

    this._styleLoading = false;

    try {
      if (this._tileContainer)
        this._reset();
    } catch (e) { }
    try {
      this._update();
    } catch (e) { }
  },

  _updateTileStyles: function () {

    for (key in this._tiles) {
      var tile = this._tiles[key];
      var geoJSON = tile.geoJSON;
      if (geoJSON) {

        for (var i = 0; i < geoJSON.length; i++) {
          var style = this.geojsonOptions.style;
          if (typeof style === 'function') {
            style = style(geoJSON[i].feature);
          }
          if (geoJSON[i].setStyle) {
            geoJSON[i].setStyle(style);
          }
        }
        this.drawTile(tile, tile._tilePoint, null, true);
      }
    }

  },

  _defaultLoadStyle: function () {
    var styleUrl = './js/style.js';

    this._styleAjax = $.ajax({
      type: "GET",
      dataType: "text",
      url: styleUrl,
      success: L.Util.bind(this._onStyleLoad, this),
      error: L.Util.bind(function () {
        this._styleLoading = false;
      }, this),
      async: true
    });
  },

  _loadStyle: function (url, styleUrl) {

    if (styleUrl && styleUrl != '')
      styleUrl = styleUrl;
    else
      styleUrl = url.replace(/\/\{z\}.*/, "") + '/style.js';

    var data = null;

    this._styleLoading = true;
    this._styleAjax = $.ajax({
      type: "GET",
      dataType: "text",
      url: styleUrl,
      data: data,
      success: L.Util.bind(this._onStyleLoad, this),
      error: L.Util.bind(this._defaultLoadStyle, this),
      async: true

    });
  },

  _updateTilePosition: function (tile, zoom, dz, pixelBounds, origin, mapSize) {
    if (!this._useCanvas) return;

    if (!zoom) {
      zoom = this._map.getZoom();
      dz = zoom - this.options.maxNativeZoom;
      pixelBounds = this._map.getPixelBounds();
      origin = this._map.getPixelOrigin();
      mapSize = this._map.getSize();
    }
    if (dz > this.options.maxDz) {
      var tilePoint = tile._tilePoint;

      var tileLeftTop = {
        x: tilePoint.x * tile._realTileSize - pixelBounds.min.x,
        y: tilePoint.y * tile._realTileSize - pixelBounds.min.y
      };
      var tileRightBottom = {
        x: (tilePoint.x + 1) * tile._realTileSize - pixelBounds.min.x,
        y: (tilePoint.y + 1) * tile._realTileSize - pixelBounds.min.y
      };

      var newCurrent = $.extend({}, tile._current);

      if (
        tileLeftTop.x + tile._current.x > 0
        || tile._current.y + tile._current.y > 0
        || tileLeftTop.x + tile._current.x + tile._tileSize < mapSize.x
        || tileLeftTop.y + tile._current.y + tile._tileSize < mapSize.y) {

        newCurrent.x = parseInt(-tileLeftTop.x + ((mapSize.x / 2) - (tile._tileSize / 2)));
        newCurrent.y = parseInt(-tileLeftTop.y + ((mapSize.y / 2) - (tile._tileSize / 2)));
      }

      if (newCurrent.x < 0)
        newCurrent.x = 0;
      if (newCurrent.y < 0)
        newCurrent.y = 0;
      if (newCurrent.x > tile._realTileSize - tile._tileSize)
        newCurrent.x = tile._realTileSize - tile._tileSize;
      if (newCurrent.y > tile._realTileSize - tile._tileSize)
        newCurrent.y = tile._realTileSize - tile._tileSize;

      if (newCurrent.x != tile._current.x || newCurrent.y != tile._current.y || !tile._updatePos) {

        tile._current.x = newCurrent.x;
        tile._current.y = newCurrent.y;

        var tilePos = this._getTilePos(tilePoint);

        tilePos.x += tile._current.x - tile._dX;
        tilePos.y += tile._current.y - tile._dY;

        L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);

        return true;
      }

    }
    return false;

  },

  _onMapMoved: function (e) {
    if (!this._useCanvas) return;
    var zoom = this._map.getZoom();
    var dz = zoom - this.options.maxNativeZoom;
    var pixelBounds = this._map.getPixelBounds();
    var origin = this._map.getPixelOrigin();
    var mapSize = this._map.getSize();
    if (dz > this.options.maxDz) {
      for (var key in this._tiles) {
        var tile = this._tiles[key];
        if (this._updateTilePosition(tile, zoom, dz, pixelBounds, origin, mapSize)) {

          var ctx = tile.getContext('2d');
          ctx.clearRect(0, 0, tile.width, tile.height);
          ctx.beginPath();
          this.drawTile(tile, tile._tilePoint, tile.geoJSON, zoom, true, tile._current);
        }
      }
    }
    return true;
  },

  _latLngToChildLayer: function (latLng) {
    if (!latLng) return null;
    var zoom = this._map.getZoom();
    var dz = zoom - this.options.maxNativeZoom;
    var drawTileSize = (this._printMode ? this.options.canvasSize : this.options.tileSize);
    var dispTileSize = this.options.tileSize;

    var tz = zoom;

    if (dz > 0) { dispTileSize = dispTileSize * Math.pow(2, dz); tz = tz - dz; }
    if (dz > 0)
      drawTileSize = (this._printMode ? this.options.canvasSize : this.options.tileSize) * Math.pow(2, dz);
    var scale = drawTileSize / dispTileSize;

    var initialResolution = 2 * Math.PI / dispTileSize;
    var resolution = initialResolution / (Math.pow(2, tz));
    var originShift = 2 * Math.PI / 2.0;

    var tilePoint = this._map.project(latLng).divideBy(dispTileSize).floor();

    var key = tilePoint.x + ":" + tilePoint.y;
    var tile = this._tiles[key];
    if (!tile) return;
    var tilePoint = tile._tilePoint;
    var x = latLng.lng * (Math.PI / 180);
    var y = Math.log(Math.tan(Math.PI / 4 + latLng.lat * (Math.PI / 180) / 2));
    var tx = (x + originShift) / (dispTileSize * resolution);
    var ty = (y + originShift) / (dispTileSize * resolution);
    ty = Math.pow(2, tz) - ty;
    tx = (tx - tilePoint.x) * dispTileSize; //+( this.options.canvasDx );
    ty = (ty - tilePoint.y) * dispTileSize; //+( this.options.canvasDy );
    tx *= scale;
    ty *= scale;
    tx += (this.options.canvasDx);
    ty += (this.options.canvasDx);

    var tile = this._tiles[key];
    var p = L.point(tx, ty);
    var hit = false;
    var result = null;
    var geoJSON = tile.geoJSON;
    if (!geoJSON) return null;

    for (var i = 0; i < geoJSON.length; i++) {
      if (geoJSON instanceof L.FeatureGroup) {
        var layers = geoJSON.getLayers();
        for (var j = 0; j < layers.length; j++) {
          if (layers[j].options && layers[j].options.clickable && layers[j]._onMouseMove) {
            if (layers[j]._containsPoint(p)) {
              result = layers[j];
              hit = true;
              return result;
            }
          }
          if (hit) break;
        }
      }
      else {
        if (geoJSON[i].options) {
          if (geoJSON[i]._containsPoint(p)) {
            result = geoJSON[i];
            hit = true;
            return result;
          }
        }
      }
    }

    return result;
  },

  addTileData: function (result, tile, geojson, tilePoint) {
    var features = L.Util.isArray(geojson) ? geojson : geojson.features,
      i, len, feature;
    var mapZoom = this._map.getZoom();

    if (features) {
      for (i = 0, len = features.length; i < len; i++) {
        feature = features[i];
        if (feature.properties) {
          for (name in feature.properties) {
            if (name == "name" || name == "iframe" || name == "description" || name == "写真") {
              continue;
            }
            else {
              if (feature.properties[name] == null) {
                feature.properties[name] = "";
              }
            }
          }
        }
        if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
          this.addTileData(result, tile, features[i], tilePoint);
        }
      }
      return result;
    }

    var options = this.geojsonOptions;

    if (options.filter && !options.filter(geojson)) { return null; }

    var parentLayer = this.geojsonLayer;
    var layer = null;

    GSI.GLOBALS.map = this._map;
    try {
      if (!this._useCanvas) {

        layer = L.GeoJSON.geometryToLayer(geojson, options);
      }
      else {
        layer = GSI.Canvas.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, this.geojsonOptions);
      }
    }
    catch (e) {
      console.log(e);
      return null;
    }

    if (!layer) return null;
    layer.feature = L.GeoJSON.asFeature(geojson);
    GSI.GLOBALS.map = null;

    layer.defaultOptions = layer.options;

    if (!this._styleLoading) {
      var style = this.geojsonOptions.style;
      if (typeof style === 'function') {
        style = style(layer.feature);
      }
      if (layer.setStyle) {

        layer.setStyle(style);
      }
    }

    if (!layer._isCanvas) this.geojsonLayer.resetStyle(layer);

    if (options.onEachFeature) {
      options.onEachFeature(geojson, layer);
    }

    if (!layer._isCanvas) {
      parentLayer.addLayer(layer);
      // If options.clipTiles is set and the browser is using SVG
      // then clip the layer using SVG clipping
      if (this.options.clipTiles) {
        this._clipLayerToTileBoundary(layer, tilePoint);
      }
    }
    else {

      layer._tilePoint = tilePoint;
      result.push(layer);

    }
    return layer;
  },

  drawTile: function (tile, tilePoint, drawLayers, zoom, redraw, drawOffset) {

    if (!this._useCanvas || !drawLayers || !tile.getContext) return;// !tile.geoJSON || !tile.getContext ) return;

    if (!zoom) zoom = this._map.getZoom();
    var dz = zoom - this.options.maxNativeZoom;
    var tileSize = (this._printMode ? this.options.canvasSize : this.options.tileSize);
    var tz = zoom;

    if (dz > 0) { tileSize = tileSize * Math.pow(2, dz); tz = tz - dz; }

    var initialResolution = 2 * Math.PI / tileSize;
    var resolution = initialResolution / (Math.pow(2, tz));
    var originShift = 2 * Math.PI / 2.0;

    var ctx = tile.getContext('2d');
    for (var i = 0; i < drawLayers.length; i++) {
      var drawList = [];

      if (drawLayers[i] instanceof L.FeatureGroup) {
        var layers = drawLayers[i].getLayers();
        for (var j = 0; j < layers.length; j++)
          drawList.push(layers[j]);
      }
      else {
        drawList.push(drawLayers[i]);
      }
      for (var j = 0; j < drawList.length; j++) {

        drawList[j]._ctx = ctx;
        drawList[j]._ctx.lineCap = 'round';
        drawList[j]._ctx.lineJoin = 'round';

        drawList[j]._map = this._map;

        drawList[j].projectLatlngs(
          tilePoint, this.options.canvasDx, this.options.canvasDy, tz, tileSize, resolution, originShift);

        if (!this._styleLoading) {
          var style = this.geojsonOptions.style;
          if (typeof style === 'function') {
            style = style(drawLayers[i].feature);
          }
          if (drawList[j].setStyle) {

            drawList[j].setStyle(style);
          }
        }
        drawList[j]._updatePath(drawOffset);
      }
    }
  },

  setOpacity: function (opacity) {
    this._opacity = opacity;
    if (this.geojsonLayer) {
      var opacitySetter = new GSI.LayerOpacitySetter();
      opacitySetter.setOpacity(this.geojsonLayer, opacity);
    }

    $(this._container).css({ "opacity": opacity });
  }
});

GSI.VectorTileLayer._onGeoJSONMouseMove = function (e) {
  if (!GSI.VectorTileLayer._layers) return;
  var hitLayer = null;
  for (var i = 0; i < GSI.VectorTileLayer._layers.length; i++) {
    var layer = GSI.VectorTileLayer._layers[i];
    if (!layer._useCanvas) continue;

    hitLayer = layer._latLngToChildLayer(e.latlng);

    if (hitLayer) break;

  }

  if (hitLayer) {
    layer._map.getContainer().style.cursor = 'pointer';
  }
  else {
    layer._map.getContainer().style.cursor = '';
  }
};

GSI.VectorTileLayer._onGeoJSONClick = function (e) {
  if (!GSI.VectorTileLayer._layers) return;
  var hitLayer = null;
  for (var i = 0; i < GSI.VectorTileLayer._layers.length; i++) {
    var layer = GSI.VectorTileLayer._layers[i];
    if (!layer._useCanvas) continue;

    var hitLayer = layer._latLngToChildLayer(e.latlng);

    if (hitLayer) {
      break;
    }
  }

  if (hitLayer) {
    layer._popup = hitLayer._popup;
    layer._popup.setLatLng(e.latlng);
    layer._map.openPopup(layer._popup);
  }
};

/************************************************************************
 L.Class
 - GSI.Toukyoken
   等距圏描画関連
 ************************************************************************/
GSI.ToukyokenDialog = GSI.Dialog.extend({

  options: {
    title: "等距圏の指定",
    width: "380px",
    minimize: true
  },

  // 初期化
  initialize: function (dialogManager, map, options) {
    this.map = map;
    this._distance = options.distance;
    this._lineStyle = $.extend({}, options.lineStyle);
    this._num = 20;
    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);

  },

  // 表示
  show: function () {
    GSI.Dialog.prototype.show.call(this);
    this._check();

  },

  // 入力監視開始
  _startCheck: function () {
    this._clearCheck();
  },

  _nextCheck: function () {
    this._checkTimerId = setTimeout(L.bind(function () {
      this._check();
    }, this), 200);

  },

  // 変更があれば生成しなおし
  _check: function () {

    var distance = this._toNumber(this._distanceInput.val());

    if (distance != undefined && distance > 0) {
      if (this._unitSelect.val() == "km") {
        distance = distance * 1000;
      }
      if (distance != this._distance) {
        var old = this._distance;
        this._distance = distance;
        this._fireChange(old, this._distance, this._unitSelect.val());
      }
    }

    var num = this._toNumber(this._numInput.val());
    if (num != undefined && num > 0) {
      if (num != this._num) {
        this._num = num;
        this._fireChange(this._distance, this._distance, this._unitSelect.val());
      }
    }

    this._nextCheck();
  },

  _toNumber: function (txt) {
    txt = txt.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });
    if (txt.match(/^[0-9]+$/)) {
      var result = parseInt(txt);
      if (!isNaN(result)) return result;
    }

    return undefined;
  },

  // チェック終了
  _clearCheck: function () {
    if (this._checkTimerId)
      clearTimeout(this._checkTimerId);

    this._checkTimerId = null;
  },

  hide: function () {

    this._clearCheck();
    GSI.Dialog.prototype.hide.call(this);
  },
  _cloceButtonClick: function () {
    this.fire("closeClick");
    this.hide();
  },
  createHeader: function () {
    this.title = $('<div>').html(this.options.title);

    return $('<div>').append(this.title);
  },

  setLineStyle: function (lineStyle) {
    this._lineStyle = $.extend({}, lineStyle);
    if (!this._unitSelect) return;

    this._lineWidthSelect.val(this._lineStyle.weight);
    this._lineColorSelect.css({ "background-color": this._lineStyle.color });
    this._lineTypeSelect.val(this._lineStyle.dashArray == undefined ? "normal" : this._lineStyle.dashArray);
  },

  setDistance: function (distance) {
    this._distance = distance;
    if (this._unitSelect) {
      var val = this._distance;
      if (this._unitSelect.val() == "km") {
        val = parseInt(this._distance / 1000);

      }

      this._distanceInput.val(val);
    }
  },

  getUnit: function () {
    return this._unitSelect.val();

  },

  _fireChange: function (from, to, unit) {

    this.fire("change", {
      from: from,
      to: to,
      unit: unit,
      num: this._num,
      label: this._visibleCheck[0].checked,
      lineStyle: this._lineStyle
    });

  },

  createContent: function () {
    this.frame = $('<div>').css({ "padding": "5px" }).addClass("gsi_toukyodialog_content");

    var table = $("<table>").css({ width: "100%" });
    var tr = $("<tr>");
    var td = null;
    td = $("<td>").attr({ "colspan": 3 });
    tr.append(td);
    table.append(tr);

    // 線幅
    var table2 = $("<table>");
    td.append(table2);

    tr = $("<tr>");
    td = $("<td>").html("線幅:");
    tr.append(td);

    this._lineWidthSelect = $("<select>");
    this._lineWidthSelect.append($("<option>").html("1px").val("1"));
    this._lineWidthSelect.append($("<option>").html("3px").val("3"));
    this._lineWidthSelect.append($("<option>").html("5px").val("5"));
    this._lineWidthSelect.append($("<option>").html("10px").val("10"));

    this._lineWidthSelect.on("change", L.bind(function () {
      var lineWidth = parseInt(this._lineWidthSelect.val());
      this._lineStyle.weight = parseInt(this._lineWidthSelect.val());

      this._fireChange(this._distance, this._distance, this._unitSelect.val());
    }, this));
    td.append(this._lineWidthSelect);

    // 線色
    td = $("<td>").html("線色:");
    tr.append(td);

    this._lineColorSelect = $("<div>").attr({ "id": "GSI_ToukyokenDialog_lineColor" }).addClass("color_select").html("　　");
    this._lineColorSelect.simpleColorPicker({
      showEffect: 'slide',
      hideEffect: 'slide',
      onChangeColor: L.bind(function (color) {
        this._lineColorSelect.css({ 'background': color });
        //
        this._lineStyle.color = color;
        this._fireChange(this._distance, this._distance, this._unitSelect.val());
      }, this)
    });

    td.append(this._lineColorSelect);

    // 線種
    td = $("<td>").html("線種:");
    tr.append(td);
    this._lineTypeSelect = $("<select>");
    this._lineTypeSelect.append($("<option>").html("実線").val("normal"));
    this._lineTypeSelect.append($("<option>").html("破線").val("dash"));
    this._lineTypeSelect.append($("<option>").html("点線").val("dot"));

    this._lineTypeSelect.on("change", L.bind(function () {
      this._lineStyle.dashArray = this._lineTypeSelect.val();

      this._fireChange(this._distance, this._distance, this._unitSelect.val());
    }, this));

    td.append(this._lineTypeSelect);

    table2.append(tr);

    //　間隔
    tr = $("<tr>");
    td = $("<td>").html("間隔:");
    tr.append(td);

    td = $("<td>");
    this._distanceInput = $("<input>").attr({ "type": "text" }).css({ "width": "100%" });

    td.append(this._distanceInput);
    tr.append(td);

    td = $("<td>");
    this._unitSelect = $("<select>");
    this._unitSelect.append($('<option>').html("m").val("m"));
    this._unitSelect.append($('<option>').html("km").val("km"));
    this._unitSelect.val("km");
    this._unitSelect.on("change", L.bind(function () {

      if (this._unitSelect.val() == "m") {
        this._distanceInput.val(this._distanceInput.val() * 1000);
      }
      else {
        this._distanceInput.val(parseInt(this._distanceInput.val() / 1000));
      }

      this._fireChange(this._distance, this._distance, this._unitSelect.val());
    }, this));

    td.append(this._unitSelect);
    tr.append(td);

    table.append(tr);

    // 本数
    tr = $("<tr>")
    td = $("<td>").html("線の本数:");
    tr.append(td);
    td = $("<td>").attr({ "colspan": 2 });
    this._numInput = $("<input>").attr({ "type": "text" }).css({ "width": "5em" });
    this._numInput.val(this._num);
    td.append(this._numInput);
    tr.append(td);
    table.append(tr);

    // 距離ラベル表示
    tr = $("<tr>")
    td = $("<td>").html("距離ラベル:");
    tr.append(td);
    td = $("<td>").attr({ "colspan": 2 });
    var id = "gsi-tokyoken-label-visible-check";
    this._visibleCheck = $("<input>").attr({ "id": id, "type": "checkbox" }).addClass("normalcheck");
    this._visibleCheck[0].checked = true;
    this._visibleCheck.on("click", L.bind(function () {

      this._fireChange(this._distance, this._distance, this._unitSelect.val());
    }, this));

    var label = $("<label>").attr({ "for": id }).html("表示する");
    td.append(this._visibleCheck);
    td.append(label);
    tr.append(td);
    table.append(tr);

    this.frame.append(table);

    var msgFrame = $("<div>").addClass("msg_frame").html("中心位置はドラッグして動かせます。");

    this.frame.append(msgFrame);

    this.setLineStyle(this._lineStyle);
    this.setDistance(this._distance);

    return this.frame;
  }
});

// 等距圏用レイヤ
GSI.Toukyoken = L.Evented.extend({
  options: {
    visible: false,
    lineStyle: {
      color: "#ea9999",
      weight: 3,
      lineCap: 'butt'
    },
    steps: 800,
    labelClassName: "gsi_toukyoken_label"
  },

  _interval: 1000000, // m
  _unit: 'km',
  _labelVisible: true,
  _num: 20,

  // 初期化
  initialize: function (map, dialogManager, menu, options) {
    options = L.setOptions(this, options);
    this._map = map;
    this._dialogManager = dialogManager;
    this._menu = menu;

    this._initialCenter = options.center ? options.center.clone() : null;

    if ( options.visible ) {
      this.setVisible(true );
    }
  },

  getCenter: function() {
    return this._center;
  },

  setVisible: function (on) {

    this.options.visible = on;
    if (this.options.visible) {
      if (!this._dlg) {
        var windowSize = this._dialogManager.getScreenSize();
        var pos = {
          left: windowSize.left + windowSize.w - 400,
          top: windowSize.h - 360
        };
        if (pos.left < 0) pos.left = 0;
        if (pos.top < 0) pos.top = 0;

        this._dlg = new GSI.ToukyokenDialog(this._dialogManager, this._map, {
          distance: this._interval,
          lineStyle: this.options.lineStyle,
          width: 320, left: pos.left, top: pos.top,
          effect: CONFIG.EFFECTS.DIALOG
        });
        this._dlg.on("change", L.bind(function (e) {
          this._interval = e.to;
          this._unit = e.unit;
          this._labelVisible = e.label;
          this._num = (e.num != undefined && e.num > 0 ? e.num : 1);
          this.options.lineStyle = $.extend({}, e.lineStyle);

          this.refresh();
        }, this))
          .on("closeClick", L.bind(function () {
            this._clear();
            this.options.visible = false;
          }, this));
      }
      this._dlg.setLineStyle(this.options.lineStyle);
      this._dlg.setDistance(this._interval);
      this._dlg.show();

      if ( this._initialCenter ) {
        this._center = this._initialCenter;
        this._initialCenter = null;
      } else {
        this._center = this._map.getCenter();
      }
      this.refresh();
    }
    else {
      if (this._dlg) {
        this._dlg.hide();
      }

      this._clear();
    }
    this.fire("change");

  },
  getVisible: function () {
    return this.options.visible;
  },
  // 等距圏用緯度経度リスト生成
  _createLatLngs: function (radius) {
    var idx = 0;

    var latlngs = [];
    latlngs[idx] = []
    var numSides = this.options.steps;
    var center = this._center.clone();
    var wrap = true;

    var direct = GSI.Utils.Geodesic.vincentyDirect(center, 0, radius, wrap);
    var prev = L.latLng(direct.lat, direct.lng);

    latlngs[idx].push(prev)
    for (step = 1; step <= numSides;) {
      direct = GSI.Utils.Geodesic.vincentyDirect(center, 360 / numSides * step, radius, wrap);
      var gp = L.latLng(direct.lat, direct.lng);

      if (Math.abs(gp.lng - prev.lng) > 180) {
        var inverse = GSI.Utils.Geodesic.vincentyInverse(prev, gp);
        var sec = GSI.Utils.Geodesic.intersection(prev, inverse.initialBearing, {
          lat: -89,
          lng: ((gp.lng - prev.lng) > 0) ? -GSI.Utils.Geodesic.INTERSECT_LNG : GSI.Utils.Geodesic.INTERSECT_LNG
        }, 0);
        if (sec) {
          latlngs[idx].push(L.latLng(sec.lat, sec.lng))
          idx++
          latlngs[idx] = []
          prev = L.latLng(sec.lat, -sec.lng)
          latlngs[idx].push(prev)
        } else {
          idx++
          latlngs[idx] = []
          latlngs[idx].push(gp)
          prev = gp
          step++
        }
      } else {
        latlngs[idx].push(gp);
        prev = gp
        step++
      }
    }

    var result = [];
    var prevLatLng = null;
    var MAX_LAT = 85.0511287798;
    var MIN_LAT = -85.0511287798;

    for (var i = 0; i < latlngs.length; i++) {
      var arr = [];
      for (var j = 0; j < latlngs[i].length; j++) {

        var latlng = latlngs[i][j];

        if (latlng.lat > MAX_LAT) {

          result.push(arr);
          arr = [];
        }
        else if (latlng.lat < MIN_LAT) {

          result.push(arr);
          arr = [];
        }
        else {
          arr.push(latlng);
        }

        prevLatLng = latlng;
      }

      if (arr.length > 0) result.push(arr);
    }

    return result;

  },
  // 等距圏クリア
  _clear: function () {
    this._clearLines();

    if (this._marker) {
      this._marker.remove();
      this._marker = null;
    }
  },

  // 等距圏ライン削除
  _clearLines: function () {

    if (this._layers)
      this._layers.remove();
    this._layers = null;

  },

  // 等距圏ラインクリック時
  _onLineClick: function (e) {
    var radius = e.target._radius;

    if (!radius) return;

    if (this._unit == 'km') {
      radiusText = parseInt(radius / 1000).toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1,') + "km"
    }
    else
      radiusText = radius.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1,') + "m";

  },

  // 等距圏生成しなおし
  refresh: function () {

    if (!this.options.visible) {
      this.clear();
      return;
    }

    var map = this._map;
    this._clearLines();
    if (!this._center) this._center = map.getCenter();

    if (!this._marker) {
      this._marker = L.marker(this._center, {
        draggable: true
      }).addTo(map).on("dragend", L.bind(function (e) {
        this._center = e.target.getLatLng();
        this.refresh();
      }, this));
    }

    if (!this._layers) {
      this._layers = L.layerGroup().addTo(map);

      var lineStyle = $.extend({}, this.options.lineStyle);
      switch (lineStyle.dashArray) {
        case "dash":
          lineStyle.dashArray = (lineStyle.weight * 5) + "," + lineStyle.weight;
          break;
        case "dot":
          lineStyle.dashArray = lineStyle.weight + "," + lineStyle.weight;
          break;
        default:
          lineStyle.dashArray = null;
          break;
      }

      lineStyle.noGeodesic = true;
      for (var i = 0; i < this._num; i++) {
        var radius = this._interval * (i + 1);
        var radiusText = radius;

        if (this._unit == 'km') {
          radiusText = parseInt(radius / 1000).toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1,') + "km"
        }
        else
          radiusText = radius.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1,') + "m";

        if (radius > 21000 * 1000) continue;
        var latLngs = this._createLatLngs(radius);
        L.polyline(latLngs, lineStyle).addTo(this._layers)
          .bindPopup(radiusText);
        L.polyline(this._addLng(latLngs, 360), lineStyle).addTo(this._layers)
          .bindPopup(radiusText);
        L.polyline(this._addLng(latLngs, -360), lineStyle).addTo(this._layers)
          .bindPopup(radiusText);

        // ラベル表示
        if (this._labelVisible) {
          var label = new L.Label({
            zoomAnimation: true,
            noHide: true,
            offset: [0, -0],
            className: this.options.labelClassName,
            clickable: false
          });

          label.setContent('<div unselectable="on" style="font-size:13pt;">' + radiusText + '</div>');
          var pos = GSI.Utils.Geodesic.vincentyDirect(this._center, (this._center.lat >= 0 ? 180 : 0), radius, true);

          label.setLatLng(pos);
          this._layers.addLayer(label);
        }
      }

      this._layers.eachLayer(function (layer) {
        layer._noMeasure = true;
      });

    }
  },

  // コピー作成
  getCloneLayer: function () {
    var result = L.layerGroup();

    if (this._layers) {
      var lineStyle = $.extend({}, this.options.lineStyle);
      switch (lineStyle.dashArray) {
        case "dash":
          lineStyle.dashArray = (lineStyle.weight * 5) + "," + lineStyle.weight;
          break;
        case "dot":
          lineStyle.dashArray = lineStyle.weight + "," + lineStyle.weight;
          break;
        default:
          lineStyle.dashArray = null;
          break;
      }

      lineStyle.noGeodesic = true;
      var labelClassName = this.options.labelClassName;

      this._layers.eachLayer(function (layer) {

        if (layer.getLatLngs) {
          var latLngs = layer.getLatLngs();

          L.polyline(latLngs, lineStyle).addTo(result);
        }
        else if (layer.setContent) {
          // ラベル表示
          var label = new L.Label({
            zoomAnimation: true,
            noHide: true,
            offset: [0, -0],
            className: labelClassName,
            clickable: false
          });
          label.setContent(layer._content);

          label.setLatLng(layer._latlng);
          result.addLayer(label);
        }
      });

      result.eachLayer(function (layer) {
        layer._noMeasure = true;
      });

    }
    return result;
  },

  _addLng: function (latLngs, a) {
    var result = [];
    for (var i = 0; i < latLngs.length; i++) {
      var arr = [];
      for (var j = 0; j < latLngs[i].length; j++) {
        arr.push(L.latLng(latLngs[i][j].lat, latLngs[i][j].lng + a));
      }
      result.push(arr);
    }

    return result;
  },

  // 画像保存時描画
  drawPath: function (texture, latLngBounds, pixelBounds) {
    var layers = this._layers.getLayers();

    var vp = this._map._pathViewport;
    var origin = this._map.getPixelOrigin();
    if (!pixelBounds) pixelBounds = this._map.getPixelBounds();

    for (var i = 0; i < layers.length; i++) {
      this._drawPath(texture, layers[i], origin, pixelBounds);
    }
  },

  _drawPath: function (ctx, layer, origin, pixelBounds) {
    if (!layer._parts) return;

    var i, len, j, len2, point, drawMethod;
    var dashArray = [];

    switch (this.options.lineStyle.dashArray) {
      case "dash":
        dashArray = [(this.options.lineStyle.weight * 5), this.options.lineStyle.weight];
        break;
      case "dot":
        dashArray = [this.options.lineStyle.weight, this.options.lineStyle.weight];
        break;
      default:
        dashArray = [];
        break;
    }

    var parts = layer._parts;

    for (i = 0, len = parts.length; i < len; i++) {

      ctx.beginPath();

      var prevPoint = null;
      for (j = 0, len2 = parts[i].length; j < len2; j++) {
        point = parts[i][j];
        drawMethod = (j === 0 ? 'move' : 'line') + 'To';

        if (j > 0 && dashArray.length > 0 && !ctx.setLineDash && !ctx.mozDash) {
          GSI.Utils.dotLineTo(ctx,
            prevPoint.x + (origin.x - pixelBounds.min.x), prevPoint.y + (origin.y - pixelBounds.min.y),
            point.x + (origin.x - pixelBounds.min.x), point.y + (origin.y - pixelBounds.min.y), dashArray);
        } else {
          ctx[drawMethod](point.x + (origin.x - pixelBounds.min.x), point.y + (origin.y - pixelBounds.min.y));
        }

        prevPoint = point;
      }
      ctx.save();
      if (ctx.setLineDash) ctx.setLineDash(dashArray);
      else if (ctx.mozDash) ctx.mozDash = dashArray;
      ctx.strokeStyle = this.options.lineStyle.color;
      ctx.lineWidth = this.options.lineStyle.weight;
      ctx.globalAlpha = 1;
      ctx.stroke();
      ctx.restore();
    }
  }
});

/************************************************************************
 L.Class
 - GSI.HouiLine
   方位線描画関連
 ************************************************************************/
GSI.HouiLineDialog = GSI.Dialog.extend({

  options: {
    title: "方位線の指定",
    width: "230px",
    minimize: true
  },

  _houiCount: 4,

  // 初期化
  initialize: function (dialogManager, map, options) {
    this._houiCount = 4;
    this.map = map;
    this._lineStyle = $.extend({}, options.lineStyle);
    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);
  },

  // ダイアログ表示
  show: function () {
    GSI.Dialog.prototype.show.call(this);

  },
  hide: function () {
    GSI.Dialog.prototype.hide.call(this);

    if (this._degCheckTimerId) {
      clearTimeout(this._degCheckTimerId);
      this._degCheckTimerId = null;
    }
  },
  // 閉じる
  _cloceButtonClick: function () {
    this.fire("closeClick");
    this.hide();
  },

  setLineStyle: function (lineStyle) {
    this._lineStyle = $.extend({}, lineStyle);
    if (!this._lineWidthSelect) return;

    this._lineWidthSelect.val(this._lineStyle.weight);
    this._lineColorSelect.css({ "background-color": this._lineStyle.color });
    this._lineTypeSelect.val(this._lineStyle.dashArray == undefined ? "normal" : this._lineStyle.dashArray);
  },

  createHeader: function () {
    this.title = $('<div>').html(this.options.title);

    return $('<div>').append(this.title);
  },

  _fireChange: function () {

    this.fire("change", {
      lineStyle: this._lineStyle
    });

  },

  createContent: function () {
    this.frame = $('<div>').css({ "padding": "5px" }).addClass("gsi_houilinedialog_content");

    var table = $("<table>");
    var tr = $("<tr>");
    var td = null;

    // 線幅

    td = $("<td>").html("線幅:");
    tr.append(td);

    this._lineWidthSelect = $("<select>");
    this._lineWidthSelect.append($("<option>").html("1px").val("1"));
    this._lineWidthSelect.append($("<option>").html("3px").val("3"));
    this._lineWidthSelect.append($("<option>").html("5px").val("5"));
    this._lineWidthSelect.append($("<option>").html("10px").val("10"));

    this._lineWidthSelect.on("change", L.bind(function () {
      var lineWidth = parseInt(this._lineWidthSelect.val());
      this._lineStyle.weight = parseInt(this._lineWidthSelect.val());

      this._fireChange();
    }, this));
    td.append(this._lineWidthSelect);

    // 線色
    td = $("<td>").html("線色:");
    tr.append(td);

    this._lineColorSelect = $("<div>").attr({ "id": "GSI_ToukyokenDialog_lineColor" }).addClass("color_select").html("　　");
    this._lineColorSelect.simpleColorPicker({
      showEffect: 'slide',
      hideEffect: 'slide',
      onChangeColor: L.bind(function (color) {
        this._lineColorSelect.css({ 'background': color });
        //
        this._lineStyle.color = color;
        this._fireChange();
      }, this)
    });

    td.append(this._lineColorSelect);

    // 線種
    td = $("<td>").html("線種:");
    tr.append(td);
    this._lineTypeSelect = $("<select>");
    this._lineTypeSelect.append($("<option>").html("実線").val("normal"));
    this._lineTypeSelect.append($("<option>").html("破線").val("dash"));
    this._lineTypeSelect.append($("<option>").html("点線").val("dot"));

    this._lineTypeSelect.on("change", L.bind(function () {
      this._lineStyle.dashArray = this._lineTypeSelect.val();

      this._fireChange();
    }, this));

    td.append(this._lineTypeSelect);

    table.append(tr);
    this.frame.append(table);

    table = $("<table>");

    // 方位線
    tr = $("<tr>");
    td = $("<td>").html("方位線:&nbsp;");
    tr.append(td);
    td = $("<td>");
    this._inputList = [];
    tr.append(this._createRadio($("<td>"), "4方向", "gsi_houiline_radio_" + GSI.Utils.getCurrentID(), 4));
    tr.append(this._createRadio($("<td>"), "8方向", "gsi_houiline_radio_" + GSI.Utils.getCurrentID(), 8));
    tr.append(this._createRadio($("<td>"), "16方向", "gsi_houiline_radio_" + GSI.Utils.getCurrentID(), 16));

    table.append(tr);

    tr = $("<tr>");
    tr.append($("<td>").html("&nbsp;"));
    tr.append(this._createRadio($("<td>").attr({ "colspan": 3 }), "角度を指定", "gsi_houiline_radio_" + GSI.Utils.getCurrentID(), 1));
    table.append(tr);

    this.frame.append(table);

    var msgFrame = $("<div>").addClass("msg_frame").html("中心位置はドラッグして動かせます。");

    this.frame.append(msgFrame);

    return this.frame;
  },

  _createRadio: function (container, caption, id, value) {
    var input = $("<input>").addClass("normalcheck").attr({ "name": "gsi_houiline_radio", "type": "radio", "id": id, "value": value }).css({ "width": "auto" });
    this._inputList.push(input);
    if (this._houiCount == value) {
      input.prop({ "checked": "checked" });
    }
    var label = $("<label>").attr({ "for": id }).html(caption);

    var refreshHandler = L.bind(function () {

      for (var i = 0; i < this._inputList.length; i++) {
        if (this._inputList[i].is(":checked")) {
          this._houiCount = parseInt(this._inputList[i].val());
          this._deg = this._degInput.data("deg");

          this.fire("change", { "houiCount": this._houiCount, "deg": this._deg });
          break;
        }
      }

    }, this);
    input.on('click',refreshHandler);
    container.append(input).append(label);

    if (value == 1) {
      var deg = (this._deg ? this._deg : 0)
      var degInput = $("<input>").attr({ "type": "text" }).val(deg + "").addClass("deginput");
      degInput.data({ "deg": deg });
      container.append(degInput).append($("<span>").html("度"));
      this._degInput = degInput;

      var checkHandler = L.bind(function () {
        var degInput = this._degInput;
        var changed = false;
        var old = degInput.data("deg");
        var current = old;

        var s = degInput.val();
        var reg = new RegExp(/^[+,-]?([1-9]\d*|0)$/);
        if (reg.test(s)) {
          current = parseInt(s);
        }

        if (old != current) {
          changed = true;
          degInput.data({ "deg": current });
        }
        return changed;
      }, this);
      degInput
        .on("focus", L.bind(function (checkHandler, refreshHandler) {
          if (!this._degCheckTimerId) {
            this._degCheckTimerId = setInterval(L.bind(function (checkHandler, refreshHandler) {

              if (checkHandler()) {
                refreshHandler();
              }

            }, this, checkHandler, refreshHandler), 200);
          }
        }, this, checkHandler, refreshHandler))
        .on("blur", L.bind(function (checkHandler, refreshHandler) {
          if (this._degCheckTimerId) {
            clearTimeout(this._degCheckTimerId);
            this._degCheckTimerId = null;
          }
          if (checkHandler()) {
            refreshHandler();
          }
        }, this, checkHandler, refreshHandler));

    }

    return container;

  },

  getHouiCount: function () {
    return this._houiCount;
  },
  getDeg: function () {
    return this._deg;
  }
});

// 方位線レイヤー
GSI.HouiLine = L.Evented.extend({
  options: {
    visible: false,
    lineStyle: {
      color: "#93c47d",
      weight: 3,
      lineCap: 'butt'
    },
    steps: 400
  },

  initialize: function (map, dialogManager, menu, options) {
    options = L.setOptions(this, options);
    this._map = map;
    this._dialogManager = dialogManager;
    this._menu = menu;

    this._initialCenter = (  options.center ? options.center.clone() : null );
    if ( options.visible ) {
      this.setVisible(true);
    }
  },

  getCenter : function() {
    return this._center;
  },

  // 表示切替
  setVisible: function (on) {
    this.options.visible = on;
    if (this.options.visible) {
      if (!this._dlg) {
        var windowSize = this._dialogManager.getScreenSize();

        var pos = {
          left: windowSize.left + windowSize.w - 400,
          top: windowSize.h - 200
        };
        if (pos.left < 0) pos.left = 0;
        if (pos.top < 0) pos.top = 0;

        this._dlg = new GSI.HouiLineDialog(this._dialogManager, this._map, {
          width: 320, left: pos.left, top: pos.top,
          lineStyle: this.options.lineStyle,
          effect: CONFIG.EFFECTS.DIALOG
        });
        this._dlg.on("change", L.bind(function (e) {
          if (e.lineStyle)
            this.options.lineStyle = $.extend({}, e.lineStyle);
          this.refresh(this._dlg.getHouiCount(), this._dlg.getDeg());
        }, this))
          .on("closeClick", L.bind(function () {
            this._clear();
            this.options.visible = false;
            this.fire("change");
          }, this));
      }
      this._dlg.setLineStyle(this.options.lineStyle);
      this._dlg.show();
      if ( this._initialCenter ) {
        this._center = this._initialCenter;
        this._initialCenter = null;
      } else {
        this._center = this._map.getCenter();
      }
      this.refresh(this._dlg.getHouiCount(), this._dlg.getDeg());
    }
    else {
      if (this._dlg) {
        this._dlg.hide();
      }

      this._clear();
    }

    if (this._dlg)
      this.refresh(this._dlg.getHouiCount(), this._dlg.getDeg());

    this.fire("change");

  },

  // クリア
  _clear: function () {
    if (this._layers) {
      this._layers.remove();
      this._layers = null;
    }

    if (this._marker) {
      this._marker.remove();
      this._marker = null;
    }

  },

  getVisible: function () {
    return this.options.visible;
  },

  // 方位線生成
  refresh: function (houiCount, deg) {
    if (!this.options.visible) {
      this._clear();
      return;
    }

    if (this._layers) {
      this._layers.remove();
      this._layers = null;
    }

    var map = this._map;

    this._layers = L.layerGroup().addTo(map);

    if (!this._center) this._center = map.getCenter();

    if (!this._marker) {
      this._marker = L.marker(this._center, {
        draggable: true
      }).addTo(map).on("dragend", L.bind(function (e) {
        this._center = e.target.getLatLng();
        this.refresh(this._dlg.getHouiCount(), this._dlg.getDeg());
      }, this));
    }
    var center = this._center;
    var latLngs;

    var lineStyle = $.extend({}, this.options.lineStyle);
    switch (lineStyle.dashArray) {
      case "dash":
        lineStyle.dashArray = (lineStyle.weight * 5) + "," + lineStyle.weight;
        break;
      case "dot":
        lineStyle.dashArray = lineStyle.weight + "," + lineStyle.weight;
        break;
      default:
        lineStyle.dashArray = null;
        break;
    }

    lineStyle.noGeodesic = true;

    if (houiCount > 1) {
      for (var step = 1; step <= houiCount; step++) {
        this._drawLine(lineStyle, center, 360 / houiCount * step);
      }
    } else {
      this._drawLine(lineStyle, center, deg);
    }

    this._layers.eachLayer(function (layer) {
      layer._noMeasure = true;
    });

  },

  _drawLine: function (lineStyle, center, deg) {
    var latLngs;
    var to = GSI.Utils.Geodesic.vincentyDirect(center, deg, 19500000, true);
    var toLatLng = L.latLng(to.lat, to.lng);

    latLngs = GSI.Utils.Geodesic.createLine([[center, toLatLng]], 200);
    L.polyline(this._fixLatLngs(latLngs), lineStyle).addTo(this._layers);

    latLngs = GSI.Utils.Geodesic.createLine([[L.latLng(center.lat, center.lng + 360), L.latLng(toLatLng.lat, toLatLng.lng + 360)]], 200);
    L.polyline(this._fixLatLngs(latLngs), lineStyle).addTo(this._layers);

    latLngs = GSI.Utils.Geodesic.createLine([[L.latLng(center.lat, center.lng - 360), L.latLng(toLatLng.lat, toLatLng.lng - 360)]], 200);
    L.polyline(this._fixLatLngs(latLngs), lineStyle).addTo(this._layers);

  },

  // 北端、南端切る
  _fixLatLngs: function (latlngs) {
    var getHalfPoint = function (a, b, lat) {
      var x = a.lng - b.lng;
      var y = a.lat - b.lat;

      var rad = Math.atan2(x, y);
      var deg = rad * 180 / Math.PI;

      return L.latLng(lat,
        a.lng + ((lat - a.lat) * Math.tan(deg)));
    };
    var result = [];
    var prevLatLng = null;
    var MAX_LAT = 85.0511287798;
    var MIN_LAT = -85.0511287798;

    for (var i = 0; i < latlngs.length; i++) {
      var arr = [];
      for (var j = 0; j < latlngs[i].length; j++) {

        var latlng = latlngs[i][j];

        if (latlng.lat > MAX_LAT) {

          if (prevLatLng && prevLatLng.lat < MAX_LAT) {
            var p =
              (latlng.lat - prevLatLng.lat) /
              (MAX_LAT - prevLatLng.lat);

            arr.push(
              L.latLng(
                MAX_LAT,
                prevLatLng.lng +
                (latlng.lng - prevLatLng.lng) * p
              )
            );
          }

          result.push(arr);
          arr = [];
        }
        else if (latlng.lat < MIN_LAT) {

          if (prevLatLng && prevLatLng.lat > MIN_LAT) {
            var p =
              (latlng.lat - prevLatLng.lat) /
              (MIN_LAT - prevLatLng.lat);

            arr.push(
              L.latLng(
                MIN_LAT,
                prevLatLng.lng +
                (latlng.lng - prevLatLng.lng) * p
              )
            );
          }

          result.push(arr);
          arr = [];
        }
        else {
          if (prevLatLng && prevLatLng.lat > MAX_LAT) {
            var p =
              (latlng.lat - prevLatLng.lat) /
              (MAX_LAT - prevLatLng.lat);

            arr.push(
              L.latLng(
                MAX_LAT,
                prevLatLng.lng +
                (latlng.lng - prevLatLng.lng) * p
              )
            );
          }
          else if (prevLatLng && prevLatLng.lat < MIN_LAT) {
            var p =
              (latlng.lat - prevLatLng.lat) /
              (MIN_LAT - prevLatLng.lat);

            arr.push(
              L.latLng(
                MIN_LAT,
                prevLatLng.lng +
                (latlng.lng - prevLatLng.lng) * p
              )
            );
          }

          arr.push(latlng);
        }

        prevLatLng = latlng;
      }

      if (arr.length > 0) result.push(arr);
    }

    return result;
  },

  // コピー生成
  getCloneLayer: function () {
    var result = L.layerGroup();
    if (this._layers) {
      var lineStyle = $.extend({}, this.options.lineStyle);
      switch (lineStyle.dashArray) {
        case "dash":
          lineStyle.dashArray = (lineStyle.weight * 5) + "," + lineStyle.weight;
          break;
        case "dot":
          lineStyle.dashArray = lineStyle.weight + "," + lineStyle.weight;
          break;
        default:
          lineStyle.dashArray = null;
          break;
      }
      lineStyle.noGeodesic = true;
      this._layers.eachLayer(function (layer) {

        if (!layer.getLatLngs) return;

        var latLngs = layer.getLatLngs();

        L.polyline(latLngs, lineStyle).addTo(result);

      });

      result.eachLayer(function (layer) {
        layer._noMeasure = true;
      });

    }

    return result;
  },

  // 画像保存時の描画
  drawPath: function (texture, latLngBounds, pixelBounds) {
    var layers = this._layers.getLayers();

    var vp = this._map._pathViewport;
    var origin = this._map.getPixelOrigin();
    if (!pixelBounds) pixelBounds = this._map.getPixelBounds();

    for (var i = 0; i < layers.length; i++) {
      this._drawPath(texture, layers[i], origin, pixelBounds);
    }

  },

  _drawPath: function (ctx, layer, origin, pixelBounds) {
    if (!layer._parts) return;

    var i, len, j, len2, point, drawMethod;
    var dashArray = [];

    switch (this.options.lineStyle.dashArray) {
      case "dash":
        dashArray = [(this.options.lineStyle.weight * 5), this.options.lineStyle.weight];
        break;
      case "dot":
        dashArray = [this.options.lineStyle.weight, this.options.lineStyle.weight];
        break;
      default:
        dashArray = [];
        break;
    }

    var parts = layer._parts;

    for (i = 0, len = parts.length; i < len; i++) {

      ctx.beginPath();

      var prevPoint = null;
      for (j = 0, len2 = parts[i].length; j < len2; j++) {
        point = parts[i][j];
        drawMethod = (j === 0 ? 'move' : 'line') + 'To';

        if (j > 0 && dashArray.length > 0 && !ctx.setLineDash && !ctx.mozDash) {
          GSI.Utils.dotLineTo(ctx,
            prevPoint.x + (origin.x - pixelBounds.min.x), prevPoint.y + (origin.y - pixelBounds.min.y),
            point.x + (origin.x - pixelBounds.min.x), point.y + (origin.y - pixelBounds.min.y), dashArray);
        } else {
          ctx[drawMethod](point.x + (origin.x - pixelBounds.min.x), point.y + (origin.y - pixelBounds.min.y));
        }
        prevPoint = point;
      }
      ctx.save();
      if (ctx.setLineDash) ctx.setLineDash(dashArray);
      else if (ctx.mozDash) ctx.mozDash = dashArray;
      ctx.strokeStyle = this.options.lineStyle.color;
      ctx.lineWidth = this.options.lineStyle.weight;
      ctx.globalAlpha = 1;
      ctx.stroke();
      ctx.restore();
    }
  }
});

/************************************************************************
 GSI.ElevationLoader
************************************************************************/
GSI.ElevationLoader = L.Evented.extend({

  initialize: function (map, options) {
    this._map = map;
    this._initUrlList();
    this._initUtils();
  },

  _initUrlList: function(){
    this._demUrlList = CONFIG.DEMURLLIST;
  },

  _initUtils(){
    this.pow2_8 = Math.pow(2, 8);
    this.pow2_16 = Math.pow(2, 16);
    this.pow2_23 = Math.pow(2, 23);
    this.pow2_24 = Math.pow(2, 24);
  },

  load: function (pos) {

    this._destroyImage();
    this._current = {
      pos: pos,
      urlList: this._makeUrlList(pos)
    }

    this._load(this._current);
  },

  _makeUrlList: function (pos) {
    var list = [];
    var buffList = [];
    for (var i = 0; i <= 20; i++) {
      buffList.push([]);
    }
    for (var i = 0; i < this._demUrlList.length; i++) {
      var demUrl = this._demUrlList[i];
      if (demUrl.maxzoom < demUrl.minzoom) {
        var buff = demUrl.maxzoom;
        demUrl.maxzoom = demUrl.minzoom;
        demUrl.minzoom = buff;
      }
      var minzoom = demUrl.minzoom;
      for (var z = demUrl.maxzoom; z >= minzoom; z--) {
        buffList[z].push({
          "title": demUrl.title,
          "zoom": z,
          "url": demUrl.url,
          "fixed": demUrl.fixed
        });
      }
    }

    for (var i = buffList.length - 1; i >= 0; i--) {
      for (var j = 0; j < buffList[i].length; j++) {
        list.push(buffList[i][j]);
      }
    }

    return list;
  },

  _destroyImage: function () {
    if (this._img) {

      this._img.removeEventListener("load", this._imgLoadHandler);
      this._img.removeEventListener("error", this._imgLoadErrorHandler);

      this._imgLoadHandler = null;
      this._imgLoadErrorHandler = null;
      delete this._img;
      this._img = null;
    }
  },

  cancel: function () {
    this._destroyImage();

  },

  _parseValidUrl: function(valueError){
    if (!this._current.urlList || this._current.urlList.length <= 0) return null;   //not found
    
    var url = this._current.urlList.shift();
    if ( valueError && url.title=="DEMGM") return null;
    
    return url;
  },

  _load: function (current, valueError) {
    this._destroyImage();

    if (this._current != current) return;

    var url = this._parseValidUrl(valueError);
    if(!url) {
      this.fire("load", {
        h: undefined,
        pos: current.pos
      });
      return;
    }

    this._initImgInfo(url);
  },

  _onImgLoad: function (url, current, tileInfo, img) {

    if (current != this._current) return;

    if (!this._canvas) {
      this._canvas = document.createElement("canvas");
      this._canvas.width = 256;
      this._canvas.height = 256;
    }
    var ctx = this._canvas.getContext("2d");
    ctx.clearRect(0, 0, 256, 256);
    ctx.beginPath();

    ctx.drawImage(img, 0, 0);

    var imgData = ctx.getImageData(0, 0, 256, 256);
    var idx = (tileInfo.pY * 256 * 4) + (tileInfo.pX * 4);
    var r = imgData.data[idx + 0];
    var g = imgData.data[idx + 1];
    var b = imgData.data[idx + 2];
    var h = 0;

    if (r != 128 || g != 0 || b != 0) {
      var d = r * this.pow2_16 + g * this.pow2_8 + b;
      h = (d < this.pow2_23) ? d : d - this.pow2_24;
      if (h == -this.pow2_23) h = 0;
      else h *= 0.01;
      this._destroyImage();

      this.fire("load", {
        h: h,
        title: url.title,
        fixed: url.fixed,
        pos: current.pos
      })
    }
    else {
      this._load(current, true);
    }
  },

  _onImgLoadError: function (url, current, tileInfo, img) {
    if (current != this._current) return;
    this._load(current);
  },

  _getTileInfo: function (lat, lng, z) {
    var lng_rad = lng * Math.PI / 180;
    var R = 128 / Math.PI;
    var worldCoordX = R * (lng_rad + Math.PI);
    var pixelCoordX = worldCoordX * Math.pow(2, z);
    var tileCoordX = Math.floor(pixelCoordX / 256);

    var lat_rad = lat * Math.PI / 180;
    var worldCoordY = - R / 2 * Math.log((1 + Math.sin(lat_rad)) / (1 - Math.sin(lat_rad))) + 128;
    var pixelCoordY = worldCoordY * Math.pow(2, z);
    var tileCoordY = Math.floor(pixelCoordY / 256);

    return {
      x: tileCoordX,
      y: tileCoordY,
      pX: Math.floor(pixelCoordX - tileCoordX * 256),
      pY: Math.floor(pixelCoordY - tileCoordY * 256)
    };

  },

  _initImgInfo: function(url){
    if(!url) return;
    var tileInfo = this._getTileInfo(this._current.pos.lat, this._current.pos.lng, url.zoom);
    this._img = document.createElement("img");
    this._img.setAttribute("crossorigin", "anonymous");

    this._imgLoadHandler = L.bind(this._onImgLoad, this, url, this._current, tileInfo, this._img);
    this._imgLoadErrorHandler = L.bind(this._onImgLoadError, this, url, this._current, tileInfo, this._img);

    this._img.addEventListener("load", this._imgLoadHandler);
    this._img.addEventListener("error", this._imgLoadErrorHandler);
    this._img.src = this._makeUrlFromTile(url, tileInfo);
  },

  _makeUrlFromTile: function(url, tileInfo) {
    var result = url.url.replace("{x}", tileInfo.x);
    result = result.replace("{y}", tileInfo.y);
    result = result.replace("{z}", url.zoom);
    return result;
  }
});

/************************************************************************
 L.Evented
 - GSI.ElevationLoader
   - GSI.FooterElevationLoader (フッター用標高画像ローダー)
 ************************************************************************/
GSI.FooterElevationLoader = GSI.ElevationLoader.extend({
  _initUrlList: function(){
    this._demUrlList = CONFIG.FOOTERDEMURLLIST;
  },

  _parseValidUrl: function(valueError){
    if (!this._current.urlList || this._current.urlList.length <= 0) return null;   //not found
    
    var url = this._current.urlList.shift();
    if ( valueError && url.title=="DEMGM") return null;
    if ((this._map.getZoom() > url.zoom) && (url.title == "DEMGM")) return null;

    return url;
  }
});

/************************************************************************
  L.Evented
- GSI.ElevationLoader
  - GSI.LakeDataLoader (フッター用湖水データローダー)
************************************************************************/
GSI.LakeDataLoader = GSI.ElevationLoader.extend({
  _initUrlList: function () {
    this._demUrlList = [];
  },

  _makeUrlList: function (pos) {
    var list = [];
    for (var i = 0; i < this._demUrlList.length; i++) {
      var demUrl = this._demUrlList[i];
      list.push({
        "title": demUrl.title,
        "zoom": 18,
        "url": demUrl.url,
        "fixed": demUrl.fixed
      });
    }

    return list;
  },

  _parseValidUrl: function(valueError){
    if (!this._current.urlList || this._current.urlList.length <= 0) return null;   //not found
    
    var url = this._current.urlList.shift();
    if (valueError) return null;
    if (this._map.getZoom() > url.zoom) return null;

    return url;
  },

  _makeUrlFromTile: function(url, tileInfo) {
    var result = url.url.replace("{x}", tileInfo.x);
    result = result.replace("{y}", tileInfo.y);
    result = result.replace("{z}", '14');
    return result;
  },

  _getTileInfo: function (lat, lng, z) {
    z = 14;

    var lng_rad = lng * Math.PI / 180;
    var R = 128 / Math.PI;
    var worldCoordX = R * (lng_rad + Math.PI);
    var pixelCoordX = worldCoordX * Math.pow(2, z);
    var tileCoordX = Math.floor(pixelCoordX / 256);

    var lat_rad = lat * Math.PI / 180;
    var worldCoordY = - R / 2 * Math.log((1 + Math.sin(lat_rad)) / (1 - Math.sin(lat_rad))) + 128;
    var pixelCoordY = worldCoordY * Math.pow(2, z);
    var tileCoordY = Math.floor(pixelCoordY / 256);

    return {
      x: tileCoordX,
      y: tileCoordY,
      pX: Math.floor(pixelCoordX - tileCoordX * 256),
      pY: Math.floor(pixelCoordY - tileCoordY * 256)
    };
  },
});

/************************************************************************
  L.Evented
- GSI.ElevationLoader
  - GSI.LakeDataLoader
    - GSI.LakeDepthLoader (フッター用湖水深画像ローダー)
************************************************************************/
GSI.LakeDepthLoader = GSI.LakeDataLoader.extend({
  _initUrlList: function () {
    this._demUrlList = CONFIG.LAKEDEPTHURLLIST;
  }
});

/************************************************************************
  L.Evented
- GSI.ElevationLoader
  - GSI.LakeDataLoader
    - GSI.LakeStdHeightLoader (フッター用基準水面標高画像ローダー)
************************************************************************/
GSI.LakeStdHeightLoader = GSI.LakeDataLoader.extend({
  _initUrlList: function () {
    this._demUrlList = CONFIG.LAKESTDHEIGHTURLLIST;
  }
});

/************************************************************************
 L.Class
 - GSI.Dialog
   - GSI.ThreeDAreaDialog (3D範囲指定管理)
 ************************************************************************/
GSI.ThreeDAreaDialog = GSI.Dialog.extend({
  options: {
    title: GSI.TEXT.THREEDAREA.DIALOG_TITLE,
    width: "200px",
    minimize: true
  },
  initialize: function (gsimaps, dialogManager, map, options) {
    this._gsimaps = gsimaps;
    this._map = map;

    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);

  },

  show: function () {

    GSI.Dialog.prototype.show.call(this);

    this._onModeChange();
  },
  hide: function () {
    this._stopCheck();
    if (this._areaSelectLayer) this._areaSelectLayer.remove();
    if (this._sizeSelectLayer) this._sizeSelectLayer.remove();
    this._areaSelectLayer = null;
    this._sizeSelectLayer = null;

    GSI.Dialog.prototype.hide.call(this);
  },
  createHeader: function () {
    this.title = $('<div>').html(this.options.title);

    return $('<div>').append(this.title);
  },

  _onSizeChange: function (e) {
    if (!this._frame) return;

    this._widthInput.removeClass("error");
    this._heightInput.removeClass("error");

    this._widthInput.val(e.width);
    this._heightInput.val(e.height);

    this._setBoundsToView(e.bounds);
    this._checkSize(e.width, e.height);
  },

  _setBoundsToView: function (bounds) {

    var nw = bounds.getNorthWest();
    var se = bounds.getSouthEast();
    this._latLtView.html((Math.round(nw.lat * 1000000) / 1000000).toFixed(6));
    this._lngLtView.html((Math.round(nw.lng * 1000000) / 1000000).toFixed(6));
    this._latRbView.html((Math.round(se.lat * 1000000) / 1000000).toFixed(6));
    this._lngRbView.html((Math.round(se.lng * 1000000) / 1000000).toFixed(6));

  },

  _checkSize: function (w, h) {

    if (w == undefined || w < 256 || h < 256 || w > 2048 || h > 2048) {
      this._errorMessage.html("大きさを256×256～2048×2048の範囲で指定して下さい。").show();
      this._okButton.hide();

      this._widthView.html(w);
      this._heightView.html(h);
    }
    else {

      if (w != undefined) {
        if (w % 2 != 0) w++;
        if (h % 2 != 0) h++;

        this._widthView.html(w);
        this._heightView.html(h);
      }
      this._okButton.show();
      this._errorMessage.hide();
    }
  },

  _onAreaChange: function (e) {

    if (!this._frame) return;

    this._latLtInput.removeClass("error");
    this._lngLtInput.removeClass("error");
    this._latRbInput.removeClass("error");
    this._lngRbInput.removeClass("error");

    this._latLtInput.val((this._areaSelectLayer && this._areaSelectLayer._latLngBounds ?
      (Math.round(this._areaSelectLayer._latLngBounds.getNorthWest().lat * 1000000) / 1000000).toFixed(6) : ""));
    this._lngLtInput.val((this._areaSelectLayer && this._areaSelectLayer._latLngBounds ?
      (Math.round(this._areaSelectLayer._latLngBounds.getNorthWest().lng * 1000000) / 1000000).toFixed(6) : ""));
    this._latRbInput.val((this._areaSelectLayer && this._areaSelectLayer._latLngBounds ?
      (Math.round(this._areaSelectLayer._latLngBounds.getSouthEast().lat * 1000000) / 1000000).toFixed(6) : ""));
    this._lngRbInput.val((this._areaSelectLayer && this._areaSelectLayer._latLngBounds ?
      (Math.round(this._areaSelectLayer._latLngBounds.getSouthEast().lng * 1000000) / 1000000).toFixed(6) : ""));

    this._checkSize(e.width, e.height);
  },

  createContent: function () {

    this._frame = $('<div>').addClass("gsi_threeddialog_content");

    var modeSelectFrame = $('<div>');

    this._areaSelectRadio = $("<input>").attr({ "name": "gsi_threeddialog_modeselect", "id": "gsi_threeddialog_modeselect_area", "type": "radio" }).addClass("normalcheck");
    var label = $("<label>").attr({ "for": "gsi_threeddialog_modeselect_area" }).html("範囲を固定");
    modeSelectFrame.append(this._areaSelectRadio).append(label);
    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.W3D) {
      label.attr({ "title": CONFIG.TOOLTIP.W3D.FIX_AREA });
      this._areaSelectRadio.attr({ "title": CONFIG.TOOLTIP.W3D.FIX_AREA });
    }

    this._sizeSelectRadio = $("<input>").attr({ "name": "gsi_threeddialog_modeselect", "id": "gsi_threeddialog_modeselect_size", "type": "radio" }).addClass("normalcheck");
    label = $("<label>").attr({ "for": "gsi_threeddialog_modeselect_size" }).html("大きさを固定");
    modeSelectFrame.append(this._sizeSelectRadio).append(label);
    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.W3D) {
      label.attr({ "title": CONFIG.TOOLTIP.W3D.FIX_SIZE });
      this._sizeSelectRadio.attr({ "title": CONFIG.TOOLTIP.W3D.FIX_SIZE });
    }

    this._areaSelectRadio[0].checked = true;

    this._areaSelectRadio.on("click", L.bind(this._onModeChange, this));
    this._sizeSelectRadio.on("click", L.bind(this._onModeChange, this));

    this._frame.append(modeSelectFrame);

    this._areaSelectFrame = this._createAreaSelectContent();
    this._sizeSelectFrame = this._createSizeSelectContent();

    this._frame.append(this._areaSelectFrame);
    this._frame.append(this._sizeSelectFrame);

    this._buttonFrame = $('<div>').css({ "text-align": "center" }).addClass("button_frame");

    this._errorMessage = $("<div>").addClass("errormessage").hide();
    this._okButton = $('<a>')
      .addClass("normalbutton threedareadialog_button")
      .attr({ "href": "javascript:void(0);" })
      .html(GSI.TEXT.THREEDAREA.DIALOG_OKBTN)
      .on('click',L.bind(this._onOkClick, this));

    this._buttonFrame
      .append(this._errorMessage)
      .append(this._okButton);

    this._frame.append(this._buttonFrame);

    return this._frame;
  },

  _onModeChange: function () {

    if (this._areaSelectRadio[0].checked) {

      var center = this._map.getCenter();
      var bounds = undefined;

      if (this._sizeSelectLayer) {
        center = this._sizeSelectLayer.getCenter();
        bounds = this._sizeSelectLayer.getBounds();
        this._sizeSelectLayer.remove();
        this._sizeSelectLayer = null;
      }

      if (!this._areaSelectLayer) {
        this._areaSelectLayer = new GSI.MapSizeAreaSelectLayer.LatLng(center, bounds);
        this._areaSelectLayer.on("change", L.bind(this._onAreaChange, this));
        this._areaSelectLayer.addTo(this._map);
      }

      this._sizeSelectFrame.hide();
      this._areaSelectFrame.show();
    } else {
      var center = this._map.getCenter();
      var size = { width: 256, height: 256 };
      var bounds = undefined;

      if (this._areaSelectLayer) {
        center = null;
        bounds = this._areaSelectLayer.getBounds();

        this._areaSelectLayer.remove();
        this._areaSelectLayer = null;
      }

      if (!this._sizeSelectLayer) {
        this._sizeSelectLayer = new GSI.MapSizeAreaSelectLayer.Size(center, size, bounds);
        this._sizeSelectLayer.on("change", L.bind(this._onSizeChange, this));
        this._sizeSelectLayer.addTo(this._map);
      }

      this._areaSelectFrame.hide();
      this._sizeSelectFrame.show();
    }
  },

  _createAreaSelectContent: function () {

    var frame = $("<div>");

    var infoTable = $('<table>');
    var infoTableTBody = $('<tbody>');
    var tr = null;
    var td = null;

    tr = $("<tr>");
    tr.append($("<td>").css({ "white-space": "nowrap" }).html("緯度:"));

    //緯度from
    td = $('<td>').css({ "white-space": "nowrap" }).html('');
    this._latRbInput = $("<input>").attr({ "type": "text" })
      .on("focus", L.bind(function () {
        this._startCheck(this._latRbInput);
      }, this))
      .on("blur", L.bind(function () {
        this._stopCheck(this._latRbInput);
      }, this));
    td.append(this._latRbInput);
    tr.append(td);

    // ～
    td = $('<td>').css({ "white-space": "nowrap", "width": "1px" }).html('～');
    tr.append(td);

    //緯度To
    td = $('<td>').css({ "white-space": "nowrap" }).html('');
    this._latLtInput = $("<input>").attr({ "type": "text" })
      .on("focus", L.bind(function () {
        this._startCheck(this._latLtInput);
      }, this))
      .on("blur", L.bind(function () {
        this._stopCheck(this._latLtInput);
      }, this));
    td.append(this._latLtInput);
    tr.append(td);

    infoTableTBody.append(tr);

    // 経度from
    tr = $("<tr>");
    tr.append($("<td>").css({ "white-space": "nowrap" }).html("経度:"));
    td = $('<td>').css({ "white-space": "nowrap" }).html('');
    this._lngLtInput = $("<input>").attr({ "type": "text" })
      .on("focus", L.bind(function () {
        this._startCheck(this._lngLtInput);
      }, this))
      .on("blur", L.bind(function () {
        this._stopCheck(this._lngLtInput);
      }, this));
    td.append(this._lngLtInput);
    tr.append(td);

    // ～
    td = $('<td>').css({ "white-space": "nowrap", "width": "1px" }).html('～');
    tr.append(td);

    //経度To
    td = $('<td>').css({ "white-space": "nowrap" }).html('');
    this._lngRbInput = $("<input>").attr({ "type": "text" })
      .on("focus", L.bind(function () {
        this._startCheck(this._lngRbInput);
      }, this))
      .on("blur", L.bind(function () {
        this._stopCheck(this._lngRbInput);
      }, this));
    td.append(this._lngRbInput);

    tr.append(td);
    infoTableTBody.append(tr);

    // 大きさ
    tr = $("<tr>").append($("<td>").css({ "white-space": "nowrap" }).html("大きさ:"));

    td = $("<td>").attr({ "colspan": 3 });

    this._widthView = $("<span>");
    td.append(this._widthView);

    td.append(document.createTextNode("×"));
    this._heightView = $("<span>");
    td.append(this._heightView);

    tr.append(td);
    infoTableTBody.append(tr);

    infoTable.append(infoTableTBody);

    frame
      .append(infoTable);

    return frame;
  },

  _createSizeSelectContent: function () {

    var frame = $("<div>");

    var infoTable = $('<table>');
    var infoTableTBody = $('<tbody>');
    var tr = null;
    var td = null;

    tr = $("<tr>");
    tr.append($("<td>").css({ "white-space": "nowrap" }).html("大きさ:"));

    //幅
    td = $('<td>').css({ "white-space": "nowrap" }).html('');
    this._widthInput = $("<input>").attr({ "type": "text" })
      .on("focus", L.bind(function () {
        this._startCheck(this._widthInput);
      }, this))
      .on("blur", L.bind(function () {
        this._stopCheck(this._widthInput);
      }, this));
    td.append(this._widthInput);
    tr.append(td);

    // ×
    td = $('<td>').css({ "white-space": "nowrap", "width": "1px" }).html('×');
    tr.append(td);

    //高さ
    td = $('<td>').css({ "white-space": "nowrap" }).html('');
    this._heightInput = $("<input>").attr({ "type": "text" })
      .on("focus", L.bind(function () {
        this._startCheck(this._heightInput);
      }, this))
      .on("blur", L.bind(function () {
        this._stopCheck(this._heightInput);
      }, this));
    td.append(this._heightInput);
    tr.append(td);

    infoTableTBody.append(tr);

    //緯度
    tr = $("<tr>");

    td = $("<td>").html("緯度：");
    tr.append(td);

    td = $("<td>");
    this._latRbView = $("<span>");
    td.append(this._latRbView);
    tr.append(td);

    td = $("<td>").html("～");
    tr.append(td);

    td = $("<td>");
    this._latLtView = $("<span>");
    td.append(this._latLtView);
    tr.append(td);

    infoTableTBody.append(tr);

    //経度
    tr = $("<tr>");

    td = $("<td>").html("経度：");
    tr.append(td);

    td = $("<td>");
    this._lngLtView = $("<span>");
    td.append(this._lngLtView);
    tr.append(td);

    td = $("<td>").html("～");
    tr.append(td);

    td = $("<td>");
    this._lngRbView = $("<span>");
    td.append(this._lngRbView);
    tr.append(td);

    infoTableTBody.append(tr);

    infoTable.append(infoTableTBody);

    frame.append(infoTable);

    return frame;

  },

  _onOkClick: function () {

    var size = null;
    var center = null;
    if (this._areaSelectRadio[0].checked) {
      center = this._areaSelectLayer.getCenter();
      size = this._areaSelectLayer.getSize();
    } else {

      center = this._sizeSelectLayer.getCenter();
      size = this._sizeSelectLayer.getSize();
    }
    var args = "";
    args += "?z=" + this._map.getZoom();
    args += "&lat=" + center.lat;
    args += "&lon=" + center.lng;
    var w = size.width;
    var h = size.height;

    if (w % 2 != 0) w++;
    if (h % 2 != 0) h++;

    args += "&w=" + w;
    args += "&h=" + h;

    args += "&" + this._gsimaps._pageStateManager.getLayersQueryString({ visibleOnly: true, withRelief: true })

    this.hide();

    window.open("./index_3d.html" + args);
  },

  _startCheck: function (input) {
    this._checkTarget = input;
    this._oldValue = input.val();
    this._check();

  },

  _isUInt: function (s) {
    if (s.match(/^[0-9]+$/)) {
      return true;
    }
    else {
      return false;
    }
  },

  _getInputBounds: function () {
    var latLt = this._latLtInput.val();
    var lngLt = this._lngLtInput.val();
    var latRb = this._latRbInput.val();
    var lngRb = this._lngRbInput.val();

    var latLtErr = false;
    var lngLtErr = false;
    var latRbErr = false;
    var lngRbErr = false;

    latLt = latLt.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });
    latLt = latLt.replace(/．/g, ".");

    lngLt = lngLt.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });
    lngLt = lngLt.replace(/．/g, ".");

    latRb = latRb.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });
    latRb = latRb.replace(/．/g, ".");

    lngRb = lngRb.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });
    lngRb = lngRb.replace(/．/g, ".");

    if (!latLt.match(/^-?[0-9]+\.[0-9]+$/) && !latLt.match(/^-?[0-9]+$/))
      latLtErr = true;
    if (!lngLt.match(/^-?[0-9]+\.[0-9]+$/) && !lngLt.match(/^-?[0-9]+$/))
      lngLtErr = true;
    if (!latRb.match(/^-?[0-9]+\.[0-9]+$/) && !latRb.match(/^-?[0-9]+$/))
      latRbErr = true;
    if (!lngRb.match(/^-?[0-9]+\.[0-9]+$/) && !lngRb.match(/^-?[0-9]+$/))
      lngRbErr = true;

    var result = null;

    if (!latLtErr && !lngLtErr && !latRbErr && !lngRbErr) {
      result = L.latLngBounds(
        L.latLng(parseFloat(this._latRbInput.val()), parseFloat(this._lngLtInput.val())),
        L.latLng(parseFloat(this._latLtInput.val()), parseFloat(this._lngRbInput.val()))
      );

    }

    if (latLtErr) this._latLtInput.addClass("error");
    else this._latLtInput.removeClass("error");

    if (lngLtErr) this._lngLtInput.addClass("error");
    else this._lngLtInput.removeClass("error");

    if (latRbErr) this._latRbInput.addClass("error");
    else this._latRbInput.removeClass("error");

    if (lngRbErr) this._lngRbInput.addClass("error");
    else this._lngRbInput.removeClass("error");

    return result;

  },

  _getInputSize: function () {
    var width = this._widthInput.val();
    var height = this._heightInput.val();

    var widthErr = false;
    var heightErr = false;

    width = width.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });

    height = height.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });

    if (!width.match(/^[0-9]+$/))
      widthErr = true;
    if (!height.match(/^[0-9]+$/))
      heightErr = true;

    var result = null;

    if (!widthErr && !heightErr) {
      result = {
        width: parseInt(this._widthInput.val()),
        height: parseInt(this._heightInput.val())
      };

    }

    if (widthErr) this._widthInput.addClass("error");
    else this._widthInput.removeClass("error");

    if (heightErr) this._heightInput.addClass("error");
    else this._heightInput.removeClass("error");

    return result;

  },

  _check: function () {

    this._clearCheck();

    if (this._oldValue != this._checkTarget.val()) {

      if (this._checkTarget == this._widthInput || this._checkTarget == this._heightInput) {
        var result = this._getInputSize();
        if (result) {
          this._checkSize(result.width, result.height);
          this._sizeSelectLayer.setSize(result);
          this._setBoundsToView(this._sizeSelectLayer.getBounds());
        } else {
          this._checkSize();
        }

      } else {

        if (this._areaSelectLayer) {
          var bounds = this._getInputBounds();

          if (bounds)
            this._areaSelectLayer.setBounds(bounds);

          var result = this._areaSelectLayer.getSize();
          this._checkSize(result.width, result.height);
        }
      }
      this._oldValue = this._checkTarget.val()

    }
    this._checkTimerId = setTimeout(L.bind(function () { this._check(); }, this), 100);

  },

  _clearCheck: function () {
    if (this._checkTimerId) clearTimeout(this._checkTimerId);
    this._checkTimerId = null;
  },

  _stopCheck: function () {
    this._clearCheck();

    if (this._areaSelectRadio[0].checked) {
      var bounds = this._getInputBounds();

      if (bounds)
        this._areaSelectLayer.setBounds(bounds);
    } else {
      var size = this._getInputSize();

      // 202303 条件追加
      if (size && this._sizeSelectLayer)
        this._sizeSelectLayer.setSize(size);
    }
  }
});

/************************************************************************
 L.Class
 - GSI.Dialog
   - GSI.MapToImageAreaSelectDialog (画像として保存範囲指定管理)
 ************************************************************************/
GSI.MapToImageAreaSelectDialog = GSI.Dialog.extend({
  options: {
    title: "画像にする範囲を選択",
    width: "200px",
    minimize: true
  },

  initialize: function (gsimaps, mapManager, map, options) {
    this._gsimaps = gsimaps;
    this._mapManager = mapManager;
    this._map = map;

    GSI.Dialog.prototype.initialize.call(this, mapManager._dialogManager, options);

  },

  setSubMapManager : function(subMapManager) {
    this._subMapManager = subMapManager;

    if( this._subMapManager ) {
      this._subMap = this._subMapManager.getMap();
    } else {
      this._subMap = null;
    }
  },

  show: function () {

    GSI.Dialog.prototype.show.call(this);

    this._onModeChange();
  },

  hide: function () {
    this._stopCheck();
    if (this._areaSelectLayer) this._areaSelectLayer.remove();
    if (this._sizeSelectLayer) this._sizeSelectLayer.remove();
    this._areaSelectLayer = null;
    this._sizeSelectLayer = null;

    GSI.Dialog.prototype.hide.call(this);
  },
  createHeader: function () {
    this.title = $('<div>').html(this.options.title);

    return $('<div>').append(this.title);
  },

  _onSizeChange: function (e) {
    if (!this._frame) return;

    if (e.width != undefined) {
      this._widthInput.removeClass("error");
      this._heightInput.removeClass("error");

      this._widthInput.val(e.width);
      this._heightInput.val(e.height);
    }

    this._setBoundsToView(e.bounds);
    this._checkSize(e.width, e.height);
  },

  _setBoundsToView: function (bounds) {

    var nw = bounds.getNorthWest();
    var se = bounds.getSouthEast();
    this._latLtView.html((Math.round(nw.lat * 1000000) / 1000000).toFixed(6));
    this._lngLtView.html((Math.round(nw.lng * 1000000) / 1000000).toFixed(6));
    this._latRbView.html((Math.round(se.lat * 1000000) / 1000000).toFixed(6));
    this._lngRbView.html((Math.round(se.lng * 1000000) / 1000000).toFixed(6));

  },

  _checkSize: function (w, h) {

    if (w == undefined || w < 256 || h < 256) {
      this._errorMessage.html("大きさを256×256以上の範囲で指定して下さい。").show();
      this._okButton.hide();

      this._widthView.html(w);
      this._heightView.html(h);
    }
    else {

      if (w != undefined) {
        if (w % 2 != 0) w++;
        if (h % 2 != 0) h++;

        this._widthView.html(w);
        this._heightView.html(h);
      }
      this._okButton.show();
      this._errorMessage.hide();
    }

  },

  _onAreaChange: function (e) {

    if (!this._frame) return;

    this._latLtInput.removeClass("error");
    this._lngLtInput.removeClass("error");
    this._latRbInput.removeClass("error");
    this._lngRbInput.removeClass("error");

    this._latLtInput.val((this._areaSelectLayer && this._areaSelectLayer._latLngBounds ?
      (Math.round(this._areaSelectLayer._latLngBounds.getNorthWest().lat * 1000000) / 1000000).toFixed(6) : ""));
    this._lngLtInput.val((this._areaSelectLayer && this._areaSelectLayer._latLngBounds ?
      (Math.round(this._areaSelectLayer._latLngBounds.getNorthWest().lng * 1000000) / 1000000).toFixed(6) : ""));
    this._latRbInput.val((this._areaSelectLayer && this._areaSelectLayer._latLngBounds ?
      (Math.round(this._areaSelectLayer._latLngBounds.getSouthEast().lat * 1000000) / 1000000).toFixed(6) : ""));
    this._lngRbInput.val((this._areaSelectLayer && this._areaSelectLayer._latLngBounds ?
      (Math.round(this._areaSelectLayer._latLngBounds.getSouthEast().lng * 1000000) / 1000000).toFixed(6) : ""));

    this._checkSize(e.width, e.height);
  },

  createContent: function () {

    this._frame = $('<div>').addClass("gsi_threeddialog_content");

    var modeSelectFrame = $('<div>');

    this._displaySelectRadio = $("<input>").attr({ "name": "gsi_maptoimagedialog_modeselect", "id": "gsi_maptoimagedialog_modeselect_display", "type": "radio" }).addClass("normalcheck");
    var label = $("<label>").attr({ "for": "gsi_maptoimagedialog_modeselect_display" }).html("表示されている範囲全体");
    modeSelectFrame.append(this._displaySelectRadio).append(label);

    this._frame.append(modeSelectFrame);

    modeSelectFrame = $('<div>');
    this._areaSelectRadio = $("<input>").attr({ "name": "gsi_maptoimagedialog_modeselect", "id": "gsi_maptoimagedialog_modeselect_area", "type": "radio" }).addClass("normalcheck");
    var label = $("<label>").attr({ "for": "gsi_maptoimagedialog_modeselect_area" }).html("範囲を固定");
    modeSelectFrame.append(this._areaSelectRadio).append(label);

    this._sizeSelectRadio = $("<input>").attr({ "name": "gsi_maptoimagedialog_modeselect", "id": "gsi_maptoimagedialog_modeselect_size", "type": "radio" }).addClass("normalcheck");
    label = $("<label>").attr({ "for": "gsi_maptoimagedialog_modeselect_size" }).html("大きさを固定");
    modeSelectFrame.append(this._sizeSelectRadio).append(label);

    this._displaySelectRadio[0].checked = true;

    this._displaySelectRadio.on("click", L.bind(this._onModeChange, this));
    this._areaSelectRadio.on("click", L.bind(this._onModeChange, this));
    this._sizeSelectRadio.on("click", L.bind(this._onModeChange, this));

    this._frame.append(modeSelectFrame);

    this._areaSelectFrame = this._createAreaSelectContent();
    this._sizeSelectFrame = this._createSizeSelectContent();

    this._frame.append(this._areaSelectFrame);
    this._frame.append(this._sizeSelectFrame);

    this._buttonFrame = $('<div>').css({ "text-align": "center" }).addClass("button_frame");

    this._errorMessage = $("<div>").addClass("errormessage").hide();
    this._okButton = $('<a>')
      .addClass("normalbutton threedareadialog_button")
      .attr({ "href": "javascript:void(0);" })
      .html(GSI.TEXT.THREEDAREA.DIALOG_OKBTN)
      .on('click',L.bind(this._onOkClick, this));

    this._buttonFrame
      .append(this._errorMessage)
      .append(this._okButton);

    this._frame.append(this._buttonFrame);

    return this._frame;
  },

  _onModeChange: function () {

    if (this._displaySelectRadio[0].checked) {

      var center = this._map.getCenter();
      var bounds = undefined;
      var size = { width: 256, height: 256 };

      if (this._sizeSelectLayer) {
        center = this._sizeSelectLayer.getCenter();
        bounds = this._sizeSelectLayer.getBounds();
        this._sizeSelectLayer.remove();
        this._sizeSelectLayer = null;
      }

      if (this._areaSelectLayer) {
        center = this._areaSelectLayer.getCenter();
        size = this._areaSelectLayer.getSize();
        this._areaSelectLayer.remove();
        this._areaSelectLayer = null;
      }

      this._areaSelectFrame.hide();
      this._sizeSelectFrame.hide();

      this._okButton.show();
      this._errorMessage.hide();

    } else if (this._areaSelectRadio[0].checked) {

      var center = this._map.getCenter();
      var bounds = undefined;

      if (this._sizeSelectLayer) {
        center = this._sizeSelectLayer.getCenter();
        bounds = this._sizeSelectLayer.getBounds();
        this._sizeSelectLayer.remove();
        this._sizeSelectLayer = null;
      }

      if (!this._areaSelectLayer) {
        this._areaSelectLayer = new GSI.MapSizeAreaSelectLayer.LatLng(center, bounds);
        this._areaSelectLayer.on("change", L.bind(this._onAreaChange, this));
        this._areaSelectLayer.addTo(this._map);
      }

      this._sizeSelectFrame.hide();
      this._areaSelectFrame.show();

    } else if (this._sizeSelectRadio[0].checked) {

      var center = this._map.getCenter();
      var size = { width: 256, height: 256 };
      var bounds = undefined;

      if (this._areaSelectLayer) {
        center = null;
        size = this._areaSelectLayer.getSize();
        bounds = this._areaSelectLayer.getBounds();

        this._areaSelectLayer.remove();
        this._areaSelectLayer = null;
      }

      if (!this._sizeSelectLayer) {
        this._sizeSelectLayer = new GSI.MapSizeAreaSelectLayer.Size(center, size, bounds);
        this._sizeSelectLayer.on("change", L.bind(this._onSizeChange, this));
        this._sizeSelectLayer.addTo(this._map);
      }

      this._areaSelectFrame.hide();
      this._sizeSelectFrame.show();
    }
  },

  _createAreaSelectContent: function () {

    var frame = $("<div>");

    var infoTable = $('<table>');
    var infoTableTBody = $('<tbody>');
    var tr = null;
    var td = null;

    tr = $("<tr>");
    tr.append($("<td>").css({ "white-space": "nowrap" }).html("緯度:"));

    //緯度from
    td = $('<td>').css({ "white-space": "nowrap" }).html('');
    this._latRbInput = $("<input>").attr({ "type": "text" })
      .on("focus", L.bind(function () {
        this._startCheck(this._latRbInput);
      }, this))
      .on("blur", L.bind(function () {
        this._stopCheck(this._latRbInput);
      }, this));
    td.append(this._latRbInput);
    tr.append(td);

    // ～
    td = $('<td>').css({ "white-space": "nowrap", "width": "1px" }).html('～');
    tr.append(td);

    //緯度To
    td = $('<td>').css({ "white-space": "nowrap" }).html('');
    this._latLtInput = $("<input>").attr({ "type": "text" })
      .on("focus", L.bind(function () {
        this._startCheck(this._latLtInput);
      }, this))
      .on("blur", L.bind(function () {
        this._stopCheck(this._latLtInput);
      }, this));
    td.append(this._latLtInput);
    tr.append(td);

    infoTableTBody.append(tr);

    // 経度from
    tr = $("<tr>");
    tr.append($("<td>").css({ "white-space": "nowrap" }).html("経度:"));
    td = $('<td>').css({ "white-space": "nowrap" }).html('');
    this._lngLtInput = $("<input>").attr({ "type": "text" })
      .on("focus", L.bind(function () {
        this._startCheck(this._lngLtInput);
      }, this))
      .on("blur", L.bind(function () {
        this._stopCheck(this._lngLtInput);
      }, this));
    td.append(this._lngLtInput);
    tr.append(td);

    // ～
    td = $('<td>').css({ "white-space": "nowrap", "width": "1px" }).html('～');
    tr.append(td);

    //経度To
    td = $('<td>').css({ "white-space": "nowrap" }).html('');
    this._lngRbInput = $("<input>").attr({ "type": "text" })
      .on("focus", L.bind(function () {
        this._startCheck(this._lngRbInput);
      }, this))
      .on("blur", L.bind(function () {
        this._stopCheck(this._lngRbInput);
      }, this));
    td.append(this._lngRbInput);

    tr.append(td);
    infoTableTBody.append(tr);

    // 大きさ
    tr = $("<tr>").append($("<td>").css({ "white-space": "nowrap" }).html("大きさ:"));

    td = $("<td>").attr({ "colspan": 3 });

    this._widthView = $("<span>");
    td.append(this._widthView);

    td.append(document.createTextNode("×"));
    this._heightView = $("<span>");
    td.append(this._heightView);

    tr.append(td);
    infoTableTBody.append(tr);

    infoTable.append(infoTableTBody);

    frame
      .append(infoTable);

    return frame;
  },

  _createSizeSelectContent: function () {

    var frame = $("<div>");

    var infoTable = $('<table>');
    var infoTableTBody = $('<tbody>');
    var tr = null;
    var td = null;

    tr = $("<tr>");
    tr.append($("<td>").css({ "white-space": "nowrap" }).html("大きさ:"));

    //幅
    td = $('<td>').css({ "white-space": "nowrap" }).html('');
    this._widthInput = $("<input>").attr({ "type": "text" })
      .on("focus", L.bind(function () {
        this._startCheck(this._widthInput);
      }, this))
      .on("blur", L.bind(function () {
        this._stopCheck(this._widthInput);
      }, this));
    td.append(this._widthInput);
    tr.append(td);

    // ×
    td = $('<td>').css({ "white-space": "nowrap", "width": "1px" }).html('×');
    tr.append(td);

    //高さ
    td = $('<td>').css({ "white-space": "nowrap" }).html('');
    this._heightInput = $("<input>").attr({ "type": "text" })
      .on("focus", L.bind(function () {
        this._startCheck(this._heightInput);
      }, this))
      .on("blur", L.bind(function () {
        this._stopCheck(this._heightInput);
      }, this));
    td.append(this._heightInput);
    tr.append(td);

    infoTableTBody.append(tr);

    //緯度
    tr = $("<tr>");

    td = $("<td>").html("緯度：");
    tr.append(td);

    td = $("<td>");
    this._latRbView = $("<span>");
    td.append(this._latRbView);
    tr.append(td);

    td = $("<td>").html("～");
    tr.append(td);

    td = $("<td>");
    this._latLtView = $("<span>");
    td.append(this._latLtView);
    tr.append(td);

    infoTableTBody.append(tr);

    //経度
    tr = $("<tr>");

    td = $("<td>").html("経度：");
    tr.append(td);

    td = $("<td>");
    this._lngLtView = $("<span>");
    td.append(this._lngLtView);
    tr.append(td);

    td = $("<td>").html("～");
    tr.append(td);

    td = $("<td>");
    this._lngRbView = $("<span>");
    td.append(this._lngRbView);
    tr.append(td);

    infoTableTBody.append(tr);

    infoTable.append(infoTableTBody);

    frame.append(infoTable);

    return frame;

  },

  _onOkClick: function () {

    var latLngBounds = null;
    var isCustom = true;

    if (this._displaySelectRadio[0].checked) {
      $('#gsi_maptoimage_scaleline_check_div').hide();
      latLngBounds = this._map.getBounds();
      isCustom = false;
    } else if (this._areaSelectRadio[0].checked) {
      $('#gsi_maptoimage_scaleline_check_div').show();
      latLngBounds = this._areaSelectLayer.getBounds();
    } else {
      $('#gsi_maptoimage_scaleline_check_div').show();
      latLngBounds = this._sizeSelectLayer.getBounds();
    }

    this.execute(latLngBounds, isCustom);

  },

  _execute : function( mapManager, mapToImage,  latLngBounds, isCustom, isSubMap ) {

    var pixelBounds = null;

    var map = mapManager.getMap();

    if (isCustom) {
      var p1 = map.project(latLngBounds.getSouthWest(), map.getZoom());
      var p2 = map.project(latLngBounds.getNorthEast(), map.getZoom());
      pixelBounds = L.bounds(p1, p2);

    }

    var list = [];
    var tileList = $.extend([], mapManager._mapLayerList.getTileList());
    var otherList = mapManager._mapLayerList.getList();
    var multiTileList = [];

    if ( !isSubMap ) {

      if (this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.TILEGRID].obj
        && this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.TILEGRID].obj.getVisible()) {
        list.push({
          type: "system",
          layer: this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.TILEGRID].obj,
          opacity: 1,
          grayscale: false
        });
      }
      if (this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.JIHOKULINE].obj
        && this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.JIHOKULINE].obj.getVisible()) {
        list.push({
          type: "system",
          layer: this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.JIHOKULINE].obj,
          opacity: 1,
          grayscale: false
        });
      }
      if (this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.LATLNGGRID].obj
        && this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.LATLNGGRID].obj.getVisible()) {
        list.push({
          type: "system",
          layer: this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.LATLNGGRID].obj,
          opacity: 1,
          grayscale: false
        });
      }
      if (this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.UTMGRID].obj
        && this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.UTMGRID].obj.getVisible()) {
        list.push({
          type: "system",
          layer: this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.UTMGRID].obj,
          opacity: 1,
          grayscale: false
        });
      }
      if (this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.HOUILINE].obj
        && this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.HOUILINE].obj.getVisible()) {
        list.push({
          type: "system",
          layer: this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.HOUILINE].obj,
          opacity: 1,
          grayscale: false
        });
      }
      if (this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.TOUKYOKEN].obj
        && this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.TOUKYOKEN].obj.getVisible()) {
        list.push({
          type: "system",
          layer: this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.TOUKYOKEN].obj,
          opacity: 1,
          grayscale: false
        });
      }

      if (this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.CHIIKIMESH].obj
        && this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.CHIIKIMESH].obj.getVisible()) {
        list.push({
          type: "geojson_tile",
          layer: this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.CHIIKIMESH].obj._layer,
          opacity: 1,
          grayscale: false
        });
      }
      if (this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.T25000GRID].obj
        && this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.T25000GRID].obj.getVisible()) {
        list.push({
          type: "geojson_tile",
          layer: this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.T25000GRID].obj._layer,
          opacity: 1,
          grayscale: false
        });
      }

      if (!CONFIG.DISABLE_KOKUDOKIHONZUZUKAKU) {
        if (this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.KOKUDOKIHONZUKAKU].obj
          && this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.KOKUDOKIHONZUKAKU].obj.getVisible()) {
          list.push({
            type: "system",
            layer: this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.KOKUDOKIHONZUKAKU].obj,
            opacity: 1,
            grayscale: false
          });
        }
      }
    }
    for (var i = this._gsimaps._sakuzuList.getLength() - 1; i >= 0; i--) {
      if (this._gsimaps._sakuzuList.get(i)._visible == false) continue;
      list.push({
        type: "geojson",
        layer: this._gsimaps._sakuzuList.get(i)._layer,
        opacity: 1,
        grayscale: false
      });

    }

    var overlayList = [];

    for (var i = 0; i < otherList.length; i++) {
      if (!otherList[i]._visibleInfo || otherList[i]._visibleInfo._isHidden) continue;
      if (otherList[i].layerType == "multiLayer") {
        var layers = otherList[i]._visibleInfo.layer.getLayers();
        for (var j = 0; j < layers.length; j++) {
          if (layers[j]._info.layerType == "" || layers[j]._info.layerType == "tile") {
            multiTileList.push({
              type: layers[j]._info.layerType,
              layer: layers[j],
              opacity: otherList[i]._visibleInfo.opacity,
              grayscale: otherList[i]._visibleInfo.grayscale
            });
            continue;
          }
          // タイル以外
          if (layers[j]._info.layerType != "tile") {
            list.push({
              type: layers[j]._info.layerType,
              layer: layers[j],
              opacity: otherList[i]._visibleInfo.opacity,
              grayscale: otherList[i]._visibleInfo.grayscale
            });
          }

        }
      }
      else {
        if (otherList[i].layerType == "geotiff" || otherList[i].layerType == "videooverlay") {
          overlayList.push({
            type: otherList[i].layerType,
            layer: otherList[i]._visibleInfo.layer,
            opacity: otherList[i]._visibleInfo.opacity,
            grayscale: otherList[i]._visibleInfo.grayscale
          });
        } else {
          list.push({
            type: otherList[i].layerType,
            layer: otherList[i]._visibleInfo.layer,
            opacity: otherList[i]._visibleInfo.opacity,
            grayscale: otherList[i]._visibleInfo.grayscale
          });
        }
      }
    }

    for (var i = multiTileList.length - 1; i >= 0; i--)list.push(multiTileList[i]);
    for (var i = overlayList.length - 1; i >= 0; i--)list.push(overlayList[i]);

    for (var i = 0; i < tileList.length; i++) {

      if (!tileList[i]._visibleInfo || tileList[i]._visibleInfo._isHidden) continue;
      if ( tileList[i].isMultiLayer ) {
        var l = tileList[i];

        for( var j=0; j<l.entries.length; j++ ) {
          if ( l.entries[j].layerType == "tile") {
            list.push({
              type: l.entries[j].layerType,
              layer: l.entries[j]._layer,
              opacity: tileList[i]._visibleInfo.opacity,
              grayscale: tileList[i]._visibleInfo.grayscale,
              blend: tileList[i]._visibleInfo.blend
            });
          }
        }
      } else {
        list.push({
          type: tileList[i].layerType,
          layer: tileList[i]._visibleInfo.layer,
          opacity: tileList[i]._visibleInfo.opacity,
          grayscale: tileList[i]._visibleInfo.grayscale,
          blend: tileList[i]._visibleInfo.blend
        });
      }
    }

    if (!mapToImage) {
      mapToImage = new GSI.MapToImage(this._gsimaps, map, list, {
        "pixelBounds": pixelBounds,
        "latLngBounds": latLngBounds,
        "drawControls": (pixelBounds ? false : true)
      });
    }
    else {
      mapToImage._map = map;
      mapToImage.options.drawControls = (pixelBounds ? false : true);
      mapToImage.options.pixelBounds = pixelBounds;
      mapToImage.options.latLngBounds = latLngBounds;
      mapToImage.setList(list);
    }

    return {
      mapToImage: mapToImage,
      pixelBounds : pixelBounds,
      latLngBounds : latLngBounds
    };

  },

  execute: function (latLngBounds, isCustom) {
    var result = this._execute(this._mapManager,this._mapToImage, latLngBounds, isCustom );

    if ( !this._mapToImage ) {
      this._mapToImage = result.mapToImage;
      this._mapToImage.on("finish", L.bind(function (e) {
        this._mapToImageWindow.setCanvas(e.canvas[0]);
      }, this));
    }

    if (!this._mapToImageWindow) {
      this._mapToImageWindow = new GSI.MapToImageWindow(this._map, {
        "pixelBounds": result.pixelBounds,
        "latLngBounds": result.latLngBounds
      });

    } else {
      this._mapToImageWindow.options.pixelBounds = result.pixelBounds;
      this._mapToImageWindow.options.latLngBounds = result.latLngBounds;
    }
    this._mapToImageWindow.options.disableWorldFile = false;

    this._mapToImageWindow.show(L.bind(function () {
      this._mapToImage.start();

    }, this));

    this.hide();

  },

  executeAll : function(compareLeft) {

    $('#gsi_maptoimage_scaleline_check_div').hide();
    if ( !this._subMapManager || ( !this._subMapManager._compared && !this._subMapManager._splited ) ) {
      return this.execute( this._map.getBounds(), false );
    }

    var result = this._execute(this._mapManager,this._mapToImage1, this._map.getBounds(), false, false );

    this._compareLeft = compareLeft;

    if ( !this._mapToImage1 ) {
      this._mapToImage1 = result.mapToImage;
      this._mapToImage1.on("finish", L.bind(function (e) {

        var canvas = document.createElement("canvas");
        var canvas1 = e.canvas[0];
        var canvas2 = this._mapToImage2._mapCanvas[0];

        if ( this._subMapManager._splited ) {
          canvas.width = canvas2.width + canvas1.width + 2;
          canvas.height = canvas2.height;
          var ctx = canvas.getContext("2d");
          ctx.fillStyle = "#333";
          ctx.fillRect(0,0,canvas.width, canvas.height);

          ctx.drawImage( canvas1,
            0, 0, canvas1.width, canvas1.height, 0,0, canvas1.width, canvas1.height);
          ctx.drawImage( canvas2,
            0, 0, canvas2.width, canvas2.height, canvas2.width+2,0, canvas2.width, canvas2.height);

        } else {

          canvas.width = canvas2.width;
          canvas.height = canvas2.height;
          var ctx = canvas.getContext("2d");

          ctx.drawImage( canvas2,
            0, 0, canvas2.width, canvas2.height, 0,0, canvas2.width, canvas2.height);

          ctx.drawImage( canvas1,
            0, 0, this._compareLeft, canvas1.height, 0,0, this._compareLeft, canvas1.height);

          ctx.fillStyle = "rgb(32,32,32)";
          ctx.globalAlpha = 0.4;
          ctx.fillRect(canvas.width/2,0,1, canvas.height);

        }
        this._mapToImageWindow.setCanvas(canvas);//this._mapToImage2._mapCanvas[0]);
      }, this));
    }

    var result2 = this._execute(this._subMapManager,this._mapToImage2, this._subMap.getBounds(), false, true );

    if ( !this._mapToImage2 ) {
      this._mapToImage2 = result2.mapToImage;
      this._mapToImage2.on("finish", L.bind(function (e) {
        this._mapToImage1.start();
      }, this));
    }

    if (!this._mapToImageWindow) {
      this._mapToImageWindow = new GSI.MapToImageWindow(this._map, {
        "pixelBounds": result.pixelBounds,
        "latLngBounds": result.latLngBounds
      });

    } else {
      this._mapToImageWindow.options.pixelBounds = result.pixelBounds;
      this._mapToImageWindow.options.latLngBounds = result.latLngBounds;
    }

    this._mapToImageWindow.options.disableWorldFile = this._subMapManager._splited;

    this._mapToImageWindow.show(L.bind(function () {
      this._mapToImage2.start();

    }, this));

    this.hide();

  },

  _startCheck: function (input) {
    this._checkTarget = input;
    this._oldValue = input.val();
    this._check();

  },

  _isUInt: function (s) {
    if (s.match(/^[0-9]+$/)) {
      return true;
    }
    else {
      return false;
    }
  },

  _getInputBounds: function () {
    var latLt = this._latLtInput.val();
    var lngLt = this._lngLtInput.val();
    var latRb = this._latRbInput.val();
    var lngRb = this._lngRbInput.val();

    var latLtErr = false;
    var lngLtErr = false;
    var latRbErr = false;
    var lngRbErr = false;

    latLt = latLt.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });
    latLt = latLt.replace(/．/g, ".");

    lngLt = lngLt.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });
    lngLt = lngLt.replace(/．/g, ".");

    latRb = latRb.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });
    latRb = latRb.replace(/．/g, ".");

    lngRb = lngRb.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });
    lngRb = lngRb.replace(/．/g, ".");

    if (!latLt.match(/^-?[0-9]+\.[0-9]+$/) && !latLt.match(/^-?[0-9]+$/))
      latLtErr = true;
    if (!lngLt.match(/^-?[0-9]+\.[0-9]+$/) && !lngLt.match(/^-?[0-9]+$/))
      lngLtErr = true;
    if (!latRb.match(/^-?[0-9]+\.[0-9]+$/) && !latRb.match(/^-?[0-9]+$/))
      latRbErr = true;
    if (!lngRb.match(/^-?[0-9]+\.[0-9]+$/) && !lngRb.match(/^-?[0-9]+$/))
      lngRbErr = true;

    var result = null;

    if (!latLtErr && !lngLtErr && !latRbErr && !lngRbErr) {
      result = L.latLngBounds(
        L.latLng(parseFloat(this._latRbInput.val()), parseFloat(this._lngLtInput.val())),
        L.latLng(parseFloat(this._latLtInput.val()), parseFloat(this._lngRbInput.val()))
      );
    }

    if (latLtErr) this._latLtInput.addClass("error");
    else this._latLtInput.removeClass("error");

    if (lngLtErr) this._lngLtInput.addClass("error");
    else this._lngLtInput.removeClass("error");

    if (latRbErr) this._latRbInput.addClass("error");
    else this._latRbInput.removeClass("error");

    if (lngRbErr) this._lngRbInput.addClass("error");
    else this._lngRbInput.removeClass("error");

    return result;

  },

  _getInputSize: function () {
    var width = this._widthInput.val();
    var height = this._heightInput.val();

    var widthErr = false;
    var heightErr = false;

    width = width.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });

    height = height.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });

    if (!width.match(/^[0-9]+$/))
      widthErr = true;
    if (!height.match(/^[0-9]+$/))
      heightErr = true;

    var result = null;

    if (!widthErr && !heightErr) {
      result = {
        width: parseInt(this._widthInput.val()),
        height: parseInt(this._heightInput.val())
      };
    }

    if (widthErr) this._widthInput.addClass("error");
    else this._widthInput.removeClass("error");

    if (heightErr) this._heightInput.addClass("error");
    else this._heightInput.removeClass("error");

    return result;

  },

  _check: function () {

    this._clearCheck();

    if (this._oldValue != this._checkTarget.val()) {

      if (this._checkTarget == this._widthInput || this._checkTarget == this._heightInput) {
        var result = this._getInputSize();
        if (result) {
          this._checkSize(result.width, result.height);
          this._sizeSelectLayer.setSize(result);
          this._setBoundsToView(this._sizeSelectLayer.getBounds());
        } else {
          this._checkSize();
        }

      } else {

        if (this._areaSelectLayer) {
          var bounds = this._getInputBounds();

          if (bounds)
            this._areaSelectLayer.setBounds(bounds);

          var result = this._areaSelectLayer.getSize();
          this._checkSize(result.width, result.height);
        }
      }
      this._oldValue = this._checkTarget.val()

    }
    this._checkTimerId = setTimeout(L.bind(function () { this._check(); }, this), 100);
  },

  _clearCheck: function () {
    if (this._checkTimerId) clearTimeout(this._checkTimerId);
    this._checkTimerId = null;
  },

  _stopCheck: function () {
    this._clearCheck();

    if (this._areaSelectRadio[0].checked) {
      var bounds = this._getInputBounds();

      if (bounds)
        this._areaSelectLayer.setBounds(bounds);
    } else {
      var size = this._getInputSize();

      // 202303 条件追加
      if (size && this._sizeSelectLayer)
        this._sizeSelectLayer.setSize(size);
    }
  }
});

/************************************************************************
 L.Class
 - L.Layer
   - GSI.MapSizeAreaSelectLayer.Size (範囲指定 大きさ固定)
 ************************************************************************/
GSI.MapSizeAreaSelectLayer = {};

GSI.MapSizeAreaSelectLayer.Size = L.Layer.extend({

  options: {
    sizeEven: true
  },
  _rectangleStyle: {
    color: "#cd5e3c",
    weight: 2,
    fillOpacity: 0,
    clickable: false
  },

  initialize: function (latlng, size, bounds, options) {
    L.setOptions(this, options);
    this._latLngBounds = bounds;
    this._latlng = latlng;
    this._size = size;

  },

  setLatLng: function (latlng) {
    this._latlng = latlng;
  },

  getCenter: function () {
    return this._latlng;

  },

  setSize: function (size) {
    this._size.width = size.width;
    this._size.height = size.height;
    this._refreshView();
  },
  getSize: function (size) {
    return this._size;
  },

  getBounds: function () {

    var lt = L.point(this._position.x - (this._size.width / 2), this._position.y - (this._size.height / 2));
    var rb = L.point(this._position.x + (this._size.width / 2), this._position.y + (this._size.height / 2));
    var latLngBounds = L.latLngBounds(
      this._map.layerPointToLatLng(lt),
      this._map.layerPointToLatLng(rb)
    );

    return latLngBounds;
  },

  onAdd: function (map) {
    this._map = map;
    if (!this._mapMoveEndHandler) {
      this._mapMoveEndHandler = L.bind(this._onMapMoveEnd, this);
      this._map.on("moveend", this._mapMoveEndHandler);
    }

    this._add();

    this._fireChange();
  },

  addTo: function (map) {
    map.addLayer(this);
    return this;
  },

  remove: function () {
    if (!this._map) return;
    this._map.removeLayer(this);
  },

  onRemove: function (map) {

    if (this._mapMoveEndHandler) {
      this._map.off("moveend", this._mapMoveEndHandler);
      this._mapMoveEndHandler = null;
    }

    this._remove();
    this.fire('remove');

    this._map = null;
  },

  _remove: function () {
    this._map._panes.markerPane.removeChild(this._div[0]);

    this._div = null;
  },

  _onMapMoveEnd: function () {

    this._position = this._map.latLngToLayerPoint(this._latlng);
    this._refreshView();
    this._fireChange();
  },

  _fireChange: function () {

    var width = Math.round(this._size.width);
    var height = Math.round(this._size.height);

    if (this.options.sizeEven) {
      if (width % 2 == 1) width++;
      if (height % 2 == 1) height++;
    }

    this.fire('change', {
      latlng: this._latlng,
      width: width,
      height: height,
      bounds: this.getBounds()
    });
  },

  _add: function () {
    if (!this._div) {
      this._div = $('<div>').css({
        "position": "absolute",
        "box-sizing": "border-box",
        "width": Math.round(this._size.width) + "px",
        "height": Math.round(this._size.height) + "px",
        "margin-left": -Math.round(this._size.width / 2) + "px",
        "margin-top": -Math.round(this._size.height / 2) + "px"
      });

      //枠線
      function makeWaku(color, l, r, t, b, w, h, marginLeft, marginTop) {

        var css = {
          "position": "absolute",
          "box-sizing": "border-box",
          "background": color,
          "margin-left": marginLeft,
          "margin-top": marginTop
        };

        if (l != undefined) css["left"] = l + "px";
        if (r != undefined) css["right"] = r + "px";
        if (t != undefined) css["top"] = t + "px";
        if (b != undefined) css["bottom"] = b + "px";
        if (w != undefined) css["width"] = w + "px";
        if (h != undefined) css["height"] = h + "px";
        waku = $('<div>').css(css);

        return waku;
      }

      var wakuColor = this._rectangleStyle.color;
      var wakuSize = this._rectangleStyle.weight;
      this._div.append(makeWaku(wakuColor, 0, undefined, 0, 0, wakuSize, undefined, -parseInt(wakuSize / 2) + "px", 0));
      this._div.append(makeWaku(wakuColor, undefined, 0, 0, 0, wakuSize, undefined, parseInt(wakuSize / 2) + "px", 0));
      this._div.append(makeWaku(wakuColor, 0, 0, 0, undefined, undefined, wakuSize, 0, -parseInt(wakuSize / 2) + "px"));
      this._div.append(makeWaku(wakuColor, 0, 0, undefined, 0, undefined, wakuSize, 0, parseInt(wakuSize / 2) + "px"));

      this._leftTopMark = $('<div>').css({
        "position": "absolute",
        "box-sizing": "border-box",
        "background": "#fff",
        "width": "12px",
        "height": "12px",
        "left": 0,
        "top": 0,
        "margin-left": "-6px",
        "margin-top": "-6px",
        "border": "1px solid #cd5e3c",
        "cursor": "nw-resize"
      });

      this._rightTopMark = $('<div>').css({
        "position": "absolute",
        "box-sizing": "border-box",
        "background": "#fff",
        "width": "12px",
        "height": "12px",
        "right": 0,
        "top": 0,
        "margin-right": "-6px",
        "margin-top": "-6px",
        "border": "1px solid #cd5e3c",
        "cursor": "ne-resize"
      });
      this._leftBottomMark = $('<div>').css({
        "position": "absolute",
        "box-sizing": "border-box",
        "background": "#fff",
        "width": "12px",
        "height": "12px",
        "left": 0,
        "bottom": 0,
        "margin-left": "-6px",
        "margin-bottom": "-6px",
        "border": "1px solid #cd5e3c",
        "cursor": "ne-resize"
      });
      this._rightBottomMark = $('<div>').css({
        "position": "absolute",
        "box-sizing": "border-box",
        "background": "#fff",
        "width": "12px",
        "height": "12px",
        "right": 0,
        "bottom": 0,
        "margin-right": "-6px",
        "margin-bottom": "-6px",
        "border": "1px solid #cd5e3c",
        "cursor": "nw-resize"
      });

      this._moveMark = $('<div>').css({
        "position": "absolute",
        "box-sizing": "border-box",
        "width": "24px",
        "height": "24px",
        "left": "50%",
        "top": "50%",
        "margin-left": "-12px",
        "margin-top": "-12px",
        "cursor": "move",
        "background-image": "url(image/system/move.png)",
        "background-position": "50% 50%",
        "background-repeat": "no-repeat"
      });

      this._div.append(this._leftTopMark);
      this._div.append(this._rightTopMark);
      this._div.append(this._leftBottomMark);
      this._div.append(this._rightBottomMark);
      this._div.append(this._moveMark);

      L.DomEvent.on(this._leftTopMark[0], "touchstart", this._onDownLT, this);
      L.DomEvent.on(this._leftTopMark[0], "mousedown", this._onDownLT, this);
      L.DomEvent.on(this._leftTopMark[0], "MSPointerDown", this._onDownLT, this);
      L.DomEvent.on(this._rightTopMark[0], "touchstart", this._onDownRT, this);
      L.DomEvent.on(this._rightTopMark[0], "mousedown", this._onDownRT, this);
      L.DomEvent.on(this._rightTopMark[0], "MSPointerDown", this._onDownRT, this);
      L.DomEvent.on(this._leftBottomMark[0], "touchstart", this._onDownLB, this);
      L.DomEvent.on(this._leftBottomMark[0], "mousedown", this._onDownLB, this);
      L.DomEvent.on(this._leftBottomMark[0], "MSPointerDown", this._onDownLB, this);
      L.DomEvent.on(this._rightBottomMark[0], "touchstart", this._onDownRB, this);
      L.DomEvent.on(this._rightBottomMark[0], "mousedown", this._onDownRB, this);
      L.DomEvent.on(this._rightBottomMark[0], "MSPointerDown", this._onDownRB, this);
      L.DomEvent.on(this._moveMark[0], "touchstart", this._onDownMove, this);
      L.DomEvent.on(this._moveMark[0], "mousedown", this._onDownMove, this);
      L.DomEvent.on(this._moveMark[0], "MSPointerDown", this._onDownMove, this);

      this._map._panes.markerPane.appendChild(this._div[0]);
    }

    if (!this._latlng) {
      var ne = this._latLngBounds.getNorthWest();

      var nePoint = this._map.latLngToLayerPoint(ne);

      this._position = L.point(nePoint.x + (this._size.width / 2), nePoint.y + (this._size.height / 2));
      this._latlng = this._map.layerPointToLatLng(this._position);

    } else {

      this._position = this._map.latLngToLayerPoint(this._latlng);
    }
    this._refreshView();
  },

  _refreshView: function () {

    this._div.css({
      "width": Math.round(this._size.width) + "px",
      "height": Math.round(this._size.height) + "px",
      "margin-left": -Math.round(this._size.width / 2) + "px",
      "margin-top": -Math.round(this._size.height / 2) + "px",
      "left": Math.round(this._position.x) + "px",
      "top": Math.round(this._position.y) + "px"
    });
  },

  _onDownLT: function (e) {
    this._onDown(e);
    this._dragTarget = this._leftTopMark;
  },

  _onDownRT: function (e) {
    this._onDown(e);
    this._dragTarget = this._rightTopMark;
  },

  _onDownLB: function (e) {
    this._onDown(e);
    this._dragTarget = this._leftBottomMark;
  },

  _onDownRB: function (e) {
    this._onDown(e);
    this._dragTarget = this._rightBottomMark;
  },

  _onDownMove: function (e) {
    this._onDown(e);
    this._dragTarget = this._moveMark;
  },

  _onDown: function (e) {
    this._moved = false;

    if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }

    L.DomEvent.stopPropagation(e);

    L.DomUtil.disableImageDrag();
    L.DomUtil.disableTextSelection();

    if (this._moving) { return; }

    var first = e.touches ? e.touches[0] : e;

    this._startPoint = new L.Point(first.clientX, first.clientY);

    L.DomEvent.on(document, "touchmove", this._onMove, this);
    L.DomEvent.on(document, "mousemove", this._onMove, this);
    L.DomEvent.on(document, "touchend", this._onUp, this);
    L.DomEvent.on(document, "mouseup", this._onUp, this);

  },

  _onMove: function (e) {
    if (e.touches && e.touches.length > 1) {
      this._moved = true;
      return;
    }

    var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e);

    L.DomEvent.preventDefault(e);

    if (!this._moved) {
      this.fire('dragstart');

      this._moved = true;

      L.DomUtil.addClass(document.body, 'leaflet-dragging');
      this._lastTarget = e.target || e.srcElement;
      this._startPoint = new L.Point(first.clientX, first.clientY);
      L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
    }

    var offset = {
      x: (this._startPoint.x - first.clientX),
      y: (this._startPoint.y - first.clientY)
    };

    if (this._dragTarget == this._moveMark) {
      var point = this._map.latLngToLayerPoint(this._latlng);
      point.x -= offset.x;
      point.y -= offset.y;

      this._latlng = this._map.layerPointToLatLng(point);
      this._position = point;
      this._refreshView();

    }
    else {
      if (this._dragTarget == this._leftTopMark) {

        this._position.x -= (offset.x / 2);
        this._position.y -= (offset.y / 2);
        this._size.width += offset.x;
        this._size.height += offset.y;

        this._latlng = this._map.layerPointToLatLng(this._position);
        this._refreshView();

      }
      else if (this._dragTarget == this._rightTopMark) {

        this._position.x -= (offset.x / 2);
        this._position.y -= (offset.y / 2);
        this._size.width -= offset.x;
        this._size.height += offset.y;

        this._latlng = this._map.layerPointToLatLng(this._position);
        this._refreshView();

      }
      else if (this._dragTarget == this._leftBottomMark) {

        this._position.x -= (offset.x / 2);
        this._position.y -= (offset.y / 2);
        this._size.width += offset.x;
        this._size.height -= offset.y;

        this._latlng = this._map.layerPointToLatLng(this._position);
        this._refreshView();

      }
      else if (this._dragTarget == this._rightBottomMark) {

        this._position.x -= (offset.x / 2);
        this._position.y -= (offset.y / 2);
        this._size.width -= offset.x;
        this._size.height -= offset.y;
        this._latlng = this._map.layerPointToLatLng(this._position);
        this._refreshView();
      }
    }

    this._fireChange();
    this._startPoint = new L.Point(first.clientX, first.clientY);
    this._moving = true;

  },

  _onUp: function () {
    L.DomUtil.removeClass(document.body, 'leaflet-dragging');

    if (this._lastTarget) {
      L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
      this._lastTarget = null;
    }

    L.DomEvent.off(document, "touchmove", this._onMove, this);
    L.DomEvent.off(document, "mousemove", this._onMove, this);
    L.DomEvent.off(document, "touchend", this._onUp, this);
    L.DomEvent.off(document, "mouseup", this._onUp, this);

    L.DomUtil.enableImageDrag();
    L.DomUtil.enableTextSelection();

    this._fireChange();

    if (this._moved && this._moving) {
      this.fire('dragend', {
      });
    }

    this._moving = false;
  }
});

/************************************************************************
 L.Class
 - L.Layer
   - GSI.MapSizeAreaSelectLayer.LatLng (範囲指定 範囲固定)
 ************************************************************************/
GSI.MapSizeAreaSelectLayer.LatLng = L.Layer.extend({

  options: {
    sizeEven: true
  },
  _rectangleStyle: {
    color: "#cd5e3c",
    weight: 2,
    fillOpacity: 0,
    clickable: false
  },
  initialize: function (latlng, bounds, options) {
    L.setOptions(this, options);
    this._latlng = latlng;
    this._latLngBounds = bounds;
  },

  setLatLng: function (latlng) {
    this._latlng = latlng;
  },

  onAdd: function (map) {
    this._map = map;
    this._initializeBounds();

    this._add();

    if (!this._mapMoveEndHandler) {
      this._mapMoveEndHandler = L.bind(this._onMapMoveEnd, this);
      this._map.on("moveend", this._mapMoveEndHandler);
    }
    this.fire('add');
    this._fireChange();

  },

  _onMapMoveEnd: function () {
    this._fireChange();
  },

  getCenter: function () {
    return this._latLngBounds.getCenter();
  },

  getSize: function () {

    var nwPoint = this._map.latLngToLayerPoint(this._latLngBounds.getNorthWest());
    var sePoint = this._map.latLngToLayerPoint(this._latLngBounds.getSouthEast());
    var width = Math.abs(nwPoint.x - sePoint.x);
    var height = Math.abs(nwPoint.y - sePoint.y);

    width = Math.round(width);
    height = Math.round(height);

    if (this.options.sizeEven) {
      if (width % 2 == 1) width++;
      if (height % 2 == 1) height++;
    }

    return { width: width, height: height };
  },

  setBounds: function (bounds) {
    this._latLngBounds = bounds;
    this._rectangle.setLatLngs(this._latLngBoundsToLatlngArray(this._latLngBounds));
    this._refreshMarkerPosition();

  },

  getBounds: function () {
    return this._latLngBounds;
  },

  _fireChange: function () {
    var size = this.getSize();
    this.fire('change', {
      latlng: this._latLngBounds.getCenter(),
      latLngBounds: this._latLngBounds,
      width: size.width,
      height: size.height
    });
  },

  addTo: function (map) {
    map.addLayer(this);
    return this;
  },
  remove: function () {
    if (!this._map) return;
    this._map.removeLayer(this);
  },
  onRemove: function (map) {

    if (this._mapMoveEndHandler) {
      this._map.off("moveend", this._mapMoveEndHandler);
      this._mapMoveEndHandler = null;
    }
    this._remove();
    this.fire('remove');
    this._map = null;
  },

  _initializeBounds: function () {

    if (this._latLngBounds) {
      this._latlng = this._latLngBounds.getCenter();
    } else {
      var size = 256;
      var centerPos = this._map.latLngToLayerPoint(this._latlng);

      this._latLngBounds = L.latLngBounds(
        this._map.layerPointToLatLng(
          L.point(centerPos.x - (size / 2), centerPos.y + (size / 2))),
        this._map.layerPointToLatLng(
          L.point(centerPos.x + (size / 2), centerPos.y - (size / 2)))
      );
    }
  },

  _latLngBoundsToLatlngArray: function (bounds) {
    return [
      this._latLngBounds.getNorthWest(),
      this._latLngBounds.getNorthEast(),
      this._latLngBounds.getSouthEast(),
      this._latLngBounds.getSouthWest(),
      this._latLngBounds.getNorthWest()
    ];

  },

  _add: function () {
    var map = this._map;
    this._rectangle = L.polyline(this._latLngBoundsToLatlngArray(this._latLngBounds), this._rectangleStyle).addTo(map);

    var nw = this._latLngBounds.getNorthWest();
    var ne = this._latLngBounds.getNorthEast();
    var sw = this._latLngBounds.getSouthWest();
    var se = this._latLngBounds.getSouthEast();
    var center = this._latLngBounds.getCenter();

    this._centerMarker = L.marker(center, {
      draggable: true,
      icon: L.divIcon({
        className: 'gsi-areaselect-move-icon',
        iconAnchor: [12, 12],
        iconSize: [24, 24]
      })
    }).addTo(map);
    this._centerMoveHandler = L.bind(function (e) {
      var from = this._latLngBounds.getCenter();
      var to = e.latlng;
      var nw = this._latLngBounds.getNorthWest();
      var se = this._latLngBounds.getSouthEast();

      se.lat += (to.lat - from.lat);
      se.lng += (to.lng - from.lng);
      nw.lat += (to.lat - from.lat);
      nw.lng += (to.lng - from.lng);
      this._latLngBounds = L.latLngBounds(se, nw);
      this._rectangle.setLatLngs(this._latLngBoundsToLatlngArray(this._latLngBounds));
      this._refreshMarkerPosition();
      this._fireChange();
    }, this);

    this._centerMarker.on("move", this._centerMoveHandler);

    function makeMarker(map, className, pos) {
      return L.marker(pos, {
        draggable: true,
        icon: L.divIcon({
          className: 'gsi-areaselect-resize-icon ' + className,
          iconAnchor: [6, 6],
          iconSize: [12, 12]
        })
      }).addTo(map);
    }

    this._nwMarker = makeMarker(map, "lt", nw);
    this._nwMoveHandler = L.bind(function (e) {
      var se = this._latLngBounds.getSouthEast();
      var nw = e.latlng;
      this._latLngBounds = L.latLngBounds(se, nw);
      this._rectangle.setLatLngs(this._latLngBoundsToLatlngArray(this._latLngBounds));
      this._refreshMarkerPosition();
      this._fireChange();
    }, this);

    this._nwMarker.on("move", this._nwMoveHandler);

    this._neMarker = makeMarker(map, "rt", ne);
    this._neMoveHandler = L.bind(function (e) {
      var sw = this._latLngBounds.getSouthWest();
      var ne = e.latlng;
      this._latLngBounds = L.latLngBounds(sw, ne);
      this._rectangle.setLatLngs(this._latLngBoundsToLatlngArray(this._latLngBounds));
      this._refreshMarkerPosition();
      this._fireChange();
    }, this);

    this._neMarker.on("move", this._neMoveHandler);

    this._swMarker = makeMarker(map, "lb", sw);
    this._swMoveHandler = L.bind(function (e) {
      var ne = this._latLngBounds.getNorthEast();
      var sw = e.latlng;
      this._latLngBounds = L.latLngBounds(sw, ne);
      this._rectangle.setLatLngs(this._latLngBoundsToLatlngArray(this._latLngBounds));
      this._refreshMarkerPosition();
      this._fireChange();
    }, this);

    this._swMarker.on("move", this._swMoveHandler);

    this._seMarker = makeMarker(map, "rb", se);
    this._seMoveHandler = L.bind(function (e) {
      var nw = this._latLngBounds.getNorthWest();
      var se = e.latlng;
      this._latLngBounds = L.latLngBounds(nw, se);
      this._rectangle.setLatLngs(this._latLngBoundsToLatlngArray(this._latLngBounds));
      this._refreshMarkerPosition();
      this._fireChange();
    }, this);

    this._seMarker.on("move", this._seMoveHandler);

  },

  _refreshMarkerPosition: function () {

    this._centerMarker.off("move", this._centerMoveHandler);
    this._nwMarker.off("move", this._nwMoveHandler);
    this._nwMarker.off("move", this._nwMoveHandler);
    this._neMarker.off("move", this._neMoveHandler);
    this._swMarker.off("move", this._swMoveHandler);
    this._seMarker.off("move", this._seMoveHandler);
    var nw = this._latLngBounds.getNorthWest();
    var ne = this._latLngBounds.getNorthEast();
    var sw = this._latLngBounds.getSouthWest();
    var se = this._latLngBounds.getSouthEast();
    var center = this._latLngBounds.getCenter();

    this._centerMarker.setLatLng(center);
    this._nwMarker.setLatLng(nw);
    this._neMarker.setLatLng(ne);
    this._swMarker.setLatLng(sw);
    this._seMarker.setLatLng(se);

    this._centerMarker.on("move", this._centerMoveHandler);
    this._nwMarker.on("move", this._nwMoveHandler);
    this._neMarker.on("move", this._neMoveHandler);
    this._swMarker.on("move", this._swMoveHandler);
    this._seMarker.on("move", this._seMoveHandler);
  },

  _remove: function () {
    if (!this._centerMarker) return;
    this._centerMarker.remove();
    this._nwMarker.remove();
    this._neMarker.remove();
    this._swMarker.remove();
    this._seMarker.remove();
    this._rectangle.remove();
    this._centerMarker = null;
    this._nwMarker = null;
    this._neMarker = null;
    this._swMarker = null;
    this._seMarker = null;
    this._rectangle = null;
  }
});

/************************************************************************
 L.Edit.Poly
 - GSI.Edit.Poly
 ************************************************************************/
L.drawLocal.draw.handlers.polyline.error = '<strong>エラー:</strong> ポリゴンが交差しています';

L.Polygon.prototype.spliceLatLngs2 = function () { // (Number index, Number howMany)

  var idx0 = arguments[0];
  if (!idx0) idx0 = 0;
  var idx = arguments[1];
  var howMany = arguments[2];
  var latlng = (arguments.length >= 4 ? arguments[3] : undefined);
  var flat = L.LineUtil.isFlat(this._latlngs);
  var removed;

  var args = (latlng ? [idx, howMany, latlng] : [idx, howMany]);

  if (flat) {
    removed = [].splice.apply(this._latlngs, args);
  } else {
    removed = [].splice.apply(this._latlngs[idx0], args);
  }

  this._convertLatLngs(this._latlngs, true);
  this.redraw();
  return removed;
};

GSI.Edit.Poly = L.Edit.Poly.extend({

  options: {
    drawError: {
      color: '#b00b00',
      timeout: 2500
    },
    icon: new L.DivIcon({
      iconSize: new L.Point(8, 8),
      className: 'leaflet-div-icon leaflet-editing-icon'
    }),
    touchIcon: new L.DivIcon({
      iconSize: new L.Point(20, 20),
      className: 'leaflet-div-icon leaflet-editing-icon leaflet-touch-icon'
    })
  },

  initialize: function (poly, options) {
    // if touch, switch to touch icon
    this.options.drawError.message = L.drawLocal.draw.handlers.polyline.error;
    if (GSI.Utils.Browser.touch) {
      this.options.icon = this.options.touchIcon;
    }

    this._poly = poly;
    L.setOptions(this, options);
  },

  _getMiddleLatLng: function (marker1, marker2) {
    var map = this._poly._map;
    var latLng1 = marker1.getLatLng();
    var latLng2 = marker2.getLatLng();
    var p1 = map.project(latLng1),
      p2 = map.project(latLng2);
    var alt = null;

    if ((latLng1.alt || latLng1.alt == 0) && (latLng2.alt || latLng2.alt == 0))
      alt = (latLng1.alt + latLng2.alt) / 2;

    var result = map.unproject(p1._add(p2)._divideBy(2));

    if (alt || alt == 0)
      result.alt = alt;

    return result;

  },

  updateMarkers: function () {
    this._moveMarker = null;
    L.Edit.Poly.prototype.updateMarkers.call(this);
  },
  updateMarkers2: function () {
    if (this._markerGroup) {
      var layers = this._markerGroup.getLayers();
      for (var i = 0; i < layers.length; i++) {
        if (layers[i] != this._moveMarker)
          this._markerGroup.removeLayer(layers[i]);
      }
    }
    this._initMarkers();
  },

  _onMarkerDragStart: function (e) {
    this._draggingMarker = e.target;
    var latlng = e.target.getLatLng();
    this._draggingMarker._prevLatLng = L.latLng(latlng.lat, latlng.lng, latlng.alt);

    this._dragStartPixelBounds = this._map.getPixelBounds();

    this._map.startAutoPan();
  },

  _onTouchMove: function (e) {

    var layerPoint = this._map.mouseEventToLayerPoint(e.originalEvent.touches[0]),
      latlng = this._map.layerPointToLatLng(layerPoint),
      marker = e.target;

    L.extend(marker._origLatLng, latlng);

    if (marker._middleLeft) {
      marker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));
    }
    if (marker._middleRight) {
      marker._middleRight.setLatLng(this._getMiddleLatLng(marker, marker._next));
    }

    if (this._intersects()) {

      if (!this._tooltip) {
        this._tooltip = new L.Tooltip(this._map);
        this._tooltip.updateContent({
          text: L.drawLocal.edit.handlers.edit.tooltip.text,
          subtext: L.drawLocal.edit.handlers.edit.tooltip.subtext
        });
        this._tooltip
          .showAsError()
          .updateContent({ text: this.options.drawError.message });
      }
      this._tooltip.updatePosition(marker._latlng);
    } else {
      if (this._tooltip) {
        this._tooltip.dispose();
        this._tooltip = null;
      }
    }

    this._poly.redraw();
    this.updateMarkers();
  },

  segmentsIntersect: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2, /*Point*/ p3) {
    return this._checkCounterclockwise(p, p2, p3) !==
      this._checkCounterclockwise(p1, p2, p3) &&
      this._checkCounterclockwise(p, p1, p2) !==
      this._checkCounterclockwise(p, p1, p3);
  },

  // check to see if points are in counterclockwise order
  _checkCounterclockwise: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
    return (p2.lat - p.lat) * (p1.lng - p.lng) > (p1.lat - p.lat) * (p2.lng - p.lng);
  },
  _checkIntersect: function (ax, ay, bx, by, cx, cy, dx, dy) {
    var ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);
    var tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);
    var tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);
    var td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);

    return tc * td < 0 && ta * tb < 0;
  },
  _intersects: function () {

    // 交差判定
    if (!(this._poly instanceof L.Polygon)) {
      return false;
    }
    var points = $.extend(true, [], this._poly._latlngs);

    var flat = L.LineUtil.isFlat(points);

    if (!flat) points = points[0];

    if (points[0].lat != points[points.length - 1].lat && points[0].lng != points[points.length - 1].lng) {
      points.push(points[0]);
    }
    for (var i = 0; i < points.length - 1; i++) {

      var p1 = points[i];
      var p2 = points[i + 1];

      for (var j = 0; j < points.length - 1; j++) {

        if (i == j) continue;
        var p3 = points[j];
        var p4 = points[j + 1];

        if (this._checkIntersect(p1.lng, p1.lat, p2.lng, p2.lat, p3.lng, p3.lat, p4.lng, p4.lat)) {
          return true;
        }
      }
    }

    if (flat) return false;

    points = this._poly._latlngs;
    var latlngs = this._poly._latlngs[0];
    // 内側との交差判定
    for (var i = 1; i < this._poly._latlngs.length; i++) {
      if (this._polyIntersected(this._poly._latlngs[i], latlngs)) return true;

    }

    return false;

  },

  _innerPolygonIntersects: function (idx, idx2) {

    // 交差判定
    if (!(this._poly instanceof L.Polygon)) {
      return false;
    }
    var flat = L.LineUtil.isFlat(this._poly._latlngs);
    if (flat) return false;

    var points = $.extend(true, [], this._poly._latlngs[idx]);

    if (points[0].lat != points[points.length - 1].lat && points[0].lng != points[points.length - 1].lng) {
      points.push(points[0]);
    }
    for (var i = 0; i < points.length - 1; i++) {

      var p1 = points[i];
      var p2 = points[i + 1];

      for (var j = 0; j < points.length - 1; j++) {

        if (i == j) continue;
        var p3 = points[j];
        var p4 = points[j + 1];

        if (this._checkIntersect(p1.lng, p1.lat, p2.lng, p2.lat, p3.lng, p3.lat, p4.lng, p4.lat)) {
          return true;
        }
      }
    }

    if (idx2 == undefined) return false;

    // 外枠との内外判定
    var outer = this._poly._latlngs[0];
    var latlngs = [];
    if (idx2 > 0) latlngs.push(points[idx2 - 1]);
    else latlngs.push(points[points.length - 1]);
    latlngs.push(points[idx2]);

    if (idx2 < points.length - 1) latlngs.push(points[idx2 + 1]);
    else latlngs.push(points[0]);

    if (this._polyIntersected(outer, [latlngs[0], latlngs[1]])
      || this._polyIntersected(outer, [latlngs[1], latlngs[2]])) {
      return true;
    }
    // 中抜き同士の交差判定
    for (var i = 1; i < this._poly._latlngs.length; i++) {
      if (i == idx) continue;

      if (this._polyIntersected(this._poly._latlngs[i], [latlngs[0], latlngs[1]])
        || this._polyIntersected(this._poly._latlngs[i], [latlngs[1], latlngs[2]])) {
        return true;
      }
    }

    return false;

  },
  _polyIntersected: function (poly1, poly2) {

    for (var i = 0; i < poly1.length; i++) {
      var from1 = poly1[i];
      var to1 = (i < poly1.length - 1 ? poly1[i + 1] : poly1[0]);

      for (var j = 0; j < poly2.length; j++) {
        var from2 = poly2[j];
        var to2 = (j < poly2.length - 1 ? poly2[j + 1] : poly2[0]);
        if (this._lineIentersected(from1, to1, from2, to2)) {
          return true;
        }
      }
    }
    return false;

  },
  _lineIentersected: function (from1, to1, from2, to2) { //ax, ay, bx, by, cx, cy, dx, dy) {
    var ax = from1.lng;
    var ay = from1.lat;
    var bx = to1.lng;
    var by = to1.lat;
    var cx = from2.lng;
    var cy = from2.lat;
    var dx = to2.lng;
    var dy = to2.lat;

    var ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);
    var tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);
    var tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);
    var td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);

    return tc * td <= 0 && ta * tb <= 0; // 端点を含む場合
  },

  _onMarkerDrag: function (e) {

    // start - autopan対応
    var pixelBounds = this._map.getPixelBounds();
    var marker = e.target;

    if (
      this._dragStartPixelBounds.min.x != pixelBounds.min.x ||
      this._dragStartPixelBounds.min.y != pixelBounds.min.y ||
      this._dragStartPixelBounds.max.x != pixelBounds.max.x ||
      this._dragStartPixelBounds.max.y != pixelBounds.max.y) {

      marker.dragging._draggable._startPoint.x -= pixelBounds.min.x - this._dragStartPixelBounds.min.x;
      marker.dragging._draggable._startPoint.y -= pixelBounds.min.y - this._dragStartPixelBounds.min.y;

      this._dragStartPixelBounds = pixelBounds;
    }
    // end - autopan対応

    L.extend(marker._origLatLng, marker._latlng);
    if (marker._middleLeft) {
      marker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));
    }
    if (marker._middleRight) {
      marker._middleRight.setLatLng(this._getMiddleLatLng(marker, marker._next));
    }
    if (this._intersects()) {
      if (!this._tooltip) {
        this._tooltip = new L.Tooltip(this._map);
        this._tooltip.updateContent({
          text: L.drawLocal.edit.handlers.edit.tooltip.text,
          subtext: L.drawLocal.edit.handlers.edit.tooltip.subtext
        });
        this._tooltip
          .showAsError()
          .updateContent({ text: this.options.drawError.message });
      }
      this._tooltip.updatePosition(marker._latlng);
    } else if (marker._index1 > 0 && this._innerPolygonIntersects(marker._index1, marker._index2)) {

      if (!this._tooltip) {
        this._tooltip = new L.Tooltip(this._map);
        this._tooltip.updateContent({
          text: L.drawLocal.edit.handlers.edit.tooltip.text,
          subtext: L.drawLocal.edit.handlers.edit.tooltip.subtext
        });
        this._tooltip
          .showAsError()
          .updateContent({ text: this.options.drawError.message });
      }
      this._tooltip.updatePosition(marker._latlng);
    } else {
      if (this._tooltip) {
        this._tooltip.dispose();
        this._tooltip = null;
      }
    }
    this._poly.redraw();
  },

  _fireEdit: function (e) {
    this._map.stopAutoPan();
    if (this._tooltip) {
      this._tooltip.dispose();
      this._tooltip = null;
    }

    if (e && e.target == this._draggingMarker) {

      if (this._intersects()) {
        L.extend(e.target._origLatLng, e.target._prevLatLng);
        this._poly.redraw();
        this.updateMarkers();
      } else if (e.target._index1 > 0 && this._innerPolygonIntersects(e.target._index1, e.target._index2)) {

        L.extend(e.target._origLatLng, e.target._prevLatLng);
        this._poly.redraw();
        this.updateMarkers();
      }
    }

    this._poly.edited = true;
    this._poly.fire('edit');
  },

  _updateIndexes: function (index, delta, index0, index1) {
    this._markerGroup.eachLayer(function (marker) {
      if (marker._index > index) {
        marker._index += delta;
        // inner index2 inc
        if (index1 || index1 == 0) {
          if (
            (index0 && marker._index1 != undefined && index0 == marker._index1) &&
            (index1 && marker._index2 != undefined && index1 == marker._index2)
          )
            marker._index3++;
        } else {
          if (index0 && marker._index1 != undefined && index0 == marker._index1)
            marker._index2++;
        }
      }
    });
  },

  _createMiddleMarker: function (marker1, marker2) {
    var latlng = this._getMiddleLatLng(marker1, marker2),
      marker = this._createMarker(latlng),
      onClick,
      onDragStart,
      onDragEnd;

    marker.setOpacity(0.6);

    marker1._middleRight = marker2._middleLeft = marker;

    onDragStart = function () {
      var i = marker2._index;
      var i1 = marker2._index1;
      var i2 = marker2._index2;
      var i3 = marker2._index3;

      marker._index = i;
      marker._index1 = i1;
      marker._index2 = i2;
      marker._index3 = i3;

      marker
        .off('click', onClick, this)
        .on('click', this._onMarkerClick, this);

      latlng.lat = marker.getLatLng().lat;
      latlng.lng = marker.getLatLng().lng;

      if (i3 || i3 == 0) {
        [].splice.apply(this._poly._latlngs[i1][i2], [i3, 0, latlng]);
        this._poly._convertLatLngs(this._poly._latlngs, true);
        this._poly.redraw();
        this._markers.splice(i, 0, marker);

        marker.setOpacity(1);

        this._updatePrevNext(marker1, marker);
        this._updatePrevNext(marker, marker2);

        var m = marker2;
        while (m != marker) {
          if (m._index < i) break;
          m._index++;
          m._index3++;
          m = m._next;
        }

      } else {
        if (i1)
          this._poly.spliceLatLngs2(i1, i2, 0, latlng);
        else
          this._poly.spliceLatLngs(i, 0, latlng);

        this._markers.splice(i, 0, marker);

        marker.setOpacity(1);

        this._updateIndexes(i, 1, i1);
        marker2._index++;
        marker2._index2++;
        this._updatePrevNext(marker1, marker);
        this._updatePrevNext(marker, marker2);
      }
      this._poly.fire('editstart');
    };

    onDragEnd = function () {
      marker.off('dragstart', onDragStart, this);
      marker.off('dragend', onDragEnd, this);
      marker.off('touchmove', onDragStart, this);

      this._createMiddleMarker(marker1, marker);
      this._createMiddleMarker(marker, marker2);
    };

    onClick = function () {
      onDragStart.call(this);
      onDragEnd.call(this);
      this._fireEdit();
    };

    marker
      .on('click', onClick, this)
      .on('dragstart', onDragStart, this)
      .on('dragend', onDragEnd, this)
      .on('touchmove', onDragStart, this);

    this._markerGroup.addLayer(marker);
  },

  _initMarkers: function () {

    if (!this._markerGroup) {
      this._markerGroup = new L.LayerGroup();
    }
    this._markers = [];
    var isPolygon = (L.Polygon && (this._poly instanceof L.Polygon));

    var i, j, k, len, marker;
    var markerLeft, markerRight;

    if (isPolygon) {
      len = this._poly._latlngs[0].length;
      var idx = 0;
      var markerArr = [];
      var isMulti = false;
      for (i = 0; i < this._poly._latlngs.length; i++) {
        if (L.LineUtil.isFlat(this._poly._latlngs[i])) {
          var arr = [];
          for (j = 0; j < this._poly._latlngs[i].length; j++) {
            marker = this._createMarker(this._poly._latlngs[i][j], idx, i, j);
            marker.on('click', this._onMarkerClick, this);
            this._markers.push(marker);
            idx++;
            arr.push(marker);
          }
          markerArr.push(arr);
        } else {
          isMulti = true;
          var arr = [];
          for (j = 0; j < this._poly._latlngs[i].length; j++) {
            var arr2 = [];
            for (k = 0; k < this._poly._latlngs[i][j].length; k++) {
              marker = this._createMarker(this._poly._latlngs[i][j][k], idx, i, j, k);
              marker.on('click', this._onMarkerClick, this);
              this._markers.push(marker);
              idx++;
              arr2.push(marker);
            }
            arr.push(arr2);
          }
          markerArr.push(arr);

        }
      }

      if (!isMulti) {
        for (i = 0; i < markerArr.length; i++) {
          for (j = 0; j < markerArr[i].length; j++) {

            if (j == 0) {
              markerLeft = markerArr[i][markerArr[i].length - 1];
              markerRight = markerArr[i][j];
            } else {
              markerLeft = markerArr[i][j - 1];
              markerRight = markerArr[i][j];
            }
            this._createMiddleMarker(markerLeft, markerRight);
            this._updatePrevNext(markerLeft, markerRight);
          }
        }
      } else {
        for (i = 0; i < markerArr.length; i++) {
          for (j = 0; j < markerArr[i].length; j++) {

            for (k = 0; k < markerArr[i][j].length; k++) {
              if (k == 0) {
                markerLeft = markerArr[i][j][markerArr[i][j].length - 1];
                markerRight = markerArr[i][j][k];
              } else {
                markerLeft = markerArr[i][j][k - 1];
                markerRight = markerArr[i][j][k];
              }
              this._createMiddleMarker(markerLeft, markerRight);
              this._updatePrevNext(markerLeft, markerRight);
            }
          }
        }
      }

    } else {

      len = this._poly._latlngs.length;
      for (i = 0; i < len; i++) {

        marker = this._createMarker(this._poly._latlngs[i], i);
        marker.on('click', this._onMarkerClick, this);
        this._markers.push(marker);
      }

      for (i = 0, j = len - 1; i < len; j = i++) {
        if (i === 0 && !isPolygon) {
          continue;
        }

        markerLeft = this._markers[j];
        markerRight = this._markers[i];

        this._createMiddleMarker(markerLeft, markerRight);
        this._updatePrevNext(markerLeft, markerRight);
      }

    }

    if (this._moveMarker) return;
    var bounds = this._poly.getBounds();
    var latlng = null;

    latlng = bounds.getCenter();
    var marker = new L.Marker.Touch(latlng, {
      draggable: true,
      zIndexOffset: 4000,
      icon: L.icon(
        {
          iconUrl: 'image/sakuzu/icon_move.png',
          iconSize: [24, 24],
          iconAnchor: [32, 32]
        })
    });

    marker._prevLatLng = L.latLng(latlng);
    marker._origLatLng = latlng;

    marker
      .on('drag', this._onCenterMarkerDrag, this)
      .on('dragend', this._fireEdit, this)
      .on('touchmove', this._onCenterMarkerDrag, this)
      .on('touchend', this._fireEdit, this);
    this._moveMarker = marker;
    this._markerGroup.addLayer(marker);
  },

  _onMarkerContextMenu: function (e) {
    L.DomEvent.preventDefault(e);

    if (e.target._isMiddleMarker) return;
    this._map.fire("drawcancel");
    var latlngs = this._poly._latlngs;
    if (L.LineUtil.isFlat(latlngs)) {
      if (
        (this.options.isPolygon && latlngs.length <= 3)
        ||
        (!this.options.isPolygon && latlngs.length <= 2)
      ) return;
    } else {
      if (e.target._index3 || e.target._index3 == 0) {

        if (
          (this.options.isPolygon &&
            latlngs[e.target._index1][e.target._index2].length <= 3)
        ) return;
      } else {
        if (
          (this.options.isPolygon && latlngs[e.target._index1].length <= 3)
          ||
          (!this.options.isPolygon && latlngs[e.target._index1].length <= 2)
        ) return;
      }
    }

    if (L.LineUtil.isFlat(latlngs)) {
      latlngs.splice(e.target._index, 1);
      this._poly.setLatLngs(latlngs);
    }
    else {
      var index1 = e.target._index1;
      var index2 = e.target._index2;
      var index3 = e.target._index3;
      if (index3 || index3 == 0) {
        latlngs[index1][index2].splice(index3, 1);
      } else {
        latlngs[index1].splice(index2, 1);
      }
      this._poly.setLatLngs(latlngs);
    }
    this.updateMarkers();
  },
  _createMarker: function (latlng, index, index1, index2, index3) {
    // Extending L.Marker in TouchEvents.js to include touch.
    var marker = new L.Marker.Touch(latlng, {
      draggable: true,
      icon: this.options.icon,
      zIndexOffset: 4000
    });

    marker._origLatLng = latlng;
    marker._index = index;
    marker._index1 = index1;
    marker._index2 = index2;
    marker._index3 = index3;

    marker
      .on('dragstart', this._onMarkerDragStart, this)
      .on('contextmenu', this._onMarkerContextMenu, this)
      .on('drag', this._onMarkerDrag, this)
      .on('dragend', this._fireEdit, this)
      .on('touchstart', this._onMarkerDragStart, this)
      .on('touchmove', this._onTouchMove, this)
      .on('touchend', this._fireEdit, this);

    this._markerGroup.addLayer(marker);

    return marker;
  },
  _removeMarker: function (marker) {
    var i = marker._index;
    var i1 = marker._index1;
    var i2 = marker._index2;
    var i3 = marker._index3;
    this._markerGroup.removeLayer(marker);
    this._markers.splice(i, 1);
    if (i3 || i3 == 0) {
      [].splice.apply(this._poly._latlngs[i1][i2], [i3, 1]);
      this._poly._convertLatLngs(this._poly._latlngs, true);
      this._poly.redraw();
      this._updateIndexes(i, -1, i2, i3);
    } else if (i1) {
      this._poly.spliceLatLngs2(i1, i2, 1);
      this._updateIndexes(i, -1, i2);
    } else {
      this._poly.spliceLatLngs(i, 1);
      this._updateIndexes(i, -1);
    }

    marker
      .off('dragstart', this._onMarkerDragStart, this)
      .off('contextmenu', this._onMarkerContextMenu, this)
      .off('drag', this._onMarkerDrag, this)
      .off('dragend', this._fireEdit, this)
      .off('touchmove', this._onTouchMove, this)
      .off('touchend', this._fireEdit, this)
      .off('click', this._onMarkerClick, this);
  },
  _onCenterMarkerDrag: function (e) {
    var marker = e.target;
    var latlngs = this._poly._latlngs;
    var latMove = marker._latlng.lat - marker._origLatLng.lat;
    var lngMove = marker._latlng.lng - marker._origLatLng.lng;

    var flat = L.LineUtil.isFlat(latlngs);
    if (flat) {
      for (var i = 0; i < latlngs.length; i++) {
        latlngs[i].lat += latMove;
        latlngs[i].lng += lngMove;
      }
    } else {
      for (var i = 0; i < latlngs.length; i++) {
        for (var j = 0; j < latlngs[i].length; j++) {
          latlngs[i][j].lat += latMove;
          latlngs[i][j].lng += lngMove;
        }
      }
    }

    this._poly.setLatLngs(latlngs);

    L.extend(marker._origLatLng, marker._latlng);

    this._poly.redraw();
    this.updateMarkers2();
  }
});

/************************************************************************
  MapManager
    マップ管理
************************************************************************/
GSI.MapManager = L.Evented.extend({

  options: {

  },

  initialize: function (gsimaps, options) {
    L.setOptions(this, options);
    this._gsimaps = gsimaps;
  },

  getMap: function () {
    return this._map;
  },

  // マップオブジェクト生成
  create: function () {

    this._mapFrame = $("<div>").css({
      "position": "absolute", "box-sizing": "border-box",
      "left": (this.options.position != "right" ? 0 : "50%"),
      "top": 0,
      "right": (this.options.position == "left" ? "50%" : 0),
      "bottom": 0,
      "overflow": "hidden",
      "zIndex": (this.options.zIndex != undefined ? this.options.zIndex : 0),
    });
    this._mapContainer = $("<div>").css({
      "position": "absolute", "box-sizing": "border-box",
      "left": (this.options.position != "right" ? 0 : "1px"),
      "top": 0,
      "right": (this.options.position == "left" ? "1px" : 0),
      bottom: 0,
      "background": "#fff"
    });

    this._dialogManager = new GSI.DialogManager(this._mapFrame);

    this._mapFrame.append(this._mapContainer);
    $("#map").css({ "background": "#333" }).append(this._mapFrame);
    this._map = GSI.map(this._mapContainer[0],
      {
        doubleClickZoom: false
        , zoomsliderControl: false
        , zoomControl: false
        , attributionControl: false
        //,maxBounds           : L.latLngBounds(L.latLng(-3600, -3600), L.latLng(3600, 3600))
        , worldCopyJump: false
        , inertiaMaxSpeed: 1000
        , center: this.options.startUpCenter
        , zoom: this.options.startUpZoom <= 18 ? this.options.startUpZoom : 18
        , trackResize: false
        , multipopup: this.options.multipopup,
        wheelPxPerZoomLevel: 120,
        maxZoom: CONFIG.MAXZOOM
      }
    );

    this._map.on("mousedown", L.bind(function () {
      this.fire("mousedown")
    }, this));

    this._map.on("touchstart", L.bind(function () {
      this.fire("mousedown")
    }, this));

    // スクロール後に正しい位置へ移動
    this._map.on('moveend', L.bind(function () {
      var center = this._map.getCenter();
      if (center.lat < -88 || center.lat > 88 || center.lng < -180 || center.lng > 180) {
        this._map.panTo(center.wrap(), { animate: false });
      }
    }, this));

    // スペース用
    this._bottomRightSpacer = (new GSI.Control.Spacer({ position: "bottomright" })).addTo(this._map);
    this._bottomLeftSpacer = (new GSI.Control.Spacer()).addTo(this._map);

    if (!this.options.noScaleControl)
      L.control.scale({ imperial: false }).addTo(this._map);

    if (!this.options.noZoomControl) {

      if (CONFIG.USEMINIZOOMCONTROL) {
        this._zoomControl = new L.Control.Zoom({ position: "bottomleft" });
      } else {
        this._zoomControl = new L.Control.Zoomslider({ position: "bottomleft" });

      }
      this._map.addControl(this._zoomControl);

      $(".leaflet-control-zoomslider-in").attr({ "title": GSI.Utils.getTooltipText("MAP", "ZOOMIN") });
      $(".leaflet-control-zoomslider-out").attr({ "title": GSI.Utils.getTooltipText("MAP", "ZOOMOUT") });

    }

    this._mapLayerList = new GSI.MapLayerList(this._gsimaps, this, this._map);
    this._mapLayerList.on("change", L.bind(function(){
      // 外部タイルのmaxZoomが18以上の場合の処理
      var outsideTileList = this._mapLayerList.getOutsideTileList();
      var maxZoom = 0;

      for( let i=0; i<outsideTileList.length; i++ ) {
        var tile = outsideTileList[i];
        if ( tile.maxZoom && tile.maxZoom > maxZoom ) {
          maxZoom = tile.maxZoom;
        }
      }

      if ( CONFIG.MAXZOOM >= maxZoom ) maxZoom = CONFIG.MAXZOOM;

      if ( this._map.getMaxZoom() != maxZoom ) {
        this._map.setMaxZoom(maxZoom);
      }

    },this));

    this._mapMouse = new GSI.MapMouse(this, this._map, {
      dblClickInterval: CONFIG.DBLCLICKINTERVAL,
      rightDblClickInterval: CONFIG.RIGHTDBLCLICKINTERVAL
    }
    );

    this._evacDialog = new GSI.EvacDialog(this._map);

    this._hanreiLoader = new GSI.HanreiLoader(this._map, this._mapLayerList, CONFIG.HANREILIST);

  },

  // 地図初期化
  initializeMap: function (ctrlSetting, leftPanelVisible) {

    if (CONFIG.USEATTRPANEL == true) {
      this._attrpanel = new GSI.Control.AttrPanel({ position: "bottomright" });
      this._map.addControl(this._attrpanel);
    }

    if (ctrlSetting.header.visible == false || GSI.GLOBALS.isCreditShow) {
      this._map.addControl(new GSI.Control.CopyrightPanel({ position: "bottomright" }));
    }

    // this._map.addControl(new GSI.Control.ZoomGuidePanel({ position: "bottomright" }, this.options.mapMenuRight ? "right" : "left"));

    if (CONFIG.USEGPS) {
      this._gpsControl = new GSI.Control.GPSButton();
      this._map.addControl(this._gpsControl);

    }

    // ココタイル
    this._cocoTileLayer = new GSI.COCOTileLayer(
      this._map
      , CONFIG.COCOTILEURL
      , {
        visible: CONFIG.COCOTILEVISIBLE
        , onLoad: L.bind(function (tileIdList) {
          this._layersJSON.setHasTileList(tileIdList);
        }, this)
      }
    );

    leftPanelOverlap = CONFIG.OVERLAPLEFTPANEL;

    if (this.options.panelOverlap) {
      leftPanelOverlap = true;
    }
    // 地図メニュー
    this._mapMenu = new GSI.MapMenu(
      this._gsimaps,
      this,
      this._map,
      $("#map"),
      leftPanelVisible,
      leftPanelOverlap, {
      panelPosition: (this.options.mapMenuRight ? "right" : "left"),
      visible: ctrlSetting.infoMenu.visible
    });

    if (leftPanelVisible && !leftPanelOverlap) {
      var panelWidth = this._mapMenu.getPanelWidth();
      var css = {};
      if (this.options.mapMenuRight) {
        css["right"] = panelWidth + "px";
      } else {
        css["left"] = panelWidth + "px";
      }
      $(this._mapContainer).css(css);
      this._map.invalidateSize(false);
    }
    this._mapMenu.on("panelshow", L.bind(this._onMapMenuShow, this));
    this._mapMenu.on("panelhide", L.bind(this._onMapMenuHide, this));
    this._mapMenu.on("panelchange", L.bind(this._onMapMenuChange, this));
    this._mapMenu.on("panelresize", L.bind(this._onMapMenuResize, this));
    this._mapMenu.on("paneloverlapchange", L.bind(this._onMepMenuOverlapChange, this));

  },

  _onMapMenuShow: function (evt) {
    if (this._mapMenu.isPanelOverlap()) return;
    var animate = {};
    if (evt.position == "right") {
      animate["right"] = evt.width + "px";
    } else {
      animate["left"] = evt.width + "px";
    }
    var center = this._map.getCenter();

    $(this._mapContainer).animate(
      animate,
      {
        "duration": evt.duration,
        "step": L.bind(function () {
          this._map.invalidateSize({ animate: false });
        }, this),
        "complete": L.bind(function () {
          this._map.invalidateSize({ animate: false });
        }, this)
      }
    );
  },

  _onMepMenuOverlapChange: function (evt) {
    if (evt.overlap) {
      $(this._mapContainer).css({ "left": "0px", "right": "0px" });
    } else {
      var css = {};
      var width = this._mapMenu.getPanelVisible() ? this._mapMenu.getPanelWidth() : 0;
      if (this._mapMenu.getPanelPosition() == "right") {
        css["right"] = width + "px";
      } else {
        css["left"] = width + "px";
      }
      $(this._mapContainer).css(css);
    }
    this._map.invalidateSize(false);
  },

  _onMapMenuResize: function (evt) {

    if (this._mapMenu.isPanelOverlap()) return;
    var css = {};
    if (this._mapMenu.getPanelPosition() == "right") {
      css["right"] = evt.width + "px";
    } else {
      css["left"] = evt.width + "px";
    }
    $(this._mapContainer).css(css);
    this._map.invalidateSize(false);
  },

  _onMapMenuHide: function (evt) {

    if (this._mapMenu.isPanelOverlap()) return;
    var animate = {};
    if (evt.position == "right") {
      animate["right"] = "0px";
    } else {
      animate["left"] = "0px";
    }

    $(this._mapContainer).animate(
      animate,
      {
        "duration": evt.duration,
        "step": L.bind(function () {
          this._map.invalidateSize(false);
        }, this),
        "complete": L.bind(function () {
          this._map.invalidateSize(false);
        }, this)
      }
    );
  },

  _onMapMenuChange: function () {

    if (this._gsimaps._hash_options) this._gsimaps._hash_options.HashCreate();
  },

  setClipLeft: function (left) {
    this._clipLeft = left;
    this._mapMenu.setButtonLeftPosition(left);
    if (this._footer) this._footer.setLeft(left);
    if (this._comparePhotoControl) this._comparePhotoControl.setLeft(left);
  },
  setClipRight: function (right) {
    if (this._footer) this._footer.setRight(right);
    if (this._comparePhotoControl) this._comparePhotoControl.setRight(right);
  },

  // フッター等初期化
  initializeControls: function (queryParams, header, ctrlSetting, viewSetting) {

    this._initializeFooter(ctrlSetting.contextMenu.visible, viewSetting.footer);

    this._confirmDlg = new GSI.Modal.confirmDialog(this._map);

    var cs = queryParams.getControlSetting();

    this._centerCross = new GSI.CenterCross(this._map, { visible: viewSetting.centerCross });

    this._zoomGuide = new GSI.ZoomGuide(this._map, {visible: viewSetting.zoomGuide});
  },

  // ダイアログ等初期化
  _initializeDialogs: function (layersJSON, headerHeight, leftPanelVisible, layerTreeDialogCurrentPath) {
    if (this._layersJSON) return;
    // 表示中レイヤーダイアログ
    this._layersJSON = layersJSON;

    // edit-r1
    this._mapMenu.setData({
      currentPath: layerTreeDialogCurrentPath,
      layersJSON: this._layersJSON,
      cocoTileLayer: this._cocoTileLayer,
      mapLayerList: this._mapLayerList
    });

    if (!this._footer) return;
    this._footer.setMapLayerList(this._mapLayerList);

  },

  // ベースマップ初期化
  initializeBaseLayer: function (baseMap, baseMapGrayScale) {
    this._baseLayer = new GSI.BaseLayer(this._layersJSON.getBase(), baseMap, baseMapGrayScale);
  },

  // フッター初期化
  _initializeFooter: function (visible, footerMode) {
    if (this.options.noFooter) return;

    this._footer = new GSI.Footer(this, this._mapFrame, { displayMode: footerMode, visible: visible });
    this._footer.on("resize", L.bind(function (evt) {
      var rightHeight = evt.height;
      var leftHeight = evt.withButtonHeight;

      this._bottomLeftSpacer.setHeight(leftHeight);
      this._bottomRightSpacer.setHeight(rightHeight);
      this._dialogManager.setMinimizePosition({ "bottom": rightHeight + "px" });
    }, this));
    this._footer.start();
  },

  // 1画面２画面時の位置調整
  setPosition: function (pos) {

    if (pos == "left") {
      this._mapFrame.css({ "right": "50%" });
      this._mapContainer.css({ "right": "1px" });
    }
    else if (pos == "right") {
      this._mapFrame.css({ "left": "50%" });
      this._mapContainer.css({ "left": "1px" });
    }
    else if (pos == "full") {
      this._mapFrame.css({ "left": 0, "right": 0 });
      this._mapContainer.css({ "left": "0px", "right": "0px" });
    }
    if (this._footer)
      this._footer.refreshSize();
    this._dialogManager.refreshClip();

    this._map.invalidateSize(false);
  },

  // ２画面目を消した時の破棄処理
  destroy: function () {
    if (this._mapMenu) {
      this._mapMenu.destroy();
    }
    if (this._mapLayerList) {
      this._mapLayerList.destroy();
    }

    if (this._viewListDialog) {
      this._viewListDialog.destroy();
    }

    if (this._layerTreeDialog) {
      this._layerTreeDialog.destroy();
    }

    if (this._footer) {
      this._footer.destroy();
    }
    if (this._comparePhotoControl) {
      this._comparePhotoControl.destroy();
    }

    this._map.remove();
    this._mapFrame.remove();

  },

  isCenterCrossVisible: function () {
    return this._centerCross.getVisible();
  },

  hideMapMenu: function () {
    this._mapMenu.hidePanel();
  },

  getComparePhotoControl: function() {
    if ( !this._comparePhotoControl ) {
      this._comparePhotoControl = new GSI.ComparePhotoControl(this);
    }
    return this._comparePhotoControl;
  },

  showComparePhotoControl: function() {
    var control = this.getComparePhotoControl();
    control.show();

    if (this._gsimaps.compared() && this._gsimaps._comparisonSeparater) {
      this._gsimaps._comparisonSeparater._refresh();

    }
    this.setTopMargin();
    return control;
  },

  setTopMargin : function() {
    this._mapMenu.setTopMargin();
    if ( this._syncControl ) {
      this._syncControl.setTopMargin();
    }
  },

  hideComparePhotoControl: function() {
    if ( !this._comparePhotoControl ) return;

    this._comparePhotoControl.hide();

    this._mapMenu.removeTopMargin();

    if ( this._syncControl ) {
      this._syncControl.removeTopMargin();
    }

    return  this._comparePhotoControl;
  },
  
  enableLakeData: function(enabled) {
    this._enableLakeData = enabled;
  },

  lakeDataEnabled: function() {
    return this._enableLakeData;
  }  
});

/************************************************************************
 L.Map
 - GSI.Map
 ************************************************************************/
GSI.Map = L.Map.extend({
  _initPanes: function () {
    L.Map.prototype._initPanes.call(this);
    this._panes.gsiObjectsPane = this.createPane('gsi-objects-pane');
  },
  _limitCenter: function (center, zoom, bounds) {
    if (!bounds) { return center; }

    var centerPoint = this.project(center, zoom),
      viewHalf = this.getSize().divideBy(2),
      viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
      offset = this._getBoundsOffset(viewBounds, bounds, zoom);

    var result = this.unproject(centerPoint.add(offset), zoom);

    return result;
  },
  _limitOffset: function (offset, bounds) {
    if (!bounds) { return offset; }

    var viewBounds = this.getPixelBounds(),
      newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

    return offset.add(this._getBoundsOffset(newBounds, bounds));
  },

  _initControlPos: function () {

    L.Map.prototype._initControlPos.call(this);

  },

  startAutoPan: function () {
    if (!this._autoPanMouseMoveHandler) {
      this._lastContainerPoint = undefined;
      this._autoPanMouseMoveHandler = L.bind(this._onAutoPanMouseMove, this);
      this._autoPanMouseOutHandler = L.bind(this._onAutoPanMouseOut, this);
      this.on("mousemove", this._autoPanMouseMoveHandler);
      this.on("mouseout", this._autoPanMouseOutHandler);
    }
  },
  stopAutoPan: function () {
    this._clearAutoPanTimer();
    if (this._autoPanMouseMoveHandler) {
      this.off("mousemove", this._autoPanMouseMoveHandler);
      this.off("mouseout", this._autoPanMouseOutHandler);
      this._autoPanMouseMoveHandler = undefined;
      this._autoPanMouseOutHandler = undefined;

    }
  },

  _clearAutoPanTimer: function () {
    if (this._autoPanTimer) {
      clearTimeout(this._autoPanTimer);
      this._autoPanTimer = undefined;
    }
  },

  _onAutoPanMouseOut: function () {

    this._lastContainerPoint = undefined;
    this._clearAutoPanTimer();
  },

  _onAutoPanMouseMove: function (evt) {

    var size = this.getSize();
    if (!this._lastContainerPoint) {

      this._lastContainerPoint = {
        x: evt.containerPoint.x,
        y: evt.containerPoint.y
      };
    }

    var move = 100;
    var autoPanPlaceSize = 70;
    var panX = 0;
    var panY = 0;
    if (evt.containerPoint.x > this._lastContainerPoint.x && size.x - evt.containerPoint.x < autoPanPlaceSize) {
      panX = move;
    } else if (evt.containerPoint.x < this._lastContainerPoint.x && evt.containerPoint.x < autoPanPlaceSize) {
      panX = -move;
    }

    if (evt.containerPoint.y > this._lastContainerPoint.y && size.y - evt.containerPoint.y < autoPanPlaceSize) {
      panY = move;
    } else if (evt.containerPoint.y < this._lastContainerPoint.y && evt.containerPoint.y < autoPanPlaceSize) {
      panY = -move;
    }

    this._lastContainerPoint = {
      x: evt.containerPoint.x,
      y: evt.containerPoint.y
    };

    this._clearAutoPanTimer();

    if (panX != 0 || panY != 0) {
      this._execAutoPan(panX, panY);
    }
  },

  _execAutoPan: function (x, y) {

    this.panBy([x, y], { animate: true });

    this._autoPanTimer = setInterval(L.bind(function (x, y) {
      this.panBy([x, y], { animate: true });
    }, this, x, y), 300);
  }
});

GSI.map = function (id, options) {
  return new GSI.Map(id, options);
};

L.Map.include({
  setMultiPopup: function (val) {

    if (this._popupList) {
      for (var i = 0; i < this._popupList.length; i++) {

        this.removeLayer(this._popupList[i]);
        this._popupList[i]._isOpen = false;

      }
      this._popupList = [];
    }

    this.options.multipopup = val;

  },
  openPopup: function (popup, latlng, options) {

    if (!this.options.multipopup) {
      this.closePopup();
    }
    if (!(popup instanceof L.Popup)) {
      var content = popup;

      popup = new L.Popup(options)
        .setLatLng(latlng)
        .setContent(content);
    }
    else if (latlng) {
      popup.setLatLng(latlng);
    }

    //			
    popup._isOpen = true;

    if (this.options.multipopup) {
      popup.options.closeOnClick = false;
      if (!this._popupList)
        this._popupList = [];
      this._popupList.push(popup);
    }
    else {
      popup.options.closeOnClick = true;
      this._popup = popup;
    }
    return this.addLayer(popup);
  },

  closePopup: function (popup) {

    if (!popup || popup === this._popup) {
      popup = this._popup;
      this._popup = null;
    }
    if (popup) {
      this.removeLayer(popup);
      popup._isOpen = false;
    }

    return this;
  }
});

/************************************************************************
 L.Class
 - GSI.Footer
 ************************************************************************/

GSI.Footer = L.Evented.extend({

  options: {

  },

  initialize: function (mapManager, parentContainer, options) {
    L.setOptions(this, options);
    this._dispMode = GSI.Footer.DISP_MINI;
    if (this.options.displayMode || this.options.displayMode == 0) {
      try {
        this._dispMode = parseInt(this.options.displayMode);
      } catch (e) { }
    }
    this._mapManager = mapManager;
    this._mapMenu = this._mapManager._mapMenu;

    this._mapMenu.on("panelshow", L.bind(this._onMapMenuShow, this));
    this._mapMenu.on("panelresize", L.bind(this._onMepMenuResize, this));
    this._mapMenu.on("panelhide", L.bind(this._onMapMenuHide, this))
    this._mapMenu.on("paneloverlapchange", L.bind(this._onMepMenuOverlapChange, this));

    this._parentContainer = parentContainer;

    this._dispAddrMode = GSI.Footer.DISP_ADDR_KANJI;
  },

  setLeft: function () {

  },
  setRight: function (right) {
    this._container.css({ right: right + "px" });
  },

  start: function (dispMode) {

    this._create();
    if (!this.options.visible) {
      this._container.hide();
      return;
    }
    this._setDisplayMode(this._dispMode, true);
    if (this._mapMenu.getPanelVisible() && !this._mapMenu.isPanelOverlap()) {
      var css = {};
      if (this._mapMenu.getPanelPosition() == "right") {
        css["right"] = this._mapMenu.getPanelWidth() + "px";
      } else {
        css["left"] = this._mapMenu.getPanelWidth() + "px";
      }

      this._container.css(css);
    }
    this._refreshLatLng();

    var map = this._mapManager.getMap();

    map.on("movestart", L.bind(this._onMapMoveStart, this));
    map.on("move", L.bind(this._onMapMove, this));
    map.on("moveend", L.bind(this._onMapMoveEnd, this));

    if (!this._windowResizeHandler) {
      this._windowResizeHandler = L.bind(this._onWindowResize, this);
      $(window).on("resize", this._windowResizeHandler);
    }
  },

  destroy: function () {

    if (this._windowResizeHandler) {
      $(window).off("resize", this._windowResizeHandler);
      this._windowResizeHandler = null;
    }

    if (this._container) {
      this._container.remove();
      this._container = null;
    }
  },

  _onMepMenuOverlapChange: function (evt) {
    if (evt.overlap) {

      this._container.css({ "left": "0px", "right": "0px" });
    } else {
      var css = {};
      var width = this._mapMenu.getPanelVisible() ? this._mapMenu.getPanelWidth() : 0;
      if (this._mapMenu.getPanelPosition() == "right") {
        css["right"] = width + "px";
      } else {
        css["left"] = width + "px";
      }
      this._container.css(css);

    }
  },

  _onMapMenuShow: function (evt) {
    if (this._mapMenu.isPanelOverlap()) return;
    var animate = {};
    if (evt.position == "right") {
      animate["right"] = evt.width + "px";
    } else {
      animate["left"] = evt.width + "px";
    }
    this._container.animate(animate, evt.duration, L.bind(function () {
      this.refreshSize();
    }, this));
  },
  _onMepMenuResize: function (evt) {
    if (this._mapMenu.isPanelOverlap()) return;
    var css = {};
    if (evt.position == "right") {
      css["right"] = evt.width + "px";
    } else {
      css["left"] = evt.width + "px";
    }

    this._container.css(css);
    this.refreshSize();

  },
  _onMapMenuHide: function (evt) {
    if (this._mapMenu.isPanelOverlap()) return;
    var animate = {};
    if (evt.position == "right") {
      animate["right"] = "0px";
    } else {
      animate["left"] = "0px";
    }
    this._container.animate(animate, evt.duration, L.bind(function () {
      this.refreshSize();
    }, this));
  },
  setDisplayMode: function (dispMode) {
    if (dispMode == true) {
      dispMode = GSI.Footer.DISP_MINI;
    } else if (dispMode == false) {
      dispMode = GSI.Footer.DISP_CLOSE;
    } else {
      dispMode = "" + dispMode;
      switch (dispMode) {
        case "0":
          dispMode = GSI.Footer.DISP_CLOSE;
          break;
        case "2":
          dispMode = GSI.Footer.DISP_LARGE;
          break;
        default:
          dispMode = GSI.Footer.DISP_MINI;
          break;
      }
    }

    if (this._dispMode != dispMode) {
      this._setDisplayMode(dispMode);
    }
  },

  _setDisplayMode: function (dispMode, noAnimation) {
    this._dispMode = parseInt(dispMode);

    switch (this._dispMode) {
      case GSI.Footer.DISP_CLOSE:
        this._startCloseMode(noAnimation);
        break;

      case GSI.Footer.DISP_LARGE:
        this._startLargeMode(noAnimation);
        break;

      default:
        this._startMiniMode(noAnimation);
        break;
    }
  },

  _startCloseMode: function (noAnimation) {

    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.CONTEXTMENU) {
      this._button.attr({ "title": CONFIG.TOOLTIP.CONTEXTMENU.BTN_HIDE });
    } else {
      this._button.attr({ "title": "" });
    }
    var after = L.bind(function () {
      this._addrContainer.hide();
      this._latlngContainer.hide();
      this._utmContainer.hide();
      this._elevationContainer.hide();
      this._lakeDepthContainer.hide();
      this._seamlessContainer.hide();
      this._container.addClass("close");
      this._container.removeClass("large");
    }, this);
    this._container.css({ "min-height": "auto" });
    if (noAnimation) {
      after();
      this._contentSizeChange();
    } else {

      this._container.stop().animate({ "height": 0 + "px" }, 300, L.bind(function () {
        after();
        this._contentSizeChange();
        this._execRefresh();
      }, this));
    }
  },

  _startLargeMode: function (noAnimation) {
    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.CONTEXTMENU) {
      this._button.attr({ "title": CONFIG.TOOLTIP.CONTEXTMENU.BTN_SHOW });
    } else {
      this._button.attr({ "title": "" });
    }
    var after = L.bind(function () {
      this._addrContainer.show();
      this._latlngContainer.show();
      this._utmContainer.show();
      this._elevationContainer.show();
      if(this._lakeDepthEnabled) this._lakeDepthContainer.show();
      if (this._seamlessPhotoVisible) this._seamlessContainer.show();
      else this._seamlessContainer.hide();
    }, this);

    this._elevationContainer.css({
      "display": "block",
      "vertical-align": "middle",
      "height": "auto",
    });

    if (noAnimation) {
      after();
      this._container.removeClass("close");
      this._container.addClass("large");
    } else {
      var fromHeight = this._container.outerHeight();
      after();
      var toHeight = this._container.outerHeight();
      this._container.css({ "height": fromHeight + "px" });

      this._container.stop().animate({ "height": toHeight + "px" }, 300, L.bind(function () {

        this._container.removeClass("close");
        this._container.addClass("large");
        this._container.css({ "height": "auto" });
        this._contentSizeChange();
        this._execRefresh();
      }, this));
    }
  },

  _startMiniMode: function (noAnimation) {
    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.CONTEXTMENU) {
      this._button.attr({ "title": CONFIG.TOOLTIP.CONTEXTMENU.BTN_MINI });
    } else {
      this._button.attr({ "title": "" });
    }
    var after = L.bind(function () {
      this._addrContainer.hide();
      this._latlngContainer.hide();
      this._utmContainer.hide();
      this._elevationContainer.show();
      this._lakeDepthContainer.hide();
      if (this._seamlessPhotoVisible) this._seamlessContainer.show();
      else this._seamlessContainer.hide();
      this._container.css({ "height": "auto" });
    }, this);

    if (!this._seamlessPhotoVisible) {
      this._elevationContainer.css({
        "display": "table-cell",
        "vertical-align": "middle",
        "height": "34px",
      });
    } else {
      this._elevationContainer.css({
        "display": "block",
        "vertical-align": "middle",
        "height": "auto",
      });
    }

    if (noAnimation) {
      this._container.css({ "min-height": "34px" });
      this._container.removeClass("close");
      this._container.removeClass("large");
      after();
    } else {
      var fromHeight = this._container.outerHeight();
      after();
      var toHeight = this._container.outerHeight();
      if (toHeight < 34) toHeight = 34;
      this._container.css({ "height": fromHeight + "px" });

      this._container.stop().animate({ "height": toHeight + "px" }, 300, L.bind(function () {

        this._container.css({ "min-height": "34px" });
        this._container.removeClass("close");
        this._container.removeClass("large");
        this._container.css({ "height": "auto" });
        this._contentSizeChange();
        this._execRefresh();
      }, this));
    }
  },

  getDisplayMode: function () {
    return this._dispMode;
  },

  _onWindowResize: function () {
    this.refreshSize();
  },

  refreshSize: function () {
    var map = this._mapManager.getMap();
    var mapSize = map.getSize();

    if (mapSize.x > 550) {
      this._addrContainer.find(".mini-comment").removeClass("block");
    } else {
      this._addrContainer.find(".mini-comment").addClass("block");
    }

    this._contentSizeChange();
  },

  getHeight: function () {
    return this._container.outerHeight();
  },

  _contentSizeChange: function () {
    if (!this._container) return;

    var containerHeight = this._container.outerHeight();
    var buttonHeight = this._dispMode == GSI.Footer.DISP_CLOSE ? 34 : 0;
    if (!this.options.visible) {
      containerHeight = 0;
      buttonHeight = 0;
    }
    this.fire("resize", { "height": containerHeight, "withButtonHeight": containerHeight + buttonHeight })

  },

  _create: function () {
    if (this._container) return;

    this._container = $("<div>").addClass("gsi-footer-container");
    // 開閉ボタン
    this._button = $("<a>").addClass("gsi-footer-button").attr({ "href": "javascript:void(0);" });
    this._button.addClass("strong");

    this._container.append(this._button);
    this._button.on("click", L.bind(this._onDisplayModeButtonClick, this));
    // 住所
    this._addrContainer = this._createAddrContainer(this._container);

    // 緯度軽度
    this._latlngContainer = this._createLatLngContainer(this._container);

    // UTMポイント
    this._utmContainer = this._createUTMPointContainer(this._container);

    // 標高
    this._elevationContainer = this._createElevationContainer(this._container);

    // 湖水深
    this._lakeDepthContainer = this._createLakeDepthContainer(this._container);

    // シームレス
    this._seamlessContainer = this._createSeamlessContainer(this._container);

    // 表示値の説明
    this._descriptionButton = $("<a>").addClass("description-button").html("表示値の説明")
      .attr({ "target": "_blank", "href": "https://maps.gsi.go.jp/help/howtouse.html#h2-3" })
    if (CONFIG.MOBILE) {
      this._descriptionButton.html("i").addClass("mobile");
    }
    this._container.append(this._descriptionButton);

    this._parentContainer.append(this._container);

  },

  _onDisplayModeButtonClick: function () {
    this._button.removeClass("strong");
    var dispMode = this._dispMode + 1;
    if (dispMode > 2) dispMode = 0;
    this._setDisplayMode(dispMode);
  },

  _onLargeModeAddrChangeClick: function(){
    if (this._dispAddrMode == GSI.Footer.DISP_ADDR_KANJI){
      this._dispAddrMode = GSI.Footer.DISP_ADDR_YOMI;
      this._addrChangeReading.html("漢");
    }
    else{
      this._dispAddrMode = GSI.Footer.DISP_ADDR_KANJI;
      this._addrChangeReading.html("あ");
    }
    var map = this._mapManager.getMap();
    if (!map) return;

    GSI.Utils.sendSelectedFunction("addr-change");

    var center = map.getCenter().wrap();
    var z = map.getZoom();
    this._loadAddr(center, z);
  },

  // 住所　表示用コンテナ作成
  _createAddrContainer: function (parentContainer) {
    var container = $("<div>").addClass("item-frame");
    this._addrChangeReading = $("<span>").addClass("addr-ToActive").html("あ");
    this._addrView = $("<span>").addClass("address").html("---");
    var nbsp2 = $("<span>").html("&nbsp;&nbsp;");
    var comment = $("<span>").addClass("mini-comment").html("（付近の住所。正確な所属を示すとは限らない。）");

    this._addrView.on('click', L.bind(this._onLargeModeAddrChangeClick, this));
    this._addrChangeReading.on('click', L.bind(this._onLargeModeAddrChangeClick, this));

    container.append(this._addrChangeReading).append(nbsp2).append(this._addrView).append(comment);
    parentContainer.append(container);
    return container;
  },

  // 緯度経度　表示用コンテナ作成
  _createLatLngContainer: function (parentContainer) {

    var container = $("<div>").addClass("item-frame");

    // 60
    this._latlng60Container = $("<div>").addClass("inline").addClass("marginright");
    this._latlng60View = $("<span>").addClass("latlng60");
    this._latlng60Container.append(this._latlng60View);

    // 10
    this._latlng10Container = $("<div>").addClass("inline");
    this._latlng10View = $("<span>").addClass("latlng10");
    var zoomHeading = $("<span>").addClass("heading").addClass("zoom").html("ズーム:");
    this._zoomView = $("<span>").addClass("zoom");
    this._latlng10Container.append(this._latlng10View).append(zoomHeading).append(this._zoomView);

    container.append(this._latlng60Container).append(this._latlng10Container);
    parentContainer.append(container);
    return container;
  },

  // UTMポイント　表示用コンテナ作成
  _createUTMPointContainer: function (parentContainer) {

    var container = $("<div>").addClass("item-frame");
    var heading = $("<span>").addClass("heading").html("UTMポイント:");
    this._utmView = $("<span>").addClass("utm").html("");

    container.append(heading).append(this._utmView);
    parentContainer.append(container);
    return container;
  },

  // 標高　表示用コンテナ作成
  _createElevationContainer: function (parentContainer) {
    var container = $("<div>").addClass("item-frame");
    var heading = $("<span>").addClass("heading").html("標高:");
    this._elevationView = $("<span>").addClass("elevation").html("---");
    this._elevationComment = $("<span>").addClass("mini-comment").html("");

    container.append(heading).append(this._elevationView).append(this._elevationComment);
    parentContainer.append(container);
    return container;
  },

  // 湖水深など　表示用コンテナ作成
  _createLakeDepthContainer: function (parentContainer) {
    const strNoData = "---";
    var container = $("<div>").addClass("item-frame");
    var lakeDepthLabel = $("<span>").addClass("heading").html("湖水深: ");
    this._lakeDepthView = $("<span>").addClass("lakeinfo").html(strNoData);
    var lakeBtmHeightLabel = $("<span>").addClass("heading").html("（湖底標高: ");
    this._lakeBtmHeightView = $("<span>").addClass("lakeinfo").html(strNoData);
    var lakeStdHeightLabel = $("<span>").addClass("heading").html("　基準水面標高: ");
    this._lakeStdHeightView = $("<span>").addClass("lakeinfo").html(strNoData);
    var end = $("<span>").addClass("heading").html(")");

    container.append(lakeDepthLabel).append(this._lakeDepthView)
    .append(lakeBtmHeightLabel).append(this._lakeBtmHeightView)
    .append(lakeStdHeightLabel).append(this._lakeStdHeightView)
    .append(end);

    parentContainer.append(container);
    return container;
  },

  _createSeamlessContainer: function (parentContainer) {

    var container = $("<div>").addClass("item-frame");
    var heading = $("<span>").addClass("heading").html("全国最新写真(シームレス)撮影期間:");
    this._seamlessView = $("<span>").addClass("seamless").html("---");

    container.append(heading).append(this._seamlessView).append();
    parentContainer.append(container);
    return container;
  },

  _refreshLatLng: function () {
    var map = this._mapManager.getMap();
    if (!map) return;

    var center = map.getCenter().wrap();
    var dms = GSI.Utils.latLngToDMS(center);

    var lats = (Math.round(dms.lat.s * 100) / 100).toFixed(2);
    var lngs = (Math.round(dms.lng.s * 100) / 100).toFixed(2);
    if ('' + lats == "60.00") {
      lats = "0.00";
      dms.lat.m += 1;
    }
    if ('' + lngs == "60.00") {
      lngs = "0.00";
      dms.lng.m += 1;
    }
    if (dms.lat.m == 60){
      dms.lat.m = 0;
      dms.lat.d += 1;
    }
    if (dms.lng.m == 60){
      dms.lng.m = 0;
      dms.lng.d += 1;
    }
    this._latlng60View.html(
      (center.lat < 0 ? '-' : '') + dms.lat.d + '度' + dms.lat.m + '分' + lats + '秒'
      + '&nbsp;' +
      (center.lng < 0 ? '-' : '') + dms.lng.d + '度' + dms.lng.m + '分' + lngs + '秒'
    );

    this._latlng10View.html(
      (Math.round(center.lat * 1000000) / 1000000).toFixed(6)
      + ','
      + (Math.round(center.lng * 1000000) / 1000000).toFixed(6)
    );

    var utmPoint = GSI.UTM.Utils.latlng2PointName(center.lat, center.lng);
    this._utmView.html(utmPoint == '' ? '---' : utmPoint);

    this._zoomView.html(map.getZoom());

    this._contentSizeChange();
  },

  isVisible: function () {
    return (this._container && this._container.is(":visible"));
  },

  setMapLayerList: function (mapLayerList) {
    this._mapLayerList = mapLayerList;

    var mapChangeHandler = L.bind(function () {
      var tileList = this._mapLayerList.getTileList();

      this._seamlessPhotoVisible = false;

      for (var i = 0; i < tileList.length; i++) {
        if (tileList[i]["id"] == "seamlessphoto") {
          this._seamlessPhotoVisible = true;
          break;
        }
      }

      this._refreshSeamlessInfo();

    }, this);
    mapLayerList.on("change", mapChangeHandler);
    mapChangeHandler();

  },

  _onMapMoveStart: function () {

    if (this._addrLoader) this._addrLoader.cancel();
    if (this._elevationLoader) this._elevationLoader.cancel();
    if (this._refreshTimerId) {
      clearTimeout(this._refreshTimerId);
      this._refreshTimerId = null;
    }
    this._clearView();

  },

  _onMapMove: function () {
    this._refreshLatLng();
  },

  _onMapMoveEnd: function () {
    this._refresh();
  },

  _clearView: function () {
    const strNoData = "---";

    this._addrView.html(strNoData);
    this._elevationView.html(strNoData);
    this._elevationComment.html("");
    this._seamlessView.html(strNoData);
    this._lakeDepthView.html(strNoData);
    this._lakeBtmHeightView.html(strNoData);
    this._lakeStdHeightView.html(strNoData);

    this._contentSizeChange();
  },

  _refresh: function () {

    if (this._seamlessSpecRequest) {
      this._seamlessSpecRequest.abort();
      this._seamlessSpecRequest = null;
    }
    if (this._addrLoader) this._addrLoader.cancel();
    if (this._elevationLoader) this._elevationLoader.cancel();
    if (this._refreshTimerId) {
      clearTimeout(this._refreshTimerId);
      this._refreshTimerId = null;
    }

    var map = this._mapManager.getMap();
    var center = map.getCenter().wrap();
    var zoom = map.getZoom();
    this._clearView();
    this._refreshTimerId = setTimeout(L.Util.bind(this._execRefresh, this, center, zoom), 800);

  },

  _loadAddr: function(center, z){
    if (!this._addrLoader) {
      this._addrLoader = new GSI.AddrLoader();
      this._addrLoader.on("load", L.bind(function (e) {
        if (e.title == undefined) return;

        if (this._dispAddrMode == GSI.Footer.DISP_ADDR_YOMI){
        this._setAddressResult(e.titleYomi);
        }
        else{
        this._setAddressResult(e.title);
        }
      }, this));
    } else {
      this._addrLoader.cancel();
    }

    this._addrLoader.load({ lat: center.lat, lng: center.lng, zoom: z });
  },

  _execRefresh: function (center, zoom) {
    var map = this._mapManager.getMap();

    if (!center) {
      center = map.getCenter().wrap();
      zoom = map.getZoom();
    }
    this._clearView();
    if (this._dispMode == GSI.Footer.DISP_CLOSE) return;

    if (this._dispMode == GSI.Footer.DISP_LARGE) {
      this._loadAddr(center, zoom);
    }

    this._refreshSeamlessInfo(center);

    const loadCondition = {lat: center.lat, lng: center.lng, zoom: zoom};
    if (!this._elevationLoader) {
      this._elevationLoader = new GSI.FooterElevationLoader(map);
      this._elevationLoader.on("load", L.bind(function (e) {
        if (e.h == undefined) return;
        this._setElevationRusult(e.h.toFixed(e.fixed != undefined ? e.fixed : 0) + "m", e.title);
      }, this));
    } else {
      this._elevationLoader.cancel();
    }
    this._elevationLoader.load(loadCondition);

    if ( !this._lakedepthLoader ) {
      this._lakedepthLoader = new GSI.LakeDepthLoader(map);
      this._lakedepthLoader.on("load", L.bind( function(e) {
        if (e.h == undefined) return;
        this._setLakeResult({type: "lakedepth", info: e});
      }, this));
    } else {
      this._lakedepthLoader.cancel();
    }
    
    if ( !this._lakeStdHeightLoader ) {
      this._lakeStdHeightLoader = new GSI.LakeStdHeightLoader(map);
      this._lakeStdHeightLoader.on("load", L.bind( function(e) {
        if (e.h == undefined) return;
        this._setLakeResult({type: "lakestdheight", info: e});
      }, this));
    } else {
      this._lakeStdHeightLoader.cancel();
    }

    if(this._mapManager.lakeDataEnabled()){
      this._lakedepthLoader.load(loadCondition);
      this._lakeStdHeightLoader.load(loadCondition);
    }
  },

  _refreshSeamlessInfo: function (center) {

    if (this._dispMode == GSI.Footer.DISP_MINI && !this._seamlessPhotoVisible) {
      this._elevationContainer.css({
        "display": "table-cell",
        "vertical-align": "middle",
        "height": "34px",
      });
    } else {
      this._elevationContainer.css({
        "display": "block",
        "vertical-align": "middle",
        "height": "auto",
      });
    }

    if (this._seamlessSpecRequest) {
      this._seamlessSpecRequest.abort();
      this._seamlessSpecRequest = null;
    }

    if (!this._seamlessPhotoVisible) {
      this._seamlessContainer.hide();
      this._contentSizeChange();
      return;
    } else {
      this._seamlessContainer.show();
      this._seamlessView.html("---");
      this._contentSizeChange();
    }

    var map = this._mapManager.getMap();

    var zoom = map.getZoom();
    if (zoom < 14 || zoom > 18) {
      return;
    }
    if (!center) {
      center = map.getCenter().wrap();
    }
    zoom = 11;

    var x = this._getTileX(zoom, center.lng);
    var y = this._getTileY(zoom, center.lat);

    var url = "https://maps.gsi.go.jp/xyz/seamlessphoto_spec/" + zoom + "/" + x.n + "/" + y.n + ".geojson";

    this._seamlessSpecRequest = $.ajax({
      type: "GET",
      dataType: "JSON",
      url: url,
      async: false
    })
      .done(L.bind(function (center, data) {
        this._setSeamlessSpecInfo(center, data);
      }, this, center))
      .always(function () {

      });
  },

  _getTileX: function (z, lon) {
    var lng_rad = lon * Math.PI / 180; var R = 128 / Math.PI; var worldCoordX = R * (lng_rad + Math.PI);
    var pixelCoordX = worldCoordX * Math.pow(2, z); var tileCoordX = Math.floor(pixelCoordX / 256);
    return { n: tileCoordX, px: Math.floor(pixelCoordX - tileCoordX * 256) };
  },

  _getTileY: function (z, lat) {
    var lat_rad = lat * Math.PI / 180; var R = 128 / Math.PI; var worldCoordY = - R / 2 * Math.log((1 + Math.sin(lat_rad)) / (1 - Math.sin(lat_rad))) + 128; var pixelCoordY = worldCoordY * Math.pow(2, z); var tileCoordY = Math.floor(pixelCoordY / 256);
    return { n: tileCoordY, px: Math.floor(pixelCoordY - tileCoordY * 256) };
  },

  _inPolygon: function (p, coords) {
    var i, j;
    var count = 0;
    var cp;

    var isCross = function (y, p1, p2) {
      var cp = {};
      if (p1.lat > p2.lat) {
        var p;
        p = p1;
        p1 = p2;
        p2 = p;
      }
      cp.lng = (p1.lng * (p2.lat - y) + p2.lng * (y - p1.lat)) / (p2.lat - p1.lat);
      cp.lat = y;
      if (p1.lat <= y && y < p2.lat)
        return cp;
      else
        return null;
    };

    for (i = 0; i < coords.length; i++) {
      j = (i + 1) % coords.length;
      var p1 = {
        lat: coords[i][1],
        lng: coords[i][0]
      };
      var p2 = {
        lat: coords[j][1],
        lng: coords[j][0]
      };
      cp = isCross(p.lat, p1, p2);

      if (cp) {
        if (cp.lng > p.lng)
          count++;
      }
    }
    return count % 2;
  },

  _setSeamlessSpecInfo: function (center, data) {
    if (!data.features) {
      return;
    }
    for (var i = 0; i < data.features.length; i++) {
      var feature = data.features[i];
      if (!feature.geometry.coordinates) continue;

      var coords = feature.geometry.coordinates[0];

      if (this._inPolygon(center, coords)) {
        this._seamlessView.html(feature.properties["撮影年月"]);
        break;
      }
    }
  },

  _setElevationRusult: function (data, dataSrc) {
    this._elevationView.html(data);
    this._elevationComment.html("（" + "データソース：" + dataSrc + "）");

    this._contentSizeChange();
  },

  _setAddressResult: function (address) {

    this._addrView.html(address ? address : "---");
    this._contentSizeChange();
  },

  updateLakeDepthVisible: function(enabled){
    this._mapManager.enableLakeData(enabled);
    this._lakeDepthEnabled = enabled;
    this._lakeDepthContainer.css("display", this._dispMode == GSI.Footer.DISP_LARGE && enabled ? "block":"none");
  },

  _setLakeResult: function (params) {
    if(!params || !params.type || !params.info) return;
    var curType = params.type;
    var curInfo = params.info;

    let strH = '---';
    if(curType == "lakedepth"){
      this._lakeDepthFix = curInfo.fixed !== undefined ? curInfo.fixed:0;
      this._lakeDepth = curInfo.h !== undefined ? curInfo.h.toFixed(this._lakeDepthFix) : undefined;
      if(this._lakeDepth !== undefined) strH = this._lakeDepth+'m';
      this._lakeDepthView.html(strH);
    } else if(curType == "lakestdheight"){
      this._lakeStdHeightFix = curInfo.fixed !== undefined ? curInfo.fixed:0;
      this._lakeStdHeight = curInfo.h !== undefined ? curInfo.h.toFixed(curInfo.fixed !== undefined?curInfo.fixed:0) : undefined;
      if(this._lakeStdHeight !== undefined) strH = this._lakeStdHeight+'m';
      this._lakeStdHeightView.html(strH);
    }

    strH = '---';
    if(this._lakeDepth !== undefined && this._lakeStdHeight !== undefined){
      try{
        let fix = Math.max(this._lakeDepthFix, this._lakeStdHeightFix);
        let fLakeBtmHeight = (parseFloat(this._lakeStdHeight) - parseFloat(this._lakeDepth)).toFixed(fix);
        strH = fLakeBtmHeight + 'm';
      } catch {}
    }
    this._lakeBtmHeightView.html(strH);

    this._contentSizeChange();
  }
});

GSI.Footer.DISP_LARGE = 2;
GSI.Footer.DISP_MINI = 1;
GSI.Footer.DISP_CLOSE = 0;

GSI.Footer.DISP_ADDR_KANJI=0;
GSI.Footer.DISP_ADDR_YOMI=1;

/************************************************************************
 L.Class
 - GSI.Dialog
   - GSI.MeasureDialog (計測ダイアログ管理)
 ************************************************************************/
GSI.MeasureDialog = GSI.Dialog.extend({
  options: {
    title: GSI.TEXT.MEASURE.DIALOG_TITLE,
    width: "290px",
    minimize: true
  },
  initialize: function (dialogManager, map, mapMouse, options) {
    this.map = map;
    this.mapMouse = mapMouse;

    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);
  },
  onMeasureChange: function (e) {
    this._lastLatLngs = undefined;
    if (this.measureLayer) {
      this.map.removeLayer(this.measureLayer);
      this.measureLayer = null;
    }
    if (e.target._markers && e.target._markers.length > 0) {
      var latLng = e.target._markers[e.target._markers.length - 1]._latlng;
      this.lastLatLng.html(latLng.lat.toFixed(6) + "," + latLng.lng.toFixed(6));
    } else {
      this.lastLatLng.html("------");
    }

    if (e.target._markers && (
      (this.polyLine && e.target._markers.length >= 2)
      || (this.polygon && e.target._markers.length >= 3)
    )) {
      this.saveBtn.removeClass("disabled");
    } else {
      this.saveBtn.addClass("disabled");
    }

    this.distance.html(e.distance);
  },
  onMeasureTypeChange: function () {
    if (this.measureLayer) {
      this.map.removeLayer(this.measureLayer);
      this.measureLayer = null;
    }

    this.stopMeasure();
    this.startMeasure();
  },
  onMeasurePathCreated: function (event) {
    this.measureLayer = event.layer;
    this.map.addLayer(event.layer);
    this._lastLatLngs = undefined;

    if (this.polyLine) {
      var latlngs = [];
      if (this.polyLine._markers) {
        for (var i = 0; i < this.polyLine._markers.length; i++) {
          latlngs.push(L.latLng(this.polyLine._markers[i]._latlng));
        }
      }
      this._lastLatLngs = latlngs;
      this.polyLine.disable();
      this.polyLine = null;
    }

    if (this.polygon) {
      var latlngs = [];
      if (this.polygon._markers) {
        for (var i = 0; i < this.polygon._markers.length; i++) {
          latlngs.push(L.latLng(this.polygon._markers[i]._latlng));
        }
        if (latlngs.length > 1) {
          // 閉じる
          if ((latlngs[0].lat != latlngs[latlngs.length - 1].lat)
            || (latlngs[0].lng != latlngs[latlngs.length - 1].lng)) {
            latlngs.push(L.latLng(latlngs[0]));
          }
        }
      }
      this._lastLatLngs = latlngs;
      this.polygon.disable();
      this.polygon = null;
    }

    if (this.drawingItems) {
      this.map.removeLayer(this.drawingItems);
      this.drawingItems = null;
    }

    this.startMeasure();
  },
  startMeasure: function () {
    if (this.drawingItems) return;

    this.mapMouse.setClickMoveEnable(false);
    this.drawingItems = L.featureGroup().addTo(this.map);

    if (this.distanceRadio.is(":checked")) {
      this.lastLatLng.css({ "visibility": "visible" });
      this.startDistanceMeasure();
    }
    else if (this.areaRadio.is(":checked")) {
      this.lastLatLng.css({ "visibility": "visible" });
      this.startAreaMeasure();
    }
    else if (this.featureRadio.is(":checked")) {
      this.lastLatLng.css({ "visibility": "hidden" });
      this.startFeatureMeasure();
    }
    else if (this.multiRadio.is(":checked")) {
      this.lastLatLng.css({ "visibility": "hidden" });
      this.startMultiFeatureMeasure();
    }
  },
  startDistanceMeasure: function () {
    if (this.polyLine) return;
    L.drawLocal.draw.handlers.polyline.tooltip.start = '開始位置をクリック';
    L.drawLocal.draw.handlers.polyline.tooltip.cont = '次の位置を選択(最終点を2回クリックして終了)';
    L.drawLocal.draw.handlers.polyline.tooltip.end = GSI.TEXT.LINEEDITTIP + '次の位置を選択(最終点を2回クリックして終了)';

    this.polyLine = new GSI.Draw.Polyline(this.map, {
      shapeOptions: {
        stroke: true,
        color: '#ee3333',
        weight: 2,
        opacity: 1,
        fill: false,
        clickable: true,
        dashArray: [3, 3],
        geodesic: true
      },
      edit: { featureGroup: this.drawingItems },
      showLength: true
    });

    this.polyLine.on('measurechange',
      L.bind(this.onMeasureChange, this)
    );
    this.polyLine.enable();
  },
  startAreaMeasure: function () {
    if (this.polygon) return;
    L.drawLocal.draw.handlers.polygon.tooltip.start = '開始位置をクリック';
    L.drawLocal.draw.handlers.polygon.tooltip.cont = '次の位置を選択';
    L.drawLocal.draw.handlers.polygon.tooltip.end = GSI.TEXT.LINEEDITTIP + '次の位置を選択(最終点を2回クリックして終了)';

    this.polygon = new GSI.Draw.Polygon(this.map, {
      shapeOptions: {
        stroke: true,
        color: '#ee3333',
        fillColor: '#ee3333',
        fillOpacity: 0.4,
        weight: 2,
        opacity: 1,
        fill: true,
        clickable: true,
        dashArray: [3, 3],
        geodesic: true
      },
      edit: { featureGroup: this.drawingItems },
      showArea: true,
      allowIntersection: false

    });

    this.polygon.on('measurechange',
      L.bind(this.onMeasureChange, this)
    );
    this.polygon.enable();
  },

  onMultiLayerClick: function (layer, e) {

    for (var i = 0; i < this.multiSelectLayerList.length; i++) {
      var layerInfo = this.multiSelectLayerList[i];
      if (layerInfo.layer == layer) {
        layerInfo.selected = !layerInfo.selected;
      }
    }

    // 面積
    var areaTotal = 0;

    for (var i = 0; i < this.multiSelectLayerList.length; i++) {

      var layerInfo = this.multiSelectLayerList[i];
      if (layerInfo.selected) {
        layerInfo.rect.setStyle(this.selectedRectStyle);
        var latLngs = layerInfo.layer.getLatLngs();
        if (!L.LineUtil.isFlat(latLngs)) latLngs = latLngs[0];
        var area = L.GeometryUtil.calc_area(latLngs);
        areaTotal += area;
      } else {
        layerInfo.rect.setStyle(this.rectStyle);
      }
    }

    var areaStr = '';

    if (areaTotal <= 0) {
      this.distance.html('------');
    } else {
      if (area >= 1000000) {
        areaStr = (areaTotal / 1000000).toFixed(3) + 'km&sup2;';
      } else {
        areaStr = Math.ceil(areaTotal) + 'm&sup2;';
      }
      this.distance.html('面積:' + areaStr);
    }
  },
  onLayerClick: function (layer, e) {
    var latLngs = layer.getLatLngs();
    var distance = 0;
    var area = 0;
    var isPolygon = false;
    var geometryType = '';

    for (var i = 0; i < this.multiSelectLayerList.length; i++) {
      var layerInfo = this.multiSelectLayerList[i];
      if (layerInfo.layer == layer) {
        layerInfo.selected = true;
        layerInfo.rect.setStyle(this.selectedRectStyle);
      } else {
        layerInfo.selected = false;
        layerInfo.rect.setStyle(this.rectStyle);
      }
    }

    try {
      geometryType = layer.toGeoJSON().geometry.type;
      isPolygon = (geometryType == "Polygon");
    }
    catch (e) { }
    if (isPolygon) {
      // 面積

      if (!L.LineUtil.isFlat(latLngs)) latLngs = latLngs[0];
      area = L.GeometryUtil.calc_area(latLngs);

      var areaStr = '';

      if (area >= 1000000) {
        areaStr = (area / 1000000).toFixed(3) + 'km&sup2;';
      } else {
        areaStr = Math.ceil(area) + 'm&sup2;';
      }

      this.distance.html('面積:' + areaStr);
    }
    else {
      //距離
      for (var i = 1; i < latLngs.length; i++) {
        distance += latLngs[i - 1].distanceTo(latLngs[i]);
      }

      var distanceStr = '';

      if (distance > 1000) {
        distanceStr = (distance / 1000).toFixed(3) + 'km';
      } else {
        distanceStr = Math.ceil(distance) + 'm';
      }

      this.distance.html('距離:' + distanceStr);
    }
    return true;
  },
  startFeatureMeasure: function () {
    this.measureLayer = L.featureGroup();
    this.rectStyle = { color: "#333333", weight: 2, fill: false, opacity: 0.5, dashArray: [3, 3] };
    this.selectedRectStyle = { color: "#ff3333", weight: 2, fill: false, opacity: 0.5, dashArray: [3, 3] };
    this.multiSelectLayerList = [];
    this.multi = false;

    this.map.eachLayer(
      L.bind(function (layer) {
        if (!layer._noMeasure) {
          // ポリゴン、ライン(layer._layersはマルチポリゴン判定)以外は無視
          if (!layer.getBounds || !layer.getLatLngs || layer._layers || layer._noMeasure) return;

          if (layer._measureClickHandler) {
            layer.off('click', layer._measureClickHandler);
            layer.off('touchend', layer._measureClickHandler);
          }
          layer._measureClickHandler = L.bind(this.onLayerClick, this, layer);
          var rect = L.rectangle(layer.getBounds(), this.rectStyle);
          this.multiSelectLayerList.push({
            "selected": false,
            "layer": layer,
            "rect": rect
          });
          layer.on('click', layer._measureClickHandler);
          this.measureLayer.addLayer(rect);
        }
      }, this)
    );
    this.map.addLayer(this.measureLayer);
  },

  startMultiFeatureMeasure: function () {
    this.measureLayer = L.featureGroup();
    this.rectStyle = { color: "#333333", weight: 2, fill: false, opacity: 0.5, dashArray: [3, 3] };
    this.selectedRectStyle = { color: "#ff3333", weight: 2, fill: false, opacity: 0.5, dashArray: [3, 3] };
    this.multiSelectLayerList = [];
    this.multi = true;

    this.map.eachLayer(
      L.bind(function (layer) {
        if (!layer._noMeasure) {
          // ポリゴン、ライン(layer._layersはマルチポリゴン判定)以外は無視
          if (!layer.getBounds || !layer.getLatLngs || layer._layers || layer._noMeasure) return;

          var isPolygon = false;
          try {
            geometryType = layer.toGeoJSON().geometry.type;
            isPolygon = (geometryType == "Polygon");
          } catch (ex) { }
          if (!isPolygon) return;

          if (layer._measureClickHandler) {
            layer.off('click', layer._measureClickHandler);
            layer.off('touchend', layer._measureClickHandler);
          }
          layer._measureClickHandler = L.bind(this.onMultiLayerClick, this, layer);

          var rect = L.rectangle(layer.getBounds(), this.rectStyle);
          this.multiSelectLayerList.push({
            "selected": false,
            "layer": layer,
            "rect": rect
          });
          layer.on('click', layer._measureClickHandler);
          this.measureLayer.addLayer(rect);
        }
      }, this)
    );
    this.map.addLayer(this.measureLayer);
  },

  stopMeasure: function () {
    this.saveBtn.addClass("disabled");

    this._lastLatLngs = undefined;
    this.map.eachLayer(
      L.bind(function (layer) {
        if (layer._measureClickHandler) {
          layer.off('click', layer._measureClickHandler);
        }
      }, this)
    );

    if (this.measureLayer) {
      this.map.removeLayer(this.measureLayer);
      this.measureLayer = null;
    }
    this.mapMouse.setClickMoveEnable(true);
    this.lastLatLng.html("------");
    this.distance.html('------');
    if (this.polyLine) {
      this.polyLine.disable();
      this.polyLine = null;
    }

    if (this.polygon) {
      this.polygon.disable();
      this.polygon = null;
    }

    if (this.drawingItems) {
      this.map.removeLayer(this.drawingItems);
      this.drawingItems = null;
    }
  },
  show: function () {
    if (!this._onMeasurePathCreated) {
      this._onMeasurePathCreated = L.bind(this.onMeasurePathCreated, this);
      this.map.on('draw:created', this._onMeasurePathCreated);
    }
    this.startMeasure();
    GSI.Dialog.prototype.show.call(this);
  },
  hide: function () {
    if (this._onMeasurePathCreated) {
      this.map.off('draw:created', this._onMeasurePathCreated);
      this._onMeasurePathCreated = null;
    }

    this.stopMeasure();
    GSI.Dialog.prototype.hide.call(this);
  },
  createHeader: function () {
    this.title = $('<div>').html(this.options.title);

    return $('<div>').append(this.title);
  },
  createContent: function () {
    this.frame = $('<div>');
    this.radioFrame = $('<div>');

    // 距離
    this.distanceRadio = $('<input>').attr({
      'id': 'GSI_MeasureDialog_distance',
      'type': 'radio',
      'name': 'measure'//,
//      'checked': true
    }).on('click',L.bind(this.onMeasureTypeChange, this));
    this.distanceRadio.prop('checked', true);
    this.distanceLabel = $('<label>').attr({ 'for': 'GSI_MeasureDialog_distance' }).append(this.distanceRadio)
      .append($('<span>').html(GSI.TEXT.MEASURE.DIALOG_DISTANCE_CAPTION));

    // 面積
    this.areaRadio = $('<input>').attr({
      'id': 'GSI_MeasureDialog_area',
      'type': 'radio',
      'name': 'measure'//,
//      'checked': false
    }).on('click',L.bind(this.onMeasureTypeChange, this));
    this.areaRadio.prop('checked', false);
    this.areaLabel = $('<label>').attr({ 'for': 'GSI_MeasureDialog_area' }).append(this.areaRadio)
      .append($('<span>').html(GSI.TEXT.MEASURE.DIALOG_AREA_CAPTION));

    // 図形
    this.featureRadio = $('<input>').attr({
      'id': 'GSI_MeasureDialog_feature',
      'type': 'radio',
      'name': 'measure'//,
//      'checked': false
    }).on('click',L.bind(this.onMeasureTypeChange, this));
    this.featureRadio.prop('checked', false);
    this.featureLabel = $('<label>').attr({ 'for': 'GSI_MeasureDialog_feature' }).append(this.featureRadio)
      .append($('<span>').html(GSI.TEXT.MEASURE.DIALOG_OBJECT_CAPTION));

    // 複数選択
    this.multiRadio = $('<input>').attr({
      'id': 'GSI_MeasureDialog_multi',
      'type': 'radio',
      'name': 'measure'//,
//      'checked': false
    }).on('click',L.bind(this.onMeasureTypeChange, this));
    this.multiRadio.prop('checked', false);
    this.multiLabel = $('<label>').attr({ 'for': 'GSI_MeasureDialog_multi' }).append(this.multiRadio)
      .append($('<span>').html(GSI.TEXT.MEASURE.DIALOG_MULTI_CAPTION));

    this.radioFrame.addClass('gsi_measuredialog_radiofrane')
      .append(this.distanceLabel)
      .append(this.areaLabel)
      .append(this.featureLabel)
      .append(this.multiLabel);

    // 直前の位置
    this.lastLatLng = $('<div>').html('------').addClass('gsi_measuredialog_lastlatlng');
    // 結果
    this.distance = $('<div>').html('------').addClass('gsi_measuredialog_result');

    this.frame.append(this.radioFrame).append(this.distance).append(this.lastLatLng);

    //保存ボタン
    this.saveBtn = $("<a>").attr({ "href": "javascript:void(0);" }).addClass('gsi_measuredialog_savebtn').html("経路又は範囲を保存");
    this.frame.append(this.saveBtn);
    this.saveBtn.on("click", L.bind(this._saveBtnClick, this));
    this.saveBtn.addClass("disabled");

    //計測値の説明
    this.infoBtn = $("<a>").attr({ "href": "https://maps.gsi.go.jp/help/howtouse.html", "target": "_blank" }).addClass('gsi_measuredialog_infobtn').html("計測値の説明");
    this.frame.append(this.infoBtn);

    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.MEASURE) {
      this.distanceRadio.attr({ "title": CONFIG.TOOLTIP.MEASURE.DISTANCE });
      this.distanceLabel.attr({ "title": CONFIG.TOOLTIP.MEASURE.DISTANCE });

      this.areaRadio.attr({ "title": CONFIG.TOOLTIP.MEASURE.AREA });
      this.areaLabel.attr({ "title": CONFIG.TOOLTIP.MEASURE.AREA });

      this.featureRadio.attr({ "title": CONFIG.TOOLTIP.MEASURE.FEATURE });
      this.featureLabel.attr({ "title": CONFIG.TOOLTIP.MEASURE.FEATURE });

      this.multiRadio.attr({ "title": CONFIG.TOOLTIP.MEASURE.MULTI });
      this.multiLabel.attr({ "title": CONFIG.TOOLTIP.MEASURE.MULTI });

      this.saveBtn.attr({ "title": CONFIG.TOOLTIP.MEASURE.SAVE });
    }

    return this.frame;
  },

  _saveBtnClick: function () {
    if (!this._saveTypeSelectContainer) {
      this._saveTypeSelectContainer = $("<div>").addClass("gsi_measuredialog_save_frame");
      var saveCSVBtn = $("<a>").attr({ "href": "javascript:void(0);" }).html("CSV形式で保存");
      var saveGeoJSONBtn = $("<a>").attr({ "href": "javascript:void(0);" }).html("GeoJSON形式で保存");
      var saveKMLBtn = $("<a>").attr({ "href": "javascript:void(0);" }).html("KML形式で保存");

      saveCSVBtn.on("click", L.bind(this._saveCSV, this));
      saveGeoJSONBtn.on("click", L.bind(this._saveGeoJSON, this));
      saveKMLBtn.on("click", L.bind(this._saveKML, this));

      this._saveTypeSelectContainer.append(saveCSVBtn).append(saveGeoJSONBtn).append(saveKMLBtn);

      this._saveTypeSelectContainer.css({ "display": "none" });
      $(document.body).append(this._saveTypeSelectContainer);

    }

    var pos = this.saveBtn.offset();
    var screenSize = GSI.Utils.getScreenSize();
    this._saveTypeSelectContainer.css({
      "left": pos.left + "px",
      "bottom": (screenSize.h - pos.top) + "px"
    });

    this._saveTypeSelectContainer.slideDown(300);
    if (!this._saveTypeSelectDocumentMouseDownHandler) {
      this._saveTypeSelectDocumentMouseDownHandler = L.bind(function (e) {
        var target = e.target;
        while (target) {
          if (target == this._saveTypeSelectContainer[0]) {

            return;
          }
          target = target.parentNode;
        }

        this._hideSaveTypeSelect();

      }, this);
      $("body").on("mousedown", this._saveTypeSelectDocumentMouseDownHandler);
    }
  },

  _getCurrentData: function () {

    var markers = null;
    var latLngs = null;
    var type = "";
    if (this.polygon) {
      if (this.polygon._markers && this.polygon._markers.length > 2) {
        markers = this.polygon._markers;
        type = "polygon";
      } else if (this._lastLatLngs) {
        latLngs = this._lastLatLngs;
        type = "polygon";
      }
    }

    if (this.polyLine) {
      if (this.polyLine._markers && this.polyLine._markers.length > 1) {
        markers = this.polyLine._markers;
        type = "polyline";
      } else if (this._lastLatLngs) {
        latLngs = this._lastLatLngs;
        type = "polyline";
      }
    }

    if (markers || latLngs) {

      if (!latLngs) {
        latLngs = []

        for (var i = 0; i < markers.length; i++) {
          latLngs.push(L.latLng(markers[i]._latlng));
        }
        if (type == "polygon" && latLngs.length > 1) {
          // 閉じる
          if ((latLngs[0].lat != latLngs[latLngs.length - 1].lat)
            || (latLngs[0].lng != latLngs[latLngs.length - 1].lng)) {
            latLngs.push(L.latLng(latLngs[0]));
          }
        }
      }

      return {
        "latlngs": latLngs,
        "type": type
      };
    }

    return undefined;
  },
  _hideSaveTypeSelect: function () {
    this._saveTypeSelectContainer.slideUp(300);
    if (this._saveTypeSelectDocumentMouseDownHandler) {
      $("body").off("mousedown", this._saveTypeSelectDocumentMouseDownHandler);
      this._saveTypeSelectDocumentMouseDownHandler = null;
    }

  },

  _saveCSV: function () {
    this._hideSaveTypeSelect();
    var data = this._getCurrentData();
    if (!data) return;

    function fix(val) {
      return (Math.round(val * 1000000) / 1000000).toFixed(6);
    }

    var csv = "lat,lng";
    for (var i = 0; i < data.latlngs.length; i++) {
      if (csv != "") csv += "\r\n";

      csv += fix(data.latlngs[i].lat) + "," + fix(data.latlngs[i].lng);
    }

    this._saveText("measure" + GSI.Utils.getTimeStampString() + ".csv", csv);

  },

  _saveGeoJSON: function () {
    this._hideSaveTypeSelect();
    var data = this._getCurrentData();
    if (!data) return;
    var geojson = {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": {
          },
          "geometry": {
            "type": "LineString",
            "coordinates": []
          }
        }
      ]
    };

    var coords = [];
    for (var i = 0; i < data.latlngs.length; i++) {
      coords.push([data.latlngs[i].lng, data.latlngs[i].lat]);
    }

    switch (data.type) {
      case "polygon":
        geojson.features[0]["geometry"]["type"] = "Polygon";
        geojson.features[0]["geometry"]["coordinates"] = [coords];
        break;

      case "polyline":
        geojson.features[0]["geometry"]["type"] = "LineString";
        geojson.features[0]["geometry"]["coordinates"] = coords;
        break;

    }

    geojson = JSON.stringify(geojson, null, 2);

    this._saveText("measure" + GSI.Utils.getTimeStampString() + ".geojson", geojson);

  },

  _saveKML: function () {
    this._hideSaveTypeSelect();
    var data = this._getCurrentData();
    if (!data) return;
    var kml = "";

    var coords = '';

    for (var i = 0; i < data.latlngs.length; i++) {
      if (coords != "") coords += " ";
      coords += data.latlngs[i].lng + "," + data.latlngs[i].lat;
    }

    coords = "<coordinates>" + coords + "</coordinates>";

    if (data.type == "polygon") {
      kml = '<?xml version="1.0" encoding="UTF-8"?>' + "\r\n" +
        '<kml xmlns="http://www.opengis.net/kml/2.2">' + "\r\n" +
        '<Document>' + "\r\n" +
        '<Style id="PolyStyle1">' + "\r\n" +
        '</Style>' + "\r\n" +
        '<Placemark>' +
        '<styleUrl>#PolyStyle1</styleUrl>' + "\r\n" +
        '<Polygon>' + "\r\n" +
        '<outerBoundaryIs>' + "\r\n" +
        '<LinearRing>' + "\r\n" +
        coords + "\r\n" +
        '</LinearRing>' + "\r\n" +
        '</outerBoundaryIs>' + "\r\n" +
        '</Polygon>' + "\r\n" +
        '</Placemark>' + "\r\n" +
        '</Document>' + "\r\n" +
        '</kml>' + "\r\n";
    } else if (data.type == "polyline") {

      kml = '<?xml version="1.0" encoding="UTF-8"?>' + "\r\n" +
        '<kml xmlns="http://www.opengis.net/kml/2.2">' + "\r\n" +
        '<Document>' + "\r\n" +
        '<Style id="LineStyle1">' + "\r\n" +
        '</Style>' + "\r\n" +
        '<Placemark>' +
        '<styleUrl>#LineStyle1</styleUrl>' + "\r\n" +
        '<LineString>' + "\r\n" +
        coords + "\r\n" +
        '</LineString>' + "\r\n" +
        '</Placemark>' + "\r\n" +
        '</Document>' + "\r\n" +
        '</kml>' + "\r\n";

    }

    this._saveText("measure" + GSI.Utils.getTimeStampString() + ".kml", kml);
  },

  _saveText: function (fileName, txt) {

    var blob = new Blob([txt], { "type": "text/plain" })

    GSI.Utils.saveFile("text/plain", fileName, blob);

  }
});

/************************************************************************
 GSI.HanreiLoader
************************************************************************/
GSI.HanreiLoader = L.Evented.extend({

  initialize: function (map, mapLayerList, hanreiList) {
    this._map = map;
    this._mapLayerList = mapLayerList;
    this._hanreiList = hanreiList;
    this._map.on("click", L.bind(this._onMapClick, this));
    this._mapLayerList.on('change', L.bind(this._onMapLayerListChange, this));
    this._mapLayerList.on('visiblechange', L.bind(this._onMapLayerListChange, this));
  },

  _onMapLayerListChange: function () {
    this._clearImageRGBLoader();
    if (this._popup) {
      this._map.closePopup(this._popup);
      this._popup = null;
    }

  },

  _onMapClick: function (evt) {
    if (this._popup) {
      this._map.closePopup(this._popup);
      this._popup = null;
    }
    // 凡例表示
    var tileList = this._mapLayerList.getTileList();
    var hanrei = undefined;
    var layer = undefined;
    for (var i = 0; i < tileList.length; i++) {
      layer = tileList[i];
      if (!layer._visibleInfo || layer._visibleInfo._isHidden) continue;
      hanrei = this._hanreiList[layer.id];
      if (hanrei) {
        break;
      }
    }
    if (!hanrei) {
      tileList = this._mapLayerList.getList();
      for (var i = 0; i < tileList.length; i++) {
        layer = tileList[i];
        if (!layer._visibleInfo || layer._visibleInfo._isHidden) continue;
        hanrei = this._hanreiList[layer.id];
        if (hanrei) {
          break;
        }
      }

    }

    if (!hanrei) return;
    if (hanrei.layer) {
      hanrei.layer.id = layer.id;
      layer = hanrei.layer;
    }

    var zoom = this._map.getZoom();
    if (layer.maxNativeZoom < zoom) zoom = layer.maxNativeZoom;
    this._load(layer, hanrei, evt.latlng, zoom);

  },

  _load: function (layer, hanrei, latlng, zoom) {

    this._clearImageRGBLoader();
    if (!this._tileImageRGBLoader) {
      this._createImageRGBLoader();
    }

    if (!this._targetHanrei || this._targetHanrei.id != layer.id) {

      this._targetHanrei = {
        "id": layer.id,
        "hanrei": hanrei
      };
      if (!hanrei.data) {
        this._loadData(this._targetHanrei);
      }
    }
    this._tileImageRGBLoader.load(latlng, zoom, layer);

  },

  _loadData: function (target) {
    $.ajax({
      type: "GET",
      url: target.hanrei.url,
      dataType: 'text'
    })
      .done(L.bind(function (target, data) {
        try {
          target.hanrei.data = JSON.parse(data);
        } catch (e) {
          target.hanrei.data = this._csvToData(data);
          if (!target.hanrei.data) return;
        }
        if (this._waitingData && this._waitingData.id == target.id && this._targetHanrei && this._targetHanrei.id == target.id) {
          this._showPopup(this._waitingData.color, this._waitingData.latlng)
        }
      }, this, target))
      .fail(L.bind(function (target, data) {
        // スキップ
      }, this, target))
      .always(L.bind(function () {

      }, this));
  },

  _csvToData: function (txt) {

    var isValid = function (item) {
      var pattern = /^([1-9]\d*|0)$/;
      if (item.r == undefined || !pattern.test(item.r)) return false;
      if (item.g == undefined || !pattern.test(item.g)) return false;
      if (item.b == undefined || !pattern.test(item.b)) return false;
      item.r = parseInt(item.r);
      item.g = parseInt(item.g);
      item.b = parseInt(item.b);
      return true;
    };
    var data = [];
    var arr = GSI.Utils.parseCSV(txt, ",");
    for (var i = 0; i < arr.length; i++) {
      var line = arr[i];
      if (line.length < 5) continue;
      var item = {
        "title": line[0],
        "description": line[1],
        "r": line[2],
        "g": line[3],
        "b": line[4]
      };
      if (isValid(item)) data.push(item);

    }
    if (data.length > 0) {
      return data;
    } else {
      return undefined;
    }
  },

  _createImageRGBLoader: function () {
    this._tileImageRGBLoader = new GSI.TileImageRGBLoader(this._map);
    this._tileImageRGBLoader.on("load", L.bind(this._onImageRGBLoad, this));
  },

  _showPopup: function (color, latlng) {

    var data = this._targetHanrei.hanrei.data;

    if (!data) {
      this._waitingData = {
        "id": this._targetHanrei.id,
        "color": color,
        "latlng": latlng
      };
      return;
    }

    for (var i = 0; i < data.length; i++) {
      var item = data[i];
      if (item.r == color.r && item.g == color.g && item.b == color.b) {

        var html = "<h3>" + item.title + "</h3>";
        if (item.description && item.description != "") {
          var description = item.description;
          description = description.replace(/\r?\n/g, '<br>');
          html += "<div>" + description + "</div>";
        }

        this._popup = new L.Popup()
          .setLatLng(latlng)
          .setContent(html);
        this._map.openPopup(this._popup);
        return;
      }
    }
  },

  _clearImageRGBLoader: function () {
    if (this._tileImageRGBLoader) {
      this._tileImageRGBLoader.cancel();
      this._tileImageRGBLoader = null;
    }
  },

  _onImageRGBLoad: function (evt) {

    if (this._targetHanrei && this._targetHanrei.id == evt.layer.id) {
      this._showPopup(evt.color, evt.latlng);
    }
  }
});

/************************************************************************
 GSI.TileImageRGBLoader
************************************************************************/
GSI.TileImageRGBLoader = L.Evented.extend({

  initialize: function (map, options) {
    this._map = map;

  },
  load: function (latlng, zoom, layer) {

    this._destroyImage();
    this._latlng = latlng;
    this._zoom = zoom;
    this._layer = layer;
    this._load();
  },

  _destroyImage: function () {
    if (this._img) {

      this._img.removeEventListener("load", this._imgLoadHandler);
      this._img.removeEventListener("error", this._imgLoadErrorHandler);

      this._imgLoadHandler = null;
      this._imgLoadErrorHandler = null;
      delete this._img;
      this._img = null;
    }
  },

  cancel: function () {
    this._destroyImage();

  },

  _load: function () {
    this._destroyImage();

    var tileInfo = this._getTileInfo(this._latlng.lat, this._latlng.lng, this._zoom);
    this._img = document.createElement("img");
    this._img.setAttribute("crossorigin", "anonymous");

    this._imgLoadHandler = L.bind(this._onImgLoad, this, tileInfo, this._img);
    this._imgLoadErrorHandler = L.bind(this._onImgLoadError, this, tileInfo, this._img);

    this._img.addEventListener("load", this._imgLoadHandler);
    this._img.addEventListener("error", this._imgLoadErrorHandler);

    function makeUrl(url, zoom, tileInfo) {
      var result = url.replace("{x}", tileInfo.x);
      result = result.replace("{y}", tileInfo.y);
      result = result.replace("{z}", zoom);
      result += ( result.indexOf("?") >= 0 ? "&" : "?" ) + (new Date()).getTime();
      return result;
    }
    var url = this._layer.url;
    if (url.slice(0, 2) == "//") {
      url = "https:" + url;
    }
    this._img.src = makeUrl(url, this._zoom, tileInfo);

  },

  _onImgLoad: function (tileInfo, img) {

    if (!this._canvas) {
      this._canvas = document.createElement("canvas");
      this._canvas.width = 256;
      this._canvas.height = 256;
    }
    var ctx = this._canvas.getContext("2d");
    ctx.clearRect(0, 0, 256, 256);
    ctx.beginPath();

    ctx.drawImage(img, 0, 0);

    var imgData = ctx.getImageData(0, 0, 256, 256);
    var idx = (tileInfo.pY * 256 * 4) + (tileInfo.pX * 4);
    var r = imgData.data[idx + 0];
    var g = imgData.data[idx + 1];
    var b = imgData.data[idx + 2];
    var a = imgData.data[idx + 3];
    if (a == 0) {
      return;
    }
    this.fire("load", {
      "color": { "r": r, "g": g, "b": b },
      "layer": this._layer,
      "latlng": this._latlng,
      "zoom": this._zoom
    });
  },

  _onImgLoadError: function (url, current, tileInfo, img) {
  },

  _getTileInfo: function (lat, lng, z) {
    var lng_rad = lng * Math.PI / 180;
    var R = 128 / Math.PI;
    var worldCoordX = R * (lng_rad + Math.PI);
    var pixelCoordX = worldCoordX * Math.pow(2, z);
    var tileCoordX = Math.floor(pixelCoordX / 256);

    var lat_rad = lat * Math.PI / 180;
    var worldCoordY = - R / 2 * Math.log((1 + Math.sin(lat_rad)) / (1 - Math.sin(lat_rad))) + 128;
    var pixelCoordY = worldCoordY * Math.pow(2, z);
    var tileCoordY = Math.floor(pixelCoordY / 256);

    return {
      x: tileCoordX,
      y: tileCoordY,
      pX: Math.floor(pixelCoordX - tileCoordX * 256),
      pY: Math.floor(pixelCoordY - tileCoordY * 256)
    };
  }
});

/*******************************************************
 L.Class
 - GSI.Dialog
   - GSI.EditReliefDialog
    自分で作る色別標高図用データ生成ダイアログ
*******************************************************/

// カラーパターンのhtmlカラーをRGBに
for (var i = 0; i < CONFIG.FREERELIEF_COLORPATTERNS.length; i++) {
  var pattern = CONFIG.FREERELIEF_COLORPATTERNS[i];
  for (var j = 0; j < pattern.colors.length; j++) {
    var color = pattern.colors[j];
    if (color.r || color.r == 0) continue;
    pattern.colors[j] = GSI.ReliefTileLayer.colorStringToRGBA(color);
  }
}

GSI.EditReliefDialog = GSI.Dialog.extend({

  options: {
    title: "自分で作る色別標高図",
    width: "300px",
    transparentGradate: false,
    minimize: true
  },

  // 初期化
  initialize: function (dialogManager, map, mapLayerList, options) {
    this._map = map;
    this._mapLayerList = mapLayerList;
    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);
  },

  // 表示
  show: function () {

    if (this.container && this._dialogManager.isMinimized(this)) {
      this._dialogManager.removeMinimizeList(this);
      this.normalize();
      return;
    }

    if (!this.getVisible()) {
      if (this._newDataView) this._newDataView.hide();
      if (this._loadDataView) this._loadDataView.hide();

      var data = this._mapLayerList.getElevationData();
      if (data && !data["default"]) {
        this._refreshReriefEdit(data, true);
      }
      else
        this._showNewDataView();
    }

    GSI.Dialog.prototype.show.call(this);

  },

  refresh: function () {
    GSI.Dialog.prototype.hide.call(this);

    if (this._newDataView) this._newDataView.hide();
    if (this._loadDataView) this._loadDataView.hide();

    var data = this._mapLayerList.getElevationData();
    if (data && !data["default"]) {
      this._refreshReriefEdit(data, true);
    }
    else
      this._showNewDataView();

    GSI.Dialog.prototype.show.call(this);

  },

  afterShow: function () {
    this._refreshGradationBar();
  },

  hide: function () {
    this._hideColorPatternSelectPanel();
    GSI.Dialog.prototype.hide.call(this);
  },

  createHeader: function () {
    this.title = $('<div>').html(this.options.title);

    return $('<div>').append(this.title);
  },

  createContent: function () {
    this.frame = $('<div>').addClass("gsi_editreliefdialog_content");

    var controlFrame = this._createControl();
    this.frame.append(controlFrame);

    var editFrame = $("<div>").css({ "margin": "4px" });

    var orderFrame = $("<div>"); //.css({ "padding": "4px" });

    if (!GSI.EditReliefDialog._labelIdInc) GSI.EditReliefDialog._labelIdInc = 0;

    // 降順チェック

    GSI.EditReliefDialog._labelIdInc++;
    var id = "gsi_editreliefdialog_ordercheck" + GSI.EditReliefDialog._labelIdInc;

    this._orderDescCheck = $("<input>").attr({ "id": id, "type": "checkbox" }).addClass("normalcheck");

    this._orderDescCheck.on('click',L.bind(function () {
      var data = this._makeElevationData(!this._orderDescCheck.is(":checked"));
      data.desc = this._orderDescCheck.is(":checked");
      this._refreshReriefEdit(data);
    }, this))
    var orderLabel = $("<label>").attr({ "for": id }).html("降順に並べる");
    orderFrame.append(this._orderDescCheck).append(orderLabel);

    // カラーパターン選択

    this._colorPatternSelect = $("<a>").attr({ "href": "javascript:void(0);" })
      .html("カラーパターン選択").addClass("gsi_editreliefdialog_patternselect");
    this._colorPatternSelect.on("click", L.bind(this._onColorPatternSelectClick, this));
    orderFrame.append(this._colorPatternSelect);

    editFrame.append(orderFrame);

    // リスト
    this._scrollFrame = $("<div>").addClass("scroll_frame");
    editFrame.append(this._scrollFrame);

    this.frame.append(editFrame);

    // 単位
    this.frame.append($("<div>").css({ "padding-left": "30px" }).html("(単位:m)"));

    var optionFrame = $("<div>").css({ "text-align": "left", "margin": "4px" });

    var label = null;
    var div = null;

    div = $("<div>").addClass("gsi_editreliefdialog_options");

    GSI.EditReliefDialog._labelIdInc++;
    id = "gsi_editreliefdialog_gradate" + GSI.EditReliefDialog._labelIdInc;

    this._gradateInput = $("<input>")
      .on('click',L.bind(function () {
        this._refreshGradationBar();
      }, this))
      .addClass("normalcheck").attr({ "id": id, "type": "checkbox" });

    label = $("<label>").attr({ "for": id }).html("グラデーション").css({ "font-size": "9pt" });
    div.append(this._gradateInput).append(label);
    optionFrame.append(div);

    GSI.EditReliefDialog._labelIdInc++;
    id = "gsi_editreliefdialog_usehillshademap" + GSI.EditReliefDialog._labelIdInc;

    this._useHillshademapInput = $("<input>").addClass("normalcheck")
      .attr({ "id": id, "type": "checkbox" });
    label = $("<label>").attr({ "for": id }).html("陰影(日本周辺)").css({ "font-size": "9pt" });
    div.append(this._useHillshademapInput).append(label);
    optionFrame.append(div);

    this.frame.append(optionFrame);

    // 地図に反映
    var reflectionFrame = $("<div>").css({ "padding": "4px", "width": "100%" });
    a = $("<a>").addClass("normalbutton").css({ "text-align": "center", "width": "100%", "padding-left": "7px", "padding-right": "7px" }).attr({ "href": "javascript:void(0);" }).html("上記の内容で地図に反映");

    a.on('click',L.bind(function () {
      this._reflection();
      var isshow = false;
      for(var i=0; i < this._mapLayerList.tileList.length; i++){
        var t = this._mapLayerList.tileList[i];
        if (t.id == CONFIG.FREERELIEFID){
          //自分で作る色別標高図が非表示の時だけ起動
          if (t._visibleInfo && t._visibleInfo._isHidden){
            if (t._visibleInfo._isHidden == true){
              var x = this._mapLayerList._gsimaps._mainMap._mapMenu.getShowingMapListPanel();
              x.showReliefFree(t);
              this._mapLayerList.fire("change");
              isshow = true;
              break;
            }
          }
        }
      }

      if (isshow == false){
        if (this.options.listItem && this.options.listObj){
          if (!this.options.listObj._visibleInfo){
            var y = this._mapLayerList._gsimaps._mainMap._mapMenu.getMapListPanel();
            y.selectReliefFree(this.options.listItem, this.options.listObj);
            GSI.Utils.sendSelectedLayer(CONFIG.FREERELIEFID);
          }
        }
      }

    }, this));

    reflectionFrame.append(a);

    this.frame.append(reflectionFrame);

    return this.frame;
  },

  _onColorPatternSelectClick: function () {
    if (!this._colorPatternSelectPanel) {
      this._colorPatternSelectPanel = $("<div>").addClass("gsi_editreliefdialog_patternselectpanel").hide();

      var ul = $("<ul>");

      for (var i = 0; i < CONFIG.FREERELIEF_COLORPATTERNS.length; i++) {
        var pattern = CONFIG.FREERELIEF_COLORPATTERNS[i];

        var li = $("<li>");
        var a = $("<a>").attr({ "href": "javascript:void(0);" }).on("click", L.bind(function (pattern) {
          this._hideColorPatternSelectPanel();
          this._setColorPattern(pattern);
        }, this, pattern));
        var canvas = $("<canvas>");
        canvas[0].width = 200;
        canvas[0].height = 10;
        this._drawPatternSample(canvas[0], pattern, 200, 10);

        a.append(canvas);
        li.append(a);
        ul.append(li);
      }
      this._colorPatternSelectPanel.append(ul);

    }
    $("body").append(this._colorPatternSelectPanel);

    if (!this._colorPatternSelectPanelHideCheckHandler) {
      this._colorPatternSelectPanelHideCheckHandler = L.bind(function (evt) {
        var target = evt.target;
        while (target) {
          if (target == this._colorPatternSelectPanel[0]) {
            return;
          }
          target = target.parentNode;
        }
        this._hideColorPatternSelectPanel();
      }, this);
      $("body").on("mousedown", this._colorPatternSelectPanelHideCheckHandler);
    }

    var pos = this._colorPatternSelect.offset();

    this._colorPatternSelectPanel.css({
      "left": (pos.left) + "px",
      "top": (pos.top + this._colorPatternSelect.outerHeight()) + "px"
    }).slideDown(200);
  },

  _hideColorPatternSelectPanel: function () {

    if (this._colorPatternSelectPanelHideCheckHandler) {
      $("body").off("mousedown", this._colorPatternSelectPanelHideCheckHandler);
      this._colorPatternSelectPanelHideCheckHandler = null;
    }
    if (this._colorPatternSelectPanel) {
      this._colorPatternSelectPanel.hide();
      this._colorPatternSelectPanel.remove();
      this._colorPatternSelectPanel = null;

    }
  },

  _drawPatternSample: function (canvas, pattern, w, h) {
    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, w, h);
    ctx.beginPath();
    var imageData = ctx.createImageData(w, h);

    var colors = pattern.colors;

    var blockWidth = Math.ceil(w / (colors.length - 1));

    for (var i = 0; i < colors.length - 1; i++) {

      var color1 = colors[i];
      var color2 = colors[i + 1];
      var startX = i * blockWidth;
      for (var x = startX; x < startX + blockWidth && x < w; x++) {
        var p = (x - startX) / blockWidth;
        var r = Math.round(color1.r + (color2.r - color1.r) * p);
        var g = Math.round(color1.g + (color2.g - color1.g) * p);
        var b = Math.round(color1.b + (color2.b - color1.b) * p);
        for (var y = 0; y < h; y++) {
          var idx = (y * w * 4) + (x * 4);
          imageData.data[idx] = r;
          imageData.data[idx + 1] = g
          imageData.data[idx + 2] = b;
          imageData.data[idx + 3] = 255;

        }
      }
    }
    ctx.putImageData(imageData, 0, 0);
  },

  _setColorPattern: function (pattern) {
    var colorSelects = this._scrollFrame.find("a.color");
    var desc = this._orderDescCheck.is(":checked");
    var colors = this._makeColorsFromColorPattern(colorSelects.length, pattern);

    for (var i = 0; i < colorSelects.length; i++) {
      var idx = (desc ? colorSelects.length - i - 1 : i);
      var a = $(colorSelects[idx]);

      var color = this._rgbToColor(colors[idx]);

      a.data({ "color": color }).css({ "background": color });

    }

    this._refreshGradationBar();
  },

  _makeColorsFromColorPattern: function (len, pattern) {

    var colors = $.extend(true, [], pattern.colors);

    if (len <= colors.length) {
      // 少ない場合
      var colorsLength = colors.length;
      for (var i = 0; i < colorsLength - len; i++) {
        if (i % 2 == 0) {
          colors.splice(colors.length - 2, 1);
        } else {
          colors.splice(1, 1);
        }
      }
      return colors;
    }

    // 多い場合は補完

    var colorLength = colors.length - 1;
    var splitNum = Math.floor(len / colorLength);
    var lastIndex = (colorLength) - (len % colorLength);

    var splitColor = function (c1, c2, num) {
      var result = [];
      //
      for (var i = 0; i < num; i++) {

        var p = (i + 1) / (num + 1);
        var color = {
          r: Math.round(c1.r + (c2.r - c1.r) * p),
          g: Math.round(c1.g + (c2.g - c1.g) * p),
          b: Math.round(c1.b + (c2.b - c1.b) * p),
        };

        result.push(color);
      }
      return result;
    };

    var result = [];

    for (var i = colorLength - 1; i >= 0; i--) {
      var sNum = splitNum;
      if (lastIndex == colorLength) {
        sNum--;
        if (i < 1) sNum--;
      } else {
        if (i < lastIndex + 1) {
          sNum--;
        }
      }

      result.unshift(colors[i + 1]);
      if (sNum <= 0) continue;
      var splittedColors = splitColor(colors[i], colors[i + 1], sNum);
      for (var j = splittedColors.length - 1; j >= 0; j--) {
        result.unshift(splittedColors[j]);
      }
    }
    result.unshift(colors[0]);

    return result;
  },

  _createControl: function () {
    var frame = $('<div>').addClass("gsi_editreliefdialog_control_frame");

    var a = null;
    var img = null;

    // 読込ボタン
    a = $("<a>").attr({ "href": "javascript:void(0);" });
    img = $("<img>").css({ "width": "24px", "height": "24px" })
      .attr({
        "src": "image/elevation/icon-open.png",
        "title": "スタイルをファイルから読み込み"
      });

    a.on('click',L.bind(this._showLoadView, this));
    a.append(img);
    frame.append(a);

    // 保存ボタン
    a = $("<a>").attr({ "href": "javascript:void(0);" });
    img = $("<img>")
      .attr({
        "src": "image/elevation/icon-save.png",
        "title": "スタイルをファイルに保存"
      });

    a.on('click',L.bind(this._save, this));
    a.append(img);
    frame.append(a);

    // 凡例保存
    a = $("<a>").attr({ "href": "javascript:void(0);" });

    img = $("<img>").css({ "width": "24px", "height": "24px" })
      .attr({
        "src": "image/elevation/icon-save-legend.png"
      });
    a.append(img);
    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.EDITRELIEF) {
      img.attr({ "title": CONFIG.TOOLTIP.EDITRELIEF.HANREI });
    }

    a.on('click',L.bind(function () {
      this._saveHanrei();
    }, this));
    frame.append(a);

    // 新しく作成（廃止）
        // 自動作成
    a = $("<a>").attr({ "href": "javascript:void(0);" });

    img = $("<img>").css({ "width": "24px", "height": "24px" })
      .attr({
        "src": "image/elevation/icon-auto.png"
      });
    a.append(img);

    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.EDITRELIEF) {
      img.attr({ "title": CONFIG.TOOLTIP.EDITRELIEF.AUTO });
    }
    a.on('click',L.bind(function () {
      this._createAutoNewData();
    }, this));
    frame.append(a);

    // 低い範囲を表示
    a = $("<a>").attr({ "href": "javascript:void(0);" });
    img = $("<img>").css({ "width": "24px", "height": "24px" })
      .attr({
        "src": "image/elevation/icon-paint-below.png"
      });
    a.append(img);

    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.EDITRELIEF) {
      img.attr({ "title": CONFIG.TOOLTIP.EDITRELIEF.LOW });
    }
    a.on('click',L.bind(function () {
      this._createLowNewData();
    }, this));
    frame.append(a);

    // 初期状態に戻す
    a = $("<a>").attr({ "href": "javascript:void(0);" });

    img = $("<img>").css({ "width": "24px", "height": "24px" })
      .attr({
        "src": "image/elevation/icon-reset.png"
      });
    a.append(img);
    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.EDITRELIEF) {
      img.attr({ "title": CONFIG.TOOLTIP.EDITRELIEF.RESET });
    }
    a.on('click',L.bind(function () {
      if (window.confirm("編集中の色情報は削除されます。\n初期状態に戻してもよろしいですか？")) {
        var data = GSI.ReliefTileLayer.getElevationSampleData();
        this._refreshReriefEdit(data);
        this._reflection(data);
        if (this._newDataView) this._newDataView.hide();
        if (this._loadDataView) this._loadDataView.hide();
      }
    }, this));
    frame.append(a);

    return frame;
  },

  // 新規データ作成ビュー作成
  _showNewDataView: function () {
    if (!this._newDataView) {
      this._newDataView = $("<div>").addClass("newdataview").hide();

      var dl = $("<dl>");
      var dt = null;
      var dd = null;
      var div = null;
      var label = null;

      // 表示範囲の標高値から作成

      dt = $("<dt>");
      this._newAutoRadio = $("<input>").addClass("normalcheck").prop({ "checked": "checked" })
        .attr({ "id": "gsi_editreliefdialog_newmode_radio_auto", "name": "gsi_editreliefdialog_newmode_radi", "type": "radio" });

      label = $("<label>").attr({ "for": "gsi_editreliefdialog_newmode_radio_auto" }).html("表示範囲の標高値から作成")
      dt.append(this._newAutoRadio).append(label);
      dl.append(dt);

      dd = $("<dd>");

      dd.append($("<div>").html("※表示している範囲の最高標高・最低標高から、自動で色分けします"));

      dl.append(dd);

      this._newDataView.append(dl);

      // 分類数を指定して作成
      dt = $("<dt>");
      this._newSplitRadio = $("<input>").addClass("normalcheck")
        .attr({ "id": "gsi_editreliefdialog_newmode_radio_split", "name": "gsi_editreliefdialog_newmode_radi", "type": "radio" });

      label = $("<label>").attr({ "for": "gsi_editreliefdialog_newmode_radio_split" }).html("分類数を指定して作成")
      dt.append(this._newSplitRadio).append(label);
      dl.append(dt);

      dd = $("<dd>");

      var table = $("<table>");
      var tr = null;
      var td = null;
      var color = null;

      // 最低標高
      tr = $("<tr>");
      tr.append($("<td>").html("最低標高"));

      this._lowElevationInput = $("<input>").attr({ "type": "text" }).val("0");

      tr.append($("<td>").append(this._lowElevationInput).append("m"));

      color = "#0000FF";
      tr.append($("<td>").html("の色"));
      var a = $("<a>").attr({ "href": "javascript:void(0);" }).addClass("color");
      a.css({
        "background-color": color
      })
        .data({ "color": color, "colorpicker": a });

      a.ColorPicker({
        clearButton: false,
        onSubmit: function (hsb, hex, rgb, el) {
          $(el).val("#" + hex.toUpperCase());
          $(el).ColorPickerHide();
        },
        onBeforeShow: function () {
          $(this).ColorPickerSetColor($(this).data("color"));
        },
        onShow: function (colpkr) {
          $(colpkr).fadeIn(200);
        },
        onHide: L.bind(function (colpkr) {
          $(colpkr).fadeOut(200);

        }, this),
        onChange: function (hsb, hex, rgb) {
          var el = this.data('colorpicker').el;
          var color = "#" + hex.toUpperCase();
          $(el).css({ "background": color }).data({ "color": color });
        }
      });

      this._lowColorInput = a;
      tr.append($("<td>").append(a));

      table.append(tr);

      // 最高標高
      tr = $("<tr>");
      tr.append($("<td>").html("最高標高"));

      this._hiElevationInput = $("<input>").attr({ "type": "text" }).val(4000);

      tr.append($("<td>").append(this._hiElevationInput).append("m"));

      color = "#FF4400";
      tr.append($("<td>").html("の色"));
      var a = $("<a>").attr({ "href": "javascript:void(0);" }).addClass("color");
      a.css({
        "background-color": color
      })
        .data({ "color": color, "colorpicker": a });

      a.ColorPicker({
        clearButton: false,
        onSubmit: function (hsb, hex, rgb, el) {
          $(el).val("#" + hex.toUpperCase());
          $(el).ColorPickerHide();
        },
        onBeforeShow: function () {
          $(this).ColorPickerSetColor($(this).data("color"));
        },
        onShow: function (colpkr) {
          $(colpkr).fadeIn(200);
        },
        onHide: L.bind(function (colpkr) {
          $(colpkr).fadeOut(200);

        }, this),
        onChange: function (hsb, hex, rgb) {
          var el = this.data('colorpicker').el;
          var color = "#" + hex.toUpperCase();
          $(el).css({ "background": color }).data({ "color": color });
        }
      });
      this._hiColorInput = a;
      tr.append($("<td>").append(a));

      table.append(tr);

      // 分類数
      tr = $("<tr>");
      tr.append($("<td>").html("分類数"));

      this._splitCountInput = $("<input>").css({ "border": "none", "margin": 0 }).attr({ "type": "number", "step": "1" }).val("5");

      tr.append($("<td>").attr({ "colspan": "3" }).append(this._splitCountInput));

      table.append(tr);

      this._splitCountInput.spinner({
        max: 50,
        min: 2,
        step: 1
      });

      dd.append(table);
      dl.append(dd);

      this._newDataView.append(dl);

      // 反映、作成ボタン等
      var optionFrame = $("<div>").addClass("option_frame");

      this._createAfterReflectionInput = $("<input>").addClass("normalcheck")
        .attr({ "id": "gsi_editreliefdialog_create_afterreclection", "type": "checkbox" }).prop({ "checked": "checked" });

      var label = $("<label>").html("読み込み後地図に反映")
        .attr({ "for": "gsi_editreliefdialog_create_afterreclection" });

      optionFrame.append(this._createAfterReflectionInput).append(label);

      this._newDataView.append(optionFrame);

      var buttonFrame = $("<div>").addClass("button_frame");

      var btn = $("<a>").addClass("normalbutton").attr({ "href": "javascript:void(0);" }).html("上記の内容で作成");
      btn.on('click',L.bind(function () {
        if (this._newSplitRadio.is(":checked"))
          this._createNewData();
        else
          this._createAutoNewData();
      }, this));

      buttonFrame.append(btn);

      btn = $("<a>").addClass("normalbutton").attr({ "href": "javascript:void(0);" }).html("キャンセル");
      btn.on('click',L.bind(function () {

        var data = this._mapLayerList.getElevationData();
        if (!data || data["default"])
          this.hide();
        else
          this._newDataView.fadeOut(200);

      }, this));

      buttonFrame.append(btn);

      this._newDataView.append(buttonFrame);

      this.frame.append(this._newDataView);
    }
    this._newAutoRadio.prop({ "checked": "checked" });
    this._newDataView.fadeIn(300);

  },

  // 新規データ生成
  _createAutoNewData: function () {

    // loading
    if (!this._loadingPanel) {
      this._loadingPanel = $("<div>").addClass("loadingpanel");
      this._loadingMessage = $("<div>").addClass("loadingmessage")
        .append($("<img>").attr({ "src": "./image/system/loading003.gif" }))
        .append("標高値を取得しています");
      this.frame.append(this._loadingPanel);
      this.frame.append(this._loadingMessage);
    }

    this._loadingPanel.show();
    this._loadingMessage.show();

    // 必要なタイル
    var tileList = [];

    var map = this._map,
      mapZoom = map.getZoom(),
      scale = map.getZoomScale(mapZoom, mapZoom),
      pixelCenter = map.project(map.getCenter(), mapZoom).floor(),
      halfSize = map.getSize().divideBy(scale * 2);

    var pixelBounds = new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));

    var tileSize = new L.Point(256, 256);
    var tileRange = new L.Bounds(
      pixelBounds.min.unscaleBy(tileSize).floor(),
      pixelBounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));

    //
    var rangeInfo = {
      tileRange: tileRange,
      offset: {
        min: {
          x: pixelBounds.min.x % 256,
          y: pixelBounds.min.y % 256
        },
        max: {
          x: pixelBounds.max.x % 256,
          y: pixelBounds.max.y % 256
        }
      }
    };

    for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
      for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
        var coords = new L.Point(i, j);
        coords.z = mapZoom;
        tileList.push({ coords: coords })
      }
    }

    if (tileList.length <= 0) {
      // エラー
      return;
    }

    var minMax = {};

    for (var i = 0; i < tileList.length; i++) {
      var tile = tileList[i];
      var coords = tile.coords;
      // 読み込み開始
      var loader = new GSI.FreeReliefDEMLoader(this._map, coords.x, coords.y, coords.z, this._demUrlList, {
        overZooming: true,
        useHillshademap: false
      });
      loader.on("load", L.bind(function (loader, tileList, tile, minMax, rangeInfo, e) {
        for (var i = 0; i < tileList.length; i++) {
          if (tileList[i] == tile) {
            tileList.splice(i, 1);
            break;
          }
        }

        var dem = e.target.getData();
        if (dem) {

          var idx = 0;
          for (var y = 0; y < 256; y++) {
            for (var x = 0; x < 256; x++) {
              var h = dem[idx];
              idx++;
              if (tile.coords.x == rangeInfo.tileRange.min.x && x < rangeInfo.offset.min.x) {
                continue;
              }
              if (tile.coords.y == rangeInfo.tileRange.min.y && y < rangeInfo.offset.min.y) {
                continue;
              }

              if (tile.coords.x == rangeInfo.tileRange.max.x && x > rangeInfo.offset.max.x) {
                continue;
              }
              if (tile.coords.y == rangeInfo.tileRange.max.y && y > rangeInfo.offset.max.y) {
                continue;
              }
              if (!h && h != 0) continue;
              if ((!minMax.min && minMax.min != 0) || minMax.min > h) {
                minMax.min = h;
              }

              if ((!minMax.max && minMax.max != 0) || minMax.max < h) {
                minMax.max = h;
              }
            }
          }
        }

        if (tileList.length <= 0) {
          var colors = $.extend(true, [], GSI.ReliefTileLayer.getElevationSampleData().colors);
          var low = Math.floor(minMax.min);
          var hi = Math.floor(minMax.max);
          if (low < 0 && hi > 0){
            low = 0;
          }
          colors[0].h = low;
          for (var i = 1; i < colors.length - 2; i++) {
            var p = (1 / (colors.length - 1)) * (i);
            colors[i].h = Math.round(low + (hi - low) * p);
          }
          colors[colors.length - 2].h = hi;

          var data = {
            gradate: false,
            useHillshademap: false,
            colors: colors
          };

          this._refreshReriefEdit(data);
          if (!this._createAfterReflectionInput || this._createAfterReflectionInput.is(":checked")) {
            this._reflection();
          }

          this._loadingMessage.hide();
          this._loadingPanel.hide();
          if (this._newDataView) this._newDataView.fadeOut(200);
        }

      }, this, loader, tileList, tile, minMax, rangeInfo));
      loader.load();
    }
  },

  // 低い範囲を表示
  _createLowNewData: function() {
    // loading
    if (!this._loadingPanel) {
      this._loadingPanel = $("<div>").addClass("loadingpanel");
      this._loadingMessage = $("<div>").addClass("loadingmessage")
        .append($("<img>").attr({ "src": "./image/system/loading003.gif" }))
        .append("標高値を取得しています");
      this.frame.append(this._loadingPanel);
      this.frame.append(this._loadingMessage);
    }

    if ( this._elevationLoader ) this._elevationLoader.cancel();
    this._elevationLoader = new GSI.ElevationLoader();
    this._elevationLoader.on("load", L.bind(function (e) {
      this._elevationLoader = undefined;
      if (e.h == undefined) {

        this._loadingMessage.hide();
        this._loadingPanel.hide();
        if (this._newDataView) this._newDataView.fadeOut(200);
        return;
      }
      var colors = [{
        h: this._reliefRound( e.h ), color:CONFIG.FREERELIEF_AUTOLOWCOLOR,
      },
      {
        h:null, color:null
      }];

      var data = {
        gradate: false,
        useHillshademap: false,
        colors: colors
      };

      this._refreshReriefEdit(data);
      if (!this._createAfterReflectionInput || this._createAfterReflectionInput.is(":checked")) {
        this._reflection();
      }

      this._loadingMessage.hide();
      this._loadingPanel.hide();
      if (this._newDataView) this._newDataView.fadeOut(200);

    }, this));

    var center = this._map.getCenter();
    this._elevationLoader.load({ lat: center.lat, lng: center.lng, zoom: this._map.getZoom() });

  },

  // 新規データ生成
  _createNewData: function () {

    if (this._newDefaultRadio && this._newDefaultRadio.is(":checked")) {
      var data = GSI.ReliefTileLayer.getElevationSampleData();
      data["default"] = false;
      this._refreshReriefEdit(data);
      if (this._createAfterReflectionInput.is(":checked")) {
        this._reflection();
      }
      this._newDataView.fadeOut(200);
      return;
    }

    if (this._newLoadFileRadio && this._newLoadFileRadio.is(":checked")) {
      this._loadData(this._newFileLoadInput, true);
      return;
    }
    var getInt = function (value) {
      value = value.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
        return String.fromCharCode(s.charCodeAt(0) - 65248);
      });
      value = value.replace(/[ー－‐]/g, "-");

      if (value.match(/^-?[0-9]+$/))
        return parseInt(value);
      else
        return null;
    };

    var getNumber = function (value) {
      value = value.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
        return String.fromCharCode(s.charCodeAt(0) - 65248);
      });
      value = value.replace(/[ー－‐]/g, "-");

      if (value.match(/^[-]?([1-9]\d*|0)(\.\d+)?$/))
        return this._reliefRound(Number(value));
      else
        return null;
    };

    var low = getNumber(this._lowElevationInput.val());
    var hi = getNumber(this._hiElevationInput.val());

    var num = getInt(this._splitCountInput.val());
    num += 1;

    var loColor = this._lowColorInput.data("color");
    var hiColor = this._hiColorInput.data("color");

    var msg = '';
    if (low == null)
      msg += '最低標高を正しく入力して下さい';
    if (hi == null)
      msg += (msg == '' ? '' : '\n') + '最高標高を正しく入力して下さい';
    if (num == null || num < 2)
      msg += (msg == '' ? '' : '\n') + '分類数を正しく入力して下さい';

    if (msg != '') {
      alert(msg);
      return;
    }

    var data = {
      gradate: false,
      useHillshademap: false,
      colors: this._makeColors(num, low, hi, loColor, hiColor)
    };

    this._refreshReriefEdit(data);
    if (this._createAfterReflectionInput.is(":checked")) {
      this._reflection();
    }
    if (this._newDataView) this._newDataView.fadeOut(200);

  },

  _makeColors: function (num, low, hi, loColor, hiColor) {

    var loRgb = GSI.ReliefTileLayer.colorStringToRGBA(loColor);
    var hiRgb = GSI.ReliefTileLayer.colorStringToRGBA(hiColor);

    var colors = [];

    colors.push({
      h: low,
      color: loColor
    });

    for (var i = 0; i < num - 2; i++) {
      var color = {};

      var p = (1 / (num - 1)) * (i + 1);
      color.r = Math.round(loRgb.r + ((hiRgb.r - loRgb.r) * p));
      color.g = Math.round(loRgb.g + ((hiRgb.g - loRgb.g) * p));
      color.b = Math.round(loRgb.b + ((hiRgb.b - loRgb.b) * p));
      if (color.r > 255) color.r = 255;
      if (color.g > 255) color.g = 255;
      if (color.b > 255) color.b = 255;

      colors.push({
        h: Math.round(low + (hi - low) * p),
        color: this._rgbToColor(color)
      });
    }

    colors.push({
      h: hi,
      color: hiColor
    });

    colors.push({
      h: null,
      color: hiColor
    });

    return colors;
  },

  // 読み込み画面表示
  _showLoadView: function () {
    if (!this._loadDataView) {
      this._loadDataView = $("<div>").addClass("loaddataview").hide();

      var fileFrame = $("<div>").addClass("file_frame");

      var messageFrame = $("<div>").addClass("message_frame");

      messageFrame
        .append($("<img>").attr({ "src": "image/system/info.png" }))
        .append($("<div>").html("読み込むファイルを指定して下さい。"));
      this._loadDataView.append(messageFrame);

      this._loadFileInput = $("<input>").attr({ "type": "file" });
      fileFrame.append(this._loadFileInput);

      this._loadDataView.append(fileFrame);

      var optionFrame = $("<div>").addClass("option_frame");

      this._loadFileAfterReflectionInput = $("<input>").addClass("normalcheck")
        .attr({ "id": "gsi_editreliefdialog_file_afterreclection", "type": "checkbox" }).prop({ "checked": "checked" });

      var label = $("<label>").html("読み込み後地図に反映")
        .attr({ "for": "gsi_editreliefdialog_file_afterreclection" });

      optionFrame.append(this._loadFileAfterReflectionInput).append(label);

      this._loadDataView.append(optionFrame);

      var buttonFrame = $("<div>").addClass("button_frame");

      var btn = $("<a>").addClass("normalbutton").attr({ "href": "javascript:void(0);" }).html("ファイルを読み込む");
      btn.on('click',L.bind(function () {
        this._loadData(this._loadFileInput);
      }, this));

      buttonFrame.append(btn);

      btn = $("<a>").addClass("normalbutton").attr({ "href": "javascript:void(0);" }).html("キャンセル");
      btn.on('click',L.bind(function () {
        this._loadDataView.fadeOut(200);
      }, this));

      buttonFrame.append(btn);

      this._loadDataView.append(buttonFrame);

      this.frame.append(this._loadDataView);
    }

    this._loadDataView.fadeIn(300);

  },

  // ファイルから読み込み
  _loadData: function (input, isNew) {
    var file = null;
    var files = input.prop('files');
    if (!files) files = input.attr('files');

    if (files && files.length > 0)
      file = files[0];
    else {
      alert("自分で作る色別標高図形式のファイルを指定して下さい。");
      return;
    }
    var reader = new FileReader();
    reader.onload = L.bind(function () {
      var text = reader.result;
      try {
        var data = JSON.parse(text);
        data.gradate = (data.gradate ? true : false);
        data.useHillshademap = (data.useHillshademap ? true : false);

        if (data.colors.length < 2) {
          alert("自分で作る色別標高図形式のファイルを指定して下さい");
          return;
        }
        for (var i = 0; i < data.colors.length; i++) {
          if (data.colors[i].h)
            data.colors[i].h = this._reliefRound(Number(data.colors[i].h));
        }

        this._refreshReriefEdit(data);

        if (isNew) {
          if (this._createAfterReflectionInput.is(":checked")) {
            this._reflection();
          }
          this._newDataView.fadeOut(200);
        }
        else {
          if (this._loadFileAfterReflectionInput.is(":checked")) {
            this._reflection();
          }
          this._loadDataView.fadeOut(200);
        }
        input.val("");
      }
      catch (e) {
        console.log(e);
        alert("自分で作る色別標高図形式のファイルを指定して下さい。");
      }

    }, this);

    reader.readAsText(file);
  },

  // 保存
  _save: function () {
    var data = this._makeElevationData();

    var text = JSON.stringify(data, null, "  ");

    var blob = new Blob([text], { "type": "text/plain" })

    var fileName = 'relief' + GSI.Utils.getTimeStampString();

    GSI.Utils.saveFile("text/plain", fileName + ".txt", blob);

  },

  //凡例保存
  _saveHanrei: function () {
    var canvas = GSI.EditReliefDialog.makeHanreiImage(this._makeElevationData());

    function makeImage(v) {
      var o = null;
      var base64 = v.split(',');
      if (base64.length > 1) {
        var data = window.atob(base64[1]);
        var data_n = data.length;
        if (data_n > 0) {
          var data_buff = new ArrayBuffer(data_n);
          var data_blob = new Uint8Array(data_buff);

          var i = 0;

          for (i = 0; i < data_n; i++) {
            data_blob[i] = data.charCodeAt(i);
          }
          o = new Blob([data_blob], { type: 'image/png' });
        }
      }
      return o;
    }

    var fileName = "hanrei" + GSI.Utils.getTimeStampString();

    GSI.Utils.saveFile("image/png", fileName + ".png", makeImage(canvas.toDataURL()));

  },

  // 入力値からデータ
  _makeElevationData: function (desc) {
    var data = {
      gradate: this._gradateInput.is(":checked"),
      useHillshademap: this._useHillshademapInput.is(":checked"),
      desc: (desc != undefined ? desc : this._orderDescCheck.is(":checked")),
      colors: []
    };

    var inputs = this._scrollFrame.find("input.elevation");
    var colorSelects = this._scrollFrame.find("a.color");

    if (data.desc) {

      for (var i = 0; i < colorSelects.length; i++) {
        var input = null;

        if (i <= inputs.length && i > 0)
          input = $(inputs[i - 1]);

        var colorSelect = $(colorSelects[i]);

        data.colors.unshift({
          h: (input ? Number(input.val()) : null),
          //h: (input ? parseInt(input.val()) : null),
          color: colorSelect.data("color")
        });

      }
    } else {
      for (var i = 0; i < colorSelects.length; i++) {
        var input = null;

        if (i < inputs.length)
          input = $(inputs[i]);

        var colorSelect = $(colorSelects[i]);

        data.colors.push({
          h: (input ? Number(input.val()) : null),
          color: colorSelect.data("color")
        });
      }
    }

    return data;

  },

  // 地図に反映
  _reflection: function (data) {
    if (!data) data = this._makeElevationData();

    this._mapLayerList.setElevationData(data);

  },

  // 内部形式から#000000へ
  _rgbToColor: function (rgb) {
    return "#"
      + ("00" + rgb.r.toString(16).toUpperCase()).substr(-2)
      + ("00" + rgb.g.toString(16).toUpperCase()).substr(-2)
      + ("00" + rgb.b.toString(16).toUpperCase()).substr(-2);
  },

  // グラデーションバー再設定
  _refreshGradationBar: function () {
    var tr = this._scrollFrame.find("table.colors").find("tr");
    var td = $(tr[0]).find("td.gradationbar");

    td.prop({ "rowspan": tr.length });

    if (!this._gradateInput.is(":checked")) {
      td.hide();
      return;
    }

    td.show();
    var w = td.find("div").innerWidth();
    var h = td.find("div").innerHeight();
    var canvas = td.find("canvas")[0];

    canvas.width = w;
    canvas.height = h;
    var ctx = canvas.getContext('2d');

    ctx.fillStyle = "rgb(255, 255, 255)";
    ctx.clearRect(0, 0, w, h);
    ctx.beginPath();

    var lineHeight = Math.round(h / tr.length);

    var prev = null;

    for (var idx = 0; idx < tr.length; idx++) {
      var color = $(tr[idx]).find("a.color").data("color");
      if (color) color = GSI.ReliefTileLayer.colorStringToRGBA(color);

      var startY = (idx * lineHeight);

      for (var y = startY; y < startY + lineHeight; y++) {
        var yP = (y - startY) / lineHeight;

        ctx.globalAlpha = 1;
        if (color) {
          var c = {
            r: color.r,
            g: color.g,
            b: color.b,
            a: 255
          };
          ctx.globalAlpha = 1;
          if (prev) {
            c.r = prev.r + Math.round((color.r - prev.r) * yP);
            c.g = prev.g + Math.round((color.g - prev.g) * yP);
            c.b = prev.b + Math.round((color.b - prev.b) * yP);
          } else if (idx > 0) {
            if (y <= startY + Math.round(lineHeight / 2)) continue;
            if (this.options.transparentGradate) {
              c.a = Math.round(255 * yP);
              ctx.globalAlpha = c.a / 255;
            }
            else {
              ctx.globalAlpha = 1;
            }
          }

          if (c.r > 255) c.r = 255;
          if (c.g > 255) c.g = 255;
          if (c.b > 255) c.b = 255;
          if (c.a > 255) c.a = 255;

          ctx.fillStyle = "rgb(" + c.r + "," + c.g + "," + c.b + ")";

        } else {

          if (prev) {
            var c = {
              r: prev.r,
              g: prev.g,
              b: prev.b,
              a: 255
            };

            if (this.options.transparentGradate) {
              c.a = prev.a + Math.round((- prev.a) * yP);
            }
            else {

              if (y >= startY + Math.round(lineHeight / 2)) c.a = 0;;

            }

            if (c.r > 255) c.r = 255;
            if (c.g > 255) c.g = 255;
            if (c.b > 255) c.b = 255;
            if (c.a > 255) c.a = 255;

            ctx.fillStyle = "rgb(" + c.r + "," + c.g + "," + c.b + ")";
            ctx.globalAlpha = c.a / 255;
          }
          else {
            ctx.fillStyle = "rgb(255,255,255)";
            ctx.globalAlpha = 0;
          }
        }

        ctx.fillRect(0, y - Math.round(lineHeight / 2), w, 1);
      }

      prev = color;
    }

    var y = tr.length * lineHeight - Math.round(lineHeight / 2) - 1;
    ctx.fillRect(0, y, w, lineHeight);

  },

  // 編集画面再設定
  _refreshReriefEdit: function (data, skipRefreshGradationBar) {
    this._scrollFrame.empty();
    $("body").children("div.colorpicker").remove();
    if (this._newDataView)
      this._newDataView.remove();
    this._newDataView = null;

    var frame = $("<div>");

    if (!data) {
      data = GSI.ReliefTileLayer.getElevationSampleData();
    }

    if (data.gradate)
      this._gradateInput.prop({ "checked": "checked" });
    else
      this._gradateInput.removeProp("checked");

    if (data.useHillshademap)
      this._useHillshademapInput.prop({ "checked": "checked" });
    else
      this._useHillshademapInput.removeProp("checked");

    if (data.desc)
      this._orderDescCheck.prop({ "checked": "checked" });
    else
      this._orderDescCheck.removeProp("checked");

    var table = $("<table>").addClass("colors");

    var colors = data.colors;

    if (data.desc) {
      for (var i = colors.length - 1; i >= 0; i--) {
        var next = (i < colors.length - 1 ? colors[i + 1] : null);
        var current = colors[i];
        var prev = (i > 0 ? colors[i - 1] : null);

        var tr = this._createLine(prev, current, next, true);
        table.append(tr);

      }
    } else {
      for (var i = 0; i < colors.length; i++) {
        var prev = (i > 0 ? colors[i - 1] : null);
        var current = colors[i];
        var next = (i < colors.length - 1 ? colors[i + 1] : null);

        var tr = this._createLine(prev, current, next);
        table.append(tr);

      }
    }

    //グラデーション
    var td = $("<td>")
      .addClass("gradationbar")
      .css({ "position": "relative", "width": "16px" }).attr({ "rowspan": table.find("tr").length });
    var div = $("<div>").css({
      "position": "absolute",
      "background": 'url("./image/system/transparent_bg.png")',
      "border": "1px solid #aaa", "left": "1px", "top": "1px", "right": "4px", "bottom": "1px"
    });
    var canvas = document.createElement('canvas');
    div.append(canvas);
    td.append(div);
    $(table.find("tr")[0]).prepend(td);

    var removeButtons = frame.find("a.remove_btn");
    if (removeButtons.length <= 2){
      if (removeButtons.length > 0){
        removeButtons.hide();
      }
      else{
        //createLowDataを通った場合はframeが空でtableにしかデータが無い
        removeButtons = table.find("a.remove_btn");
        if (removeButtons.length <= 2){
          removeButtons.hide();
        }
      }
    }
    else
      removeButtons.show();
    frame.append(table);
    this._scrollFrame.append(frame);
    this._scrollFrame.scrollTop(0);
    if (!skipRefreshGradationBar) this._refreshGradationBar();

  },

  //
  _createLine: function (prev, current, next, desc) {
    var tr = $("<tr>").addClass("line");
    var td = null;

    if (!prev) {
      td = $("<td>").html("&nbsp;").addClass("from");
      tr.append(td);
    }
    else {
      td = $("<td>").html(prev.h).addClass("from");
      tr.append(td);
    }

    td = $("<td>").html("-");
    tr.append(td);

    if (next) {
      var input = $("<input>")
      .addClass("elevation").attr({ "type": "number", "step":"0.5" })
      .css({"ime-mode": "disabled"})
      .val(current.h);

      td = $("<td>").append(input);
      tr.append(td);
      input
        .on('focus',L.bind(function (elem) {
          elem.trigger('select');
        }, this, input))
        .on('blur', L.bind(function (tr) {

          this._checkInputElevation(tr);
        }, this, tr))
        .on("keydown", L.bind(function(e){
          var keyCode = e.keyCode;

          var str = ( e.key ? e.key : String.fromCharCode(keyCode) );

          if ( e.ctrlKey || e.metaKey) return;

          if( ( !str.match(/[0-9.-]/) )
            && (keyCode != 8 && keyCode != 46 && keyCode != 189 && keyCode != 190 )
            && (keyCode != 37 && keyCode != 38 && keyCode != 39 && keyCode != 40 )){
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        }))
        .on("beforeinput", L.bind(function(e){
          var str = e.originalEvent.data;
          if ( !str ) return;
          if(!str.match(/[0-9.-]/) ){
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        }))
        .on('click',function () {
          $(this).trigger('select');
          return false;
        });

    }
    else {
      td = $("<td>").html("&nbsp;").addClass("to");
      tr.append(td);
    }

    td = $("<td>");

    var color = current.color;
    if (color) {
      if (color.r || color.r == 0) color = this._rgbToColor(color);
    }
    else {
      color = null;
    }

    var a = $("<a>").attr({ "href": "javascript:void(0);" }).addClass("color");
    a.css({
      "background": (color ? color : 'url("./image/system/transparent_bg.png")')
    })
      .data({ "color": color, "colorpicker": a });

    var this$ = this;
    a.ColorPicker({
      onSubmit: function (hsb, hex, rgb, el) {
        $(el).val("#" + hex.toUpperCase());
        $(el).ColorPickerHide();
        this$._refreshGradationBar();
      },
      onBeforeShow: function () {
        var color = $(this).data("color");
        if (color)
          $(this).ColorPickerSetColor(color);
      },
      onShow: function (colpkr) {
        $(colpkr).fadeIn(200);
      },
      onHide: L.bind(function (colpkr) {
        $(colpkr).fadeOut(200);
        this$._refreshGradationBar();
      }, this),
      onChange: function (hsb, hex, rgb) {
        var el = this.data('colorpicker').el;
        var color = "#" + hex.toUpperCase();
        $(el).css({ "background": color }).data({ "color": color });
      },
      onClear: function () {
        var el = this.data('colorpicker').el;
        $(el).css({ "background": 'url("./image/system/transparent_bg.png")' }).data({ "color": null });
        this$._refreshGradationBar();
      }
    });
    td.append(a);
    tr.append(td);

    if (next) {
      td = $("<td>");
      a = $("<a>").attr({ "title": "この行を削除", "href": "javascript:void(0);" }).addClass("btn").addClass("remove_btn");
      a.on('click',L.bind(function (prev, current, next, tr) {
        this._removeLine(tr);

      }, this, prev, current, next, tr));
      td.append(a);
      tr.append(td);

      //
      td = $("<td>");
      a = $("<a>").attr({ "title": "ここに追加", "href": "javascript:void(0);" }).addClass("btn")
        .addClass((desc ? "append_prev_btn" : "append_next_btn")).html("+");
      a.on('click',L.bind(function (prev, current, next, tr) {
        this._appendLine(tr);
      }, this, prev, current, next, tr));

      td.append(a);
      tr.append(td);
    }
    else {
      td = $("<td>").html("&nbsp;");
      tr.append(td);
      td = $("<td>").html("&nbsp;");
      tr.append(td);
    }
    return tr;
  },

  // 入力チェック
  _checkInputElevation: function (tr) {

    var desc = this._orderDescCheck.is(":checked");
    var h = tr.find("input.elevation").val();
    h = h.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 65248);
    });
    h = h.replace(/[ー－‐]/g, "-");

    var x = Number(h);
    if (h.match(/^[-]?([1-9]\d*|0)(\.\d+)?$/))
      h = this._reliefRound(x);
    else
      h = null;

    var nextH = (desc ? tr.prev() : tr.next()).find("input.elevation").val();
    if (h != null && nextH) {
      nextH = nextH.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
        return String.fromCharCode(s.charCodeAt(0) - 65248);
      });
      nextH = nextH.replace(/[ー－‐]/g, "-");

      if (nextH.match(/^[-]?([1-9]\d*|0)(\.\d+)?$/))
        nextH = this._reliefRound(Number(nextH));
      else
        nextH = null;

      if (nextH != null && h >= nextH) {
        h = nextH - 1;
        tr.find("input.elevation").val(h)
      } else if (x != h) {
        tr.find("input.elevation").val(h)
      }
    }

    var prevH = (desc ? tr.next() : tr.prev()).find("input.elevation").val();
    if (h != null && prevH) {
      prevH = prevH.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
        return String.fromCharCode(s.charCodeAt(0) - 65248);
      });
      prevH = prevH.replace(/[ー－‐]/g, "-");

      if (prevH.match(/^[-]?([1-9]\d*|0)(\.\d+)?$/))
        prevH = this._reliefRound(Number(prevH));
      else
        prevH = null;

      if (prevH != null && h <= prevH) {
        h = prevH + 1;
        tr.find("input.elevation").val(h)
      }
      else if (x != h) {
        tr.find("input.elevation").val(h)
      }
    }

    if (h != null) {
      var nextTr = (desc ? tr.prev() : tr.next());
      if (nextTr.length > 0) {
        nextTr.find(".from").html(h);
      }
    }
  },

  _removeLine: function (tr) {
    var inputs = this._scrollFrame.find("input.elevation");
    if (inputs.length <= 2) return;

    tr.remove();

    var removeButtons = this._scrollFrame.find("a.remove_btn");
    if (removeButtons.length <= 2)
      removeButtons.hide();
    else
      removeButtons.show();

    this._refreshElevationFrom();
    this._refreshGradationBar();
  },

  _trToData: function (tr) {
    var h = tr.find("input.elevation").val();
    if (h) {
      h = h.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function (s) {
        return String.fromCharCode(s.charCodeAt(0) - 65248);
      });
      h = h.replace(/[ー－‐]/g, "-");

      if (h.match(/^[-]?([1-9]\d*|0)(\.\d+)?$/))
        h = this._reliefRound(Number(h));
      else
        h = null;
    }
    else
      h = null;

    color = tr.find("a.color").data("color");

    return {
      h: h,
      color: color
    };
  },

  _appendLine: function (tr) {

    var appendNext = !this._orderDescCheck.is(":checked");

    var current = this._trToData(tr);
    var prev = null;
    //(tr.prev("tr.line").length > 0 ? this._trToData(tr.prev("tr.line")) : null);
    var next = null;
    //(tr.next("tr.line").length ? this._trToData(tr.next("tr.line")) : null);
    if (appendNext) {
      prev = (tr.prev("tr.line").length > 0 ? this._trToData(tr.prev("tr.line")) : null);
      next = (tr.next("tr.line").length ? this._trToData(tr.next("tr.line")) : null);
    } else {
      next = (tr.prev("tr.line").length > 0 ? this._trToData(tr.prev("tr.line")) : null);
      prev = (tr.next("tr.line").length ? this._trToData(tr.next("tr.line")) : null);
    }
    var h = 0;

    if (next) h = (current.h || current.h == 0 ? current.h + 1 : null);
    else h = (current.h || current.h == 0 ? current.h - 1 : null);

    if (next && next.h && (h || h == 0)) {
      h = parseInt(current.h + ((next.h - current.h) / 2));
    }
    else if (prev && prev.h && (h || h == 0)) {
      h = parseInt(current.h + ((current.h - prev.h) / 2));
    }
    var color = GSI.ReliefTileLayer.colorStringToRGBA(current.color);

    if (next) {
      var nextColor = GSI.ReliefTileLayer.colorStringToRGBA(next.color);
      var p = 0.5;
      color.r = Math.round(color.r + ((nextColor.r - color.r) * p));
      color.g = Math.round(color.g + ((nextColor.g - color.g) * p));
      color.b = Math.round(color.b + ((nextColor.b - color.b) * p));
      if (color.r > 255) color.r = 255;
      if (color.g > 255) color.g = 255;
      if (color.b > 255) color.b = 255;

    }

    var newTr = null;

    if (appendNext) {

      newTr = this._createLine(current, {
        h: h,
        color: this._rgbToColor(color)
      }, next);
      newTr.insertAfter(tr);
    } else {

      newTr = this._createLine(current, {
        h: h,
        color: this._rgbToColor(color)
      }, next, true);
      newTr.insertBefore(tr);
    }

    newTr.find("input[type=text]").trigger('focus');

    this._refreshElevationFrom();
    this._refreshGradationBar();

    var removeButtons = this._scrollFrame.find("a.remove_btn");
    if (removeButtons.length <= 2)
      removeButtons.hide();
    else
      removeButtons.show();

  },

  _refreshElevationFrom: function () {

    var orderDesc = this._orderDescCheck.is(":checked");

    var trArr = this._scrollFrame.find("tr.line");
    var prev = null;

    for (var i = 0; i < trArr.length; i++) {
      var tr = $(trArr[(orderDesc ? trArr.length - i - 1 : i)]);
      var current = this._trToData(tr);

      if (!prev) tr.find("td.from").html("");
      else tr.find("td.from").html(prev.h);

      prev = current;
    }
  },

  _reliefRound: function (val) {
    var nsign = val < 0 ? -1 : 1;

    var iv = Math.floor(val);
    if (val < 0) {
      iv = Math.ceil(val);
    }

    var sv = Math.round((Math.abs(val) - Math.abs(iv)) * 10) / 10;
    var res = 0;
    if (sv < 0.3) {
      res = iv;
    }
    else if (sv < 0.8) {
      res = iv + (0.5 * nsign);
    } else {
      res = iv + (1 * nsign);
    }

    return res;
  }
});

// 凡例画像生成（他からも利用する）
GSI.EditReliefDialog.HanreiImageInfo = {
  cellPadding: 2,
  padding: 4,
  colorWidth: 40,
  colorHeight: 20,
  margin: 8,
  colorRadius: 3,
  gradateWidth: 14,
  font: '12px "Lucida Grande","Hiragino Kaku Gothic ProN", "ヒラギノ角ゴ ProN W3", Meiryo, メイリオ, sans-serif'
};

GSI.EditReliefDialog.HanreiImageInfo.lineHeight =
  GSI.EditReliefDialog.HanreiImageInfo.colorHeight +
  (GSI.EditReliefDialog.HanreiImageInfo.cellPadding * 2);

GSI.EditReliefDialog._initializeHanreiImage = function (data) {
  var canvas = document.createElement("canvas");
  var ctx = canvas.getContext("2d");
  ctx.font = GSI.EditReliefDialog.HanreiImageInfo.font;
  var info = GSI.EditReliefDialog.HanreiImageInfo;

  var rows = [];
  var textWidth = {};

  var size = ctx.measureText("-");
  textWidth["-"] = size.width;
  size = ctx.measureText("　～");
  textWidth["　～"] = size.width;
  size = ctx.measureText(" 以下");
  textWidth[" 以下"] = size.width;
  var maxTextWidth = 0;

  for (var i = 0; i < data.colors.length; i++) {
    var c = data.colors[i];
    var text = "";
    var textSize = 0;

    if (c.h != undefined) {
      text = (c.h + "").replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1,') + "m";
      size = ctx.measureText(text);
      textSize = size.width;
      if (maxTextWidth < textSize) maxTextWidth = textSize;
      textWidth[text] = textSize;
    }

    var color = c.color;
    if (color != undefined && (typeof color != "string")) {
      color = "rgba(" + color.r + "," + color.g + "," + color.b + "," + (color.a / 255) + ")";
    }
    rows.push({
      "h": c.h,
      "text": text,
      "color": color,
      "width": textSize
    });
  }

  maxTextWidth += (textWidth[" 以下"] > textWidth["　～"] ? textWidth[" 以下"] : textWidth["　～"]);

  var canvasWidth = (maxTextWidth + (info.cellPadding * 2)) * 2;
  canvasWidth += (textWidth["-"] + (info.cellPadding * 2));
  canvasWidth += (info.padding * 2);
  canvasWidth += info.margin;

  var colorLeft = info.padding + info.cellPadding;
  var gradateLeft = 0;
  var textLeft = 0;

  if (data.gradate) {
    canvasWidth += info.gradateWidth + (info.padding * 2);
    gradateLeft = info.padding + info.cellPadding;
    textLeft = gradateLeft + info.gradateWidth + info.cellPadding + info.margin + info.cellPadding;
  } else {
    canvasWidth += (info.colorWidth + (info.cellPadding * 2));
    gradateLeft = info.padding + (info.cellPadding * 2) + info.colorWidth + info.cellPadding;
    textLeft = info.padding + (info.cellPadding * 2) + info.colorWidth + info.margin + info.cellPadding;
  }

  var canvasHeight = (info.colorHeight + (info.cellPadding * 2)) * rows.length;
  canvasHeight += (info.padding * 2);

  canvasWidth = Math.ceil(canvasWidth);
  canvasHeight = Math.ceil(canvasHeight);

  canvas = document.createElement("canvas");
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  ctx = canvas.getContext("2d");
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0, 0, canvasWidth, canvasHeight);
  ctx.font = GSI.EditReliefDialog.HanreiImageInfo.font;

  return {
    width: canvasWidth,
    height: canvasHeight,
    rows: rows,
    textWidth: textWidth,
    maxTextWidth: maxTextWidth,
    canvas: canvas,
    ctx: ctx,
    colorLeft: colorLeft,
    gradateLeft: gradateLeft,
    textLeft: textLeft
  };
}

GSI.EditReliefDialog.makeHanreiImage = function (data) {
  if (!data) return undefined;

  var info = GSI.EditReliefDialog.HanreiImageInfo;
  var drawInfo = GSI.EditReliefDialog._initializeHanreiImage(data);

  var canvas = drawInfo.canvas;
  var ctx = drawInfo.ctx;

  function drawColor(gradate, drawInfo, lineNo, ctx, row) {
    var info = GSI.EditReliefDialog.HanreiImageInfo;
    var left = drawInfo.colorLeft; //info.padding + info.cellPadding;
    var top = info.padding + (info.lineHeight * lineNo) + info.cellPadding;

    var right = left + info.colorWidth;
    var bottom = top + info.colorHeight;
    var yOffset = 0;
    ctx.fillStyle = "#bbb";
    for (var x = left; x < right; x += 4) {
      if (yOffset == 0) yOffset = 4;
      else yOffset = 0;

      for (var y = top + yOffset; y < bottom; y += 8) {
        var w = 4;
        var h = 4;
        if (x + w > right) w = right - x;
        if (y + h > bottom) h = bottom - y;
        ctx.fillRect(x, y, w, h);

      }
    }

    ctx.beginPath();
    ctx.moveTo(left + info.colorRadius, top);

    ctx.lineTo(left + info.colorWidth - info.colorRadius, top);
    ctx.arc(left + info.colorWidth - info.colorRadius, top + info.colorRadius, info.colorRadius, Math.PI * 1.5, 0, false);

    ctx.lineTo(left + info.colorWidth, top + info.colorHeight - info.colorRadius);
    ctx.arc(left + info.colorWidth - info.colorRadius, top + info.colorHeight - info.colorRadius, info.colorRadius, 0, Math.PI * 0.5, false);

    ctx.lineTo(left + info.colorRadius, top + info.colorHeight);
    ctx.arc(left + info.colorRadius, top + info.colorHeight - info.colorRadius, info.colorRadius, Math.PI * 0.5, Math.PI, false);

    ctx.lineTo(left, top + info.colorRadius);
    ctx.arc(left + info.colorRadius, top + info.colorRadius, info.colorRadius, Math.PI, Math.PI * 1.5, false);
    ctx.closePath();

    ctx.fillStyle = row.color;
    ctx.strokeStyle = "#999";
    if (row.color) ctx.fill();
    ctx.stroke();

  }

  function drawText(gradate, drawInfo, lineNo, ctx, prev, row) {
    var info = GSI.EditReliefDialog.HanreiImageInfo;
    var left = drawInfo.textLeft;
    var right = drawInfo.width - (info.padding + info.cellPadding);
    var top = info.padding + (info.lineHeight * lineNo) + info.cellPadding;
    var middle = top + (info.colorHeight / 2);

    ctx.textBaseline = "middle";
    ctx.fillStyle = "#000000";

    // 下限
    if (prev) {
      ctx.textAlign = "right";
      ctx.fillText(prev.text + "　～", left + drawInfo.maxTextWidth, middle);
    }

    //　上限
    if (row.text != "") {
      ctx.textAlign = "right";
      ctx.fillText(row.text + "以下", right, middle);
    }

    // ～
    ctx.textAlign = "left";

  }

  function drawGradateBar(drawInfo, data, ctx) {
    var info = GSI.EditReliefDialog.HanreiImageInfo;
    var top = info.padding; // + ( info.lineHeight * lineNo ) + info.cellPadding;
    var left = drawInfo.gradateLeft; //info.padding + (info.cellPadding * 2) + info.colorWidth + info.cellPadding;

    var lineHeight = info.lineHeight;

    var bottom = top + (lineHeight * data.colors.length);

    ctx.fillStyle = "#fff";
    ctx.fillRect(left, top, info.gradateWidth, (lineHeight / 2) + info.cellPadding);
    ctx.fillRect(left, bottom + (lineHeight / 2) - info.cellPadding, info.gradateWidth, (lineHeight / 2));

    top += (lineHeight / 2) + info.cellPadding;
    bottom += (lineHeight / 2) - info.cellPadding;

    ctx.fillStyle = "#bbb";
    var yOffset = 0;
    for (var x = left; x < left + info.gradateWidth; x += 4) {
      if (yOffset == 0) yOffset = 4;
      else yOffset = 0;

      for (var y = top + yOffset; y < bottom; y += 8) {
        var w = 4;
        var h = 4;
        if (x + w > left + info.gradateWidth) w = left + info.gradateWidth - x;
        if (y + h > bottom) h = bottom - y;
        ctx.fillRect(x, y, w, h);

      }
    }

    top = info.padding - lineHeight / 2;

    var prev = null;
    for (var idx = 0; idx < data.colors.length; idx++) {

      var lineNo = (data.desc ? data.colors.length - idx - 1 : idx);

      var row = data.colors[lineNo];
      var color = row.color;
      if (color) color = GSI.ReliefTileLayer.colorStringToRGBA(color);

      var startY = top + (idx * lineHeight);// - Math.round( lineHeight/ 2 )-1;

      for (var y = startY; y < startY + lineHeight; y++) {
        var yP = (y - startY) / lineHeight;

        if (color) {
          var c = {
            r: color.r,
            g: color.g,
            b: color.b,
            a: 255
          };
          ctx.globalAlpha = 1;
          if (prev) {
            c.r = prev.r + Math.round((color.r - prev.r) * yP);
            c.g = prev.g + Math.round((color.g - prev.g) * yP);
            c.b = prev.b + Math.round((color.b - prev.b) * yP);
          } else if (idx > 0) {
            if (y < startY + (lineHeight / 2)) continue;
          }

          if (c.r > 255) c.r = 255;
          if (c.g > 255) c.g = 255;
          if (c.b > 255) c.b = 255;
          if (c.a > 255) c.a = 255;

          ctx.fillStyle = "rgb(" + c.r + "," + c.g + "," + c.b + ")";

        } else {
          if (prev) {
            var c = {
              r: prev.r,
              g: prev.g,
              b: prev.b,
              a: 255
            };

            if (y >= startY + (lineHeight / 2)) c.a = 0;

            if (c.r > 255) c.r = 255;
            if (c.g > 255) c.g = 255;
            if (c.b > 255) c.b = 255;
            if (c.a > 255) c.a = 255;

            ctx.fillStyle = "rgb(" + c.r + "," + c.g + "," + c.b + ")";
            ctx.globalAlpha = c.a / 255;
          }
          else {
            ctx.fillStyle = "rgb(255,255,255)";
            ctx.globalAlpha = 0;
          }

        }
        ctx.fillRect(left, y, info.gradateWidth, 1);

        if (idx == data.colors.length - 1 && y == startY + lineHeight - 1) {

          ctx.fillRect(left, y + 1, info.gradateWidth, lineHeight + 1);
        }
      }

      prev = color;
    }

    var bottom = top + (lineHeight * data.colors.length);

    ctx.fillStyle = "#fff";
    ctx.fillRect(left, top, info.gradateWidth, (lineHeight / 2) + info.cellPadding);
    ctx.fillRect(left, bottom + (lineHeight / 2) - info.cellPadding, info.gradateWidth, (lineHeight / 2));

    top += (lineHeight / 2) + info.cellPadding;
    bottom += (lineHeight / 2) - info.cellPadding;

    ctx.beginPath();
    ctx.moveTo(left, top);
    ctx.lineTo(left + info.gradateWidth, top);
    ctx.lineTo(left + info.gradateWidth, bottom);
    ctx.lineTo(left, bottom);
    ctx.lineTo(left, top);
    ctx.closePath();

    ctx.strokeStyle = "#999";
    ctx.stroke();

  }

  var prev = null;
  var rows = drawInfo.rows;
  if (data.gradate)
    drawGradateBar(drawInfo, data, ctx);

  for (var i = 0; i < rows.length; i++) {
    var row = rows[i];
    // 昇順、降順による描画位置
    var lineNo = (data.desc ? rows.length - i - 1 : i);
    if (!data.gradate) drawColor(data.gradate, drawInfo, lineNo, ctx, row);
    drawText(data.gradate, drawInfo, lineNo, ctx, prev, row);
    prev = row;
  }

  return canvas;

};

/************************************************************************
 GSI.Utils.parseCSV
************************************************************************/
GSI.Utils.parseCSV = function (str, delimiter) {
  var rows = [], row = [], i, len, v, s = "", q, c;
  for (i = 0, len = str.length; i < len; i++) {
    v = str.charAt(i);
    if (q) {
      if (v === '"') {
        if (str.charAt(i + 1) === '"') {
          i++;
          s += v;
        } else {
          q = false;
        }
      } else {
        s += v;
      }
    } else {
      if (v === '"' && !s) {
        q = true;
      } else if (v === delimiter) {
        row.push(s); s = "";
      } else if (v === '\r' || v === '\n') {
        row.push(s); s = "";
        rows.push(row); row = [];
        if (v === '\r' && str.charAt(i + 1) === '\n') { i++; }
      } else {
        s += v;
      }
    }
  }
  if (s || v === ',' || !s && v === '"') { row.push(s); }
  if (row.length) { rows.push(row); }
  if (!s && (v === '\r' || v === '\n')) { rows.push([]); }
  return rows;
};

/************************************************************************
 L.Evented
 - GSI.CSVLoadDialog
************************************************************************/
GSI.CSVLoadDialog = GSI.Dialog.extend({
  options: {
    title: "CSVファイル読込",
    width: "200px",
    minimize: true
  },

  initialize: function (gsimaps, dialogManager, map, options) {
    this._gsimaps = gsimaps;
    this._map = map;

    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);

  },

  _onResize: function () {
    GSI.Dialog.prototype._onResize.call(this);

    this.container.css({ height: "" });
    this.container.css({ height: "auto" });
  },

  show: function (txt, fileName) {

    if (!txt && this.container && this._dialogManager.isMinimized(this)) {
      this._dialogManager.removeMinimizeList(this);
      this.normalize();
      return;
    }

    if (this._loader) {
      // 読み込み中
      return;
    }

    if (!txt) return;

    var hasList = (this._fileQueue && this._fileQueue.length);

    if (!hasList) {
      this._fileQueue = [];
    }
    if (Array.isArray(txt)) {
      var list = txt;
      for (var i = 0; i < list.length; i++) {
        this._fileQueue.push({
          "text": list[i].data,
          "fileName": list[i].fileName
        });
      }
    } else {
      this._fileQueue.push({
        "text": txt,
        "fileName": fileName
      });
    }

    this._showNext();

  },

  _showNext: function () {
    if (!this._fileQueue) {
      this.hide();
    }
    var item = this._fileQueue.shift();

    this._fileName = item.fileName;
    this.title.html(this.options.title + "&nbsp;" + this._fileName);

    this._text = item.text;
    if (!this._parse()) {
      return;
    }

    this._hideProgress();
    GSI.Dialog.prototype.show.call(this);

    this._initializeView();
  },

  hide: function () {
    this._fileQueue = undefined;
    if (this._loader) {
      this._loader.cancel();
      delete this._loader;
      this._loader = null;
    }
    GSI.Dialog.prototype.hide.call(this);
  },

  createHeader: function () {
    this.title = $('<div>').html(this.options.title);

    return $('<div>').append(this.title);
  },

  _createIconFrame: function () {
    var iconFrame = $("<div>").addClass("icon_frame");
    var table = $('<table>');
    var tbody = $('<tbody>');

    this._pointIconImage = $('<img>');

    var tr = $('<tr>');
    tr.append($('<td>').css({ 'white-space': 'nowrap' }).html('アイコン:'));
    tr.append($('<td>').append(this._pointIconImage));
    tr.append($('<td>').css({ 'white-space': 'nowrap' }).html('&nbsp;&nbsp;拡大率:'));

    this._pointIconSizeSelect = $('<select>');
    this._pointIconSizeSelect.append($('<option>').html("0.5").val("0.5"));
    this._pointIconSizeSelect.append($('<option>').html("1.0").val("1.0"));
    this._pointIconSizeSelect.append($('<option>').html("1.5").val("1.5"));
    this._pointIconSizeSelect.append($('<option>').html("2.0").val("2.0"));

    this._pointIconSizeSelect[0].selectedIndex = 1;
    this._pointIconSizeSelect.on('change', L.bind(this._onPointIconSizeChange, this));

    tr.append($('<td>').append(this._pointIconSizeSelect));

    tr.append($('<td>').css({ 'white-space': 'nowrap' }).html('<a href = "https://geocode.csis.u-tokyo.ac.jp/home/simple-geocoding/" target=_blank style="padding-left:2em;">協力：東大CSIS</a>'));

    tbody.append(tr);
    table.append(tbody);
    iconFrame.append(table);

    var iconList = [];

    for (var i = 0; i < CONFIG.SAKUZU.SYMBOL.FILES.length; i++) {
      iconList.push({
        url: CONFIG.SAKUZU.SYMBOL.URL + CONFIG.SAKUZU.SYMBOL.FILES[i],
        size: CONFIG.SAKUZU.SYMBOL.ICONSIZE,
        anchor: CONFIG.SAKUZU.SYMBOL.ICONANCHOR
      });
    }

    this._pointIconSelector = new GSI.IconSelector(this._pointIconImage, iconList);
    this._pointIconSelector.on('select', L.bind(this._onPointIconSelect, this));

    this._pointIconImage.attr({ src: iconList[0].url });
    this._pointIconSelector.setSelectedIcon(iconList[0].url);
    this._pointIconSizeSelect.val("1.0");

    return iconFrame;
  },
  _onPointIconSizeChange: function () {
  },
  _onPointIconSelect: function (event) {
  },

  createContent: function () {

    this.frame = $('<div>').addClass("gsi_csvdialog_content");
    this.frame.append(this._tableMassageFrame);

    // アイコン選択
    var iconFrame = this._createIconFrame();
    this.frame.append(iconFrame);

    // メッセージ
    this._messageFrame = $("<div>").addClass("message_frame");
    this.frame.append(this._messageFrame);

    // ヘッダ扱い

    //
    this._tableMassageFrame = $("<div>").addClass("tablemessage_frame");
    this.frame.append(this._tableMassageFrame);

    // テーブル
    var tableFrame = $("<div>").addClass("table_frame");
    var table = $("<table>");
    this._tableHeader = $("<thead>");
    this._tableBody = $("<tbody>");
    table.append(this._tableHeader).append(this._tableBody);
    tableFrame.append(table);
    this.frame.append(tableFrame);

    // 開始ボタン
    var buttonFrame = $("<div>").addClass("button_frame")
    this._okButton = $("<a>").addClass("normalbutton").attr({ "href": "javascript:void(0);" }).html("上記の内容で読込開始");

    this._okButton.on("click", L.bind(function () {
      this._initMessage();
      if (this._okButton.hasClass("disabled")) return;

      this._loader = new GSI.CSVLatLngLoader(this._csv);
      this._loader.on("finish", L.bind(this._onFinish, this));
      this._loader.on("progress", L.bind(this._onProgress, this));
      this._showProgress();
      this._loader.load();
    }, this));
    buttonFrame.append(this._okButton);

    this.frame.append(buttonFrame);
    return this.frame;
  },

  _onFinish: function (e) {
    this.title.html(this.options.title);
    this.fire("titlechange");
    this._hideProgress();
    delete this._loader;
    this._loader = null;

    var icon = this._pointIconSelector.selectedIcon;
    var iconScale = parseFloat(this._pointIconSizeSelect.val());

    try {
      var geojson = {
        "type": "FeatureCollection",
        "features": []
      };

      for (var i = 0; i < e.lines.length; i++) {
        var line = e.lines[i];
        if (!line.latlng || line.latlng.lat == undefined || line.latlng.lng == undefined) continue;
        var point = {
          "type": "Feature",
          "geometry": {
            "type": "Point",
            "coordinates": [line.latlng.lng, line.latlng.lat]
          },
          "properties": {}
        };

        point.properties["_markerType"] = "Icon";
        point.properties["_iconUrl"] = icon.url;
        point.properties["_iconSize"] = [Math.floor(icon.size[0] * iconScale), Math.floor(icon.size[1] * iconScale)];
        point.properties["_iconAnchor"] = [Math.floor(icon.anchor[0] * iconScale), Math.floor(icon.anchor[1] * iconScale)];

        var fieldNo = 1;
        for (var j = 0; j < line.line.length; j++) {
          var value = line.line[j];
          if (value == "") continue;

          if (e.headers && e.headers.length > j)
            fieldName = e.headers[j];
          else
            fieldName = "";
          if (fieldName == "") {
            fieldName = "属性" + fieldNo;
            fieldNo++;
          }
          point.properties[fieldName] = value;
        }

        geojson.features.push(point);
      }

      this._gsimaps._sakuzuList.addCSVGeoJSON(geojson, this._fileName);

      if (this._fileQueue && this._fileQueue.length > 0) {
        this._showNext();
      } else {
        this.hide();
      }
    } catch (e) {
      alert("CSVファイルを読み込めません");
      console.log(e);
    }
  },

  getTitle: function () {
    return this.title.text();
  },

  _onProgress: function (e) {
    var p = Math.round((e.value / e.max) * 100);

    this.title.html(p + "% " + this.options.title);
    this._progress.css({ "width": p + "%" });
    this.fire("titlechange");

  },

  _showProgress: function () {

    if (!this._progressFrame) {
      this._progressFrame = $("<div>").addClass("progress_frame");
      this._progressBg = $("<div>").addClass("progress_bg");
      this._progress = $("<div>").addClass("progress");

      this._progressBg.append(this._progress);

      this._progressFrame.append(this._progressBg);

      this.frame.append(this._progressFrame);
    }

    this._progress.css({ "width": "0%" });

    this._progressFrame.fadeIn(300);

  },

  _hideProgress: function () {
    if (!this._progressFrame) return;
    this._progressFrame.fadeOut(300);
  },

  _parse: function () {
    this._csv = {
      data: $.csv.toArrays(this._text),
      hasHeader: false,
      headers: {
        title: -1,
        lat: -1,
        lng: -1,
        addr: -1
      }
    };
    this._tableType = "addr";
    if (!this._csv.data || this._csv.data.length <= 0) return false;
    this._initHeader();

    return true;
  },

  _initHeader: function () {
    var line = this._csv.data[0];

    for (var i = 0; i < line.length; i++) {
      var title = line[i].trim();

      switch (title) {
        case "緯度":
        case "lat":
        case "latitude":
          this._csv.hasHeader = true;
          if (this._csv.headers.lat < 0) this._csv.headers.lat = i;
          break;

        case "経度":
        case "lng":
        case "lon":
        case "longitude":
          this._csv.hasHeader = true;
          if (this._csv.headers.lng < 0) this._csv.headers.lng = i;
          break;
        case "施設名":
        case "施設名称":
        case "名称":
        case "名前":
        case "title":
          this._csv.hasHeader = true;
          if (this._csv.headers.title < 0) this._csv.headers.title = i;
          break;

        case "住所":
        case "所在地":
        case "addr":
        case "address":
          this._csv.hasHeader = true;
          if (this._csv.headers.addr < 0) this._csv.headers.addr = i;
          break;
      }
    }

    if (!this._csv.hasHeader && this._csv.data.length > 0) {

      var latIndex = -1;
      var lngIndex = -1;

      for (var row = 0; row < this._csv.data.length && row < 2; row++) {

        var line = this._csv.data[row];
        for (var i = 0; i < line.length; i++) {
          var value = line[i];
          var regex = new RegExp(/^[-+]?[0-9]+(\.[0-9]+)?$/);
          if (regex.test(value)) {
            value = parseFloat(value);
            if (value >= 10 && value < 100) {
              latIndex = i;
            } else if (value >= 100 && value < 1000) {
              lngIndex = i;
            }
          }

        }
      }

      if (latIndex >= 0 && lngIndex >= 0) {
        this._csv.headers.lat = latIndex;
        this._csv.headers.lng = lngIndex;
        this._tableType = "latlngaddr";
      } else {
        var hitColArr = [];
        for (var col = 0; col < this._csv.data[0].length; col++) {
          var value = line[col];
          var hit = { num: 0 };
          hitColArr.push(hit);
          if (value == undefined) {
            continue;
          }
          for (var row = 0; row < this._csv.data.length && row < 10; row++) {

            var value = this._csv.data[row][col];
            for (var key in GSI.MUNI_ARRAY) {
              var parts = GSI.MUNI_ARRAY[key].split(",")
              if (parts.length < 4) continue;

              parts = parts[3].split(/[\s|　]/);

              if (value.indexOf(parts[0]) >= 0) {
                hit.num++;
                break;
              }
            }
          }
        }

        var maxHit = -1;

        for (var i = 0; i < hitColArr.length; i++) {
          if (maxHit < hitColArr[i].num) {
            maxHit = hitColArr[i].num;
            this._csv.headers.addr = i;
          }
        }
      }

    } else {

      if (this._csv.headers.lat >= 0 && this._csv.headers.lng >= 0) {
        //緯度経度あり（緯度経度選択）
        this._tableType = "latlng";
      } else if (this._csv.headers.addr >= 0) {
        // 住所有り（住所選択）
      } else {
        // なし（住所選択）
      }
    }

    return false;
  },

  _initMessage: function () {
    this._messageFrame.empty();

    var latSelect = this._tableHeader.find("select[name=lat]");
    var lngSelect = this._tableHeader.find("select[name=lng]");
    var addrSelect = this._tableHeader.find("select[name=addr]");

    if (addrSelect.length > 0 && latSelect.length > 0) {
      this._messageFrame.html("緯度及び経度の列を選択してください。<br>緯度及び経度の列がない場合は住所の列を選択してください。");
    } else if (latSelect.length > 0) {
      this._messageFrame.html("緯度及び経度の列を選択してください。");
    } else if (addrSelect.length > 0) {
      this._messageFrame.html("住所の列を選択してください。");
    }

    var err = false;
    var isSetHeader = false;
    for (var key in this._csv.headers) {
      if (this._csv.headers[key] >= 0) {
        isSetHeader = true;
        break;
      }
    }

    if (!isSetHeader) {
      err = true;
    } else {

      if (this._csv.headers["lat"] >= 0) {
        if (this._csv.headers["lng"] < 0) {
          err = true;
        }
      } else if (this._csv.headers["lng"] >= 0) {
        if (this._csv.headers["lat"] < 0) {
          err = true;
        }
      }
    }
    this.container.css({ height: "" });
    setTimeout(L.bind(function () {
      this.container.css({ height: "auto" });
    }, this), 10);

    if (err) {
      this._okButton.addClass("disabled");
    } else {
      this._okButton.removeClass("disabled");

    }
  },

  _initializeTableHader: function () {

    this._tableHeader.empty();

    function createSelect($this, name, idx) {
      var line = $this._csv.data[0];
      var select = $("<select>").attr({ "name": name });
      select.append($('<option>').html("なし").val(""));
      for (var i = 0; i < line.length; i++) {
        var title = (i + 1) + "列目";
        if ($this._csv.hasHeader) {

          title = line[i];

        }
        select.append($('<option>').html(title).val(i));
      }

      if (idx >= 0)
        select.val(idx);
      else
        select.val("");

      select.on("change", L.bind($this._onHeaderSelectChange, $this));
      return select;
    }

    var tr = null;
    var th = null;
    switch (this._tableType) {
      case "latlng":
        tr = $("<tr>");
        th = $("<th>").html("緯度");
        tr.append(th);
        th = $("<th>").html("経度");
        tr.append(th);
        this._tableHeader.append(tr);

        tr = $("<tr>");
        th = $("<th>").append(createSelect(this, "lat", this._csv.headers.lat));
        tr.append(th);
        th = $("<th>").append(createSelect(this, "lng", this._csv.headers.lng));
        tr.append(th);
        this._tableHeader.append(tr);
        break;

      case "latlngaddr":
        tr = $("<tr>");
        th = $("<th>").html("住所");
        tr.append(th);
        th = $("<th>").html("緯度");
        tr.append(th);
        th = $("<th>").html("経度");
        tr.append(th);
        this._tableHeader.append(tr);

        tr = $("<tr>");
        th = $("<th>").append(createSelect(this, "addr", this._csv.headers.addr));
        tr.append(th);
        th = $("<th>").append(createSelect(this, "lat", this._csv.headers.lat));
        tr.append(th);
        th = $("<th>").append(createSelect(this, "lng", this._csv.headers.lng));
        tr.append(th);
        this._tableHeader.append(tr);
        break;

      default:
        tr = $("<tr>");
        th = $("<th>").html("住所");
        tr.append(th);
        this._tableHeader.append(tr);

        tr = $("<tr>");

        th = $("<th>").append(createSelect(this, "addr", this._csv.headers.addr));
        tr.append(th);
        this._tableHeader.append(tr);

        break;

    }

    this._onHeaderSelectChange();
  },

  _onHeaderSelectChange: function (e) {
    var latSelect = this._tableHeader.find("select[name=lat]");
    var lngSelect = this._tableHeader.find("select[name=lng]");
    var addrSelect = this._tableHeader.find("select[name=addr]");
    var startIndex = (this._csv.hasHeader ? 1 : 0);

    var displayLength = this._csv.data.length - startIndex;
    if (displayLength > 5) displayLength = 5;

    this._tableMassageFrame.html("全" + (this._csv.data.length - startIndex) + "件中" + displayLength + "件表示");
    this._tableBody.empty();

    if (latSelect.length <= 0) this._csv.headers.lat = -1;
    if (lngSelect.length <= 0) this._csv.headers.lng = -1;
    if (addrSelect.length <= 0) this._csv.headers.addr = -1;

    var titleCol = -1;
    var addrCol = -1;
    if (addrSelect.length > 0) {
      addrCol = addrSelect.val();
      if (addrCol == "") addrCol = -1;
      else addrCol = parseInt(addrCol);
      this._csv.headers.addr = addrCol;
    }

    var latCol = -1;
    var lngCol = -1;
    if (latSelect.length > 0) {
      latCol = latSelect.val();
      lngCol = lngSelect.val();
      if (latCol == "") latCol = -1;
      else latCol = parseInt(latCol);
      if (lngCol == "") lngCol = -1;
      else lngCol = parseInt(lngCol);
      this._csv.headers.lat = latCol;
      this._csv.headers.lng = lngCol;
    }

    var td = null;
    for (var i = startIndex; i < this._csv.data.length && i < 5 + startIndex; i++) {
      tr = $("<tr>");
      line = this._csv.data[i];

      if (addrSelect.length > 0) {

        // addr
        td = $("<td>").html("&nbsp;");
        if (addrCol >= 0) {
          td.html(line[addrCol]);
        }
        tr.append(td);
      }

      if (latSelect.length > 0) {
        // lat
        td = $("<td>").html("&nbsp;");
        if (latCol >= 0) {
          td.html(line[latCol]);
        }
        tr.append(td);

        // lng
        td = $("<td>").html("&nbsp;");
        if (lngCol >= 0) {
          td.html(line[lngCol]);
        }
        tr.append(td);
      }
      this._tableBody.append(tr);
    }

    this._initMessage();

    this.container.css({ height: "" });
    setTimeout(L.bind(function () {
      this.container.css({ height: "auto" });
    }, this), 10);

  },

  _initializeView: function () {
    this._initializeTableHader();
    return;
  }
});

GSI.CSVLatLngLoader = L.Evented.extend({

  options: {
    maxload: 40
  },

  initialize: function (csv, options) {
    this._csv = csv;

    options = L.setOptions(this, options);
  },

  cancel: function () {
    this._cancel = true;
    this._queue = [];
    for (var i = 0; i < this._loadingList.length; i++) {
      this._loadingList[i].cancel();
    }
    this._loadingList = [];
  },

  load: function () {
    this._queue = [];
    this._loadingList = [];
    var startIdx = (this._csv.hasHeader ? 1 : 0);
    this._result = {
      lines: []
    };
    if (this._csv.hasHeader && this._csv.data.length > 0) {
      this._result.headers = [];
      for (var i = 0; i < this._csv.data[0].length; i++) {
        this._result.headers.push(this._csv.data[0][i]);
      }
    } else if (this._csv.data.length > 0) {
      this._result.headers = [];
      for (var i = 0; i < this._csv.data[0].length; i++) {
        this._result.headers.push("");
      }

      if (this._csv.headers.addr >= 0) {
        this._result.headers[this._csv.headers.addr] = "所在地";
      }
      if (this._csv.headers.lat >= 0) {
        this._result.headers[this._csv.headers.lat] = "緯度";
      }
      if (this._csv.headers.lng >= 0) {
        this._result.headers[this._csv.headers.lng] = "経度";
      }
    }

    if (this._csv.headers.title >= 0) {
      this._result.headers[this._csv.headers.title] = "name";
    }

    for (var i = startIdx; i < this._csv.data.length; i++) {
      var loader = new GSI.CSVLineLatLngLoader(
        i - startIdx, this._csv.data[i], {
        headers: this._csv.headers
      });
      loader.on("load", L.bind(this._onLoad, this, loader));
      this._queue.push(loader);

      this._result.lines.push({
        line: this._csv.data[i]
      });
    }
    this._next();

  },

  _onLoad: function (loader, e) {
    if (this._cancel) return;
    if (e.lat != undefined && e.lng != undefined) {
      this._result.lines[e.idx].latlng = {
        lat: e.lat,
        lng: e.lng
      };
    }
    var idx = this._loadingList.indexOf(loader);
    if (idx >= 0) {
      this._loadingList.splice(idx, 1);
    }
    this._next();
  },

  _next: function () {
    if (this._cancel) return;
    while (this._queue.length > 0 && this._loadingList.length < this.options.maxload) {
      var loader = this._queue.shift();
      this._loadingList.push(loader);
      loader.load();
    }
    this.fire("progress", {
      max: this._result.lines.length,
      value: this._result.lines.length - (this._queue.length + this._loadingList.length)
    });
    if (this._queue.length <= 0 && this._loadingList.length <= 0) {
      this.fire("finish", this._result);
    }
  }
});

GSI.CSVLineLatLngLoader = L.Evented.extend({

  options: {},

  initialize: function (idx, line, options) {
    this._line = line;
    this._idx = idx;
    options = L.setOptions(this, options);
  },

  _fireLoad: function (lat, lng) {
    this.fire("load", { idx: this._idx, lat: lat, lng: lng });
  },

  cancel: function () {

    this._queue = [];
    if (this._request) {
      this._request.abort();
      this._request = null;
    }
  },

  load: function () {

    try {
      if (this.options.headers.lat >= 0 && this.options.headers.lng >= 0) {
        var lat = this._line[this.options.headers.lat];
        var lng = this._line[this.options.headers.lng];
        if (lat.match(/^[+,-]?([1-9]\d*|0)(\.\d+)?$/)
          && lng.match(/^[+,-]?([1-9]\d*|0)(\.\d+)?$/)) {
          lat = parseFloat(lat);
          lng = parseFloat(lng);
          setTimeout(L.bind(function (lat, lng) {
            this._fireLoad(lat, lng);
          }, this, lat, lng), 0);
          return
        }
      }
    } catch (e) { console.log(e); }

    // load
    //https://msearch.gsi.go.jp/address-search/AddressSearch?q=%E4%B8%89%E5%8E%9F%E5%B8%82

    this._queue = [];
    if (this.options.headers.addr >= 0 || this.options.headers.title >= 0) {
      if (this.options.headers.addr >= 0)
        this._queue.push(this._line[this.options.headers.addr]);
      if (this.options.headers.title >= 0)
        this._queue.push(this._line[this.options.headers.title]);
      this._next();
    } else {
      setTimeout(L.bind(function () {
        this._fireLoad();
      }, this), 0);
    }
  },

  _next: function () {
    if (this._queue.length <= 0) {

      this._fireLoad();
      return;
    }

    var q = this._queue.shift();
    if (q == undefined) this._next();
    q = q.trim();

    if (q == "") {
      setTimeout(L.bind(function () {
        this._next();
      }, this), 0);
      return;
    }

    this._request = $.ajax({
      type: "GET",
      dataType: "JSON",
      "url": "https://msearch.gsi.go.jp/address-search/AddressSearch",
      "data": { "q": q }
    })
      .done(L.bind(this._onLoad, this, q))
      .fail(L.bind(this._onLoadError, this));

  },

  _onLoad: function (q, e) {
    var item = (e && e.length > 0 ? e[0] : null);
    if (item && item.geometry) {
      this._fireLoad(item.geometry.coordinates[1], item.geometry.coordinates[0]);
    } else {
      // ヒットしない
      console.log(q);
      this._next();
    }
  },

  _onLoadError: function (e) {
    this._next();

  }
});

/************************************************************************
 GSI.LocalFileLoader
************************************************************************/
GSI.LocalFileLoader = L.Evented.extend({

  initialize: function (files) {
    this._files = files;
  },

  load: function () {
    this._queue = [];
    for (var i = 0; i < this._files.length; i++) {
      var reader = new FileReader();
      var fileName = decodeURIComponent(this._files[i].name);
      var queItem = { "no": i, "reader": reader, "file": this._files[i], "fileName": fileName };
      reader.addEventListener("load", L.bind(this._onLoad, this, queItem));
      reader.addEventListener("error", L.bind(this._onError, this, queItem));

      this._queue.push(queItem);

    }

    if (this._queue.length <= 0) {
      return;
    }

    for (var i = 0; i < this._queue.length; i++) {
      this._queue[i].reader.readAsArrayBuffer(this._queue[i].file);
    }
  },

  _fireLoad: function () {

    for (var i = 0; i < this._queue.length; i++) {
      if (!this._queue[i].loaded) {
        return;
      }
    }

    this.fire("load", { "list": this._queue })
  },

  _onError: function (queItem) {
    queItem.error = true;
    queItem.loaded = true;
    this._fireLoad();
  },

  _onLoad: function (queItem) {

    if (queItem.reader.readyState != FileReader.DONE) return;

    queItem.error = false;
    queItem.loaded = true;

    this._fireLoad();
  }
});

/************************************************************************
 GSI.Utils.saveFile
************************************************************************/
GSI.Utils.saveFile = function (contentType, fileName, blob, func) {

  if (false) {
    if (window.navigator.msSaveBlob) {
      window.navigator.msSaveOrOpenBlob(blob, fileName);
    } else {
      var url = window.URL || window.webkitURL;

      if (GSI.SaveFileWindow._dummyButton) GSI.SaveFileWindow._dummyButton.remove();

      GSI.SaveFileWindow._dummyButton = $("<a>").html("　");

      GSI.SaveFileWindow._dummyButton.attr({
        "download": fileName,
        "href": url.createObjectURL(blob)
      });

      $("body").append(GSI.SaveFileWindow._dummyButton);

      setTimeout(function () {
        GSI.SaveFileWindow._dummyButton[0].trigger('click');
        setTimeout(function () {
          if (GSI.SaveFileWindow._dummyButton) GSI.SaveFileWindow._dummyButton.remove();
          GSI.SaveFileWindow._dummyButton = null;
        }, 0);
      }, 0);

    }
  } else {
    if (GSI.SaveFileWindow._instance) GSI.SaveFileWindow._instance.destroy();

    GSI.SaveFileWindow._instance = new GSI.SaveFileWindow();
    GSI.SaveFileWindow._instance.show(contentType, fileName, blob);
    if (func) GSI.SaveFileWindow._instance.on("after", func);
  }
};

/************************************************************************
 GSI.SaveFileWindow
************************************************************************/
GSI.SaveFileWindow = L.Evented.extend({

  initialize: function () {

  },

  destroy: function () {
    this._clear();
    if (this._container) {
      this._container.remove();
      this._container = null;
    }
  },

  _getExt: function (fileName) {
    var parts = fileName.split(".");
    if (parts.length == 1) return "";
    else return "." + parts[parts.length - 1];
  },

  show: function (contentType, fileName, blob) {
    this._contentType = contentType;
    this._fileName = fileName;
    this._ext = this._getExt(fileName);
    this._blob = blob;

    this._create();

    this._fileNameInput.trigger('focus');
    this._container.fadeIn(200, L.bind(function () {
      this._fileNameInput.trigger('focus');
    }, this));

  },

  hide: function () {
    this._clear();
    this._container.fadeOut(200);

  },

  _clear: function () {

  },

  _onFileNameFocus: function () {
    setTimeout(L.bind(function () {
      this._fileNameInput.trigger('select');
    }, this), 1);
  },

  _onFileNameBlur: function () {
    var fileName = (this._fileNameInput.val()) ? this._fileNameInput.val().trim() : '';
    if (fileName == "") {
      this._fileNameInput.val(this._fileName);
    } else {
      var ext = this._getExt(fileName);
      if (fileName.charAt(0) == ".") {
        fileName = this._fileName;
      } else {
        if (ext == ".") {
          fileName += this._ext.replace(".", "");

        } else if (ext == "") {
          fileName += this._ext;
        }
      }
      this._fileName = fileName;
      if (!window.navigator.msSaveBlob) {

        this._okButton.attr({ "download": this._fileName });
      }
    }
  },

  _onFileNameKeyPress: function (evt) {
    if (evt.keyCode == 13) {
      this._onFileNameBlur();
      this._okButton[0].trigger('click');
    }
  },

  _create: function () {
    this._container = $("<div>").addClass("gsi-topmostwindow-container").hide();

    this._frame = $("<div>").addClass("frame");

    this._message = $("<div>").addClass("message").html("ファイル名を入力し「保存」ボタンをクリックして下さい。");
    this._frame.append(this._message);

    this._fileNameInput = $("<input>").attr({ "type": "text" }).addClass("filename").val(this._fileName);

    this._fileNameInput
      .on("keypress", L.bind(this._onFileNameKeyPress, this))
      .on("focus", L.bind(this._onFileNameFocus, this))
      .on("blur", L.bind(this._onFileNameBlur, this));

    this._fileNameInputFrame = $("<div>").addClass("filename-frame");
    this._fileNameInputFrame.append(this._fileNameInput);
    this._frame.append(this._fileNameInputFrame);

    this._buttonFrame = $("<div>").addClass("button-frame");

    this._okButton = $("<a>").addClass("normalbutton").html("保存");
    this._cancelButton = $("<a>").addClass("normalbutton").html("キャンセル");

    if (window.navigator.msSaveBlob) {

      this._okButton.on("click", L.bind(function () {
        window.navigator.msSaveOrOpenBlob(this._blob, this._fileName);
      }, this));
    } else {
      var url = window.URL || window.webkitURL;
      this._okButton.attr({
        "download": this._fileName,
        "href": url.createObjectURL(this._blob)
      });

      this._okButton.on("click", L.bind(function () {
        this.fire("after", { "button": "ok" });
        this.hide();
        return true;
      }, this));
    }
    this._cancelButton.on("click", L.bind(function () {
      this.fire("after", { "button": "cancel" });
      this.hide();
    }, this));

    this._buttonFrame.append(this._okButton).append(this._cancelButton);

    this._frame.append(this._buttonFrame);

    this._container.append(this._frame);

    $("body").append(this._container);
  }
});

/*******************************************************

 GSI.CrossSectionView
    断面図管理クラス

*******************************************************/
GSI.CrossSectionView = L.Evented.extend({

  options: {
    maxPoints: 300,
    steps: 100,
    lineColor: '#0000ff'
  },

  // 初期化
  initialize: function (map, options) {
    this._map = map;
    L.setOptions(this, options);

  },

  // 経路指定開始
  start: function () {
    L.drawLocal.draw.handlers.polyline.tooltip.start = '始点を選択';
    L.drawLocal.draw.handlers.polyline.tooltip.cont = '次の位置を選択(最終点を2回クリックして終了)';
    L.drawLocal.draw.handlers.polyline.tooltip.end = '次の位置を選択(最終点を2回クリックして終了)';

    this._editingPathList = [];

    // デフォルト
    var shapeOptions = {
      color: this.options.lineColor,
      weight: 4,
      stroke: true,
      fill: false,
      clickable: true,
      opacity: 1
    };

    var path = new GSI.CrossSectionView.Draw.Polyline(this._map, {
      shapeOptions: shapeOptions,
      showLength: true
    });
    path.enable();

    this._routePath = path;

    this._pathCreatedEventHandler = L.bind(this._onPathCreated, this);

    this._map.on('draw:created', this._pathCreatedEventHandler);
    path.on('change', L.bind(function () {
    }, this));
  },

  setUseDEMTileList: function (list) {
    this._useDEMTileList = list;
  },

  getUseDEMTileList: function () {
    return this._useDEMTileList;
  },

  // 経路指定後
  _onPathCreated: function (e) {
    this._points = $.extend(true, [], e.layer._latlngs);
    this._routePath = null;
    this._refresh();
    if (this.options.autoGraph)
      this.createCossSectionData(this._useDEMTileList);

  },

  // クリア
  restart: function () {
    this.destroy();
    this.start();
  },

  setData: function (data) {
    this._points = $.extend(true, [], data);
    this._refresh();
    if (this.options.autoGraph)
      this.createCossSectionData(this._useDEMTileList);
  },

  // 破棄処理
  destroy: function () {
    if (this._graph)
      this._graph.destroy();
    this._graph = null;

    this.clear();
    if (this._mousePointMarker) this._mousePointMarker.remove();
    this._mousePointMarker = null;
    if (this._distancePopup) this._distancePopup.remove();
    this._distancePopup = null;

    this._map.off('draw:created', this._pathCreatedEventHandler);
    this._pathCreatedEventHandler = null;
  },

  // 断面図イメージエレメント取得
  getGraphElement: function () {
    if (!this._graph) return null;
    return this._graph.getGraphElement();

  },

  // 断面図生成
  createGraph: function () {

    if (this._graph)
      this._graph.destroy();
    this._graph = null;

    this._graph = new GSI.CrossSectionView.Graph();
    this._graph.on("mousepointchange", L.bind(function (e) {
      this.setMousePoint(e.point);
    }, this));

    var minScale = 0;
    var maxScale = 10;

    this._graph.create(this._data);
    this.fire("graphcreated", {
      graph: this._graph,
      minScale: minScale,
      maxScale: maxScale
    });

  },

  // 断面図上マウス位置から地図上にアイコン表示
  setMousePoint: function (p) {
    this._mousePoint = p;

    if (this._mousePoint) {

      if (!this._mousePointMarker) {

        this._mousePointMarker = L.marker(this._mousePoint.latlng, {
          icon: L.divIcon({ className: 'gsi_crosssectionview_mousepointmarker' })
        }).addTo(this._map);
      }
      else
        this._mousePointMarker.setLatLng(this._mousePoint.latlng);
    }
    else {
      if (this._mousePointMarker)
        this._mousePointMarker.remove();
      this._mousePointMarker = null;
    }
  },
  // 再設定
  _refresh: function () {
    if (this._routePath) {
      if (!this._routePath._poly || !this._routePath._poly._latlngs) return;
      var points = this._routePath._poly._latlngs;

      if (points.length > 0 && !this._startMarker) {
        this._startMarker = L.marker(points[0], { zIndexOffset: 6000 }).addTo(this._map);
      }

      return;
    }

    if (this._points.length > 0) {
      if (!this._startMarker) {
        this._startMarker = L.marker(this._points[0], {
          icon: L.icon({
            iconUrl: 'image/danmen/icon_start.png',
            iconSize: [50, 50],
            iconAnchor: [25, 50]
          })
        }).addTo(this._map);
      }
      else
        this._startMarker.setLatLng(this._points[0], { clickable: false });
    }

    var shapeOptions = {
      color: 'black',
      weight: 4,
      stroke: true,
      fill: false,
      clickable: true,
      opacity: 1
    };

    if (this._points.length >= 2) {

      if (!this._endtMarker)
        this._endtMarker = L.marker(this._points[this._points.length - 1], {
          icon: L.icon({
            iconUrl: 'image/danmen/icon_end.png',
            iconSize: [50, 50],
            iconAnchor: [25, 50]
          }),
          clickable: false
        }).addTo(this._map);
      else
        this._endtMarker.setLatLng(this._points[this._points.length - 1], { clickable: false });

      if (!this._line) {
        this._line = L.polyline(GSI.Utils.Geodesic.createLine([this._points], GSI.Utils.Geodesic.LINESTEPS), shapeOptions).addTo(this._map);
        this._line.on("mousemove", L.bind(this._onLineMouseMove, this));
        this._line.on("mouseout", L.bind(this._onLineMouseOut, this));
      }
      else {
        this._line.setLatLngs(GSI.Utils.Geodesic.createLine([this._points], GSI.Utils.Geodesic.LINESTEPS));
      }
    }
  },

  //経路上マウス移動時
  _onLineMouseMove: function (e) {

    if (!this._data) return;

    var distance = 0;
    var latlngs = e.target._latlngs;
    var p = {
      x: e.latlng.lng,
      y: e.latlng.lat
    };

    var minDistance = null;
    var targetI = -1;
    var targetJ = -1;

    for (var i = 0; i < latlngs.length; i++) {
      for (var j = 0; j < latlngs[i].length - 1; j++) {
        var center = {
          x: (latlngs[i][j].lng + latlngs[i][j + 1].lng) / 2,
          y: (latlngs[i][j].lat + latlngs[i][j + 1].lat) / 2
        };

        var d = Math.sqrt(Math.pow(center.x - p.x, 2) + Math.pow(center.y - p.y, 2));

        if (minDistance == null || minDistance > d) {
          targetI = i;
          targetJ = j;
          minDistance = d;
        }
      }
    }

    for (var i = 0; i < latlngs.length; i++) {
      for (var j = 0; j < latlngs[i].length - 1; j++) {

        if (i == targetI && j == targetJ) {
          var inverse = GSI.Utils.Geodesic.vincentyInverse(latlngs[i][j], e.latlng);

          if (inverse)
            distance += inverse.distance;

          break;
        }
        else {
          var inverse = GSI.Utils.Geodesic.vincentyInverse(latlngs[i][j], latlngs[i][j + 1]);
          if (inverse)
            distance += inverse.distance;
        }

      }

      if (i == targetI) break;
    }

    var popupPoint = this._map.latLngToLayerPoint(e.latlng);

    if (!this._distancePopup) this._distancePopup = L.popup();
    this._distancePopup
      .setLatLng(this._map.layerPointToLatLng(L.point(popupPoint.x, popupPoint.y - 20)))
      .setContent("<div>始点からの距離:" + L.GeometryUtil.readableDistance(distance, true) + "</div>")
      .openOn(this._map);

    if (this._graph)
      this._graph.setDistanceLine(distance);

    this.fire("linemousemove", {
      distance: distance
    });
  },

  // 経路上からマウスが外れた時
  _onLineMouseOut: function (e) {

    if (this._distancePopup) this._distancePopup.remove();
    if (this._graph)
      this._graph.removeDistanceLine();

  },

  // クリア
  clear: function () {
    if (this._routePath) {
      this._routePath.disable();
      this._routePath = null;
    }
    if (this._startMarker) {
      this._startMarker.remove();
      delete this._startMarker;
      this._startMarker = null;
    }

    if (this._endtMarker) {
      this._endtMarker.remove();
      delete this._endtMarker;
      this._endtMarker = null;
    }

    if (this._line) {

      this._line.remove();
      delete this._line._endtMarker;
      this._line = null;
    }

    this._points = null;
  },

  // 経路のGeoJSONデータ生成
  getGeoJSONText: function () {
    var result = {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": {},
          "geometry": {
            "type": "LineString",
            "coordinates": []
          }
        }

      ]
    };

    var points = this._pointsData;
    if (!L.LineUtil.isFlat(points))
      points = points[0];

    for (var i = 0; i < points.length; i++) {
      result.features[0].geometry.coordinates.push([
        points[i].latlng.lng, points[i].latlng.lat, points[i].h
      ])
    }

    return JSON.stringify(result, null, "  ");
  },

  // 経路のKMLータ生成
  getKMLText: function () {
    var result = '<?xml version="1.0" encoding="UTF-8"?>\n' +
      '<kml xmlns="http://www.opengis.net/kml/2.2">\n' +
      '<Document>\n' +
      '<Placemark>\n' +
      '<LineString>\n' +
      '<coordinates>';
    var points = this._pointsData;
    if (!L.LineUtil.isFlat(points))
      points = points[0];
    var coordsText = '';
    for (var i = 0; i < points.length; i++) {
      if (coordsText != '') coordsText += ' ';
      coordsText += points[i].latlng.lng + ',' + points[i].latlng.lat + ',' + points[i].h;
    }

    result += coordsText;

    result += '</coordinates>\n' +
      '</LineString>\n' +
      '</Placemark>\n' +
      '</Document>\n' +
      '</kml>\n';

    return result;
  },

  _getBoundsZoom: function (bounds, size, inside) {

    bounds = L.latLngBounds(bounds);

    var map = this._map;

    var zoom = map.getZoom() || 0,
      min = 9,
      max = 15,
      nw = bounds.getNorthWest(),
      se = bounds.getSouthEast(),
      boundsSize = L.bounds(map.project(se, zoom), map.project(nw, zoom)).getSize(),
      snap = 1,
      scalex = size.x / boundsSize.x,
      scaley = size.y / boundsSize.y,
      scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

    zoom = map.getScaleZoom(scale, zoom);

    if (snap) {
      zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
      zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
    }

    return Math.max(min, Math.min(max, zoom));
  },

  // 経路を分割し必要な標高タイルを取得
  createCossSectionData: function (useDEMTileList) {
    if (!this._points || this._points.length <= 1 || !this._line) return;

    this.fire("graphcreatestart", {});

    var wrap = false;
    bounds = this._line.getBounds();

    var options = {
      padding: L.point([32, 32]),
      maxZoom: 15
    };
    var zoom = this._getBoundsZoom(bounds, L.point(2560, 2560));// target.zoom;

    var totalDistance = 0;

    for (var i = 0; i < this._points.length - 1; i++) {
      var distance = GSI.Utils.DistanceCalculator.calc(this._points[i], this._points[i + 1]);

      totalDistance += distance;
    }

    var interval = totalDistance / (this.options.maxPoints - 1);
    var interval2 = 0;

    var data = {
      totalDistance: totalDistance,
      points: []
    };
    data.points.push({ latlng: this._points[0], distance: 0 });
    for (var i = 0; i < this._points.length - 1; i++) {

      var pointA = L.latLng(this._points[i]);
      var pointB = L.latLng(this._points[i + 1]);
      if (pointA.equals(pointB)) {
        continue;
      }
      var inverse = GSI.Utils.Geodesic.vincentyInverse(pointA, pointB);
      var prev = pointA;

      var distance = interval - interval2;

      if (distance > inverse.distance) {
        interval2 += inverse.distance;
        continue;
      }

      interval2 = 0;

      for (var s = 1; true;) {
        var direct = GSI.Utils.Geodesic.vincentyDirect(pointA, inverse.initialBearing,
          distance, wrap
        );

        var gp = L.latLng(direct.lat, direct.lng);

        var dd = GSI.Utils.Geodesic.vincentyInverse(prev, gp);
        if (Math.abs(gp.lng - prev.lng) > 180) {
          var sec = GSI.Utils.Geodesic.intersection(pointA, inverse.initialBearing, {
            lat: -89,
            lng: ((gp.lng - prev.lng) > 0) ? -GSI.Utils.Geodesic.INTERSECT_LNG : GSI.Utils.Geodesic.INTERSECT_LNG
          }, 0);
          if (sec) {
            data.points.push({
              latlng: L.latLng(sec.lat, sec.lng)
            });
            prev = L.latLng(sec.lat, -sec.lng);
            data.points.push({
              latlng: prev
            });

          } else {
            data.points.push({
              latlng: gp
            });
            prev = gp;
            s++;
            distance += interval;
          }
        } else {
          data.points.push({
            latlng: gp
          });
          prev = gp;
          s++;
          distance += interval;
        }

        if (distance > inverse.distance) {
          interval2 = interval - (distance - inverse.distance);
          break;
        }
      }
    }

    if (data.points.length < this.options.maxPoints) data.points.push({ latlng: this._points[this._points.length - 1] });

    // 必要なタイル一覧取得
    this._data = data;
    this._requestTileList = {};

    for (var i = 0; i < data.points.length; i++) {
      var p = this._map.project(data.points[i].latlng, zoom)

      var tilePoint = p.divideBy(256).floor();

      data.points[i].key = tilePoint.x + ':' + tilePoint.y + ':' + zoom;
      data.points[i].px = {
        x: Math.floor(p.x - (tilePoint.x * 256)),
        y: Math.floor(p.y - (tilePoint.y * 256))
      };

      if (!this._requestTileList[data.points[i].key]) {
        this._requestTileList[data.points[i].key] = {
          x: tilePoint.x,
          y: tilePoint.y,
          z: zoom,
          loader: new GSI.DEMLoader(this._map, tilePoint.x, tilePoint.y, zoom, null, {
            overZooming: true,
            useTileList: useDEMTileList
          })
        };

        this._requestTileList[data.points[i].key].loader.on("load", L.bind(this._demLoaded, this, data.points[i].key));

      }
    }

    this._pointsData = [];

    for (var i = 0; i < this._points.length; i++) {
      var p = this._map.project(this._points[i], zoom)

      var tilePoint = p.divideBy(256).floor();

      var pointData = {
        latlng: this._points[i],
        z: zoom,
        key: tilePoint.x + ':' + tilePoint.y + ':' + zoom,
        px: {
          x: Math.floor(p.x - (tilePoint.x * 256)),
          y: Math.floor(p.y - (tilePoint.y * 256))
        }
      };
      this._pointsData.push(pointData);

      if (!this._requestTileList[pointData.key]) {
        this._requestTileList[pointData.key] = {
          x: tilePoint.x,
          y: tilePoint.y,
          z: zoom,
          loader: new GSI.DEMLoader(this._map, tilePoint.x, tilePoint.y, zoom, null, {
            overZooming: true,
            useTileList: useDEMTileList
          })
        };

        this._requestTileList[pointData.key].loader.on("load", L.bind(this._demLoaded, this, pointData.key));

      }
    }

    for (var key in this._requestTileList) {
      this._requestTileList[key].loader.load();
    }
  },

  // 標高タイル取得後
  _demLoaded: function (key) {
    var req = this._requestTileList[key];

    var demData = req.loader.getData();
    var demInfo = req.loader.getInfo();

    var data = this._data;
    for (var i = 0; i < data.points.length; i++) {
      if (key != data.points[i].key) continue;

      var idx = (data.points[i].px.y * 256) + (data.points[i].px.x);

      data.points[i].h = (demData ? demData[idx] : null);
      if (demInfo) {
        data.points[i].info = demInfo[idx];
      }
      data.points[i].urlId = req.urlId;

    }

    for (var i = 0; i < this._pointsData.length; i++) {

      if (key != this._pointsData[i].key) continue;

      var idx = (this._pointsData[i].px.y * 256) + (this._pointsData[i].px.x);

      this._pointsData[i].h = (demData ? demData[idx] : null);

      if (demInfo) {
        this._pointsData[i].info = demInfo[idx];
      }
    }

    req.loaded = true;
    this._demLoadFinish();
  },

  // 全ての標高タイル取得後
  _demLoadFinish: function () {
    var loaded = true;

    for (var key in this._requestTileList) {
      if (!this._requestTileList[key].loaded) {
        loaded = false;
        break;
      }
    }

    if (!loaded) return;

    if (this._data.points.length < 2) {
      //err
      this.fire("finish", { loadedData: null });
      this.fire("graphcreated", {});
      return;
    }

    this._data.points[0].distance = 0;
    this._data.max = this._data.points[0].h;
    this._data.min = this._data.points[0].h;

    for (var i = 0; i < this._data.points.length - 1; i++) {
      this._data.points[i + 1].distance = this._data.totalDistance / (this.options.maxPoints - 1) * (i + 1);
      if (this._data.max == null) {
        this._data.max = this._data.points[i + 1].h;
      } else if (this._data.max < this._data.points[i + 1].h) {
        this._data.max = this._data.points[i + 1].h;
      }

      if (this._data.min == null) {
        this._data.min = this._data.points[i + 1].h;
      } else if (this._data.min > this._data.points[i + 1].h) {
        this._data.min = this._data.points[i + 1].h;
      }

    }

    if (!this._data.max && this._data.max != 0) {
      console.log("err");
      this.fire("finish", { loadedData: null });
      this.fire("graphcreated", { msg: "標高データが読み込めませんでした。" });
    }
    else {
      this.fire("finish", { loadedData: this._data });
      this.createGraph();

    }
  }
});

// 読み込んだデータに複数経路があった場合の選択用
GSI.CrossSectionView.LineSelector = L.Evented.extend({

  options: {
    rectStyle: {
      color: "#ff3333",
      weight: 2,
      fill: false,
      opacity: 1,
      dashArray: [3, 3]
    }
  },

  // 初期化
  initialize: function (map, options) {
    this._map = map;
    L.setOptions(this, options);

  },

  // 表示
  show: function (layers) {
    this.destroy();

    this._layers = layers
    this._boxLayers = L.layerGroup();
    this._markerLayers = L.layerGroup();
    this._list = [];

    var layerList = this._layers.getLayers();

    var screenBounds = null;

    this._map.addLayer(this._layers);

    var rectStyle = $.extend(true, { clickable: false }, this.options.rectStyle);

    for (var i = 0; i < layerList.length; i++) {
      var l = layerList[i];
      var bounds = l.getBounds();
      var box = L.rectangle(bounds, rectStyle);
      var marker = L.marker(bounds.getCenter(), {
        icon: L.divIcon({ iconSize: [40, 24], className: 'gsi_crosssectionview_lineselector_selectbtn', html: "選択" })
      }).on("click", L.bind(function (l) {
        this._select(l);
      }, this, l));

      this._list.push({
        layer: l,
        box: box,
        marker: marker
      });
      this._boxLayers.addLayer(box);
      this._markerLayers.addLayer(marker);

      if (!screenBounds)
        screenBounds = L.latLngBounds(l.getLatLngs());
      else
        screenBounds.extend(bounds);

      l.on("click", L.bind(function (e) {
        this._select(e.target);

      }, this));
    }

    this._map.addLayer(this._boxLayers);
    this._map.addLayer(this._markerLayers);
    this._map.fitBounds(screenBounds);
    this._map.getContainer().click();

    if (layerList.length == 1) {
      this._select(this._list[0].layer);

    }
  },

  // 選択された経路
  getSelectedItem: function () {
    return this._selectedItem;
  },

  // 選択解除
  clearSelect: function () {
    this._select(null);
  },

  // 選択時処理
  _select: function (layer) {

    if (this._selectedItem) {

      this._layers.addLayer(this._selectedItem.layer);
      this._boxLayers.addLayer(this._selectedItem.box);
      this._markerLayers.addLayer(this._selectedItem.marker);
      this._selectedItem = null;
    }

    var layerList = this._layers.getLayers();

    for (var i = 0; i < this._list.length; i++) {
      var item = this._list[i];
      if (layer == item.layer) {
        this._selectedItem = item;
        this._layers.removeLayer(item.layer);
        this._boxLayers.removeLayer(item.box);
        this._markerLayers.removeLayer(item.marker);
        break;
      }
    }

    if (this._selectedItem) {
      this.fire("select", {
        item: this._selectedItem,
        latLngs: this._selectedItem.layer.getLatLngs()
      });
    }
    else {
      this.fire("select", {});
    }
  },

  // 破棄
  destroy: function () {
    this._selectedItem = null;
    if (this._layers)
      this._map.removeLayer(this._layers);
    if (this._boxLayers)
      this._map.removeLayer(this._boxLayers);
    if (this._markerLayers)
      this._map.removeLayer(this._markerLayers);
    this._layers = null;
    this._boxLayers = null;
    this._markerLayers = null;
    this._list = null;
  }
});

// 経路の含まれたベクトルファイル読み込み
GSI.CrossSectionView.VectorFileLoader = L.Evented.extend({

  options: {
    lineStyle: {
      "weight": 3,
      "color": "#3333FF"

    }
  },

  // 初期化
  initialize: function (options) {

    L.setOptions(this, options);

    $(this.options.fileElement).on("change", L.bind(this._onFileChange, this));

  },

  // ファイルが選択された
  _onFileChange: function (e) {

    if (e.target.files && e.target.files.length > 0) {
      this._load(e.target.files[0])
    }
  },

  // 読み込み
  _load: function (file) {
    this.fire("start");
    var reader = new FileReader();
    reader.onload = L.bind(function () {
      var text = reader.result;
      var layers = null;
      var result = null
      try {
        var json = JSON.parse(text);
        var l = L.geoJSON(json);

        layers = l.getLayers();
      }
      catch (e) {
        //kml
        var data = null;
        try {
          if (window.ActiveXObject) {
            data = new ActiveXObject("Microsoft.XMLDOM");
            data.async = false;
            data.loadXML((text) ? text.trim() : '');
          }
          else if (window.DOMParser) {
            data = new DOMParser().parseFromString(
              (text) ? text.trim() : '',
              "application/xml"
            );
          }
          layers = GSI.KML.parseKML(data);

        }
        catch (e) {
          console.log(e);
          data = null;
        }
      }

      if (layers && layers.length > 0) {
        result = L.layerGroup();
        this._initializeLayers(result, layers);
      }

      this.fire("finish", {
        layers: result
      });

    }, this);

    reader.readAsText(file);

  },

  // レイヤー初期化
  _initializeLayers: function (result, layers) {

    var style = $.extend(true, {}, this.options.lineStyle);

    for (var i = 0; i < layers.length; i++) {
      var l = layers[i];
      if (l instanceof L.Polyline && !(l instanceof L.Polygon)) {
        var latLngs = l.getLatLngs();

        result.addLayer(L.polyline(latLngs, style));
      }
    }
  }
});

// 経路表示用ポリゴン
GSI.CrossSectionView.Draw = {};
/*
GSI.CrossSectionView.Polyline = L.Polyline.extend({

  initialize: function (latlngs, options) {
    L.Polyline.prototype.initialize.call(this, latlngs, options);
  },

  _project: function () {
    var pxBounds = new L.Bounds();
    this._rings = [];

    var latlngs = GSI.Utils.Geodesic.createLine([this._latlngs], GSI.Utils.Geodesic.LINESTEPS);
    this._projectLatlngs([latlngs], this._rings, pxBounds);

    var w = this._clickTolerance(),
      p = new L.Point(w, w);

    if (this._bounds.isValid() && pxBounds.isValid()) {
      pxBounds.min._subtract(p);
      pxBounds.max._add(p);
      this._pxBounds = pxBounds;
    }
  }
});
*/
GSI.CrossSectionView.Draw.Polyline = L.Draw.Polyline.extend({
  options: {
    allowIntersection: false,
    repeatMode: false,
    drawError: {
      color: '#b00b00',
      timeout: 2500
    },
    icon: new L.DivIcon({
      iconSize: new L.Point(8, 8),
      className: 'leaflet-div-icon leaflet-editing-icon'
    }),
    touchIcon: new L.DivIcon({
      iconSize: new L.Point(24, 24),
      className: 'leaflet-div-icon leaflet-editing-icon gsi_draw_icon'
    }),
    guidelineDistance: 20,
    maxGuideLineLength: 4000,
    shapeOptions: {
      stroke: true,
      color: '#f06eaa',
      weight: 4,
      opacity: 0.5,
      fill: false,
      clickable: true
    },
    metric: true, // Whether to use the metric meaurement system or imperial
    showLength: true, // Whether to display distance in the tooltip
    zIndexOffset: 2000 // This should be > than the highest z-index any map layers
  },

  initialize: function (map, options) {
    if (GSI.Utils.Browser.touch) {
      this.options.icon = this.options.touchIcon;
    }

    // Need to set this here to ensure the correct message is used.
    this.options.drawError.message = L.drawLocal.draw.handlers.polyline.error;

    // Merge default drawError options with custom options
    if (options && options.drawError) {
      options.drawError = L.Util.extend({}, this.options.drawError, options.drawError);
    }

    // Save the type so super can fire, need to do this as cannot do this.TYPE :(
    this.type = L.Draw.Polyline.TYPE;

    L.Draw.Feature.prototype.initialize.call(this, map, options);
  },

  _updateRunningMeasure: function (latlng, added) {
    var markersLength = this._markers.length,
      previousMarkerIndex, distance;

    if (this._markers.length === 1) {
      this._measurementRunningTotal = 0;
    } else {
      previousMarkerIndex = markersLength - (added ? 2 : 1);
      var inverse = GSI.Utils.Geodesic.vincentyInverse(
        latlng, this._markers[previousMarkerIndex].getLatLng());
      distance = (inverse ? inverse.distance : 0);

      this._measurementRunningTotal += distance * (added ? 1 : -1);
    }
  },

  _getMeasurementString: function () {
    var currentLatLng = this._currentLatLng,
      previousLatLng = this._markers[this._markers.length - 1].getLatLng(),
      distance;

    var inverse = GSI.Utils.Geodesic.vincentyInverse(currentLatLng, previousLatLng);

    distance = this._measurementRunningTotal + (inverse ? inverse.distance : 0);

    return L.GeometryUtil.readableDistance(distance, this.options.metric);
  }
});

// 断面図生成用
GSI.CrossSectionView.Graph = L.Evented.extend({

  // 初期化
  initialize: function (options) {
    this.options = {
      width: 400,
      height: 200,
      scale: 1,
      ratio: {
      }
    };
    this.options.minMode = GSI.CrossSectionView.Graph.MINMODE_LOW;

    L.setOptions(this, options);

    this._graphImage = new GSI.CrossSectionView.GraphImage();
  },

  // 最低値モード
  getMinMode: function () {
    return this.options.minMode;
  },
  // 最低値モード
  setMinMode: function (minMode) {
    this.options.minMode = minMode;
    this.create(this._data);
  },
  // 縦横比
  setRatio: function (ratio) {
    if (this.options.ratio.vert != ratio.vert || this.options.ratio.horz != ratio.horz) {
      this.options.ratio = ratio;
      this.create(this._data);
    }
  },
  // 縦横比
  getRatio: function () {
    return this.options.ratio;

  },

  getDefaultRatio: function () {
    return this._graphImage.getDrawInfo().getDefaultRatio();
  },

  reset: function () {
    this.options.ratio = {};
    this.options.scale = 1;
    this.options.minMode = GSI.CrossSectionView.Graph.MINMODE_LOW;
    this.create(this._data);
  },
  // スケール取得
  getScale: function () {
    return this.options.scale;
  },

  // スケール設定
  setScale: function (scale) {
    this.options.scale = scale;
    this.create(this._data);
  },

  // CSV生成
  getTextData: function () {
    if (!this._data) return "";

    var fix = function (val) {
      if (!val) return 0;

      return (Math.round(val * 1000000) / 1000000).toFixed(6);
    };
    var result = 'lat,lng,elevation,distance' + "\n";
    for (var i = 0; i < this._data.points.length; i++) {
      var p = this._data.points[i];
      if (p.h || p.h == 0)
        result += fix(p.latlng.lat) + "," + fix(p.latlng.lng) + "," + Math.round(p.h * 100) / 100 + ',' +
          (p.distance || p.distance == 0 ? Math.floor(p.distance) : "")
          + "\n";
    }
    return result;

  },

  // 破棄
  destroy: function () {

    if (this._canvasFrame)
      this._canvasFrame.remove();
    this.options.ratio = {};

    this._mousePontData = null;
    this._distanceLineDistance = null;
    this._data = null;
    this._canvasFrame = null;
    this._canvas = null;
    this._displayCanvas = null;

  },

  // 断面図が描画されたCanvas取得
  getGraphElement: function () {
    return this._displayCanvas;
  },

  // 断面図生成
  create: function (data) {

    this._data = data;
    if (!this._data) return;

    this._graphImage.setData(data, {
      base0: this.options.minMode == GSI.CrossSectionView.Graph.MINMODE_0,
      ratio: {
        vert: this.options.ratio.vert,
        horz: this.options.ratio.horz,
        height: this.options.scale
      }
    });

    var ratio = this._graphImage.getDrawInfo().getRatio();

    this.options.ratio.vert = ratio.vert;
    this.options.ratio.horz = ratio.horz;

    if (this._canvas)
      $(this._canvas).remove();
    this._canvas = null;

    if (!this._canvas) {
      this._canvas = this._graphImage.getCanvas();

      if (!this._displayCanvas) {
        this._displayCanvas = document.createElement('canvas');

        $(this._displayCanvas).on("mousemove", L.bind(this._onCanvasMouseMove, this));
        $(this._displayCanvas).on("mouseout", L.bind(this._onCanvasMouseOut, this));
      }

    }
    this._displayCanvas.width = this._canvas.width;
    this._displayCanvas.height = this._canvas.height;

    this._backgroundCanvasToFront();

  },

  setDistanceLine: function (distance) {
    this._distanceLineDistance = distance;
    try {
      this._onCanvasMouseMove({
        _distance: distance
      });
    }
    catch (e) {
      console.log(e);
    }
  },

  removeDistanceLine: function (latlng) {
    this._distanceLineDistance = null;
    try {
      this._onCanvasMouseOut();

    }
    catch (e) { }
  },

  // 背景を表示用Canvasに転送
  _backgroundCanvasToFront: function () {
    if (!this._displayCanvas) return;

    var srcCtx = this._canvas.getContext('2d');
    var destCtx = this._displayCanvas.getContext('2d');

    var image = srcCtx.getImageData(0, 0, this._canvas.width, this._canvas.height);
    destCtx.putImageData(image, 0, 0);

    if (!this._mousePontData) return;
    var area = this._graphImage.getDrawInfo().getGraphArea();

    var x = this._mousePontData.drawPoint.x;

    var ctx = destCtx;
    var strokeColor = "#0000FF";
    var strokeWidth = 1;
    var iTranslate = (strokeWidth % 2) / 2;
    ctx.translate(iTranslate, iTranslate);

    ctx.globalAlpha = 0.8;
    ctx.imageSmoothingEnabled = false;
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = strokeWidth;
    ctx.beginPath();

    ctx.moveTo(x, this._mousePontData.drawPoint.y);
    ctx.lineTo(x, area.bottom);

    ctx.stroke();
    ctx.translate(-iTranslate, -iTranslate);

    this._drawPopupBaloon(ctx, this._mousePontData);
    return;    
  },

  // 標高表示用ポップアップ描画
  _drawPopupBaloon: function (ctx, p) {

    var h = p.h;
    h = Math.round(h * 100) / 100;
    var info = p.info
    if (!h && h != 0) return;

    ctx.globalAlpha = 0.8;
    ctx.textBaseline = "middle";
    ctx.textAlign = 'center';
    ctx.font = 'normal 12px sans-serif';
    ctx.fillStyle = '#ffffff';
    var text = h + "m";
    var w1 = ctx.measureText(text);

    var text2 = info.id + "(" + info.zoom + ")";
    ctx.font = 'normal 10px sans-serif';

    var w2 = ctx.measureText(text2);

    var width = (w1.width > w2.width ? w1.width : w2.width) + 4;
    var height = 30;

    var rect = {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0
    };

    var drawPoint = {
      x: p.drawPoint.x,
      y: p.drawPoint.y - 5
    };
    rect.left = drawPoint.x - (width / 2);
    rect.right = drawPoint.x + (width / 2);
    rect.top = drawPoint.y - height;
    rect.bottom = drawPoint.y;
    rect.center = rect.left + ((rect.right - rect.left) / 2);
    var strokeWidth = 0;
    ctx.globalAlpha = 0.5;
    var iTranslate = (strokeWidth % 2) / 2;
    ctx.translate(iTranslate, iTranslate);
    ctx.imageSmoothingEnabled = false;
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = strokeWidth;

    ctx.beginPath();
    ctx.moveTo(rect.left, rect.top);
    ctx.lineTo(rect.left, rect.bottom);

    // △
    ctx.lineTo(rect.center - 3, rect.bottom);
    ctx.lineTo(rect.center, p.drawPoint.y);
    ctx.lineTo(rect.center + 3, rect.bottom);

    ctx.lineTo(rect.right, rect.bottom);
    ctx.lineTo(rect.right, rect.top);
    ctx.lineTo(rect.left, rect.top);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.font = 'normal 12px sans-serif';
    ctx.fillStyle = '#000000';
    ctx.fillText(text, drawPoint.x, drawPoint.y - 20);

    ctx.font = 'normal 10px sans-serif';
    ctx.fillText(text2, drawPoint.x, drawPoint.y - 8);
  },

  // Canvasからマウスが出た
  _onCanvasMouseOut: function () {
    if (this._mousePontData) {
      this._mousePontData = null;
      this._backgroundCanvasToFront();
      this.fire("mousepointchange", {
        point: null
      });
    }
  },

  // Canvas上をマウスが動いた時標高をポップアップ
  _onCanvasMouseMove: function (e) {
    if (!this._graphImage) return;
    var data = null;
    if (e._distance) {
      data = this._graphImage.getPointDataByDistance(e._distance);
    } else {
      data = this._graphImage.getPointData(e.offsetX, e.offsetY);
    }

    if (data != this._mousePontData) {
      this._mousePontData = data;
      this._backgroundCanvasToFront();
      if (!e._distance) {
        this.fire("mousepointchange", {
          point: data
        });
      }
    }
  }
});
GSI.CrossSectionView.Graph.MINMODE_0 = 0;
GSI.CrossSectionView.Graph.MINMODE_LOW = 1;

/*******************************************************

 GSI.CrossSectionViewDialog
    断面図ダイアログ管理クラス

*******************************************************/
GSI.CrossSectionViewDialog = GSI.Dialog.extend({

  options: {
    title: "断面図",
    width: "230px",
    minimize: true
  },

  // 初期化
  initialize: function (dialogManager, map, options) {
    this._map = map;
    this._useDEMTileList = ["DEM5A", "DEM5B", "DEM5C", "DEM10B", "DEMGM"];
    this._crossSectionView = new GSI.CrossSectionView(this._map, {
      autoGraph: true
    });

    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);

  },

  // 表示
  show: function () {

    if (this.container && this._dialogManager.isMinimized(this)) {
      this._dialogManager.removeMinimizeList(this);
      this.normalize();
      return;
    }

    GSI.Dialog.prototype.show.call(this);

    this._crossSectionView.on("graphcreatestart", L.bind(this._onGraphCreateStart, this));
    this._crossSectionView.on("graphcreated", L.bind(this._onGraphCreate, this));
    this._crossSectionView.start();
  },

  // 非表示
  hide: function () {
    if (this._displayDialog) this._displayDialog.hide();

    this._crossSectionView.off("graphcreatestart");
    this._crossSectionView.off("graphcreated");
    this._lineSelectFrame.hide();
    if (this._vectorSelector) this._vectorSelector.destroy();
    if (this._crossSectionView) this._crossSectionView.destroy();

    GSI.Dialog.prototype.hide.call(this);
  },
  createHeader: function () {
    this.title = $('<div>').html(this.options.title);

    return $('<div>').append(this.title);
  },
  createContent: function () {
    this.frame = $('<div>').addClass("gsi_crosssectionviewdialog_content").css({ "position": "relative", "padding": "8px" });

    var titleFrame = $("<div>").addClass("titleframe");
    titleFrame.append($("<div>").addClass("message").html("操作方法"));
    this.frame.append(titleFrame);

    // 経路指定
    var pointFrame = $("<div>").addClass("pointframe");
    pointFrame.append($("<div>").addClass("message").html("地図上をクリック(タップ)して経路を指定"));

    var clearButton = $("<a>").addClass("normalbutton-alt").attr({ "href": "javascript:void(0);" }).html("指定をクリア")
      .on("click", L.bind(function () {

        if (this._displayDialog) this._displayDialog.hide();
        this._crossSectionView.restart();
      }, this));
    pointFrame.append($("<div>").addClass("btnframe").append(clearButton));
    this.frame.append(pointFrame);

    // ファイル読み込み
    var fileFrame = $("<div>").addClass("fileframe");

    fileFrame.append($("<div>").addClass("message").html("又は既存のGeoJSON,KMLファイルを選択"));

    this._vectorFileInput = $("<input>").attr({ "type": "file" });
    fileFrame.append($("<div>").addClass("btnframe").append(this._vectorFileInput));
    this.frame.append(fileFrame);

    this._fileLoader = new GSI.CrossSectionView.VectorFileLoader({
      fileElement: this._vectorFileInput
    });

    this._fileLoader
      .on("start", L.bind(this._onFileLoadStart, this))
      .on("finish", L.bind(this._onFileLoaded, this));

    // ライン選択
    this._lineSelectFrame = $("<div>").addClass("lineselect").css({ "z-index": 1000, "position": "absolute", "background": "#ffffff", "left": 0, "top": 0, "right": 0, "bottom": 0 }).hide();

    this._lineSelectFrameMsg = $("<div>").addClass("message").html("断面図を表示する経路を地図上から選択してください。");
    this._lineSelectFrame
      .append($("<img>").attr({ "src": "image/system/info.png" })).append(this._lineSelectFrameMsg);

    var backButton = $("<a>").addClass("normalbutton").attr({ "href": "javascript:void(0);" }).html("経路指定画面に戻る")
      .on("click", L.bind(function () {

        if (this._displayDialog) this._displayDialog.hide();
        if (this._vectorSelector) this._vectorSelector.destroy();

        this._vectorSelector = null;

        this._crossSectionView.restart();
        this._vectorFileInput.val("");
        this._lineSelectFrame.fadeOut(200);
      }, this));
    this._lineSelectFrame.append(
      $("<div>").addClass("btnframe")
        .append(backButton)
    );

    this.frame.append(this._lineSelectFrame);

    // オプション
    this._createOption(this.frame);

    return this.frame;
  },

  // オプション生成
  _createOption: function (parentContainer) {

    // 開閉ボタン
    this._optionToggleButton = $("<a>")
      .attr({ "href": "javascript:void(0);" }).html("オプション").addClass("option-toggle-button")
      .on('click',L.bind(function () {
        if (this._optionFrame.is(":visible")) {
          this._optionFrame.slideUp(300);
          this._optionToggleButton.removeClass("open");
        } else {
          this._optionFrame.slideDown(300);
          this._optionToggleButton.addClass("open");
        }
      }, this));

    parentContainer.append(this._optionToggleButton);

    this._optionFrame = $("<div>").hide().addClass("option-container");

    var message = $("<div>").html("断面図に使用するデータを選択").addClass("message")
    this._optionFrame.append(message);

    // リンク

    var linkFrame = $("<div>");
    var link = $("<a>")
      .attr({ "target": "_blank", "href": "https://maps.gsi.go.jp/development/hyokochi.html" })
      .html("データについて").addClass("link")
    linkFrame.append(link);

    this._optionFrame.append(linkFrame);

    // 一覧
    this._optionDEMCheckList = [];

    var __createOption = L.bind(function (name) {
      var id = "gsi_crosssectionviewdialog_dem_" + name;
      var frame = $("<div>");
      var input = $("<input>").data({ "demid": name }).attr({ "type": "checkbox", "id": id }).val(name).addClass("normalcheck");
      var label = $("<label>").attr({ "for": id }).html(name);
      frame.append(input).append(label);

      if (this._useDEMTileList.indexOf(name) >= 0) {
        input[0].checked = true;
      }
      input.on("click", L.bind(this._onUseDemChange, this));
      this._optionDEMCheckList.push(input);
      return frame;
    }, this);

    this._optionFrame.append(__createOption("DEM5A"));
    this._optionFrame.append(__createOption("DEM5B"));
    this._optionFrame.append(__createOption("DEM5C"));
    this._optionFrame.append(__createOption("DEM10B"));
    this._optionFrame.append(__createOption("DEMGM"));

    // メッセージ２

    var message2 = $("<div>").html("選択したもののうち、その地点における最も精度の良いデータを用いて断面図を作成します。").addClass("message2")
    this._optionFrame.append(message2);

    parentContainer.append(this._optionFrame);

  },

  _onUseDemChange: function () {

    this._useDEMTileList = [];
    for (var i = 0; i < this._optionDEMCheckList.length; i++) {
      var input = this._optionDEMCheckList[i];
      if (input.is(":checked")) {
        this._useDEMTileList.push(input.data("demid"));
      }
    }
    this._crossSectionView.setUseDEMTileList(this._useDEMTileList);
  },

  // ファイル読み込みスタート
  _onFileLoadStart: function () {
    this._crossSectionView.destroy();
  },

  // ファイル読み込み終了後データ解析
  _onFileLoaded: function (e) {

    if (!e.layers) {
      alert("指定されたファイルに経路情報は含まれていません。");
      if (this._vectorSelector) {
        this._vectorSelector.destroy();
        this._vectorSelector = null;
      }
      this._vectorFileInput.val("");
      return;
    }
    if (!this._vectorSelector) {
      this._vectorSelector = new GSI.CrossSectionView.LineSelector(this._map, {});

      this._vectorSelector.on("select", L.bind(function (e) {
        if (!e.item) return;
        this._onGraphCreateStart();
        this._crossSectionView.setData(e.latLngs);
      }, this));

    }
    this._vectorSelector.show(e.layers);
    if (!this._vectorSelector.getSelectedItem()) {
      this._lineSelectFrame.fadeIn(200);
    }
    else {
      this._vectorSelector.destroy();
      this._vectorSelector = null;
      this._vectorFileInput.val("");
    }
  },

  // 断面図生成開始前処理
  _onGraphCreateStart: function (e) {
    if (!this._blind) {
      this._blind = $("<div>").addClass("window_blind");
      this._msg = $("<div>").css({
        "position": "absolute",
        "left": "50%",
        "top": "50%",
        "margin-left": "-90px",
        "padding-left": "34px",
        "display": "none",
        "color": "#fff",
        "z-index": 999999,
        "line-height": "32px",
        "background-image": "url(image/system/loading002.gif)",
        "background-position": "0px 50%",
        "background-repeat": "no-repeat"
      }).html("断面図を生成しています");
      $("body").append(this._blind).append(this._msg);
    }

    this._blind.fadeIn(300);
    this._msg.fadeIn(300);
  },

  // 断面図生成開始
  _onGraphCreate: function (e) {
    this._blind.fadeOut(200);
    this._msg.fadeOut(200);

    if (!e.graph) {
      if (e.msg)
        alert(e.msg);
      else
        alert("グラフを作成できません。");
      if (this._displayDialog) this._displayDialog.hide();
      this._crossSectionView.restart();
      return;
    }

    if (!this._displayDialog) {
      this._displayDialog = new GSI.CrossSectionViewDisplayDialog(this._dialogManager, {
        left: 46, top: 46, width: 480,
        minScale: e.minScale, maxScale: e.maxScale,
        minimize: true
      });
      this._displayDialog.on("hide", L.bind(function () {

        if (this._vectorSelector) {
          this._crossSectionView.clear();
          this._vectorSelector.clearSelect();
        }
        else
          this._crossSectionView.restart();
      }, this));
    }
    this._displayDialog.show(e.graph, this._crossSectionView);
  }
});

GSI.CrossSectionViewDisplayDialog = GSI.Dialog.extend({

  getTitle: function () {
    return "断面図表示";
  },

  // 初期化
  initialize: function (dialogManager, options) {

    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);

    this.container.css({ "border": "1px solid #333" });
    this.headerFrame
      .addClass("gsi_crosssectionview_displaygraph_dialog_header");
  },

  // 表示
  show: function (graph, crossSectionView) {

    if (this.container && this._dialogManager.isMinimized(this)) {
      this._dialogManager.removeMinimizeList(this);
      this.normalize();
      return;
    }

    this._graph = graph;
    this._crossSectionView = crossSectionView;
    if (this._graphFrame) this._graphFrame.empty();

    if (!this.container) this.create();

    this._graphFrame.empty().append(this._graph.getGraphElement());

    GSI.Dialog.prototype.show.call(this);

    this._scaleSliderContainer.slider("value", 200);

    if (this._graph.getMinMode() == GSI.CrossSectionView.Graph.MINMODE_0) {
      this._0mSelectRadio[0].checked = true;
    } else {
      this._lowSelectRadio[0].checked = true;
    }

    var ratio = this._graph.getRatio();
    this._ratioVertInput.val(ratio.vert).data({ "vert": ratio.vert });

    this._refreshTitle();

  },

  _refreshTitle: function () {

    if (!this._crossSectionView) {
      return;
    }
    var list = this._crossSectionView.getUseDEMTileList();
    var text = "";
    if (list) {
      for (var i = 0; i < list.length; i++) {
        text += (text != "" ? "," : "")
          + list[i];
      }
    } else {
      text = "DEM5A,DEM5B,DEM5C,DEM10B,DEMGM";
    }
    this._titleTextContainer.html("データ:" + text);
  },

  afterShow: function () {
    this._dragEnd();
    this._graph.getGraphElement().click();
  },
  _dragEnd: function (e, ui) {
    this._graphFrame.css({ "height": "auto" });
    this.contentFrame.css({ "height": "auto" });
    this.container.css({ "height": "auto" });
    GSI.Dialog.prototype._dragEnd.call(this, e, ui);
  },

  hide: function () {

    if (this._ratioVertInputCheckTimerId) clearTimeout(this._ratioVertInputCheckTimerId);
    this._ratioVertInputCheckTimerId = null;

    if (this._hideHandler) $("body").off("mousedown", this._hideHandler);
    this._saveTypeSelect.hide();
    GSI.Dialog.prototype.hide.call(this);
    this.fire("hide");
  },
  createHeader: function () {
    this._titleTextContainer = $("<span>").html('　　　').css({ "font-size": "8pt" });

    return this._titleTextContainer;
  },
  createContent: function () {
    this.frame = $('<div>').addClass("gsi_crosssectionview_displaygraph_content").css({ "position": "relative", "margin-top": "0" });

    this._headerControlFrame = this._createHeaderControls();
    this.frame.append(this._headerControlFrame);

    this._graphFrame = $("<div>").addClass("graphframe").css({ "position": "relative" });

    this.frame.append(this._graphFrame);

    this._controlFrame = $("<div>");

    var table = $("<table>").css({ "width": "100%" });
    var tr = $("<tr>");
    var td = null;

    td = $("<td>").attr({ "colspan": 3, "width": "100%" });
    td.css({ "font-size": "9pt", "padding-left": "8px", "padding-right": "8px" }).html("指定した点の位置や点数に関わらず、始点～終点間を300等分した各点の標高値よりグラフを作成しています");

    tr.append(td);
    table.append(tr);

    tr = $("<tr>");

    td = $("<td>").css({ "width": "100%" });

    this._resetButton = $("<a>").addClass("normalbutton")
      .attr({
        "href": "javascript:void(0);"
      }).html("初期状態に戻す");

    this._resetButton.on("click", L.bind(function () {
      this.reset();
    }, this));

    td.append(this._resetButton);
    tr.append(td);

    td = $("<td>");
    this._saveImageButton = $("<a>").addClass("normalbutton").attr({ "href": "javascript:void(0);" }).html("グラフを保存");
    td.append(this._saveImageButton);
    tr.append(td);

    this._saveGraphTypeSelect = $("<div>").addClass("savetypeselect").css({ "position": "absolute", "right": "2px", "bottom": "30px" }).hide();

    var a = $("<a>").attr({ "href": "javascript:void(0);" }).html("PNG形式で保存");
    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.DANMEN) {
      a.attr({ "title": CONFIG.TOOLTIP.DANMEN.SAVE_IMAGE });
    }
    a.on("click", L.bind(this._onSaveImageButtonClick, this));
    this._saveGraphTypeSelect.append(a);
    this.frame.append(this._saveGraphTypeSelect);

    a = $("<a>").attr({ "href": "javascript:void(0);" }).html("CSV形式で保存");
    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.DANMEN) {
      a.attr({ "title": CONFIG.TOOLTIP.DANMEN.SAVE_CSV });
    }
    a.on("click", L.bind(this._onSaveCSVDataButtonClick, this));
    this._saveGraphTypeSelect.append(a);

    td = $("<td>");
    this._saveVectorDataButton = $("<a>").addClass("normalbutton").attr({ "href": "javascript:void(0);" }).html("経路を保存");
    td.append(this._saveVectorDataButton);
    tr.append(td);

    table.append(tr);

    table.append(this._controlFrame);

    this.frame.append(table);

    this._saveTypeSelect = $("<div>").addClass("savetypeselect").css({ "position": "absolute", "right": "2px", "bottom": "30px" }).hide();

    a = $("<a>").attr({ "href": "javascript:void(0);" }).html("GeoJSON形式で保存");
    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.DANMEN) {
      a.attr({ "title": CONFIG.TOOLTIP.DANMEN.SAVE_GEOJSON });
    }
    a.on("click", L.bind(this._onSaveGeoJSONVectorDataButtonClick, this));
    this._saveTypeSelect.append(a);
    this.frame.append(this._saveTypeSelect);
    a = $("<a>").attr({ "href": "javascript:void(0);" }).html("KML形式で保存");
    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.DANMEN) {
      a.attr({ "title": CONFIG.TOOLTIP.DANMEN.SAVE_KML });
    }
    a.on("click", L.bind(this._onSaveKMLVectorDataButtonClick, this));
    this._saveTypeSelect.append(a);
    a = $("<a>").attr({ "href": "javascript:void(0);" }).html("CSV形式で保存");
    a.on("click", L.bind(this._onSaveCSVDataButtonClick, this));
    this._saveImageButton.on("click", L.bind(this._onSaveGraphButtonClick, this));
    this._saveVectorDataButton.on("click", L.bind(this._onSaveVectorDataButtonClick, this));

    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.DANMEN) {
      this._resetButton.attr({ "title": CONFIG.TOOLTIP.DANMEN.RESET });
    }

    return this.frame;
  },

  // 縦横比、最低標高些<->0m
  _createHeaderControls: function () {
    var container = $("<div>");

    container.append(this._crateRatioInput());
    container.append(this._createMinmodeSelect());

    container.append(this._createHeightSlider());
    return container;
  },

  _createHeightSlider: function () {
    var container = $("<div>").css({ "clear": "both", "padding": "3px 8px 0 3px" });

    var table = $("<table>").css({ "width": "100%", "border-spacing": "0", "table-collapse": "collapse" });
    var tr = $("<tr>");
    var td = $("<td>").html("縦軸の長さ").css({ "white-space": "nowrap", "width": "1px" });

    tr.append(td);
    this._scaleSliderContainer = $("<div>");

    var onChnage = L.bind(function (event, ui) {
      if (event.type == "slidechange") return;
      var ratio = this._graph.getDefaultRatio();

      var ratioVert = 1;
      if (ui.value <= 200) {
        ratioVert = Math.round(ratio.vert * (ui.value / 200));
      } else {
        ratioVert = ratio.vert + Math.round(ratio.vert * ((ui.value - 200) / 200));

      }

      if (ratioVert < 1) ratioVert = 1;
      this._ratioVertInput.val(ratioVert);
      this._refreshRatio();

    }, this);

    this._scaleSliderContainer.slider(
      {
        range: "min", min: 0, max: 1000, step: 1, value: 1,
        "slide": onChnage,
        "change": onChnage
      }
    );

    td = $("<td>");
    td.append(this._scaleSliderContainer);
    tr.append(td);
    table.append(tr);
    container.append(table);
    return container;
  },

  _crateRatioInput: function () {

    var container = $("<div>").addClass("gsi_crosssectionview_graph_ratio");

    var caption = $("<span>").html("縦横比").css({ "margin-right": "4px" });
    container.append(caption);

    this._ratioVertInput = $("<input>").attr({
      "type": "number", "min": 1
    }).val(1).data({ "vert": 1 });
    container.append(this._ratioVertInput);

    container.append($("<span>").html(":").css({ "margin-left": "2px", "margin-right": "2px" }));

    container.append($("<span>").html("1"));

    this._ratioResetButton = $("<a>").attr({ "href": "javascript:void(0);" }).html("等倍に戻す").addClass("normalbutton");
    container.append(this._ratioResetButton);

    this._ratioResetButton.on('click',L.bind(function () {
      this._ratioVertInput.val(1).data({ "vert": 1 });
      this._scaleSliderContainer.slider("value", 0);
      this._refreshRatio();
    }, this));

    this._ratioVertInput.on("focus", function () {
      setTimeout(L.bind(function () {
        this.select();
      }, this), 1);
    });

    this._ratioVertInput.on("blur", L.bind(function () {

      if (this._ratioVertInputCheckTimerId) clearTimeout(this._ratioVertInputCheckTimerId);
      this._ratioVertInputCheckTimerId = null;

      this._refreshRatio();
    }, this));

    this._ratioVertInput.on("focus", L.bind(function () {

      if (this._ratioVertInputCheckTimerId) clearTimeout(this._ratioVertInputCheckTimerId);
      this._ratioVertInputCheckTimerId = setInterval(L.bind(function () {

        var reg = new RegExp(/^[0-9]*$/);
        var vert = this._ratioVertInput.val();
        if (reg.test(vert)) {
          vert = parseInt(vert);
          if (vert > 0) {
            var sliderValue = 1;

            var ratio = this._graph.getDefaultRatio();
            if (vert <= ratio.vert) {
              sliderValue = Math.round(200 * (vert / ratio.vert));
            } else {
              sliderValue = Math.round(200 * (vert / ratio.vert));
            }
            this._scaleSliderContainer.slider("value", sliderValue);
            this._refreshRatio();
            return;
          }
        }

        if (this._ratioVertInput.val() != "") {
          var ratio = this._graph.getRatio();
          this._ratioVertInput.val(ratio.vert);
        }

      }, this), 100);
    }, this));

    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.DANMEN) {
      this._ratioResetButton.attr({ "title": CONFIG.TOOLTIP.DANMEN.FLAT });
    }

    return container;
  },

  reset: function () {
    this._scaleSliderContainer.slider("value", 200);
    this._lowSelectRadio[0].checked = true;

    this._graph.reset();
    var ratio = this._graph.getRatio();
    this._ratioVertInput.val(ratio.vert).data({ "vert": ratio.vert });

  },

  _refreshRatio: function () {
    if (!this._graph) return;

    //

    var reg = new RegExp(/^[0-9]*$/);
    var err = false;

    var vert = this._ratioVertInput.val();
    err = false;
    if (reg.test(vert)) {
      vert = parseInt(vert);
      if (vert > 0) {
        this._ratioVertInput.data({ "vert": vert });
      } else {
        err = true;
      }
    } else {
      err = true;
    }
    if (err) this._ratioVertInput.val(this._ratioVertInput.data("vert"));

    var ratio = {
      vert: this._ratioVertInput.data("vert"),
      horz: 1
    };
    this._graph.setRatio(ratio);
  },

  _createMinmodeSelect: function () {
    var container = $("<div>").addClass("gsi_crosssectionview_graph_minmode");

    var caption = $("<span>").html("縦軸メモリ").css({ "margin-right": "4px" });
    container.append(caption);
    this._0mSelectRadio = $("<input>").attr({
      "id": "gsi_crosssectionview_graph_min_0m",
      "name": "gsi_crosssectionview_graph_min",
      "type": "radio"
    }).addClass("normalcheck");
    var label = $("<label>").attr({ "for": "gsi_crosssectionview_graph_min_0m" }).html("0m");
    container.append(this._0mSelectRadio).append(label);

    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.DANMEN) {
      this._0mSelectRadio.attr({ "title": CONFIG.TOOLTIP.DANMEN.BASE_0 });
      label.attr({ "title": CONFIG.TOOLTIP.DANMEN.BASE_0 });
    }

    this._lowSelectRadio = $("<input>").attr({
      "id": "gsi_crosssectionview_graph_min_low",
      "name": "gsi_crosssectionview_graph_min",
      "type": "radio"
    }).addClass("normalcheck");
    label = $("<label>").attr({ "for": "gsi_crosssectionview_graph_min_low" }).html("最低標高");

    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.DANMEN) {
      this._lowSelectRadio.attr({ "title": CONFIG.TOOLTIP.DANMEN.BASE_LO });
      label.attr({ "title": CONFIG.TOOLTIP.DANMEN.BASE_LO });
    }

    this._0mSelectRadio.on("click", L.bind(function () {
      this._graph.setMinMode(GSI.CrossSectionView.Graph.MINMODE_0);
    }, this));
    this._lowSelectRadio.on("click", L.bind(function () {
      this._graph.setMinMode(GSI.CrossSectionView.Graph.MINMODE_LOW);
    }, this));

    container.append(this._lowSelectRadio).append(label);
    return container;

  },

  // テキストデータを保存
  _saveText: function (txt, fileName) {

    var blob = new Blob([txt], { "type": "text/plain" });

    GSI.Utils.saveFile("text/plain", fileName, blob);

  },

  // 画像データ保存
  _saveImage: function (canvas, fileName) {
    var createImage = function (base64, mime) {
      var tmp = base64.split(',');
      var data = atob(tmp[1]);
      var mime = tmp[0].split(':')[1].split(';')[0];
      var buf = new Uint8Array(data.length);
      for (var i = 0; i < data.length; i++) {
        buf[i] = data.charCodeAt(i);
      }
      var blob = new Blob([buf], { type: mime });
      return blob;
    };

    var data = canvas.toDataURL("image/png");
    var blob = null;
    blob = createImage(data, "image/png");

    GSI.Utils.saveFile("image/png", fileName, blob);

  },

  _onSaveDataButtonClick: function () {
    this._saveText(this._graph.getTextData(), 'csdata' + GSI.Utils.getTimeStampString() + ".csv");
  },
  _onSaveImageButtonClick: function () {
    this._saveImage(this._graph.getGraphElement(), 'cs' + GSI.Utils.getTimeStampString() + ".png");
  },

  _onSaveGraphButtonClick: function () {

    this._saveGraphTypeSelect.css({
      "right": (this._saveVectorDataButton.outerWidth() + 6) + "px"
    });

    this._saveGraphTypeSelect.slideDown(300);

    if (!this._hideHandler) this._hideHandler = L.bind(this._onBodyMousedown, this);

    $("body").off("mousedown", this._hideHandler).on('mousedown', this._hideHandler);

  },

  _onSaveVectorDataButtonClick: function () {
    this._saveTypeSelect.slideDown(300);

    if (!this._hideHandler) this._hideHandler = L.bind(this._onBodyMousedown, this);

    $("body").off("mousedown", this._hideHandler).on('mousedown', this._hideHandler);

  },

  // どこかクリックされたら保存タイプ選択リストを非表示
  _onBodyMousedown: function (e) {
    if (this._saveTypeSelect[0] != e.target
      && this._saveTypeSelect.find(e.target).length <= 0) {
      this._saveTypeSelect.slideUp(300);
    }

    if (this._saveGraphTypeSelect[0] != e.target
      && this._saveGraphTypeSelect.find(e.target).length <= 0) {
      this._saveGraphTypeSelect.slideUp(300);

    }
  },

  _onSaveGeoJSONVectorDataButtonClick: function () {
    this._saveTypeSelect.slideUp();

    this._saveText(this._crossSectionView.getGeoJSONText(), 'csline' + GSI.Utils.getTimeStampString() + ".geojson");

  },

  _onSaveKMLVectorDataButtonClick: function () {
    this._saveTypeSelect.slideUp();

    this._saveText(this._crossSectionView.getKMLText(), 'csline' + GSI.Utils.getTimeStampString() + ".kml");
  },

  _onSaveCSVDataButtonClick: function () {
    this._saveTypeSelect.slideUp();
    this._saveText(this._graph.getTextData(), 'csdata' + GSI.Utils.getTimeStampString() + ".csv");
  }
});

GSI.CrossSectionView.GraphImage = L.Evented.extend({

  options: {
    base0: true,
    ratio: {
      height: 1
    }
  },

  // 初期化
  initialize: function (options) {

    L.setOptions(this, options);
  },

  setData: function (data, options) {
    if (options) {
      L.setOptions(this, options);
    }
    this._data = data;
    this.redraw();
  },

  getDrawInfo: function () {
    return this._drawInfo;
  },

  clear: function () {

    if (this._canvas) {
      $(this._canvas).remove();
      delete this._canvas;
      this._canvas = undefined;
    }

    this._drawInfo = undefined;
  },

  redraw: function () {

    this.clear();
    if (!this._data) return;

    this._drawInfo = new GSI.CrossSectionView.GraphImage.DrawInfo(
      this._data, this.options
    );

    this._canvas = document.createElement('canvas');
    this._canvas.width = this._drawInfo.getCanvasWidth();
    this._canvas.height = this._drawInfo.getCanvasHeight();
    if (this.options.ratio.height <= 0) {

      return;
    }

    this._ctx = this._canvas.getContext("2d");
    this._drawBackground();
    this._drawGraph();
    this._drawBackgroundLine();
    this._drawBackgroundFrame();
  },

  getPointData: function (x, y) {
    var graphArea = this._drawInfo.getGraphArea();

    if (graphArea.top > y || graphArea.bottom < y || graphArea.left > x || graphArea.right < x) return null;

    var points = this._data.points;
    var minDistance = 99999999;
    var result = null;
    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      if (!p.drawPoint) continue;
      var distance = Math.abs(p.drawPoint.x - x);
      if (distance < minDistance) {
        result = p;
        minDistance = distance;
      }
    }
    return result;
  },
  getPointDataByDistance: function (distance) {

    var points = this._data.points;
    var minDistance = 99999999;
    var result = null;

    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      if (!p.drawPoint) continue;
      var sa = Math.abs(p.distance - distance);
      if (sa < minDistance) {
        result = p;
        minDistance = sa;
      }
    }
    return result;
  },

  _drawBackground: function () {
    var width = this._drawInfo.getCanvasWidth();
    var height = this._drawInfo.getCanvasHeight();
    var ctx = this._ctx;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, width, height);

  },

  _drawBackgroundFrame: function () {

    var graphArea = this._drawInfo.getGraphArea();

    var ctx = this._ctx;

    var strokeWidth = 2;
    var iTranslate = (strokeWidth % 2) / 2;
    ctx.translate(iTranslate, iTranslate);
    ctx.imageSmoothingEnabled = false;
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";
    ctx.globalAlpha = 1;
    ctx.strokeStyle = "#666666";
    ctx.lineWidth = strokeWidth;

    if (ctx.setLineDash)
      ctx.setLineDash([]);
    ctx.beginPath();
    ctx.lineTo(graphArea.left, graphArea.top);
    ctx.lineTo(graphArea.left, graphArea.bottom);
    ctx.lineTo(graphArea.right, graphArea.bottom);
    ctx.lineTo(graphArea.right, graphArea.top);
    ctx.lineTo(graphArea.left - 1, graphArea.top);

    ctx.stroke();

  },
  _drawBackgroundLine: function () {

    var graphArea = this._drawInfo.getGraphArea();

    var ctx = this._ctx;

    var strokeWidth = 1;
    var iTranslate = (strokeWidth % 2) / 2;
    ctx.translate(iTranslate, iTranslate);
    ctx.imageSmoothingEnabled = false;
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";
    ctx.globalAlpha = 1;
    ctx.strokeStyle = "#bbbbbb";
    ctx.lineWidth = strokeWidth;

    if (ctx.setLineDash)
      ctx.setLineDash([]);

    // 横ライン
    var graphMinElevation = this._drawInfo.getGraphMinElevation();
    var graphMaxElevation = this._drawInfo.getGraphMaxElevation();
    var stepElevation = this._drawInfo.getStepElevation();

    var vertMeterPixel = this._drawInfo.getVertMeterPixel();
    var startElevation = Math.ceil(graphMinElevation / stepElevation) * stepElevation;
    var lastY = undefined;

    for (var elevation = startElevation; elevation < graphMaxElevation; elevation += stepElevation) {
      var y = (elevation - graphMinElevation) / vertMeterPixel;

      y = graphArea.bottom - y;

      if (!lastY && graphMinElevation != elevation) {

        lastY = graphArea.bottom;
        // メートル
        ctx.textBaseline = "middle";
        ctx.textAlign = 'right';
        ctx.font = 'normal 11px sans-serif';
        ctx.fillStyle = '#000000';
        ctx.fillText(Math.floor(graphMinElevation), graphArea.left - 3, lastY);
      }

      if (lastY && lastY - y < 10) continue;

      {
        ctx.beginPath();
        if (ctx.setLineDash) {
          ctx.setLineDash([2, 2]);
          ctx.moveTo(graphArea.left - 3, y);
          ctx.lineTo(graphArea.right, y);
        } else {
          GSI.Utils.dotLineTo(ctx, graphArea.left - 3, y, graphArea.right, y, [3, 3]);
        }
        ctx.stroke();
        if (ctx.setLineDash)
          ctx.setLineDash([]);

      }

      // メートル
      ctx.textBaseline = "middle";
      ctx.textAlign = 'right';
      ctx.font = 'normal 11px sans-serif';
      ctx.fillStyle = '#000000';
      ctx.fillText(elevation, graphArea.left - 3, y);
      lastY = y;

    }
    // 単位
    ctx.textBaseline = "bottom";
    ctx.textAlign = 'left';
    ctx.font = 'normal 11px sans-serif';
    ctx.fillStyle = '#000000';
    ctx.fillText("(m)", graphArea.left - 3, graphArea.top - 5);

    // 縦線
    var horzMeterPixel = this._drawInfo.getHorzMeterPixel();
    var totalDistance = this._data.totalDistance;
    var lastX = undefined;
    var lastLineX = undefined;
    var unit = "(m)";
    var unitCalc = 1;
    if (totalDistance >= 10000) {
      unit = "(km)";
      unitCalc = 1000;
      stepElevation = 1000;
    }

    for (var distance = 0; distance < totalDistance; distance += stepElevation) {
      var x = distance / horzMeterPixel;
      x = graphArea.left + x;

      if (lastLineX && x - lastLineX < 10) continue;

      ctx.beginPath();
      if (ctx.setLineDash) {
        ctx.setLineDash([2, 2]);
        ctx.moveTo(x, graphArea.top);
        ctx.lineTo(x, graphArea.bottom + 3);
      } else {
        GSI.Utils.dotLineTo(ctx, x, graphArea.top, x, graphArea.bottom + 3, [3, 3]);
      }
      ctx.stroke();
      if (ctx.setLineDash)
        ctx.setLineDash([]);
      lastLineX = x;

      if (lastX && x - lastX < 30) continue;
      // メートル
      ctx.textBaseline = "top";
      ctx.textAlign = 'center';
      ctx.font = 'normal 11px sans-serif';
      ctx.fillStyle = '#000000';

      ctx.fillText(Math.floor(distance / unitCalc), x, graphArea.bottom + 3);
      lastX = x;
    }

    // 横単位
    ctx.textBaseline = "bottom";
    ctx.textAlign = 'left';
    ctx.font = 'normal 11px sans-serif';
    ctx.fillStyle = '#000000';
    ctx.fillText(unit, graphArea.right + 2, graphArea.bottom);
  },

  _drawGraph: function () {
    this._drawGraphFill();
    this._drawGraphLine();
  },

  _drawGraphFill: function () {

    var graphArea = this._drawInfo.getGraphArea();
    var points = this._data.points;

    var ctx = this._ctx;

    var strokeWidth = 1;
    var iTranslate = (strokeWidth % 2) / 2;
    ctx.translate(iTranslate, iTranslate);
    ctx.imageSmoothingEnabled = false;
    ctx.lineCap = "butt";
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = "#f4a460";
    ctx.lineWidth = strokeWidth;

    if (ctx.setLineDash)
      ctx.setLineDash([]);

    ctx.beginPath();

    var start = null;
    var prev = null;
    var last = null;

    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      if (!p.drawPoint) {

        if (prev) {
          ctx.lineTo(
            prev.drawPoint.x,
            graphArea.bottom);
          ctx.lineTo(
            start.drawPoint.x,
            graphArea.bottom);
          ctx.closePath();
          ctx.fill();
        }
        prev = null;
        start = null;
        continue;
      }
      if (prev) {
        ctx.lineTo(p.drawPoint.x, p.drawPoint.y);

      } else {

        ctx.beginPath();
        ctx.moveTo(p.drawPoint.x, p.drawPoint.y);
        start = p;
      }
      last = p;
      prev = p;
    }

    if (start && prev) {
      ctx.lineTo(
        prev.drawPoint.x,
        graphArea.bottom);
      ctx.lineTo(
        start.drawPoint.x,
        graphArea.bottom);
      ctx.closePath();
      ctx.fill();
    }
  },

  _drawGraphLine: function () {
    var graphArea = this._drawInfo.getGraphArea();
    var points = this._data.points;

    var ctx = this._ctx;

    var strokeWidth = 1;
    var iTranslate = (strokeWidth % 2) / 2;
    ctx.translate(iTranslate, iTranslate);
    ctx.imageSmoothingEnabled = false;
    ctx.lineCap = "butt";
    ctx.globalAlpha = 1.0;
    ctx.strokeStyle = "#f4a460";
    ctx.lineWidth = strokeWidth;

    if (ctx.setLineDash)
      ctx.setLineDash([]);

    ctx.beginPath();

    var prev = null;
    var last = null;

    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      if (!p.drawPoint) {
        prev = null;
        ctx.stroke();
        continue;
      }
      if (prev) {
        ctx.lineTo(p.drawPoint.x, p.drawPoint.y);

      } else {
        var from = null;
        var to = null;
        if (last) {
          from = last;
          to = p;
        } else if (i > 0) {
          from = {
            drawPoint: {
              x: graphArea.left,
              y: p.drawPoint.y
            }
          };
          to = p;
        }

        if (from) {
          if (ctx.setLineDash) {
            ctx.setLineDash([4, 4]);
            ctx.moveTo(from.drawPoint.x, from.drawPoint.y);
            ctx.lineTo(to.drawPoint.x, to.drawPoint.y);
          } else {
            GSI.Utils.dotLineTo(ctx, from.drawPoint.x, from.drawPoint.y, to.drawPoint.x, to.drawPoint.y, [5, 5]);
          }
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.beginPath();
        }
        ctx.moveTo(p.drawPoint.x, p.drawPoint.y);

      }
      last = p;
      prev = p;
    }

    ctx.stroke();

    if (!prev) {
      from = last;
      to = {
        drawPoint: {
          x: graphArea.right,
          y: last.drawPoint.y
        }
      };
      if (ctx.setLineDash) {
        ctx.setLineDash([4, 4]);
        ctx.moveTo(from.drawPoint.x, from.drawPoint.y);
        ctx.lineTo(to.drawPoint.x, to.drawPoint.y);
      } else {
        GSI.Utils.dotLineTo(ctx, from.drawPoint.x, from.drawPoint.y, to.drawPoint.x, to.drawPoint.y, [5, 5]);
      }
      ctx.stroke();
    }
  },

  _drawDanmen: function () {

  },

  getCanvas: function () {
    return this._canvas;
  }
});

GSI.CrossSectionView.GraphImage.DrawInfo = L.Class.extend({
  options: {
    base0: true,
    ratio: {
      vert: 1,
      horz: 1,
      height: 1
    },
    margin: {
      left: 8,
      top: 20,
      right: 30,
      bottom: 8
    },
    width: 400
  },

  initialize: function (data, options) {
    options = L.setOptions(this, options);
    this._data = data;
    this._initialize();
  },

  getDefaultRatio: function () {
    return this._defaultRatio;
  },

  _initialize: function () {

    var points = this._data.points;
    this._minElevation = undefined;
    this._maxElevation = undefined;
    this._elevationDifference = undefined;

    for (var i = 0; i < points.length; i++) {
      var p = this._data.points[i];
      if (!p.h && p.h != 0) continue;

      if (this._minElevation == undefined || this._minElevation > p.h) {
        this._minElevation = p.h;
      };
      if (this._maxElevation == undefined || this._maxElevation < p.h) {
        this._maxElevation = p.h;
      }
    }

    if (this.options.base0) {
      this._graphMinElevation = 0;
    } else {
      this._graphMinElevation = this._minElevation; // ( this._minElevation >= 0 ? this._minElevation : 0 );
      if (this._graphMinElevation < 0) {
        this._graphMinElevation = Math.floor(this._graphMinElevation);

      } else if (this._graphMinElevation < 100) {
        this._graphMinElevation = Math.floor(this._graphMinElevation / 10) * 10;
      } else if (this._graphMinElevation < 1000) {
        this._graphMinElevation = Math.floor(this._graphMinElevation / 100) * 100;
      } else {
        this._graphMinElevation = Math.floor(this._graphMinElevation / 1000) * 1000;
      }
    }
    this._elevationDifference = this._maxElevation - this._graphMinElevation;

    // 横幅
    this._graphWidth = this.options.width;

    this._leftNumberSize = 35;
    this._canvasWidth =
      this.options.margin.left + // 左余白
      this._leftNumberSize + // 左数字領域
      this._graphWidth +
      this.options.margin.right // 右余白
      ;

    this._horzMeterPixel = this._data.totalDistance / this._graphWidth; // 1ピクセル当たりのメートル

    var getHorzVert = function (graphHeight, elevationDifference, horzMeterPixel) {
      var vertMeterPixel = elevationDifference / (graphHeight - 10);
      var horz = 1;
      var vert = horzMeterPixel / vertMeterPixel;

      horz = Math.round(horz * 10);
      vert = Math.round(vert * 10);

      var tmp;
      var x = horz;
      var y = vert;

      while ((tmp = x % y) != 0) {
        x = y;
        y = tmp;
      }
      horz /= y;
      vert /= y;

      if (horz > 1) {
        vert = Math.round(vert / horz);
        if (vert < 1) vert = 1;

        horz = 1;
      }

      return {
        vertMeterPixel: vert,
        horz: horz,
        vert: vert
      }

    };

    // 縦幅
    this._bottomNumberSize = 20;
    if (!this.options.ratio.horz && this.options.ratio.horz != 0) {
      this._graphHeight = 210;
      var ret = getHorzVert(210, this._elevationDifference, this._horzMeterPixel);
      this._vertMeterPixel = ret.vertMeterPixel;
      this._graphMaxElevation = this._graphHeight * this._vertMeterPixel + this._graphMinElevation;

      this.options.ratio.horz = ret.horz;
      this.options.ratio.vert = ret.vert;
      this._defaultRatio = {
        horz: ret.horz,
        vert: ret.vert
      };

    } else {
      var ret = getHorzVert(210, this._elevationDifference, this._horzMeterPixel);
      this._defaultRatio = {
        horz: ret.horz,
        vert: ret.vert
      };

    }

    this._vertMeterPixel = this._horzMeterPixel * (
      (this.options.ratio.horz / this.options.ratio.vert) / this.options.ratio.height);

    this._graphHeight = this._elevationDifference / this._vertMeterPixel + 10;
    if (this._graphHeight < 100) {
      this._graphHeight = 100;
    }
    this._graphHeight = Math.floor(this._graphHeight);
    this._graphMaxElevation = this._graphHeight * this._vertMeterPixel + this._graphMinElevation;

    this._canvasHeight =
      this.options.margin.top + // 上余白
      this._graphHeight +
      this._bottomNumberSize +  // 下数字領域
      this.options.margin.bottom// 下余白
      ;

    var bottom = this._canvasHeight - this._bottomNumberSize - this.options.margin.bottom;
    var left = this.options.margin.left + this._leftNumberSize;

    for (var i = 0; i < points.length; i++) {
      var p = this._data.points[i];
      if (!p.h && p.h != 0) continue;

      if (this.options.base0 && p.h < 0) {

        p.drawPoint = {
          x: left + (i * (this._graphWidth / (points.length - 1))),
          y: bottom - ((0 - this._graphMinElevation) / this._vertMeterPixel)
        };
        continue;
      }
      p.drawPoint = {
        x: left + (i * (this._graphWidth / (points.length - 1))),
        y: bottom - ((p.h - this._graphMinElevation) / this._vertMeterPixel)
      };
    }

    var sa = this._graphMaxElevation - this._graphMinElevation;
    this._stepElevation = 10;

    if (sa <= 100) {
      this._stepElevation = 10;
    } else if (sa <= 500) {
      this._stepElevation = 50;
    } else if (sa <= 1000) {
      this._stepElevation = 100;
    } else if (sa <= 2000) {
      this._stepElevation = 200;
    } else {
      this._stepElevation = 500;
    }

  },

  getRatio: function () {
    return this.options.ratio;
  },

  getStepElevation: function () {
    return this._stepElevation;
  },

  getGraphMinElevation: function () {
    return this._graphMinElevation;
  },

  getGraphMaxElevation: function () {
    return this._graphMaxElevation;
  },

  getHorzMeterPixel: function () {
    return this._horzMeterPixel;
  },

  getVertMeterPixel: function () {
    return this._vertMeterPixel;
  },

  getGraphArea: function () {
    var result = {
      left: this.options.margin.left + this._leftNumberSize,
      top: this.options.margin.top
    };

    result.right = this._canvasWidth - this.options.margin.right;
    result.bottom = this._canvasHeight - this._bottomNumberSize - this.options.margin.bottom;

    result.width = result.right - result.left;
    result.height = result.bottom - result.top;
    return result;
  },

  getCanvasWidth: function () {
    return this._canvasWidth;
  },

  getCanvasHeight: function () {
    return this._canvasHeight;
  }
});

/************************************************************************
 L.Class
 - GSI.TGrid
 ************************************************************************/
GSI.TGrid = L.Evented.extend({
  layerList: [
    {
      url: "https://maps.gsi.go.jp/xyz/zk200000/{z}/{x}/{y}.geojson",
      "options": {
        minZoom: 5,
        maxZoom: 8,
        maxNativeZoom: 8,
        skipLoadStyle: true
      },
      "geojsonOptions": {
        "stroke": true,
        "color": "#E14900",
        "weight": 2,
        "opacity": 0.90,
        "dashArray": [2, 2],
        "fill": false,
        "fillColor": "#E14900",
        "fillOpacity": 0.20,
        "textColor": "#E14900",
        "textFontFamilyType": 0,
        "textFontSize": 14.5,
        "textFontBold": true,
        "textFontItalic": false,
        noGeodesic: true,
        pointToLayer: function (feature, latlng) {
          var title = feature.properties["name"];
          var idstyle = "\"font-size:16px; color:#E14900; white-space:nowrap;\"";
          var idAnchor = title.length / 2 * 16;
          var icon = L.divIcon({
            iconAnchor: [idAnchor, 10],
            className: "gsi-div-icon",
            html: "<div style=" + idstyle + ">" + title + "</div>"
          });
          var marker = L.marker(latlng, { icon: icon });
          return marker;
        }
      }
    },
    {
      url: "https://maps.gsi.go.jp/xyz/zk50000/{z}/{x}/{y}.geojson",
      "options": {
        minZoom: 9,
        maxZoom: 10,
        maxNativeZoom: 10,
        skipLoadStyle: true
      },
      "geojsonOptions": {
        "stroke": true,
        "color": "#3388FF",
        "weight": 2,
        "opacity": 1.00,
        "dashArray": [3, 3],
        "fill": false,
        "fillColor": "#3388FF",
        "fillOpacity": 0.20,
        "textColor": "#3388FF",
        "textFontFamilyType": 0,
        "textFontSize": 10.5,
        "textFontBold": true,
        "textFontItalic": false,
        noGeodesic: true,
        pointToLayer: function (feature, latlng) {
          var title = feature.properties["name"];
          var idstyle = "\"font-size:16px; color:#3388FF; white-space:nowrap; \"";
          var idAnchor = title.length / 2 * 16;
          var icon = L.divIcon({
            iconAnchor: [idAnchor, 10],
            className: "gsi-div-icon",
            html: "<div style=" + idstyle + ">" + title + "</div>"
          });
          var marker = L.marker(latlng, { icon: icon });
          return marker;
        }
      }
    },
    {
      id: "zk25000",
      url: 'https://cyberjapandata.gsi.go.jp/xyz/zk25000/{z}/{x}/{y}.geojson',
      options: {
        minZoom: 11,
        maxZoom: 18
      }
    }
  ],
  options: {
    lineStyle: {
      color: "#1D417A",
      weight: 2,
      opacity: 1,
      fillOpacity: 1,
      dashArray: [3, 3]
    },
    labelClassName: 'latlnggrid_label'
  },
  visible: false,
  initialize: function (map, options) {
    this._layers = [];

    for (var i = 0; i < this.layerList.length; i++) {
      if (this.layerList[i].id == "zk25000") continue;
      this.layerList[i].geojsonOptions.onGeoJSONLoad = L.bind(this._onGeoJSONLoad, this);
    }
    this._map = map;
    this._style = null;

    options = L.setOptions(this, options);

    options.lineStyle.clickable = false;
    options.lineStyle.noGeodesic = true;

    this._visible = options.visible;
    this.setVisible(this._visible);
  },
  setVisible: function (on) {
    this._visible = on;

    this._clearLayers();

    if (this._visible) {

      if (!this._style) {
        $.ajax({
          type: "GET",
          url: "https://cyberjapandata.gsi.go.jp/xyz/zk25000/style.js",
          dataType: "text",
          cache: false,
          success: L.bind(this._onStyleLoad, this),
          error: L.bind(this._onStyleLoadError, this)
        });

      }
      else {
        this._loadLayers();
      }
    }
    this.fire("change");
  },

  _onGeoJSONLoad: function (geojson) {
    if (!geojson.features) return;
    for (var i = 0; i < geojson.features.length; i++) {
      var feature = geojson.features[i];
      if (feature.geometry.type != "Polygon") continue;
      if (!feature.properties) continue;

      var properties = $.extend(true, [], feature.properties);
      var latlngs = feature.geometry.coordinates;
      if (!L.LineUtil.isFlat(latlngs)) {
        latlngs = latlngs[0];
      }
      var bounds = L.latLngBounds(
        [latlngs[0][1], latlngs[0][0]],
        [latlngs[2][1], latlngs[2][0]]);
      var center = bounds.getCenter();
      var markerFeature = {
        "type": "Feature",
        "geometry": {
          "type": "Point",
          "coordinates": [center.lng, center.lat]
        },
        "properties": properties
      };
      geojson.features.push(markerFeature);
    }
  },

  _loadLayers: function () {
    for (var i = 0; i < this.layerList.length; i++) {
      var info = this.layerList[i];

      var layer = new GSI.VectorTileLayer(
        info.url,
        info.options, info.geojsonOptions, true);
      this._layers.push(layer);
      this._map.addLayer(layer, info.style);
    }
  },

  _clearLayers: function () {
    for (var i = 0; i < this._layers.length; i++) {
      this._map.removeLayer(this._layers[i]);
    }
    this._layers = [];
  },
  getVisible: function () {
    return this._visible;
  },

  _onStyleLoad: function (text) {
    try {
      this._style = eval("(" + text + ")");

      this._style.options.skipLoadStyle = true;
      if (!this._style.geojsonOptions) this._style.geojsonOptions = {};
      this._style.geojsonOptions.clickable = false;
      this._style.options.minZoom = this.layerList[2].options.minZoom;
      this._style.options.maxZoom = this.layerList[2].options.maxZoom;

      this._style.geojsonOptions.noGeodesic = true;
      this.layerList[2].options = this._style.options;
      this.layerList[2].geojsonOptions = this._style.geojsonOptions;

      this._loadLayers();
    }
    catch (e) {
      this._onStyleLoadError();
      return;
    }
    if (this._layer)
      this._map.removeLayer(this._layer);
  },

  _onStyleLoadError: function (text) {
    if (this._visible) {
      this._loadLayers();
    }
  }
});

/************************************************************************
 L.Class
 - GSI.T25000Grid（2万5千分の1）
 ************************************************************************/
/*
GSI.T25000Grid = L.Class.extend({
  options: {
    lineStyle: {
      color: "#1D417A",
      weight: 2,
      opacity: 1,
      fillOpacity: 1,
      dashArray: [3, 3]
    },
    labelClassName: 'latlnggrid_label'
  },
  visible: false,
  initialize: function (map, options) {
    this._layer = null;
    this._map = map;
    this._style = null;

    options = L.setOptions(this, options);

    options.lineStyle.clickable = false;
    options.lineStyle.noGeodesic = true;

    this._visible = options.visible;
    this.setVisible(this._visible);

  },
  setVisible: function (on) {
    this._visible = on;

    if (this._layer)
      this._map.removeLayer(this._layer);
    if (this._visible) {

      if (!this._style) {
        $.ajax({
          type: "GET",
          url: "https://cyberjapandata.gsi.go.jp/xyz/zk25000/style.js",
          dataType: "text",
          cache: false,
          success: L.bind(this._onStyleLoad, this),
          error: L.bind(this._onStyleLoadError, this)
        });
      }
      else {
        this._layer = new GSI.VectorTileLayer(
          'https://cyberjapandata.gsi.go.jp/xyz/zk25000/{z}/{x}/{y}.geojson',
          this._style.options, this._style.geojsonOptions, true);

        this._map.addLayer(this._layer);
      }
    }
  },
  getVisible: function () {
    return this._visible;
  },

  _onStyleLoad: function (text) {
    try {
      this._style = eval("(" + text + ")");
      this._style.options.skipLoadStyle = true;
    }
    catch (e) {
      this._onStyleLoadError();
      return;
    }
    if (this._layer)
      this._map.removeLayer(this._layer);
    if (this._visible) {

      this._layer = new GSI.VectorTileLayer(
        'https://maps.gsi.go.jp/xyz/zk25000/{z}/{x}/{y}.geojson',
        this._style.options, this._style.geojsonOptions, true);

      this._map.addLayer(this._layer, this._style.geojsonOptions);
    }
  },

  _onStyleLoadError: function (text) {
    if (this._visible) {
      this._layer = new L.TileLayer.GeoJSON(
        'https://maps.gsi.go.jp/xyz/zk25000/{z}/{x}/{y}.geojson',
        {});

      this._map.addLayer(this._layer);
    }
  }
});
 */

/************************************************************************
 L.Class
 - GSI.HashOptions
 ************************************************************************/
GSI.HashOptions = L.Class.extend({
  initialize: function (gsimaps, map) {
    this._gsimaps = gsimaps;
    this.map = map;

    this._onMapMoveStart = L.bind(this.onMapMoveStart, this);
    this._onMapMoveEnd = L.bind(this.onMapMoveEnd, this);

    this.map.on('movestart', this._onMapMoveStart);
    this.map.on('moveend', this._onMapMoveEnd);

    this.vLD = 3000;
    this.oTM = null;
    this.vTM = 1500;
    this.nTM = 0;
    this.vHash = "";
    this.vHashOptions = "";
    this.eHashChange = false;
    this.eHashChangeOptions = "";

    this.Init();
  },
  Init: function () {
    this.oTM = null;
    this.vHash = "";
    this.vHashOptions = "";
    this.eHashChange = false;
    this.eHashChangeOptions = "";

    if (this.vTM >= 1000) {
      this.HashCreate();
    }
    this.Hash();
  },
  onMapMoveStart: function () {
    clearInterval(this.oTM);
    this.oTM = null;
  },
  onMapMoveEnd: function () {
    if (this.oTM != null) {
      clearInterval(this.oTM);
    }

    this.oTM = null;
    this.Hash();
  },
  Callback: function (t, o, hash) {
    
    if (t == "moveend") {
      hash += o.vHashOptions;
      o.vHash = hash;
      // 202303
//      if (CONFIG.USECOOKIE) $.cookie(CONFIG.COOKIEKEY_HASH, hash, { path: '/', expires: 365 });
      if (CONFIG.USECOOKIE) Cookies.set(CONFIG.COOKIEKEY_HASH, hash, { path: '/', expires: 365 });
    }
    else if (t == "hashchange") {
      o.HashSetProc(hash);
      // 202303 &baseの値をチェック。
      hash = o.baseHashCheck(hash);

      location.replace(hash);
    }
    return hash;
  },
  Hash: function () {
    if (this.oTM == null) {
      var that = this;
      this.oTM = setInterval(
        function () {
          that.nTM += that.vTM;
          if (that.nTM > that.vLD) {
            that.nTM = that.vLD;
          }
          that.HashCreate();
        }
        , this.vTM);
    }
  },
  HashCreate: function (force) {
    var hash = location.hash;
    var hash_location = "";
    var hash_options = this.HashCreateProc();

    if (hash.indexOf("/&") == -1) {
      hash_location = this._gsimaps._hash.formatHash(this.map);

      this.vHash = "";
      this.vHashOptions = "";
    }
    else {
      var hash_ary = hash.split("/&");
      hash_location = hash_ary[0];
    }

    hash = hash_location + hash_options;

    if (this._cookieHash != hash) {
      this._cookieHash = hash;
    }
    if (force || (!this.eHashChange && this.vHash != hash)) {
      if (CONFIG.USECOOKIE) Cookies.set(CONFIG.COOKIEKEY_HASH, hash, { path: '/', expires: 365 });
      location.replace(hash);
      this.vHash = hash;
      this.vHashOptions = hash_options;
    }

    this.eHashChange = false;
  },
  HashCreateProc: function () {
    var v = "";
    var hash = "";
    if (this.eHashChange) {
      hash = this.eHashChangeOptions;
    }
    else {
      hash += "/";

      // 基本設定：表示中の背景地図を共有
      // base=
      v = this._gsimaps._pageStateManager.getBaseLayerQueryString();
      if (v != "") {
        hash += "&" + v;
      }

      // 基本設定：表示中のレイヤーを共有
      // ls=
      v = this._gsimaps._pageStateManager.getLayersQueryString();
      if (v != "") {
        hash += "&" + v;
      }

      // 選択中の情報設定
      // disp=
      v = this._gsimaps._pageStateManager.getTileViewSetting();
      if (v != "") {
        hash += "&" + v;
      }

      // 情報リスト設定：表示階層を共有
      // lcd=
      v = this._gsimaps._pageStateManager.getCurrentPathQueryString();
      if (v != "") {
        hash += "&" + v;
      }

      var hcList = [];

      var skips = {};
      skips[CONFIG.PARAMETERNAMES.CLICKMOVE] = true;
      skips[CONFIG.PARAMETERNAMES.COCOTILE] = true;
      skips[CONFIG.PARAMETERNAMES.MINIMAP] = true;

      var visibles = {};
      visibles[CONFIG.PARAMETERNAMES.CENTERCROSS] = this._gsimaps._pageStateManager.getViewSettingVisible(CONFIG.PARAMETERNAMES.CENTERCROSS); // 表示設定：中心十字線        vs=c[0/1]
      visibles[CONFIG.PARAMETERNAMES.ZOOMGUIDE] = this._gsimaps._pageStateManager.getViewSettingVisible(CONFIG.PARAMETERNAMES.ZOOMGUIDE); // 表示設定：表示ズームの案内        vs=g[0/1]
      visibles[CONFIG.PARAMETERNAMES.JIHOKULINE] = this._gsimaps._pageStateManager.getViewSettingVisible(CONFIG.PARAMETERNAMES.JIHOKULINE); // 表示設定：緯度経度グリッド  vs=l[0/1]
      visibles[CONFIG.PARAMETERNAMES.LATLNGGRID] = this._gsimaps._pageStateManager.getViewSettingVisible(CONFIG.PARAMETERNAMES.LATLNGGRID); // 表示設定：UTMグリッド       vs=u[0/1]
      visibles[CONFIG.PARAMETERNAMES.UTMGRID] = this._gsimaps._pageStateManager.getViewSettingVisible(CONFIG.PARAMETERNAMES.UTMGRID); // 表示設定：磁北線            vs=j[0/1]
      visibles[CONFIG.PARAMETERNAMES.TILEGRID] = this._gsimaps._pageStateManager.getViewSettingVisible(CONFIG.PARAMETERNAMES.TILEGRID); // 表示設定：タイル座標            vs=t[0/1]
      visibles[CONFIG.PARAMETERNAMES.T25000GRID] = this._gsimaps._pageStateManager.getViewSettingVisible(CONFIG.PARAMETERNAMES.T25000GRID); // 表示設定：図郭            vs=z[0/1]
      visibles[CONFIG.PARAMETERNAMES.CHIIKIMESH] = this._gsimaps._pageStateManager.getViewSettingVisible(CONFIG.PARAMETERNAMES.CHIIKIMESH); // 表示設定：地域メッシュ            vs=r[0/1]
      visibles[CONFIG.PARAMETERNAMES.TOUKYOKEN] = this._gsimaps._pageStateManager.getViewSettingVisible(CONFIG.PARAMETERNAMES.TOUKYOKEN); // 表示設定：等距圏            vs=k[0/1]
      visibles[CONFIG.PARAMETERNAMES.HOUILINE] = this._gsimaps._pageStateManager.getViewSettingVisible(CONFIG.PARAMETERNAMES.HOUILINE); // 表示設定：方位線            vs=k[0/1]

      if (!CONFIG.DISABLE_KOKUDOKIHONZUZUKAKU) visibles[CONFIG.PARAMETERNAMES.KOKUDOKIHONZUKAKU] = this._gsimaps._pageStateManager.getViewSettingVisible(CONFIG.PARAMETERNAMES.KOKUDOKIHONZUKAKU); // 表示設定：国土基本図郭            vs=a[0/1]
      visibles[CONFIG.PARAMETERNAMES.SPLITWINDOW] = this._gsimaps.splited();
      visibles[CONFIG.PARAMETERNAMES.COMPAREMAP] = this._gsimaps.compared();

      if (this._gsimaps._mainMap._footer && this._gsimaps._mainMap._footer.isVisible())
        visibles[CONFIG.PARAMETERNAMES.FOOTER] = this._gsimaps._mainMap._footer.getDisplayMode();
      else
        visibles[CONFIG.PARAMETERNAMES.FOOTER] = 0;
      var visibleDialogs = {};
      visibleDialogs[CONFIG.DIALOGPARAMETER.LEFTPANEL] = this._gsimaps._mainMap._mapMenu.getPanelVisible(); // 情報リスト設定：選択中の情報   d=v

      var visibles2 = {};
      var visibleDialogs2 = {};
      if (this._gsimaps.splited()) {
        if (this._gsimaps._subMap._footer && this._gsimaps._subMap._footer.isVisible())
          visibles2[CONFIG.PARAMETERNAMES.FOOTER] = this._gsimaps._subMap._footer.getDisplayMode();
        else
          visibles2[CONFIG.PARAMETERNAMES.FOOTER] = 0;
        if (this._gsimaps._subMap._viewListDialog)
          visibleDialogs2[CONFIG.DIALOGPARAMETER.VIEWLISTDIALOG] = this._gsimaps._subMap._viewListDialog.getVisible(); // 情報リスト設定：情報リスト d=l
        if (this._gsimaps._subMap._layerTreeDialog)
          visibleDialogs2[CONFIG.DIALOGPARAMETER.LAYERTREEDIALOG] = this._gsimaps._subMap._layerTreeDialog.getVisible(); // 情報リスト設定：選択中の情報   d=v
      }

      var queryParams = this._gsimaps._pageStateManager.getQueryParams(
        {
          hcList: hcList
          , vsInfo: {
            skips: skips,
            visibles: visibles,
            visibles2: visibles2
          }
          , visibleDialogs: visibleDialogs
          , visibleDialogs2: visibleDialogs2
        });

      for (var key in queryParams) {
        v = queryParams[key];
        if (v != "") {
          hash += "&" + key + '=' + queryParams[key];
        }
      }

      for (var i = 1; i <= 5; i++) {
        v = GSI.FILEURL["url" + i] == undefined? "" : GSI.FILEURL["url" + i];
        if (v != "") {
          hash += "&url" + i + "=" + encodeURIComponent(v);
        }
      }

      // 自由な色別標高図
      var freeRelief = this._gsimaps._pageStateManager.getFreeReliefQueryString();

      if (freeRelief != "")
        hash += "&" + freeRelief;

      if (this._gsimaps.splited() || this._gsimaps.compared()) {
        if (!this._gsimaps.compared()) {
          hash += "&sync=" + (this._gsimaps._syncSplitMap ? "1" : "0");
          if (!this._gsimaps._syncSplitMap) {
            var center = this._gsimaps._subMap._map.getCenter();
            hash += "&ll2=" + encodeURIComponent(
              center.lat.toFixed(6) + ',' + center.lng.toFixed(6) + ',' + this._gsimaps._subMap._map.getZoom()
            );
          }
        }

        // base2=
        v = this._gsimaps._pageStateManager.getBaseLayerQueryString2();
        if (v != "") {
          hash += "&" + v;
        }

        // ls2=
        v = this._gsimaps._pageStateManager.getLayersQueryString2();
        if (v != "") {
          hash += "&" + v;
        }

        // disp2=
        v = this._gsimaps._pageStateManager.getTileViewSetting2();
        if (v != "") {
          hash += "&" + v;
        }

        // 情報リスト設定：表示階層を共有
        // lcd2=
        v = this._gsimaps._pageStateManager.getCurrentPathQueryString2();
        if (v != "") {
          hash += "&" + v;
        }
        var freeRelief2 = this._gsimaps._pageStateManager.getFreeReliefQueryString2();
        if (freeRelief2 != "")
          hash += "&" + freeRelief2;
  
      }

      // 等距圏
      var toukyokenCenter = this._gsimaps._pageStateManager.getToukyokenCenter();
      if ( toukyokenCenter ) {
        hash += "&tpos=" +
          toukyokenCenter.lat.toFixed(6) + "," +
          toukyokenCenter.lng.toFixed(6);
      }
      // 方位線
      var houilineCenter = this._gsimaps._pageStateManager.getHouiLineCenter();
      if ( houilineCenter ) {
        hash += "&hpos=" +
          houilineCenter.lat.toFixed(6) + "," +
          houilineCenter.lng.toFixed(6);
      }

      if (this.nTM < this.vLD) {
        var vHash = location.hash.split("/&");
        if (vHash.length > 1) {
          if (vHash[1].indexOf("base=") != -1
            || vHash[1].indexOf("ls=") != -1
            || vHash[1].indexOf("disp=") != -1
            || vHash[1].indexOf("lcd=") != -1
          ) {
            if (!(this.vHash.indexOf("base=") != -1
              || this.vHash.indexOf("ls=") != -1
              || this.vHash.indexOf("disp=") != -1
              || this.vHash.indexOf("lcd=") != -1
            )
            ) {
              hash = "/&" + vHash[1];
            }
          }
        }
      }
    }

    return hash;
  },
  HashSetProc: function (hash) {

    var n = hash.indexOf("/&");
    if (n >= 1) {
      var options = hash.substr(n);
      if (this.vHashOptions != options) {

        if (options.indexOf(CONFIG.layerEvacuationHeader) >= 0) {
          this.forEvacuation(options);
        }
        else {

          this.HashSetProc_sub(options);
        }
      }
    }
  },
  HashSetProc_sub: function (options) {
    this.eHashChangeOptions = options;
    this._gsimaps._queryParams.initialize_proc(options);

    // 基本設定：表示中の背景地図を共有
    // base=
    var base = this._gsimaps._queryParams.getBaseMap();

    this._gsimaps._mainMap._baseLayer.setActiveId(base);
    // base_grayscale=
    this._gsimaps._mainMap._baseLayer.setGrayScale(this._gsimaps._queryParams.getBaseMapGrayScale());

    // 基本設定：表示中のレイヤーを共有
    // ls=
    //  +
    // 選択中の情報設定
    // disp=
    var layers = this._gsimaps._queryParams.getLayers();
    var lcd = this._gsimaps._queryParams.getCurrentPath();

    if (layers) {
      for (i = 0; i < layers.length; i++) {
        GSI.Utils.sendSelectedLayer(layers[i].id);
      }
    }

    if (lcd != ""){
      this._gsimaps._mainMap._layersJSON.initialize_layers_data(layers);
      this._gsimaps._mainMap._mapMenu.getMapListPanel().setLayers(layers);
      this._gsimaps._mainMap._mapMenu.getMapListPanel().setCurrentPath(lcd);
      this._gsimaps._mainMap._mapMenu.getShowingMapListPanel().refresh(this._gsimaps._mainMap._layersJSON.visibleLayers);
    }
    else{
      this._gsimaps._mainMap._layersJSON.initialize_layers_data(layers);
      this._gsimaps._mainMap._mapMenu.getShowingMapListPanel().refresh(this._gsimaps._mainMap._layersJSON.visibleLayers);  
    }

    var viewSetting = this._gsimaps._queryParams.getViewSetting();
    try {
      // 表示設定：中心十字線           vs=c[0/1]
      this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.CENTERCROSS].obj.setVisible(viewSetting.centerCross);
      // 表示設定：表示ズームの案内           vs=g[0/1]
      this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.ZOOMGUIDE].obj.setVisible(viewSetting.zoomGuide);
      // 表示設定：磁北線               vs=j[0/1]
      this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.JIHOKULINE].obj.setVisible(viewSetting.jihokuLine);
      // 表示設定：緯度経度グリッド     vs=l[0/1]
      this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.LATLNGGRID].obj.setVisible(viewSetting.latLngGrid);
      // 表示設定：UTMグリッド          vs=u[0/1]
      this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.UTMGRID].obj.setVisible(viewSetting.utmGrid);
      // 表示設定：タイルグリッド          vs=t[0/1]
      this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.TILEGRID].obj.setVisible(viewSetting.tileGrid);
      // 表示設定：図郭グリッド          vs=z[0/1]
      this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.T25000GRID].obj.setVisible(viewSetting.t25000Grid);
      // 表示設定：地域メッシュ          vs=r[0/1]
      this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.CHIIKIMESH].obj.setVisible(viewSetting.chiikiMesh);
      // 表示設定：等距圏          vs=k[0/1]
      this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.TOUKYOKEN].obj.setVisible(viewSetting.toukyoKen);
      // 表示設定：方位線          vs=h[0/1]
      this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.HOUILINE].obj.setVisible(viewSetting.houiLine);

      // 表示設定：国土基本図図郭          vs=a[0/1]
      if (!CONFIG.DISABLE_KOKUDOKIHONZUZUKAKU)
        this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.KOKUDOKIHONZUKAKU].obj.setVisible(viewSetting.kokudokihonzukaku);

      // 表示設定：コンテキストメニュー vs=f[0/1]
      this._gsimaps._onoffObjects[CONFIG.PARAMETERNAMES.FOOTER].obj.setVisible(viewSetting.footer);

      // 左パネル
      if (this._gsimaps._queryParams.getLeftPanelVisible()) {
        this._gsimaps._mainMap._mapMenu.showPanel();
      }
      else {
        this._gsimaps._mainMap._mapMenu.hidePanel();
      }

    }
    catch (e) {
      console.log(e);
    }

    this._gsimaps._mainMap._mapLayerList.setElevationData(this._gsimaps._queryParams.getReliefData());
    if (this._gsimaps._mainMap._mapLayerList._editReliefDialog) {
      this._gsimaps._mainMap._mapLayerList._editReliefDialog.refresh();
    }

    if (viewSetting.splitWindow || viewSetting.compareMap) {
      var sync = this._gsimaps._queryParams._syncSplitedMap;
      if (viewSetting.splitWindow) {
        // 2画面
        if (!this._gsimaps.splited()) {
          this._gsimaps.split(true);
        }
      } else if (viewSetting.compareMap) {
        // 比較
        if (!this._gsimaps.compared()) {
          this._gsimaps.comparison(true);
        }
      }

      this._gsimaps._subMap._syncControl.set(sync);

      var base2 = this._gsimaps._queryParams.getBaseMap2();

      this._gsimaps._subMap._baseLayer.setActiveId(base2);
      // base_grayscale=
      this._gsimaps._subMap._baseLayer.setGrayScale(this._gsimaps._queryParams.getBaseMapGrayScale2());

      // 基本設定：表示中のレイヤーを共有
      // ls=
      //  +
      // 選択中の情報設定
      // disp=
      var layers2 = this._gsimaps._queryParams.getLayers2();
      var lcd2 = this._gsimaps._queryParams.getCurrentPath2();

      if (lcd2 != ""){
        this._gsimaps._subMap._layersJSON.initialize_layers_data(layers2);
        this._gsimaps._subMap._mapMenu.getMapListPanel().setLayers(layers2);
        this._gsimaps._subMap._mapMenu.getMapListPanel().setCurrentPath(lcd2);
        this._gsimaps._subMap._mapMenu.getShowingMapListPanel().refresh(this._gsimaps._subMap._layersJSON.visibleLayers);
      }
      else{
        this._gsimaps._subMap._layersJSON.initialize_layers_data(layers2);
        this._gsimaps._subMap._mapMenu.getShowingMapListPanel().refresh(this._gsimaps._subMap._layersJSON.visibleLayers);  
      }
  
      this._gsimaps._subMap._mapLayerList.setElevationData(this._gsimaps._queryParams.getReliefData2());
      if (this._gsimaps._subMap._mapLayerList._editReliefDialog) {
        this._gsimaps._subMap._mapLayerList._editReliefDialog.refresh();
      }
    }
    else {
      // 2画面解除
      if (this._gsimaps.splited()) {
        this._gsimaps.split(false);
      }
      // 比較解除
      if (this._gsimaps.compared()) {
        this._gsimaps.comparison(false);
      }
    }
  },
  forEvacuation: function (options) {

    var disp = "";
    var ops = {};
    var op = options.split("&");
    for (var i = 0; i < op.length; i++) {
      var it = op[i].split("=");
      ops[it[0]] = it[1];
    }

    if (ops["disp"]) {
      //逆順に並べておく
      for (var i = ops["disp"].length - 1; i >= 0; i--) {
        disp += ops["disp"].charAt(i);
      }
      ops["disp"] = "";
    }
    this._gsimaps._mainMap._confirmDlg.onPositiveButtonClick = L.bind(this.evacuationConfirmOK, this, ops, disp);
    this._gsimaps._mainMap._confirmDlg.onNegativeButtonClick = L.bind(this.evacuationConfirmCancel, this, ops, disp);

    if (ops["ls"].indexOf(CONFIG.layerEvacuationHeader) < 0) {
      this._gsimaps._mainMap._evacDialog.hide();
      HashSetProc_sub(options);
    }
    else {
      var ls = ops["ls"].split("%7C");
      if (CONFIG.layerEvacuationIsConfirmOK == false) {
        this._gsimaps._mainMap._confirmDlg.show();
      }
      else {
        this.evacuationConfirmOK(ops, disp);
      }
    }
  },
  evacuationConfirmOK: function (ops, disp) {
    var wrongls = false;
    if (ops["ls"]) {
      var ls = ops["ls"].split("%7C");
      if (ls) {
        if (disp.length < ls.length) GSI.Utils.rpad(disp, "0", ls.length);

        if (ops["lcd"] && ops["lcd"].indexOf(CONFIG.layerEvacuationHeader) >= 0) {
          var cc = 0;
          //with lcd
          for (var i = ls.length - 1; i >= 0; i--) {

            if ((ops["lcd"] != ls[i]) && (ls[i].indexOf(CONFIG.layerEvacuationHeader) >= 0)) {
              ls.splice(i, 1);
              wrongls = true;
            }
            else {
              ops["disp"] += disp.charAt(i);
            }
          }
        }
        else {
          var dct;
          for (var i = ls.length - 1; i >= 0; i--) {
            if (ls[i].indexOf(CONFIG.layerEvacuationHeader) >= 0) {
              if (dct > 0) {
                ls.splice(i, 1);
                wrongls = true;
              }
              else {
                ops["disp"] += disp.charAt(i);
                dct++;
              }
            }
            else {
              if (disp.charAt(i)) {
                ops["disp"] += disp.charAt(i);
              }
            }
          }
        }
        ops["ls"] = ls.join("%7C");
      }
    }
    var newop = "";
    for (var key in ops) {
      if (ops[key])
        newop += (key + "=" + ops[key] + "&");
      else
        newop += (key + "&");
    }
    if (wrongls == true) {
      location.hash = newop;
    }
    else {
      this.HashSetProc_sub(newop.substring(0, newop.length - 1));
    }
    this._gsimaps._mainMap._confirmDlg.hide();
    if (this._gsimaps._mainMap._dialogManager.isVisibleDialog(this._gsimaps._mainMap._evacDialog) == false) {
      this._gsimaps._mainMap._evacDialog.show();
    }
  },
  evacuationConfirmCancel: function (ops, disp) {
    if (ops["ls"]) {
      var ls = ops["ls"].split("%7C");
      if (ls) {
        if (disp.length < ls.length) GSI.Utils.rpad(disp, "0", ls.length);

        for (var i = ls.length - 1; i >= 0; i--) {
          if (ls[i].indexOf(CONFIG.layerEvacuationHeader) >= 0) {
            ls.splice(i, 1);
          }
          else {
            if (disp.charAt(i)) {
              ops["disp"] += disp.charAt(i);
            }
          }
        }
        ops["ls"] = ls.join("%7C");
      }
      if (ops["lcd"]) {
        if (ops["lcd"].indexOf(CONFIG.layerEvacuationHeader) >= 0) {
          ops["lcd"] = null;
        }
      }
    }
    var newop = "";
    for (var key in ops) {
      if (ops[key])
        newop += (key + "=" + ops[key] + "&");
      else
        newop += (key + "&");
    }
    location.hash = newop;
    this._gsimaps._mainMap._confirmDlg.hide();
  },

  baseHashCheck: function(hash) {
    // 202303
    // baseMapの状況に応じてhashを書き換える。
    var baseDisp = this._checkBaseDispParams(hash);

    if (!baseDisp) {
      for(var i=0; i < CONFIG.BASEMAPLIST.length; i++) {
        var baseOption = '&base=';
        baseOption += CONFIG.BASEMAPLIST[i].id;
        if (hash.indexOf(baseOption) != -1) {
          hash= hash.replace(baseOption, '');
        }
      }
    } else {
      // baseMapが表示されていて&base=がハッシュに存在せず、ls=baseMapが存在する場合は&base=を追加する。
      if (this._gsimaps._queryParams._baseMap) {
        var baseOption = '/&base=';

        if (this._gsimaps._queryParams._baseMap) {
          var lsOption = '&ls=' + this._gsimaps._queryParams._baseMap;
          // &baseをチェック
          if (hash.indexOf(baseOption) == -1) {
            // &lsをチェック
            if (hash.indexOf(lsOption) != -1) {
              baseOption += this._gsimaps._queryParams._baseMap;
              baseOption += '&';
              hash= hash.replace('/&', baseOption);
            }
          }

        }

      }
  }

    return hash;
  }, 
  _checkBaseDispParams: function(hash) {
    // lsの値とdispの値からbaseのdispを判断する。
    // 202303 baseMap非表示時にlsからbaseMapを取得する。

    var params = this._gsimaps._queryParams._parse(hash);
    var layers = (params["ls"]) ? this._gsimaps._queryParams.params["ls"].split('|') : null;
    var disp = params["disp"];

    if (layers && disp) {
        
      for (var i = 0; i < layers.length; i++) {
        if (((layers[i]) ? layers[i].trim() : '') == '') continue;
        var parts = layers[i].split(',');

        if (CONFIG.BASETILES.length >= 1) {

          for (n = 0; n < CONFIG.BASETILES.length; n++) {
            if (CONFIG.BASETILES[n].id == parts[0]) {

              if (disp.length > i && disp.charAt(i) == '0') {
                  return false;
              } else {
                  return true;
              }

            }
          }
        }

      }
      
    }

    return false;
  }

});

/************************************************************************
 L.Class
 - GSI.QueryParams

　GETパラメータ||ハッシュll 10進経度,10進経度
  z    ズームレベル
  base ベース
  hc   隠す機能
  vs   表示設定の値
  ls   表示するレイヤー
  skz  作図レイヤー
************************************************************************/
GSI.QueryParams = L.Class.extend({

  _controlSetting: {
    infoMenu: { visible: true },
    funcMenu: { visible: true },
    header: { visible: true },
    contextMenu: { visible: true },
    baseMapSelector: { visible: true }
  },
  _viewSetting: {
    centerCross: true,
    zoomGuide: true,
    latLngGrid: false,
    utmGrid: false,
    tileGrid: false,
    t25000Grid: false,
    kokudokihonzukaku: false,
    chiikiMesh: false,
    jihokuLine: false,
    toukyoken: false,
    houiLine: false,
    miniMap: false,
    footer: 1
  },
  _viewSetting2: {
    footer: 1
  },
  _layers: [],
  _viewListDialogVisible: false,
  _layerTreeDialogVisible: false,

  initialize: function (options) {

    var locationHash = location.hash;
    if (CONFIG.USECOOKIE) {
      if (!locationHash || locationHash == "" || locationHash == "#" ||
        locationHash.match(CONFIG.DEFAULTHASH)) {
        locationHash = Cookies.get(CONFIG.COOKIEKEY_HASH);
        if (!locationHash) locationHash = "";
      }
    } else {
      //$.cookie("GSIMAPS-HASH", "");
    }

    var queryStrings = (options && options.queryString ? options.queryString : window.location.search);
    var vHashLocation = locationHash;
    var vHashOptions = "";
    var vHash = vHashLocation.split("/&");
    if (vHash.length == 2) {
      vHashLocation = vHash[0];
      vHashOptions = vHash[1];
    }

    queryStrings += (queryStrings != "" ? "&" : "") + vHashOptions;

    this._f_queryLocation = queryStrings;
    this._f_queryOptions = vHashOptions;
    this._f_queryStrings = queryStrings + vHashLocation;
    this.initialize_proc(queryStrings);
  },

  initialize_proc: function (queryStrings) {
    this._baseMap = "";
    this._baseMapDisp = true;

    this.params = this._parse(queryStrings);
    try { this._initPosition(); } catch (e) { }
    try { this._initBaseMap(); } catch (e) { }
    try { this._initBaseMap2(); } catch (e) { }
    try { this._initControlSetting(); } catch (e) { }
    try { this._initViewSetting(); } catch (e) { }
    try { this._initViewSetting2(); } catch (e) { }
    try { this._initLayerList(); } catch (e) { }
    try { this._initLayerList2(); } catch (e) { }
    try { this._initDialogSettings(); } catch (e) { }
    try { this._initSyncSplitedMap(); } catch (e) { }
    try { this._initReliefData(); } catch (e) { }
    try { this._initReliefData2(); } catch (e) { }
    try { this._initToukyokenCenter(); } catch (e) { }
    try { this._initHouilineCenter(); } catch (e) { }

  },

  getInit: function () {
    var args = this._parse(window.location.search);

    var ret = true;
    if (args["postmessage"] && args["postmessage"] == "1") {
      ret = false;
    }

    return ret;
  },
  getToukyokenCenter: function() {
    return this._toukyokenCenter;
  },
  getHouilineCenter: function() {
    return this._houilineCenter;
  },

  getReliefData: function () {
    return this._reliefData;
  },
  getReliefData2: function () {
    return this._reliefData2;
  },
  getPosition: function (defaultPosition) {
    return (this._position ? this._position : defaultPosition);
  },
  getPosition2: function (defaultPosition) {
    return (this._position2 ? this._position2 : defaultPosition);
  },
  getSyncSplitedMap: function () {
    return this._syncSplitedMap;
  },
  getZoom: function (defaultZoom) {
    return (this._zoom ? this._zoom : defaultZoom);
  },
  getZoom2: function (defaultZoom) {
    return (this._zoom2 ? this._zoom2 : defaultZoom);
  },
  getBaseMap: function () {
    this._initBaseMapExist();
    var ret = "";
    if (this._baseMap) {
      ret = this._baseMap;
    }
    return ret;
  },
  getBaseMapDisp: function () {
    var ret = this._baseMapDisp;

    return ret;
  },
  getBaseMapGrayScale: function () {
    return this._baseMapGrayScale;
  },
  getLayers: function () {
    return this._layers;
  },

  getBaseMap2: function () {
    this._initBaseMapExist2();
    var ret = "";
    if (this._baseMap2) {
      ret = this._baseMap2;
    }
    return ret;
  },
  getBaseMapDisp2: function () {
    var ret = this._baseMapDisp2;

    return ret;
  },
  getBaseMapGrayScale2: function () {
    return this._baseMapGrayScale2;
  },
  getLayers2: function () {
    return this._layers2;
  },
  getLeftPanelVisible: function () {
    return this._leftPanelVisible;
  },

  getLeftPanel2Visible: function () {
    return this._leftPanel2Visible;
  },
  getViewListDialogVisible: function () {
    return this._viewListDialogVisible;
  },
  getLayerTreeDialogVisible: function () {
    return this._layerTreeDialogVisible;
  },
  getViewListDialog2Visible: function () {
    return this._viewListDialog2Visible;
  },
  getLayerTreeDialog2Visible: function () {
    return this._layerTreeDialog2Visible;
  },
  getCurrentPath: function () {
    var cd = "";
    if (this.params["lcd"]) {
      cd = this.params["lcd"];
    }

    return cd;
  },
  getCurrentPath2: function () {
    var cd = "";
    if (this.params["lcd2"]) {
      cd = this.params["lcd2"];
    }

    return cd;
  },
  getControlSetting: function () {
    return this._controlSetting;
  },
  getViewSetting: function () {
    return this._viewSetting;
  },
  getViewSetting2: function () {
    return this._viewSetting2;
  },
  _initPosition: function () {
    if (this.params["ll"]) {
      var latLng = this.params["ll"].split(',');

      if (latLng.length >= 2) {
        if (
          (latLng[0].match(/^-?[0-9]+\.[0-9]+$/) || latLng[0].match(/^-?[0-9]+$/))
          &&
          (latLng[1].match(/^-?[0-9]+\.[0-9]+$/) || latLng[1].match(/^-?[0-9]+$/))
        ) {
          this._position = [
            parseFloat(latLng[0]),
            parseFloat(latLng[1])
          ];
        }
      }

      if (latLng.length >= 3) {
        if (latLng[2] && latLng[2].match(/^[0-9]+$/))
          this._zoom = parseInt(latLng[2]);
      }
    }

    // ズーム
    if (this.params["z"] && this.params["z"].match(/^[0-9]+$/))
      this._zoom = parseInt(this.params["z"]);
    if (this._zoom && (this._zoom < 1 || this._zoom > 18)) {
      this._zoom = null;
    }

    if (this.params["ll2"]) {
      var latLng = this.params["ll2"].split(',');

      if (latLng.length >= 2) {
        if (
          (latLng[0].match(/^-?[0-9]+\.[0-9]+$/) || latLng[0].match(/^-?[0-9]+$/))
          &&
          (latLng[1].match(/^-?[0-9]+\.[0-9]+$/) || latLng[1].match(/^-?[0-9]+$/))
        ) {
          this._position2 = [
            parseFloat(latLng[0]),
            parseFloat(latLng[1])
          ];
        }
      }

      if (latLng.length >= 3) {
        if (latLng[2] && latLng[2].match(/^[0-9]+$/))
          this._zoom2 = parseInt(latLng[2]);
      }
    }
    // ズーム2
    if (this.params["z2"] && this.params["z2"].match(/^[0-9]+$/))
      this._zoom2 = parseInt(this.params["z2"]);
    if (this._zoom2 && (this._zoom < 1 || this._zoom > 18)) {
      this._zoom2 = null;
    }

  },
  _initBaseMap: function () {
    if (this._baseMap) {
      this._baseMap = "";
    }
    var fBaseMap = true;
    if (this._f_queryStrings == "" || (this._f_queryOptions.lastIndexOf("base") == -1 && this._f_queryOptions.lastIndexOf("=") == -1)) {
      fBaseMap = false;
    }

    this._baseMapGrayScale = false;

    if (this.params["base"]) {
      this._baseMap = this.params["base"];
      if (this._baseMap != "") {
        fBaseMap = true;
      }
    } else {
      // 202303 baseMap非表示時にlsからbaseMapを取得する。
      var layers = (this.params["ls"]) ? this.params["ls"].split('|') : null;
      var disp = this.params["disp"];

      if (layers && disp) {
        
        for (var i = 0; i < layers.length; i++) {
          if (((layers[i]) ? layers[i].trim() : '') == '') continue;
          var parts = layers[i].split(',');
  
          if (0 < CONFIG.BASETILES.length) {
            for (n = 0; n < CONFIG.BASETILES.length; n++) {
              if (CONFIG.BASETILES[n].id == parts[0]) {
                if (disp.length > i) {
                  // 個々の設定自体は無条件にしてもOK
                  this._baseMap = parts[0];
                  fBaseMap = true;
                  break;
                  }
              }
            }
          }
  
        }
        
      }

    }

    if (!fBaseMap) {
      this.params["base"] = CONFIG.layerBaseDefaultID;
      this._initBaseMap();
    }
    if (this.params["base_grayscale"]) {
      if (this.params["base_grayscale"] == "1") {
        this._baseMapGrayScale = true;
      }
    }

    this._initBaseMapExist();
  },

  _initBaseMap2: function () {
    if (this._baseMap2) {
      this._baseMap2 = "";
    }

    var fBaseMap = true;
    if (this._f_queryStrings == "" || (this._f_queryOptions.lastIndexOf("base2") == -1 && this._f_queryOptions.lastIndexOf("=") == -1)) {
      fBaseMap = false;
    }

    this._baseMapGrayScale2 = false;

    if (this.params["base2"]) {
      this._baseMap2 = this.params["base2"];
      if (this._baseMap2 != "") {
        fBaseMap = true;
      }
    } else {
      // 202303 baseMap非表示時にls2からbaseMap2を取得する。
      var layers = (this.params["ls2"]) ? this.params["ls2"].split('|') : null;
      var disp = this.params["disp2"];

      if (layers && disp) {
        
        for (var i = 0; i < layers.length; i++) {
          if (((layers[i]) ? layers[i].trim() : '') == '') continue;
          var parts = layers[i].split(',');
  
          if (0 < CONFIG.BASETILES.length) {
            for (n = 0; n < CONFIG.BASETILES.length; n++) {
              if (CONFIG.BASETILES[n].id == parts[0]) {
  
                if (disp.length > i) {
                  this._baseMap2 = parts[0];
                  fBaseMap = true;
                  break;
                  }
              }
            }
          }
  
        }
        
      }

    }

    if (!fBaseMap) {
      this.params["base2"] = CONFIG.layerBaseDefaultID;
      this._initBaseMap2();
    }
    if (this.params["base_grayscale2"]) {
      if (this.params["base_grayscale2"] == "1") {
        this._baseMapGrayScale2 = true;
      }
    }

    this._initBaseMapExist2();
  },

  _initBaseMapExist: function () {
    if (this._baseMap != "") {
      var fBaseMapExists = true;
      if (this._f_queryStrings != "") {
        if (CONFIG.BASETILES.length > 0) {
          fBaseMapExists = false;
          for (n = 0; n < CONFIG.BASETILES.length; n++) {
            if (CONFIG.BASETILES[n].id == this._baseMap) {
              fBaseMapExists = true;
              break;
            }
          }
        }
      }
      if (!fBaseMapExists) {
        this._baseMap = "";
      }
    }
  },

  _initBaseMapExist2: function () {
    if (this._baseMap2 != "") {
      var fBaseMapExists = true;
      if (this._f_queryStrings != "") {
        if (CONFIG.BASETILES.length > 0) {
          fBaseMapExists = false;
          for (n = 0; n < CONFIG.BASETILES.length; n++) {
            if (CONFIG.BASETILES[n].id == this._baseMap2) {
              fBaseMapExists = true;
              break;
            }
          }
        }
      }
      if (!fBaseMapExists) {
        this._baseMap2 = "";
      }
    }
  },

  _initLayerList: function (num) {
    var fBaseMap = true;
    var vParams = "";

    if (!this._baseMap) {
      fBaseMap = false;
    }

    this._layers = [];
    if (this.params["ls"]) {
      vParams = this.params["ls"];

      var disp = this.params["disp"];

      var layers = this.params["ls"].split('|');

      var blds = this.params["blend"];

      // urlのgeojsonとkmlの読み込み
      for (var i = 0; i <= 5; i++) {
        var url = "url" + i;
        if (this.params[url]) {
          if (GSI.FILEURL[url] != this.params[url]) {
            GSI.FILEURL[url] = this.params[url];
            getFileeData(GSI.FILEURL[url], url);
          }
        }
      }

      for (var i = 0; i < layers.length; i++) {
        if (((layers[i]) ? layers[i].trim() : '') == '') continue;
        var parts = layers[i].split(',');
        var $hdn = false;

        var bld = "0";
        if (i > 0) {
          if (blds)
            bld = (blds ? blds.charAt(i - 1) : "0");
          else {
            if (parts[0].indexOf("relief") >= 0)
              bld = "1";
          }
        }
        if (disp && disp.length > i) {
          if (disp.charAt(i) == '0') {
            $hdn = true;
          }
          else {
            $hdn = false;
          }
        }
        else {
          $hdn = false;
        }

        var vID = parts[0];
        if (CONFIG.BASETILES.length == 0) {
        }
        else {
          for (n = 0; n < CONFIG.BASETILES.length; n++) {
            if (CONFIG.BASETILES[n].id == parts[0]) {
              vID = this._baseMap;
              break;
            }
          }
        }

        if (!this._baseMap) {
          if (i == 0) {
            this._baseMap = vID;
          }
        }

        if (vID == this._baseMap) {
          fBaseMap = false;
          this._baseMap = vID;
          this._baseMapDisp = !$hdn;
        }

        var layerData = {
          id: vID,
          opacity: 1,
          hidden: $hdn,
          blend: bld
        };

        if (parts.length >= 2) {
          var opacity = parts[1];
          if (!isNaN(opacity)) {
            opacity = parseFloat(opacity);
            if (opacity >= 0.0 && opacity <= 1.0)
              layerData.opacity = opacity;
          }
        }
        this._layers.push(layerData);
      }
    }

    if (fBaseMap && this._baseMap != "") {
      this.params["ls"] = this._baseMap;
      if (vParams != "") {
        this.params["ls"] += '|' + vParams;
      }
      this._initLayerList();
    }

    this._initBaseMapExist();
  },

  _initLayerList2: function (num) {
    var fBaseMap = true;
    var vParams = "";

    if (!this._baseMap2) {
      fBaseMap = false;
    }

    this._layers2 = [];
    if (this.params["ls2"]) {
      vParams = this.params["ls2"];

      var disp = this.params["disp2"];

      var layers = this.params["ls2"].split('|');

      var blds = this.params["blend2"];

      for (var i = 0; i < layers.length; i++) {
        if (((layers[i]) ? layers[i].trim() : '') == '') continue;
        var parts = layers[i].split(',');
        var $hdn = false;

        var bld = "0";
        if (i > 0) {
          if (blds)
            bld = (blds ? blds.charAt(i - 1) : "0");
          else {
            if (parts[0].indexOf("relief") >= 0)
              bld = "1";
          }
        }
        if (disp && disp.length > i) {
          if (disp.charAt(i) == '0') {
            $hdn = true;
          }
          else {
            $hdn = false;
          }
        }
        else {
          $hdn = false;
        }

        var vID = parts[0];
        if (CONFIG.BASETILES.length == 0) {
        }
        else {
          for (n = 0; n < CONFIG.BASETILES.length; n++) {
            if (CONFIG.BASETILES[n].id == parts[0]) {
              vID = this._baseMap2;
              break;
            }
          }
        }

        if (!this._baseMap2) {
          if (i == 0) {
            this._baseMap2 = vID;
          }
        }

        if (vID == this._baseMap2) {
          fBaseMap = false;
          this._baseMap2 = vID;
          this._baseMapDisp2 = !$hdn;
        }

        var layerData = {
          id: vID,
          opacity: 1,
          hidden: $hdn,
          blend: bld
        };

        if (parts.length >= 2) {
          var opacity = parts[1];
          if (!isNaN(opacity)) {
            opacity = parseFloat(opacity);
            if (opacity >= 0.0 && opacity <= 1.0)
              layerData.opacity = opacity;
          }
        }
        this._layers2.push(layerData);
      }
    }

    if (fBaseMap && this._baseMap2 != "") {
      this.params["ls2"] = this._baseMap2;
      if (vParams != "") {
        this.params["ls2"] += '|' + vParams;
      }
      this._initLayerList2();
    }

    this._initBaseMapExist2();
  },

  _initControlSetting: function () {
    if (this.params["hc"]) {
      var ctrl = this.params["hc"];
      if (ctrl.toLowerCase() == CONFIG.HIDDENCONTROLPARAMETER.ALL) {
        this._controlSetting = {
          infoMenu: { visible: false },
          funcMenu: { visible: false },
          header: { visible: false },
          contextMenu: { visible: false },
          baseMapSelector: { visible: false }
        };
      }
      else {
        for (var i = 0; i < ctrl.length; i++) {
          switch (ctrl.charAt(i).toLowerCase()) {
            case CONFIG.HIDDENCONTROLPARAMETER.INFOMENU:
              // 情報メニュー
              this._controlSetting.infoMenu.visible = false;
              break;

            case CONFIG.HIDDENCONTROLPARAMETER.FUNCMENU:
              // 機能メニュー
              this._controlSetting.funcMenu.visible = false;
              break;
            case CONFIG.HIDDENCONTROLPARAMETER.HEADER:
              // ヘッダー
              this._controlSetting.header.visible = false;
              break;

            case CONFIG.HIDDENCONTROLPARAMETER.CONTEXTMENU:
              // コンテキストメニュー
              this._controlSetting.contextMenu.visible = false;
              break;

            case CONFIG.HIDDENCONTROLPARAMETER.BASEMAPSELECTOR:
              // ベースマップセレクター
              this._controlSetting.baseMapSelector.visible = false;
              break;
          }
        }
      }
    }
  },
  _initViewSetting: function () {
    if (this.params["vs"]) {
      var vs = this.params["vs"];

      for (var i = 0; i < vs.length; i += 2) {
        if (vs.length - 1 == i) break;
        var key = vs.charAt(i);
        var value = vs.charAt(i + 1);

        for (var qpKey in CONFIG.QUERYPARAMETER) {
          if (CONFIG.QUERYPARAMETER[qpKey].prefix == key) {

            if (CONFIG.QUERYPARAMETER[qpKey].settingName == "footer") {
              if (value == "1" || value == "2")
                this._viewSetting[CONFIG.QUERYPARAMETER[qpKey].settingName] = parseInt(value);
              else
                this._viewSetting[CONFIG.QUERYPARAMETER[qpKey].settingName] = 0;

            }
            else {
              this._viewSetting[CONFIG.QUERYPARAMETER[qpKey].settingName] = (value == "1");
            }
            break;
          }
        }
      }
    }
  },
  _initViewSetting2: function () {
    if (this.params["vs2"]) {
      var vs = this.params["vs2"];

      for (var i = 0; i < vs.length; i += 2) {
        if (vs.length - 1 == i) break;
        var key = vs.charAt(i);
        var value = vs.charAt(i + 1);

        for (var qpKey in CONFIG.QUERYPARAMETER) {
          if (CONFIG.QUERYPARAMETER[qpKey].prefix == key) {

            if (CONFIG.QUERYPARAMETER[qpKey].settingName == "footer") {
              if (value == "1" || value == "2")
                this._viewSetting2[CONFIG.QUERYPARAMETER[qpKey].settingName] = parseInt(value);
              else
                this._viewSetting2[CONFIG.QUERYPARAMETER[qpKey].settingName] = 0;

            }

            break;
          }
        }
      }
    }
  },
  _initDialogSettings: function () {
    this._viewListDialogVisible = false;
    this._layerTreeDialogVisible = false;
    this._leftPanelVisible = undefined;
    this._viewListDialog2Visible = false;
    this._layerTreeDialog2Visible = false;
    this._leftPanel2Visible = undefined;

    if (this.params["d"]) {
      var d = this.params["d"];

      for (var i = 0; i < d.length; i++) {
        var id = d.charAt(i);
        switch (id) {
          case CONFIG.DIALOGPARAMETER.VIEWLISTDIALOG:
            this._viewListDialogVisible = true;
            break;

          case CONFIG.DIALOGPARAMETER.LAYERTREEDIALOG:
            this._layerTreeDialogVisible = true;
            break;

          case CONFIG.DIALOGPARAMETER.LEFTPANEL:
            this._leftPanelVisible = true;
            break;

        }
      }
    }

    if (this._leftPanelVisible == undefined) {
      this._leftPanelVisible = (this._viewListDialogVisible | this._layerTreeDialogVisible);
    }

    if (this.params["d2"]) {
      var d = this.params["d2"];

      for (var i = 0; i < d.length; i++) {
        var id = d.charAt(i);
        switch (id) {
          case CONFIG.DIALOGPARAMETER.VIEWLISTDIALOG:
            this._viewListDialog2Visible = true;
            break;

          case CONFIG.DIALOGPARAMETER.LAYERTREEDIALOG:
            this._layerTreeDialog2Visible = true;
            break;

          case CONFIG.DIALOGPARAMETER.LEFTPANEL:
            this._leftPanel2Visible = true;
            break;

        }
      }
    }

    if (this._leftPanel2Visible == undefined) {
      this._leftPanel2Visible = (this._viewListDialog2Visible | this._layerTreeDialog2Visible);
    }
  },

  _initSyncSplitedMap: function () {
    this._syncSplitedMap = true;
    if (this.params["sync"] && this.params["sync"] == "0")
      this._syncSplitedMap = false;
  },

  _initReliefData: function () {
    var reliefData = this.params["reliefdata"];
    if (reliefData)
      this._reliefData = GSI.ReliefTileLayer.decodeElevationDataText(reliefData);

  },
  _initReliefData2: function () {
    var reliefData = this.params["reliefdata2"];
    if (reliefData)
      this._reliefData2 = GSI.ReliefTileLayer.decodeElevationDataText(reliefData);

  },

  _initToukyokenCenter:function() {
    var center = this.params["tpos"]
    if (!center) return;

    const parts = center.split(",");
    if ( parts.length != 2 ) return;

    if (
      (parts[0].match(/^-?[0-9]+\.[0-9]+$/) || parts[0].match(/^-?[0-9]+$/))
      &&
      (parts[1].match(/^-?[0-9]+\.[0-9]+$/) || parts[1].match(/^-?[0-9]+$/))
    ) {
      this._toukyokenCenter = L.latLng( parseFloat(parts[0]), parseFloat(parts[1]));
    }
  },
  _initHouilineCenter: function() {
    var center = this.params["hpos"];
    if (!center) return;

    const parts = center.split(",");
    if ( parts.length != 2 ) return;

    if (
      (parts[0].match(/^-?[0-9]+\.[0-9]+$/) || parts[0].match(/^-?[0-9]+$/))
      &&
      (parts[1].match(/^-?[0-9]+\.[0-9]+$/) || parts[1].match(/^-?[0-9]+$/))
    ) {
      this._houilineCenter = L.latLng( parseFloat(parts[0]), parseFloat(parts[1]));
    }
  },

  _parse: function (queryString, separator) {
    var result = {};
    if (1 < queryString.length) {
      var query = (queryString.charAt(0) == '?' ? queryString.substring(1) : queryString);

      var parameters = query.split('&');

      for (var i = 0; i < parameters.length; i++) {
        try {
          var element = parameters[i].split('=');

          var paramName = decodeURIComponent(element[0]);
          var paramValue = decodeURIComponent(element[1]);
          result[paramName] = paramValue;
        }
        catch (e) {

        }
      }
    }
    return result;
  }
});

/*******************************************************
 GSI.DEMLoader
    標高タイル読込
    自分で作る色別標高図などで利用
    3D版は別ファイル（leafletの機能を使わない）
*******************************************************/
GSI.DEMLoader = L.Evented.extend({

  _hillshademapUrl: 'https://cyberjapandata.gsi.go.jp/xyz/hillshademap/{z}/{x}/{y}.png',

  options: {
    minZoom: 8,
    overZooming: true,
    useHillshademap: false,
    tms: false
  },

  // 初期化
  initialize: function (map, x, y, z, urlList, options) {

    if (!GSI.DEMLoader.pow2_8) {
      // 利用するべき乗キャッシュ
      GSI.DEMLoader.pow2_8 = Math.pow(2, 8);
      GSI.DEMLoader.pow2_16 = Math.pow(2, 16);
      GSI.DEMLoader.pow2_23 = Math.pow(2, 23);
      GSI.DEMLoader.pow2_24 = Math.pow(2, 24);
    }

    this._map = map;

    this._coords = {
      x: x,
      y: y,
      z: z
    };

    L.setOptions(this, options);

    this._urlList = urlList;
  },

  // 表示に必要な範囲
  _pxBoundsToTileRange: function (bounds) {
    var tileSize = 256;
    return new L.Bounds(
      bounds.min.unscaleBy(tileSize).floor(),
      bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
  },

  // 後始末、破棄
  destroy: function () {
    if (this._demImage) {
      this._demImage.onload = null;
      this._demImage.onerror = null;
      $(this._demImage).off("load").off("error");
      delete this._demImage;
      this._demImage = null;
    }

    if (this._hillshademapImage) {
      this._hillshademapImage.onload = null;
      this._hillshademapImage.onerror = null;
      $(this._hillshademapImage).off("load").off("error");
      delete this._hillshademapImage;
      this._hillshademapImage = null;
    }

    if (this._demData) {
      delete this._demData;
      this._demData = null;
    }
    if (this._demInfo) {
      delete this._demInfo;
      this._demInfo = null;
    }
  },

  // 読み込んだデータ
  getData: function () {
    return this._demData;
  },
  // 読み込んだデータの情報
  getInfo: function () {
    return this._demInfo;
  },

  // 読み込んだ陰影画像
  getHillshademapImage: function () {
    return (this._hillshademapLoaded && !this._hillshademapError ? this._hillshademapImage : null);
  },

  // 読み込み開始
  load: function () {

    if (!this._globalTileRange) {
      var bounds = this._map.getPixelWorldBounds(this._tileZoom);
      if (bounds) {
        this._globalTileRange = this._pxBoundsToTileRange(bounds);
      }
    }

    this._demData = null;
    this._demInfo = null;
    this._demLoaded = false;
    this._currentCoords = $.extend(true, {}, this._coords);

    if (!this._urlList) {
      this._urlList = GSI.DEMLoader.getURLList(this._coords.x, this._coords.y, this._coords.z);
    }

    this._urlList = this._makeUrlList(this._urlList);

    this._startLoadDEM(this._currentCoords);
    if (this.options.useHillshademap) {
      this._loadHillshademap(this._currentCoords);
    }

  },

  _makeUrlList: function (list) {
    var zoomList = [];
    for (var i = 0; i < 20; i++) {
      zoomList.push([]);
    }
    for (var i = 0; i < list.length; i++) {
      for (var z = list[i].maxZoom; z >= list[i].minZoom; z--) {
        var item = $.extend(true, {}, list[i]);
        item.minZoom = z;
        item.maxZoom = z;
        zoomList[z].push(item);
      }
    }

    if (!this.options.useTileList) {
      this.options.useTileList = ["DEM5A", "DEM5B", "DEM5C", "DEM10B", "DEMGM"];
    }

    var useTileList = this.options.useTileList;

    var result = [];
    for (var z = zoomList.length - 1; z >= 0; z--) {
      for (var i = 0; i < zoomList[z].length; i++) {
        var item = zoomList[z][i];
        if (useTileList.indexOf(item.id) >= 0) {
          if (item.complementList) {
            var complementList = [];
            for (var j = 0; j < item.complementList.length; j++) {

              var complement = item.complementList[j];
              if (useTileList.indexOf(complement.id) >= 0)
                complementList.push(complement);

            }
            item.complementList = complementList;
          }
          result.push(zoomList[z][i]);
        }
      }
    }

    if (result.length <= 0 && useTileList.indexOf("DEMGM") == 0) {

      result.push({
        id: "DEMGM",
        url: "https://cyberjapandata.gsi.go.jp/xyz/demgm_png/{z}/{x}/{y}.png",
        minZoom: 0,
        maxZoom: 8
      });
    }
    return result;
  },

  // 陰影画像読み込み
  _loadHillshademap: function (coords) {

    var url = this.getDEMTileUrl(this._hillshademapUrl, coords);
    this._hillshademapImage = document.createElement('img');
    $(this._hillshademapImage)
      .on('load', L.bind(
        function (coords) {

          var scale = 1, lt, rb, point;
          if (this._coords.z != coords.z) {
            scale = Math.pow(2, this._coords.z - coords.z);

            lt = L.point(coords.x * 256 * scale, coords.y * 256 * scale);
            rb = L.point((coords.x + 1) * 256 * scale, (coords.y + 1) * 256 * scale);

            point = L.point(this._coords.x * 256, this._coords.y * 256);

            point.x -= lt.x;
            point.y -= lt.y;
          }
          else {
            point = L.point(0, 0);
          }

          this._hillshademapImage._point = point;
          this._hillshademapImage._scale = scale;

          this._hillshademapLoadSuccess();
        }, this, coords)
      )
      .on('error', L.bind(
        function (e) {
          this._hillshademapLoadError();
        }, this)
      );

    this._hillshademapImage.setAttribute('crossOrigin', 'anonymous');
    this._hillshademapImage.setAttribute('role', 'presentation');

    this._hillshademapImage.src = url;
  },

  // URL生成
  getDEMTileUrl: function (url, coords) {
    var data = {
      r: L.Browserretina ? '@2x' : '',
      s: this.options.subdomains,
      x: coords.x,
      y: coords.y,
      z: coords.z
    };
    if (this._map && !this._map.options.crs.infinite) {
      var invertedY = this._globalTileRange.max.y - coords.y;
      if (this.options.tms) {
        data['y'] = invertedY;
      }
      data['-y'] = invertedY;
    }

    return L.Util.template(url, L.extend(data, this.options));
  },

  // 指定のタイルが無い場合一つ上のズーム
  _nextZoom: function () {

    var nextZoom = this._currentCoords.z - 1;

    if (nextZoom < this.options.minZoom) {
      this._demLoadError();
      return;
    }

    var scale = Math.pow(2, this._coords.z - nextZoom);
    var point = L.point(this._coords.x * 256 / scale, this._coords.y * 256 / scale)
      .divideBy(256)._floor();

    this._currentCoords = {
      x: point.x,
      y: point.y,
      z: nextZoom
    };

    this._startLoadDEM(this._currentCoords);

  },

  // 読み込み開始
  _startLoadDEM: function (coords) {

    var urlList = $.extend(true, [], this._urlList);
    this._loadDEM(urlList, coords);

  },

  // 標高データ取得
  _loadDEM: function (urlList, coords) {
    var targetUrl = null;
    var targetId = null;
    var z = coords.z;

    while (urlList.length > 0) {
      var urlInfo = urlList.shift();
      if (urlInfo.minZoom <= z && z <= urlInfo.maxZoom) {
        targetUrl = $.extend(true, {}, urlInfo);
        targetId = urlInfo.id;
        break;
      }
    }

    if (!targetUrl) {
      //err
      if (z > 0 && this.options.overZooming) {
        this._nextZoom();
      }
      else {
        this._demLoadError();
      }
      return;
    }

    var url = this.getDEMTileUrl(targetUrl.url, coords);

    this._demImage = document.createElement('img');

    $(this._demImage)
      .on('load', L.bind(
        function (urlList, coords, targetUrl, targetId) {
          this._demLoadSuccess(urlList, coords, targetUrl, targetId);
        }, this, urlList, coords, targetUrl, targetId)
      )
      .on('error', L.bind(
        function (urlList, coords, e) {
          this._loadDEM(urlList, coords);
        }, this, urlList, coords)
      );

    this._demImage.setAttribute('crossOrigin', 'anonymous');
    this._demImage.setAttribute('role', 'presentation');
    this._demImage.src = url;

  },

  // 読み込み完了後解析
  _demLoadSuccess: function (urlList, coords, targetUrl, targetId) {
    var scale = 1, lt, rb, point, idx = 0, destIdx = 0;
    if (this._coords.z != coords.z) {
      scale = Math.pow(2, this._coords.z - coords.z);

      lt = L.point(coords.x * 256 * scale, coords.y * 256 * scale);
      rb = L.point((coords.x + 1) * 256 * scale, (coords.y + 1) * 256 * scale);

      point = L.point(this._coords.x * 256, this._coords.y * 256);

      point.x -= lt.x;
      point.y -= lt.y;
    }
    else {
      point = L.point(0, 0);
    }

    var pow2_8 = GSI.DEMLoader.pow2_8;
    var pow2_16 = GSI.DEMLoader.pow2_16;
    var pow2_23 = GSI.DEMLoader.pow2_23;
    var pow2_24 = GSI.DEMLoader.pow2_24;

    var demData = (this._demData ? this._demData : []);
    var demInfo = (this._demInfo ? this._demInfo : []);

    var canvas = GSI.DEMLoader.getCanvas();
    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, 256, 256);
    ctx.beginPath();
    ctx.drawImage(this._demImage, 0, 0, 256, 256);
    var data = ctx.getImageData(0, 0, 256, 256).data;
    var hasErrorPixel = false;

    for (var y = 0; y < 256; ++y) {
      for (var x = 0; x < 256; ++x) {

        if (!this._demData || this._demData[destIdx] == null) {

          if (scale != 1) {
            var x2 = Math.floor((point.x + x) / scale);
            var y2 = Math.floor((point.y + y) / scale);
            idx = (y2 * 256 * 4) + (x2 * 4);
          }
          else
            idx = (y * 256 * 4) + (x * 4);

          var r = data[idx + 0];
          var g = data[idx + 1];
          var b = data[idx + 2];
          var h = 0;
          if ((r != undefined && g != undefined && b != undefined) && (r != 128 || g != 0 || b != 0)) {
            var d = r * pow2_16 + g * pow2_8 + b;
            h = (d < pow2_23) ? d : d - pow2_24;
            if (h == -pow2_23) h = 0;
            else h *= 0.01;
            demData[destIdx] = h;
            demInfo[destIdx] = {
              "id": targetId,
              "zoom": coords.z
            };
          }
          else {
            hasErrorPixel = true;
            demData[destIdx] = null;
            demInfo[destIdx] = null;
          }
        }

        destIdx++;
      }
    }
    if (this._demData) {
      hasErrorPixel = false;

      for (var i = 0; i < demData.length; i++) {
        if (demData[i] == null) {
          hasErrorPixel = true;
          break;
        }
      }
      if (hasErrorPixel) {
        hasErrorPixel = false;
        var complementList = $.extend(true, [], this._urlList);

        for (var i = 0; i < complementList.length; i++) {
          if (complementList[i].url == targetUrl.url &&
            complementList[i].minZoom == targetUrl.minZoom &&
            complementList[i].maxZoom == targetUrl.maxZoom) {
            complementList.splice(i, 1);
            if (complementList.length > 0) {
              targetUrl.complementList = complementList;
              hasErrorPixel = true;
            }
            break;
          }
        }
      }
    }
    this._demData = demData;
    this._demInfo = demInfo;

    if (hasErrorPixel && targetUrl.complementList) {

      // DEM5aなどの境目補完
      // urlリストを補完用に変更
      this._urlList = $.extend(true, [], targetUrl.complementList);
      this._startLoadDEM(this._currentCoords);

    }
    else {

      this._demLoaded = true;
      this._checkLoaded();
    }
  },

  _demLoadError: function () {
    this._demLoaded = true;
    this._checkLoaded();
  },

  _hillshademapLoadSuccess: function () {
    this._hillshademapLoaded = true;
    this._hillshademapError = false;
    this._checkLoaded();
  },

  _hillshademapLoadError: function () {

    this._hillshademapLoaded = true;
    this._hillshademapError = true;
    this._checkLoaded();
  },

  // 読み込み完了チェック
  _checkLoaded: function () {
    if (this._demLoaded &&
      (!this.options.useHillshademap || this._hillshademapLoaded)) {
      this.fire("load");
    }
  }
});

GSI.FreeReliefDEMLoader = GSI.DEMLoader.extend({
  // 読み込み開始
  load: function () {
    if (!this._globalTileRange) {
      var bounds = this._map.getPixelWorldBounds(this._tileZoom);
      if (bounds) {
        this._globalTileRange = this._pxBoundsToTileRange(bounds);
      }
    }

    this._demData = null;
    this._demInfo = null;
    this._demLoaded = false;
    this._currentCoords = $.extend(true, {}, this._coords);

    this._urlList = GSI.FreeReliefDEMLoader.getURLList(this._coords.x, this._coords.y, this._coords.z);

    this._startLoadDEM(this._currentCoords);
    if (this.options.useHillshademap) {
      this._loadHillshademap(this._currentCoords);
    }
  },
  _loadDEM: function (urlList, coords) {
    var targetUrl = null;
    var targetId = null;
    var z = coords.z;

    if (urlList.length > 0){
      var urlInfo = urlList.shift();
      targetUrl = $.extend(true, {}, urlInfo);
      targetId = urlInfo.id;

      if (this.options.overZooming){
        if (targetId == "DEM10B"){
          if (z > 14){
            coords = this._slideZoom(urlInfo.maxZoom);
          }
        }
      }
      else{
        if (urlInfo.maxZoom < z || urlInfo.minZoom > z){
          this._demLoadError();
          return;
        }
      }
    }
    else{
      //遡らない
      this._demLoadError();
      return;
    }

    var url = this.getDEMTileUrl(targetUrl.url, coords);

    this._demImage = document.createElement('img');

    $(this._demImage)
      .on('load', L.bind(
        function (urlList, coords, targetUrl, targetId) {
          this._demLoadSuccess(urlList, coords, targetUrl, targetId);
        }, this, urlList, coords, targetUrl, targetId)
      )
      .on('error', L.bind(
        function (urlList, coords, e) {
          this._loadDEM(urlList, coords);
        }, this, urlList, coords)
      );

    this._demImage.setAttribute('crossOrigin', 'anonymous');
    this._demImage.setAttribute('role', 'presentation');
    this._demImage.src = url;

  },
  _slideZoom: function (z) {
    var scale = Math.pow(2, this._coords.z - z);
    var point = L.point(this._coords.x * 256 / scale, this._coords.y * 256 / scale)
      .divideBy(256)._floor();

    this._currentCoords = {
      x: point.x,
      y: point.y,
      z: z
    };

    return this._currentCoords;
  }
});

/*******************************************************
 GSI.CrossSectionDEMLoader
    標高タイル読込
    断面図で利用
    3D版は別ファイル（leafletの機能を使わない）
*******************************************************/
GSI.CrossSectionDEMLoader = L.Evented.extend({

  options: {
    minZoom: 8,
    overZooming: true,
    tms: false
  },

  // 初期化
  initialize: function (map, x, y, z, urlList, options) {

    // 20190904
    if (!GSI.CrossSectionDEMLoader.pow2_8) {
      // 利用するべき乗キャッシュ
      GSI.CrossSectionDEMLoader.pow2_8 = Math.pow(2, 8);
      GSI.CrossSectionDEMLoader.pow2_16 = Math.pow(2, 16);
      GSI.CrossSectionDEMLoader.pow2_23 = Math.pow(2, 23);
      GSI.CrossSectionDEMLoader.pow2_24 = Math.pow(2, 24);
    }

    this._map = map;

    this._coords = {
      x: x,
      y: y,
      z: z
    };

    L.setOptions(this, options);

    this._urlList = urlList;
  },

  // 表示に必要な範囲
  _pxBoundsToTileRange: function (bounds) {
    var tileSize = 256;
    return new L.Bounds(
      bounds.min.unscaleBy(tileSize).floor(),
      bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
  },

  // 後始末、破棄
  destroy: function () {
    if (this._demImage) {
      this._demImage.onload = null;
      this._demImage.onerror = null;
      $(this._demImage).off("load").off("error");
      delete this._demImage;
      this._demImage = null;
    }

    if (this._demData) {
      delete this._demData;
      this._demData = null;
    }
    if (this._demInfo) {
      delete this._demInfo;
      this._demInfo = null;
    }
  },

  // 読み込んだデータ
  getData: function () {
    return this._demData;
  },

  // 読み込み開始
  load: function () {
    if (!this._globalTileRange) {
      var bounds = this._map.getPixelWorldBounds(this._tileZoom);
      if (bounds) {
        this._globalTileRange = this._pxBoundsToTileRange(bounds);
      }
    }

    this._demData = null;
    this._demInfo = null;
    this._demLoaded = false;
    this._currentCoords = $.extend(true, {}, this._coords);

    this._urlList = GSI.CrossSectionDEMLoader.getURLList(this._coords.x, this._coords.y, this._coords.z);

    this._startLoadDEM(this._currentCoords);

  },

  // URL生成
  getDEMTileUrl: function (url, coords) {
    var data = {
      r: L.Browserretina ? '@2x' : '',
      s: this.options.subdomains,
      x: coords.x,
      y: coords.y,
      z: coords.z
    };
    if (this._map && !this._map.options.crs.infinite) {
      var invertedY = this._globalTileRange.max.y - coords.y;
      if (this.options.tms) {
        data['y'] = invertedY;
      }
      data['-y'] = invertedY;
    }

    return L.Util.template(url, L.extend(data, this.options));
  },

  // 指定のタイルが無い場合一つ上のズーム
  _nextZoom: function () {

    var nextZoom = this._currentCoords.z - 1;

    if (nextZoom < this.options.minZoom) {
      this._demLoadError();
      return;
    }

    var scale = Math.pow(2, this._coords.z - nextZoom);
    var point = L.point(this._coords.x * 256 / scale, this._coords.y * 256 / scale)
      .divideBy(256)._floor();

    this._currentCoords = {
      x: point.x,
      y: point.y,
      z: nextZoom
    };

    this._startLoadDEM(this._currentCoords);
  },

  // 読み込み開始
  _startLoadDEM: function (coords) {

    var urlList = $.extend(true, [], this._urlList);
    this._loadDEM(urlList, coords);

  },

  // 標高データ取得
  _loadDEM: function (urlList, coords) {
    var targetUrl = null;
    var z = coords.z;

    while (urlList.length > 0) {
      var urlInfo = urlList.shift();
      if (urlInfo.minZoom <= z && z <= urlInfo.maxZoom) {
        targetUrl = $.extend(true, {}, urlInfo);
        break;
      }
    }

    if (!targetUrl) {
      //err
      if (z > 0 && this.options.overZooming) {
        this._nextZoom();
      }
      else {
        this._demLoadError();
      }
      return;
    }

    var url = this.getDEMTileUrl(targetUrl.url, coords);

    this._demImage = document.createElement('img');

    $(this._demImage)
      .on('load', L.bind(
        function (urlList, coords, targetUrl) {
          this._demLoadSuccess(urlList, coords, targetUrl);
        }, this, urlList, coords, targetUrl)
      )
      .on('error', L.bind(
        function (urlList, coords, e) {
          this._loadDEM(urlList, coords);
        }, this, urlList, coords)
      );

    this._demImage.setAttribute('crossOrigin', 'anonymous');
    this._demImage.setAttribute('role', 'presentation');

    this._demImage.src = url;

  },

  // 読み込み完了後解析
  _demLoadSuccess: function (urlList, coords, targetUrl) {
    var scale = 1, lt, rb, point, idx = 0, destIdx = 0;
    if (this._coords.z != coords.z) {
      scale = Math.pow(2, this._coords.z - coords.z);

      lt = L.point(coords.x * 256 * scale, coords.y * 256 * scale);
      rb = L.point((coords.x + 1) * 256 * scale, (coords.y + 1) * 256 * scale);

      point = L.point(this._coords.x * 256, this._coords.y * 256);

      point.x -= lt.x;
      point.y -= lt.y;
    }
    else {
      point = L.point(0, 0);
    }

    var pow2_8 = GSI.CrossSectionDEMLoader.pow2_8;
    var pow2_16 = GSI.CrossSectionDEMLoader.pow2_16;
    var pow2_23 = GSI.CrossSectionDEMLoader.pow2_23;
    var pow2_24 = GSI.CrossSectionDEMLoader.pow2_24;

    var demData = (this._demData ? this._demData : []);
    var demInfo = (this._demInfo ? this._demInfo : []);

    var canvas = GSI.CrossSectionDEMLoader.getCanvas();
    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, 256, 256);
    ctx.beginPath();
    ctx.drawImage(this._demImage, 0, 0, 256, 256);
    var data = ctx.getImageData(0, 0, 256, 256).data;
    var hasErrorPixel = false;

    for (var y = 0; y < 256; ++y) {
      for (var x = 0; x < 256; ++x) {

        if (!this._demData || this._demData[destIdx] == null) {

          if (scale != 1) {
            var x2 = Math.floor((point.x + x) / scale);
            var y2 = Math.floor((point.y + y) / scale);
            idx = (y2 * 256 * 4) + (x2 * 4);
          }
          else
            idx = (y * 256 * 4) + (x * 4);

          var r = data[idx + 0];
          var g = data[idx + 1];
          var b = data[idx + 2];
          var h = 0;
          if (r != 128 || g != 0 || b != 0) {
            var d = r * pow2_16 + g * pow2_8 + b;
            h = (d < pow2_23) ? d : d - pow2_24;
            if (h == -pow2_23) h = 0;
            else h *= 0.01;
            demData[destIdx] = h;
          }
          else {
            hasErrorPixel = true;
            demData[destIdx] = null;
          }
        }

        destIdx++;
      }
    }
    if (this._demData) {
      hasErrorPixel = false;

      for (var i = 0; i < demData.length; i++) {
        if (demData[i] == null) {
          hasErrorPixel = true;
          break;
        }
      }
      if (hasErrorPixel) {
        hasErrorPixel = false;
        var complementList = $.extend(true, [], this._urlList);

        for (var i = 0; i < complementList.length; i++) {
          if (complementList[i].url == targetUrl.url &&
            complementList[i].minZoom == targetUrl.minZoom &&
            complementList[i].maxZoom == targetUrl.maxZoom) {
            complementList.splice(i, 1);
            if (complementList.length > 0) {
              targetUrl.complementList = complementList;
              hasErrorPixel = true;
            }
            break;
          }

        }
      }
    }
    this._demData = demData;
    this._demInfo = demInfo;

    if (hasErrorPixel && targetUrl.complementList) {
      // DEM5aなどの境目補完
      // urlリストを補完用に変更
      this._urlList = $.extend(true, [], targetUrl.complementList);
      this._startLoadDEM(this._currentCoords);

    }
    else {

      this._demLoaded = true;
      this._checkLoaded();
    }
  },

  _demLoadError: function () {
    this._demLoaded = true;
    this._checkLoaded();
  },

  // 読み込み完了チェック
  _checkLoaded: function () {
    if (this._demLoaded &&
      (!this.options.useHillshademap || this._hillshademapLoaded)) {
      this.fire("load");
    }
  }
});

// 標高png読み取り用Canvas
GSI.DEMLoader.getCanvas = function () {
  if (!GSI.DEMLoader._canvas) {
    GSI.DEMLoader._canvas = document.createElement('canvas');
    GSI.DEMLoader._canvas.width = 256;
    GSI.DEMLoader._canvas.height = 256;
  }
  return GSI.DEMLoader._canvas;
}

// 標高png読み取り用Canvas
GSI.CrossSectionDEMLoader.getCanvas = function () {
  if (!GSI.CrossSectionDEMLoader._canvas) {
    GSI.CrossSectionDEMLoader._canvas = document.createElement('canvas');
    GSI.CrossSectionDEMLoader._canvas.width = 256;
    GSI.CrossSectionDEMLoader._canvas.height = 256;
  }
  return GSI.CrossSectionDEMLoader._canvas;
}

/*******************************************************

 GSI.DEMLoader.getURLList
    標高データURL

*******************************************************/
GSI.DEMLoader.DEMAREA = {};
GSI.DEMLoader.DEMAREA2 = {};
GSI.DEMLoader.DEMAREA3 = {};
for (var i = 0; i < CONFIG.DEMAREA.length; i++) GSI.DEMLoader.DEMAREA[CONFIG.DEMAREA[i]] = 1;
for (var i = 0; i < CONFIG.DEMAREA2.length; i++) GSI.DEMLoader.DEMAREA2[CONFIG.DEMAREA2[i]] = 1;
for (var i = 0; i < CONFIG.DEMAREA3.length; i++) GSI.DEMLoader.DEMAREA3[CONFIG.DEMAREA3[i]] = 1;
delete CONFIG.DEMAREA; CONFIG.DEMAREA = null;
delete CONFIG.DEMAREA2; CONFIG.DEMAREA2 = null;
delete CONFIG.DEMAREA3; CONFIG.DEMAREA3 = null;

// タイル座標から標高タイルURLを決定
GSI.DEMLoader.getURLList = function (x, y, z) {

  //-------------------------------------------------------------------------------
  var getCoords = function (x, y, z, targetZoom) {
    var scale = Math.pow(2, z - targetZoom);
    var point = L.point(x * 256 / scale, y * 256 / scale).divideBy(256)._floor();

    return {
      x: point.x,
      y: point.y,
      z: targetZoom
    };
  };
  var coordsToKey = function (coords) { return coords.z + "/" + coords.x + "/" + coords.y; };
  //-------------------------------------------------------------------------------

  // ZL8以下はdem_gm
  if (z <= 8) {
    return [{
      id: "DEMGM",
      url: "https://cyberjapandata.gsi.go.jp/xyz/demgm_png/{z}/{x}/{y}.png",
      minZoom: 0,
      maxZoom: 8
    }];
  }

  // ZL9以上
  var key;

  // DEMAREAになけれdem_gm
  key = coordsToKey(getCoords(x, y, z, 8));
  if (!GSI.DEMLoader.DEMAREA[key]) return [{
    id: "DEMGM",
    url: "https://cyberjapandata.gsi.go.jp/xyz/demgm_png/{z}/{x}/{y}.png",
    minZoom: 0,
    maxZoom: 8
  }];

  // DEMAREA2になければdem
  key = coordsToKey(getCoords(x, y, z, 9));
  if (!GSI.DEMLoader.DEMAREA2[key])
    return [
      {
        id: "DEM5A",
        url: "https://cyberjapandata.gsi.go.jp/xyz/dem5a_png/{z}/{x}/{y}.png",
        minZoom: 9,
        maxZoom: 15,
        complementList: [
          {
            id: "DEM5B",
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem5b_png/{z}/{x}/{y}.png",
            minZoom: 9,
            maxZoom: 15
          },
          {
            id: "DEM5C",
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem5c_png/{z}/{x}/{y}.png",
            minZoom: 9,
            maxZoom: 15
          },
          {
            id: "DEM10B",
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
            minZoom: 9,
            maxZoom: 14
          }
        ]
      },
      {
        id: "DEM5B",
        url: "https://cyberjapandata.gsi.go.jp/xyz/dem5b_png/{z}/{x}/{y}.png",
        minZoom: 9,
        maxZoom: 15,
        complementList: [
          {
            id: "DEM5C",
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem5c_png/{z}/{x}/{y}.png",
            minZoom: 9,
            maxZoom: 15
          },
          {
            id: "DEM10B",
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
            minZoom: 9,
            maxZoom: 14
          }
        ]
      },
      {
        id: "DEM5C",
        url: "https://cyberjapandata.gsi.go.jp/xyz/dem5c_png/{z}/{x}/{y}.png",
        minZoom: 9,
        maxZoom: 15,
        complementList: [
          {
            id: "DEM10B",
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
            minZoom: 9,
            maxZoom: 14
          }
        ]
      },
      {
        id: "DEM10B",
        url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
        minZoom: 9,
        maxZoom: 14,
        complementList: [
        ]
      }
    ];

  key = coordsToKey(getCoords(x, y, z, 10));
  if (!GSI.DEMLoader.DEMAREA3[key] == -1) {
    // DEMAREA2にあって、DEMAREA3になければdemgm
    return [{
      id: "DEMGM",
      url: "https://cyberjapandata.gsi.go.jp/xyz/demgm_png/{z}/{x}/{y}.png",
      minZoom: 0,
      maxZoom: 8
    }];
  }
  else {
    // DEMAREA2にあって、DEMAREA3にあればdem
    return [{
      id: "DEM10B",
      url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
      minZoom: 0,
      maxZoom: 14,
      complementList: [
        {
          id: "DEMGM",
          url: "https://cyberjapandata.gsi.go.jp/xyz/demgm_png/{z}/{x}/{y}.png",
          minZoom: 0,
          maxZoom: 8
        }
      ]
    }
    ];
  }
};

GSI.CrossSectionDEMLoader.getURLList = function (x, y, z) {

  //-------------------------------------------------------------------------------
  var getCoords = function (x, y, z, targetZoom) {
    var scale = Math.pow(2, z - targetZoom);
    var point = L.point(x * 256 / scale, y * 256 / scale).divideBy(256)._floor();

    return {
      x: point.x,
      y: point.y,
      z: targetZoom
    };
  };
  var coordsToKey = function (coords) { return coords.z + "/" + coords.x + "/" + coords.y; };
  //-------------------------------------------------------------------------------

  // ZL8以下はdem_gm
  if (z <= 8) return [{
    url: "https://cyberjapandata.gsi.go.jp/xyz/demgm_png/{z}/{x}/{y}.png",
    minZoom: 0,
    maxZoom: 14
  }];

  // ZL9以上
  var key;

  // DEMAREAになけれdem_gm
  key = coordsToKey(getCoords(x, y, z, 8));
  if (!GSI.DEMLoader.DEMAREA[key]) return [{
    url: "https://cyberjapandata.gsi.go.jp/xyz/demgm_png/{z}/{x}/{y}.png",
    minZoom: 0,
    maxZoom: 14
  }];

  // DEMAREA2になければdem
  key = coordsToKey(getCoords(x, y, z, 9));
  if (!GSI.DEMLoader.DEMAREA2[key])
    return [
      {
        url: "https://cyberjapandata.gsi.go.jp/xyz/dem5a_png/{z}/{x}/{y}.png",
        minZoom: 15,
        maxZoom: 15,
        complementList: [
          {
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem5b_png/{z}/{x}/{y}.png",
            minZoom: 15,
            maxZoom: 15
          },
          {
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem5c_png/{z}/{x}/{y}.png",
            minZoom: 15,
            maxZoom: 15
          },
          {
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
            minZoom: 0,
            maxZoom: 14
          }
        ]
      },
      {
        url: "https://cyberjapandata.gsi.go.jp/xyz/dem5b_png/{z}/{x}/{y}.png",
        minZoom: 15,
        maxZoom: 15,
        complementList: [
          {
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem5c_png/{z}/{x}/{y}.png",
            minZoom: 15,
            maxZoom: 15
          },
          {
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
            minZoom: 0,
            maxZoom: 14
          }
        ]
      },
      {
        url: "https://cyberjapandata.gsi.go.jp/xyz/dem5c_png/{z}/{x}/{y}.png",
        minZoom: 15,
        maxZoom: 15,
        complementList: [
          {
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
            minZoom: 0,
            maxZoom: 14
          }
        ]
      },
      {
        url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
        minZoom: 0,
        maxZoom: 14
      }
    ];

  key = coordsToKey(getCoords(x, y, z, 10));
  if (!GSI.DEMLoader.DEMAREA3[key] == -1) {
    // DEMAREA2にあって、DEMAREA3になければdemgm
    return [{
      url: "https://cyberjapandata.gsi.go.jp/xyz/demgm_png/{z}/{x}/{y}.png",
      minZoom: 0,
      maxZoom: 8
    }];
  }
  else {
    // DEMAREA2にあって、DEMAREA3にあればdem
    return [{
      url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
      minZoom: 0,
      maxZoom: 14,
      complementList: [
        {
          url: "https://cyberjapandata.gsi.go.jp/xyz/demgm_png/{z}/{x}/{y}.png",
          minZoom: 0,
          maxZoom: 8
        }
      ]
    }
    ];
  }
};

GSI.FreeReliefDEMLoader.getURLList = function(x, y, z){
  var getCoords = function (x, y, z, targetZoom) {
    var scale = Math.pow(2, z - targetZoom);
    var point = L.point(x * 256 / scale, y * 256 / scale).divideBy(256)._floor();

    return {
      x: point.x,
      y: point.y,
      z: targetZoom
    };
  };
  var coordsToKey = function (coords) { return coords.z + "/" + coords.x + "/" + coords.y; };
  //-------------------------------------------------------------------------------

  // ZL8以下はdem_gm
  if (z <= 8) {
    return [{
      id: "DEMGM",
      url: "https://cyberjapandata.gsi.go.jp/xyz/demgm_png/{z}/{x}/{y}.png",
      minZoom: 0,
      maxZoom: 8
    }];
  }

  // ZL9以上
  var key;

  // DEMAREAになけれdem_gm
  key = coordsToKey(getCoords(x, y, z, 8));
  if (!GSI.DEMLoader.DEMAREA[key]) return [{
    id: "DEMGM",
    url: "https://cyberjapandata.gsi.go.jp/xyz/demgm_png/{z}/{x}/{y}.png",
    minZoom: 0,
    maxZoom: 8
  }];

  // DEMAREA2になければdem
  key = coordsToKey(getCoords(x, y, z, 9));
  if (!GSI.DEMLoader.DEMAREA2[key])
    return [
      {
        id: "DEM5A",
        url: "https://cyberjapandata.gsi.go.jp/xyz/dem5a_png/{z}/{x}/{y}.png",
        minZoom: 9,
        maxZoom: 15,
        complementList: [
          {
            id: "DEM5B",
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem5b_png/{z}/{x}/{y}.png",
            minZoom: 9,
            maxZoom: 15
          },
          {
            id: "DEM5C",
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem5c_png/{z}/{x}/{y}.png",
            minZoom: 9,
            maxZoom: 15
          },
          {
            id: "DEM10B",
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
            minZoom: 9,
            maxZoom: 14
          }
        ]
      },
      {
        id: "DEM5B",
        url: "https://cyberjapandata.gsi.go.jp/xyz/dem5b_png/{z}/{x}/{y}.png",
        minZoom: 14,
        maxZoom: 15,
        complementList: [
          {
            id: "DEM5C",
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem5c_png/{z}/{x}/{y}.png",
            minZoom: 14,
            maxZoom: 15
          },
          {
            id: "DEM10B",
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
            minZoom: 14,
            maxZoom: 14
          }
        ]
      },
      {
        id: "DEM5C",
        url: "https://cyberjapandata.gsi.go.jp/xyz/dem5c_png/{z}/{x}/{y}.png",
        minZoom: 14,
        maxZoom: 15,
        complementList: [
          {
            id: "DEM10B",
            url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
            minZoom: 14,
            maxZoom: 14
          }
        ]
      },
      {
        id: "DEM10B",
        url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
        minZoom: 9,
        maxZoom: 14,
        complementList: [
        ]
      }
    ];

  key = coordsToKey(getCoords(x, y, z, 10));
  if (!GSI.DEMLoader.DEMAREA3[key] == -1) {
    // DEMAREA2にあって、DEMAREA3になければdemgm
    return [{
      id: "DEMGM",
      url: "https://cyberjapandata.gsi.go.jp/xyz/demgm_png/{z}/{x}/{y}.png",
      minZoom: 0,
      maxZoom: 8
    }];
  }
  else {
    // DEMAREA2にあって、DEMAREA3にあればdem
    return [{
      id: "DEM10B",
      url: "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png",
      minZoom: 0,
      maxZoom: 14,
      complementList: [
        {
          id: "DEMGM",
          url: "https://cyberjapandata.gsi.go.jp/xyz/demgm_png/{z}/{x}/{y}.png",
          minZoom: 0,
          maxZoom: 8
        }
      ]
    }
    ];
  }
}

/************************************************************************
 L.Control
 - GSI.Control.GPSButton
 ************************************************************************/
GSI.Control.GPSButton = L.Control.extend({
  options: {
    position: 'bottomright'
  },
  counter: null,
  initialize: function (options) {
    L.setOptions(this, options);
  },
  show: function () {

    $(this._container).show();
  },

  hide: function () {
    $(this._container).hide();
  },
  _onClick: function () {
    this._on = !this._on;
    if (this._on) {
      this.start();
    } else {
      this.stop();
    }
  },

  start: function () {
    this._zooming = false;
    this._map.options.doubleClickZoom = "center";
    this._map.options.scrollWheelZoom = "center";
    this._map.options.touchZoom = "center";

    this._on = true;
    this._startInitialized = false;
    if (!this._locationWatcher) {
      this._locationWatcher = new GSI.LocationWatcher();
      this._locationWatcher.on("change", L.bind(this._onLocationChange, this));
      this._locationWatcher.on("stop", L.bind(this.stop, this));
    }
    this._locationWatcher.start();
    this._resetImage();
  },
  stop: function () {
    this._zooming = false;
    this._map.options.doubleClickZoom = "";
    this._map.options.scrollWheelZoom = "";
    this._map.options.touchZoom = "";
    this._on = false;

    if (this._locationWatcher) {
      this._locationWatcher.destroy();
      this._locationWatcher = null;
    }
    this._hideMarker();
    this._resetImage();

  },

  _onLocationChange: function (evt) {
    var coords = evt["coords"];
    this._selfMove = true;
    var zoom = this._map.getZoom();
    if (!this._startInitialized && zoom < 15) {
      this._startInitialized = true;
      this._map.flyTo([coords.latitude, coords.longitude], 15, { duration: 1 });
    } else {
      this._map.panTo([coords.latitude, coords.longitude], { reset: true });
    }
    this._selfMove = false;
    this._showMarker(coords);

  },
  _onZoomStart: function () {
    this._zooming = true;
  },
  _onZoomEnd: function () {
    this._zooming = false;
  },

  _onMoveStart: function () {
    if (!this._selfMove && !this._zooming) {
      this.stop();
    }
    this._selfMove = false;
  },

  _resetImage: function () {
    if (this._on) {
      $(this._container).addClass("on");
      this._img.src = "./image/system/gps_on.png";
    } else {
      $(this._container).removeClass("on");
      this._img.src = "./image/system/gps_off.png";
    }
  },

  onAdd: function (map) {
    this._on = false;
    this._map = map;
    this._map.on("movestart", L.bind(this._onMoveStart, this));
    this._map.on("zoomstart", L.bind(this._onZoomStart, this));
    this._map.on("zoomend", L.bind(this._onZoomEnd, this));
    this._container = L.DomUtil.create('a');
    $(this._container).on("click", L.bind(this._onClick, this)).addClass("gsi-gps-button");

    this._img = L.DomUtil.create("img");
    this._resetImage();
    $(this._container).append($(this._img));

    L.DomEvent.addListener(this._container, 'click', L.DomEvent.stop);
    L.DomEvent.disableClickPropagation(this._container);

    return this._container;
  },
  onRemove: function (map) {
  },

  _showMarker: function (coords) {
    if (!this._circle) {
      this._circle = new L.Circle([coords.latitude, coords.longitude],
        {
          geodesic: false,
          radius: coords.accuracy,
          stroke: true,
          color: "#0078A8",
          weight: 1,
          opaciy: 0.2,
          fill: true,
          fillColor: "#0078A8",
          clickable: false,
          draggable: false
        }
      ).addTo(this._map);
    } else {
      this._circle.setLatLng([coords.latitude, coords.longitude]);
      this._circle.setRadius(coords.accuracy);
    }

    if (!this._marker) {
      var icon = L.divIcon({
        className: "gsi-gps-marker",
        iconSize: [12, 12],
        iconAnchor: [6, 6],
        clickable: false,
        draggable: false,
        html: '<div style="border:none; border-radius:50%; position:absolute; width:12px; height:12px; background-color:#0078A8;"></div>'
      });
      this._marker = L.marker([coords.latitude, coords.longitude],
        {
          icon: icon
        }
      ).addTo(this._map);

    } else {
      this._marker.setLatLng([coords.latitude, coords.longitude]);
    }
  },

  _hideMarker: function () {
    if (this._circle) {
      this._map.removeLayer(this._circle);
      this._circle = null;
    }
    if (this._marker) {
      this._map.removeLayer(this._marker);
      this._marker = null;
    }
  }
});

/*******************************************************

 GSI.SharePanel
    共有用パネル

*******************************************************/
GSI.SharePanel = L.Evented.extend({

  initialize: function (gsimaps, options) {
    this._gsimaps = gsimaps;
    L.setOptions(this, options);
  },

  create: function () {
    if (this._container) return;

    this._container = $("<div>").addClass("gsi-share-panel").hide();
    this._iconPanel = $("<div>").addClass("gsi-share-panel-icons");
    this._urlPanel = $("<div>").addClass("gsi-share-panel-url");

    if (CONFIG.MOBILE) {
      this._container.addClass("mobile");
    }
    // アイコン
    this._createIcons(this._iconPanel);

    // url
    this._urlTextarea = $("<textarea>")
      .on('focus',function () {
        setTimeout(L.bind(function () { $(this).trigger('select'); }, this), 1);
      })
      .on('click',function () {
        setTimeout(L.bind(function () { $(this).trigger('select'); }, this), 1);
        return false;
      });
    this._urlPanel.append(this._urlTextarea);

    this._container.append(this._iconPanel);
    this._container.append(this._urlPanel);
    this._container.append(this._codePanel);
    $("body").append(this._container);
  },

  _createIcons: function (container) {
    // facebook
    {
      var a = $("<a>").addClass("facebook").attr({
        "href": "javascript:void(0);",
        "title": (CONFIG.TOOLTIP && CONFIG.TOOLTIP.SHARE ? CONFIG.TOOLTIP.SHARE.FACEBOOK : "")
      });
      a.on('click',function () { GSI.SHARE.showFacebook(); });
      container.append(a);
    }
    // twitter
    {
      var a = $("<a>").addClass("twitter").attr({
        "href": "javascript:void(0);",
        "title": (CONFIG.TOOLTIP && CONFIG.TOOLTIP.SHARE ? CONFIG.TOOLTIP.SHARE.TWITTER : "")
      });
      a.on('click',function () { GSI.SHARE.showTwitter(); });
      container.append(a);
    }

    if (!CONFIG.MOBILE) {
      // 画像として保存
      {
        var a = $("<a>").addClass("save-image").attr({
          "href": "javascript:void(0);",
          "title": (CONFIG.TOOLTIP && CONFIG.TOOLTIP.SHARE ? CONFIG.TOOLTIP.SHARE.SAVEIMAGE : "")
        });
        a.on('click',L.bind(function () {
          this._gsimaps.executeSaveImage();
        }, this));
        container.append(a);
      }
    }

    if (!CONFIG.MOBILE) {
      // QRコード
      var a = $("<a>").addClass("qr-code").attr({
        "href": "javascript:void(0);",
        "title": (CONFIG.TOOLTIP && CONFIG.TOOLTIP.SHARE ? CONFIG.TOOLTIP.SHARE.QRCODE : "")
      });
      a.on('click',L.bind(function () {
        this._gsimaps.showQRCodeDialog();
      }, this));
      container.append(a);
    } else {
      // メール
      var subject = GSI.TEXT.SHARE.MAIL_SUBJECT;
      var body = GSI.TEXT.SHARE.MAIL_BODY;
      body += location.href;
      body += "\n";
      var a = $("<a>").addClass("mail").attr({
        "href": "mailto:?subject=" + encodeURI(subject) + "&body=" + encodeURIComponent(body),
        "title": (CONFIG.TOOLTIP && CONFIG.TOOLTIP.SHARE ? CONFIG.TOOLTIP.SHARE.MAIL : "")
      });
      container.append(a);

    }

    if (!CONFIG.MOBILE) {
      // 一時保存
      {
        var a = $("<a>").addClass("save-temp").attr({
          "href": "javascript:void(0);",
          "title": (CONFIG.TOOLTIP && CONFIG.TOOLTIP.SHARE ? CONFIG.TOOLTIP.SHARE.SAVEHTML : "")
        });
        a.on('click',L.bind(function () {
          this._gsimaps.showShareDialog(GSI.ShareDialog.MODE.FILE);
        }, this));
        container.append(a);
      }

      // サイトに埋め込み
      {
        var a = $("<a>").addClass("umekomi").attr({
          "href": "javascript:void(0);",
          "title": (CONFIG.TOOLTIP && CONFIG.TOOLTIP.SHARE ? CONFIG.TOOLTIP.SHARE.IFRAME : "")
        });
        a.on('click',L.bind(function () {
          this._gsimaps.showShareDialog(GSI.ShareDialog.MODE.BUILTIN);
        }, this));
        container.append(a);
      }
    }

    container.find("a").on('click',L.bind(function () {
      this.hide();
    }, this));

  },

  refresh: function () {
    this._urlTextarea.val(location.href);
  },

  toggle: function (options) {
    if (this._container && this._container.is(":visible")) {
      this.hide();
    } else {
      this.show(options);
    }
  },

  show: function (options) {
    this.create();

    if (options && options.center) {
      var windowSize = GSI.Utils.getScreenSize();
      this._container.css({ "visibility": "hidden" }).show();
      var containerWidth = this._container.outerWidth();
      this._container.css({ "visibility": "visible" }).hide();
      var right = (windowSize.w - options.center);
      right -= Math.floor(containerWidth / 2) + 8;
      if (right < 8) right = 8;

      this._container.css({ "right": right + "px" });
    } else {
      this._container.css({ "right": "8px" });
    }
    this.refresh();
    if (!this._mapMouseDownHandler) {
      this._mapMouseDownHandler = L.bind(this._onMapMouseDown, this);
      if (this._gsimaps._mainMap) {
        this._gsimaps._mainMap.getMap().on("mousedown", this._mapMouseDownHandler);
        this._gsimaps._mainMap.getMap().on("touchstart", this._mapMouseDownHandler);
      }
      if (this._gsimaps._subMap) {
        this._gsimaps._subMap.getMap().on("mousedown", this._mapMouseDownHandler);
        this._gsimaps._subMap.getMap().on("touchstart", this._mapMouseDownHandler);
      }
    }
    if (!this._bodyMouseDownHandler) {
      this._bodyMouseDownHandler = L.bind(this._onBodyMouseDown, this);
      $("body").on("mousedown", this._bodyMouseDownHandler);
    }

    this._container.slideDown(300);
  },

  hide: function () {

    if (this._mapMouseDownHandler) {
      if (this._gsimaps._mainMap) {
        this._gsimaps._mainMap.getMap().off("mousedown", this._mapMouseDownHandler);
        this._gsimaps._mainMap.getMap().off("touchstart", this._mapMouseDownHandler);
      }
      if (this._gsimaps._subMap) {
        this._gsimaps._subMap.getMap().off("mousedown", this._mapMouseDownHandler);
        this._gsimaps._subMap.getMap().off("touchstart", this._mapMouseDownHandler);
      }
    }
    if (this._bodyMouseDownHandler) {
      $("body").off("mousedown", this._bodyMouseDownHandler);
    }
    this._mapMouseDownHandler = null;
    this._bodyMouseDownHandler = null;

    if (!this._container) return;

    this._container.slideUp(300);
  },

  _onMapMouseDown: function () {
    this.hide();
  },

  _onBodyMouseDown: function (evt) {
    var target = evt.target;

    while (target) {
      if (target == this._container[0]) return;
      target = target.parentNode;
    }

    this.hide();
  }
});

/************************************************************************
  作図
************************************************************************/
/************************************************************************
 L.Class
 - GSI.SakuzuList（作図リスト管理）
 ************************************************************************/
GSI.SakuzuListItem = L.Evented.extend({
  _title: '',
  _fileName: '',
  _layer: null,

  initialize: function (owner, dataType, title, fileName, layer, visible, iconLabelVisible, fKey) {
    this.editMode = GSI.SakuzuListItem.NONE;
    this._owner = owner;
    this._dataType = dataType;
    this._title = title;
    this._fileName = fileName;
    this._layer = layer;
    this._visible = visible;
    this._iconLabelVisible = iconLabelVisible;
    this._fKey = fKey;
    if (!this._layer) this._layer = L.featureGroup();

    if (visible) this._owner._map.addLayer(this._layer);
  },

  getMap : function() {
    return this._owner._map;
  },
  getVisible: function () {
    return this._visible;
  },

  setVisible: function (visible) {
    if (this._visible != visible) {
      this._visible = visible;
      if (this._layer) {
        if (this._visible)
          this._owner._map.addLayer(this._layer);
        else
          this._owner._map.removeLayer(this._layer);
      }

      this._owner.fire('visiblechange');
    }
  },

  getIconLabelVisible: function () {
    return this._iconLabelVisible;
  },

  getIconLabelSize: function() {
    return ( this._iconLabelSize ? this._iconLabelSize : "middle" );
  },

  setIconLabelSize: function(size) {
    if ( size) {
      this._iconLabelSize = size;
    } else {
      size =this._iconLabelSize;
    }
    if (this._layer) {
      if (this._layer.getLayers) {
        var layers = this._layer.getLayers();
        for (var i = 0; i < layers.length; i++) {
          this._setIconLabelSize(layers[i], size);
        }
      }
      else
        this._setIconLabelSize(this._layer.layer, this._iconLabelSize);

    }
  },
  setIconLabelVisible: function (visible) {
    if (this._iconLabelVisible != visible) {
      this._iconLabelVisible = visible;
      if (this._layer) {
        if (this._layer.getLayers) {
          var layers = this._layer.getLayers();
          for (var i = 0; i < layers.length; i++) {
            this._setIconLabelVisible(layers[i], visible);
          }
        }
        else
          this._setIconLabelVisible(this._layer.layer, visible);

      }
    }
  },

  _setIconLabelVisible: function (layer, visible) {
    if (!layer) return;
    if (layer.setLabelVisible) {
      layer.setLabelVisible(visible);
    }
    if (layer.options && layer.options.icon && layer.options.icon.setLabelVisible) {
       layer.options.icon.setLabelVisible(visible);
    }
    if (layer.getLayers) {
      var layers = layer.getLayers();
      for (var i = 0; i < layers.length; i++) {
        this._setIconLabelVisible(layers[i], visible);
      }
    }
  },

  _setIconLabelSize: function (layer, size) {
    if (!layer) return;
    if (layer.setLabelSize) layer.setLabelSize(size);
    if (layer.options && layer.options.icon && layer.options.icon.setLabelSize) layer.options.icon.setLabelSize(size);
    if (layer.getLayers) {
      var layers = layer.getLayers();
      for (var i = 0; i < layers.length; i++) {
        this._setIconLabelSize(layers[i], size);
      }
    }
  },

  getDataType : function() {
    return this._dataType;
  },

  getTitle: function () {
    return this._title;
  },

  getFileName: function () {
    return this._fileName;
  },

  _getLayerCount: function (layer) {
    if (!layer) return 0;
    if (!layer.getLayers) return 1;
    var layers = layer.getLayers();

    var result = 0;
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      var layerType = this._getType(layer);

      if (layerType != GSI.SakuzuListItem.FEATURES)
        result++;
      else {
        result += this._getLayerCount(layer);
      }
    }

    return result;
  },

  getLayerCount: function () {
    return this._getLayerCount(this._layer);
  },

  _setUrl: function(fKey){
    var items = window.location.href.split('&');
    items = items.filter((item)=>{
      return !item.startsWith(fKey+"=")
    })
    var url = items.join('&');
    window.history.pushState({url: url, title: document.title}, document.title, url);
    if(GSI.FILEURL[fKey]) GSI.FILEURL[fKey] = null;
  },

  remove: function () {
    this._owner.remove(this);
    if(this._fKey) this._setUrl(this._fKey);
  },

  removeAllLayers: function () {
    if (this._layer) {
      this._owner._map.removeLayer(this._layer);
      delete this._layer;
      this._layer = null;
    }
    this._layer = L.featureGroup();
    this._owner._map.addLayer(this._layer);
  },

  destroy: function () {

    this._owner._map.stopAutoPan();
    if (this._layer) {
      this._owner._map.removeLayer(this._layer);
      delete this._layer;
      this._layer = null;
    }
  },

  getEditingStyle: function () {
    var style = null;
    if (this._editingEditingLayer) {
      style = this._editingEditingLayer.options;
      if (this._editingEditingLayer.getLayers) {
        var layers = this._editingEditingLayer.getLayers();

        if (layers.length > 0) {
          style = layers[0].options;
        }
      }

      if (style && style.shapeOptions) style = style.shapeOptions;

    }
    else if (this._editingPathList && this._editingPathList.length > 0) {
      style = this._editingPathList[0].options.shapeOptions;

      if (!style || Object.keys(style).length <= 0) {
        style = this._editingPathList[0].options;
      }
    }

    if (style) {
      if (this._editingType == GSI.SakuzuListItem.POLYGON
        || this._editingType == GSI.SakuzuListItem.CIRCLE
        || this._editingType == GSI.SakuzuListItem.MULTIPOLYGON
        || this._editingType == GSI.SakuzuListItem.MULTICIRCLE) {
        if (!style.fillColor) style.fillColor = style.color;
        if ((style.fillOpacity === null) || (style.fillOpacity === undefined) || (style.fillOpacity === "")) {
          style.fillOpacity = style.opacity;
        }
      }
    }
    return style;
  },

  setEditingStyle: function (style) {

    var radius = style.radius;
    var currentStyle = this.getEditingStyle();
    var icon = null;
    var iconInfo = style._iconInfo;
    var lineStyle = style.lineStyle;
    if ( lineStyle ) delete style["lineStyle"];
    if (iconInfo) {
      delete style["_iconInfo"];
      if (iconInfo.html || iconInfo.html == '') {
        var currentIconOptions = $.extend(true, {}, currentStyle.icon.options);
        if (currentIconOptions.html == iconInfo.html) return;
        currentIconOptions.html = iconInfo.html;
        icon = GSI.divIcon(currentIconOptions);
      }
      else {
        var currentIconUrl = "";
        var currentIconScale = 1;
        var currentIconSize = [20, 20];
        var currentIconAnchor = [10, 10];

        if (currentStyle.icon) {
          currentIconUrl = currentStyle.icon.options.iconUrl;
          currentIconScale = currentStyle.icon.options._iconScale;
          currentIconSize = currentStyle.icon.options.iconSize;
          currentIconAnchor = currentStyle.icon.options.iconAnchor;

          if (!currentIconScale) currentIconScale = 1;
        }

        var iconScale = (iconInfo._iconScale ? iconInfo._iconScale : currentIconScale);

        if (currentIconSize) {
          currentIconSize[0] = Math.floor(parseFloat(currentIconSize[0]) * (1.0 / parseFloat(currentIconScale)) * parseFloat(iconScale));
          currentIconSize[1] = Math.floor(parseFloat(currentIconSize[1]) * (1.0 / parseFloat(currentIconScale)) * parseFloat(iconScale));
        }

        if (currentIconAnchor) {
          currentIconAnchor[0] = Math.floor(parseFloat(currentIconAnchor[0]) * (1.0 / parseFloat(currentIconScale)) * parseFloat(iconScale));
          currentIconAnchor[1] = Math.floor(parseFloat(currentIconAnchor[1]) * (1.0 / parseFloat(currentIconScale)) * parseFloat(iconScale));
        }

        var iconSize = (iconInfo.iconSize ? iconInfo.iconSize : currentIconSize);
        var iconAnchor = (iconInfo.iconAnchor ? iconInfo.iconAnchor : currentIconAnchor);

        icon = L.icon({
          iconUrl: (iconInfo.iconUrl ? iconInfo.iconUrl : currentIconUrl),
          iconSize: iconSize,
          iconAnchor: iconAnchor,
          _iconScale: iconScale
        });
      }
    }

    if (this._editingEditingLayer) {
      var oldStyle = this._editingEditingLayer.options;

      var newStyle = jQuery.extend(true, oldStyle, style);

      // marker
      if (this._editingEditingLayer.setIcon && icon) {
        this._editingEditingLayer.setIcon(icon);
      }

      // 円
      if (radius) {

        if (this._editingType == GSI.SakuzuListItem.POINT_CIRCLE) {
          this._editingEditingLayer._radius_px = radius;

        }
      }

      if (this._editingEditingLayer.setRadius && radius) { this._editingEditingLayer.setRadius(radius); }
      if (this._editingEditingLayer._mRadius && radius) { this._editingEditingLayer._mRadius = radius; }

      if (radius) {
        if (this._editingType == GSI.SakuzuListItem.POINT_CIRCLE) {
          if (this._editingPathList.length >= 1) {
            this._editingPathList[0].onZoomEnd();
          }
        }
      }

      // その他
      if (this._editingEditingLayer.setStyle) {
        this._editingEditingLayer.setStyle(newStyle);
        if( ( newStyle.geodesic ==true || newStyle.geodesic == false ) && this._editingEditingLayer.redraw)
          this._editingEditingLayer.redraw();

      }
    }

    if (this._nextPath) {
      // marker
      if (icon) {
        this._nextPath.setOptions({ icon: icon });
        if (this._nextPath._marker && this._nextPath._marker.setIcon)
          this._nextPath._marker.setIcon(icon);
      }

      // 円

      if (this._nextPath.setRadius && radius) this._nextPath.setRadius(radius);

      // その他
      var newStyle = jQuery.extend(true, this._nextPath.options.shapeOptions, style);
      var shape = this._nextPath._shape;
      if (!shape) shape = this._nextPath._poly;
      if (!shape) shape = this._nextPath._area;

      if (shape && shape.setStyle) {
        shape.setStyle(newStyle);
        if( ( newStyle.geodesic ==true || newStyle.geodesic == false ) && shape.redraw)
          shape.redraw();
      }
      if (this._nextPath.setOptions)
        this._nextPath.setOptions({ shapeOptions: newStyle });
    }

    if (this._editingPathList && this._editingPathList.length > 0) {
      for (var i = 0; i < this._editingPathList.length; i++) {
        // marker
        if (icon) {
          this._editingPathList[i].setOptions({ icon: icon });
          if (this._editingPathList[i]._marker && this._editingPathList[i]._marker.setIcon)
            this._editingPathList[i]._marker.setIcon(icon);
        }

        // 円
        if (this._editingPathList[i].setRadius && radius) this._editingPathList[i].setRadius(radius);

        // その他
        var newStyle = jQuery.extend(true, this._editingPathList[i].options.shapeOptions, style);
        var shape = this._editingPathList[i]._shape;
        if (!shape) shape = this._editingPathList[i]._poly;
        if (!shape) shape = this._editingPathList[i]._area;

        if (shape && shape.setStyle) {
          shape.setStyle(newStyle);
          if( ( newStyle.geodesic ==true || newStyle.geodesic == false ) && shape.redraw)
            shape.redraw();
        }
        if (this._editingPathList.setOptions)
          this._editingPathList.setOptions({ shapeOptions: newStyle });

      }
    }
  },

  _startAddInner : function(rect, layer) {

    if (!this._reservedFreatureGroup) {
      this._reservedFreatureGroup = L.featureGroup();
      this._owner._map.addLayer(this._reservedFreatureGroup);
    }

    var oldEditingLayer = this._editingEditingLayer;
    if (this._editingPathList) {
      for (var i = 0; i < this._editingPathList.length; i++) {
        this._editingPathList[i].disable();
      }
    }
    if ( rect ) this._reservedFrameFreatureGroup.removeLayer(rect);
    this._reservedFreatureGroup.removeLayer(layer);

    this._editingPathList = [];

    if (oldEditingLayer) {
      this._editingFreatureGroup.removeLayer(oldEditingLayer);
      this._editingEditingLayer = null;

      if (!oldEditingLayer._layerInfo) {
        oldEditingLayer._layerInfo = {};
      }

      this._addReservedFeature(oldEditingLayer);

    }
    this._editingType = GSI.SakuzuListItem.POLYGONINNER;

    this._editingEditingLayer = layer;
    this._editingFreatureGroup.addLayer(layer);
    this._owner.fire("createedit", {
      oldLayer: oldEditingLayer,
      currentLayer: layer,
      itemType: this._getType(layer)
    });

    if (oldEditingLayer) {
      oldEditingLayer._cloneLayer._layerInfo = oldEditingLayer._layerInfo;
      this._addReservedFrameRectangle(oldEditingLayer._cloneLayer);
    }
    this._reservedFrameFreatureGroup.addTo(this._owner._map);
    this._startAddInnerPolygon();
  },

  _getPolygonCenter : function(latlngs) {
    var minLat =undefined;
    var minLng = undefined;
    var maxLat =undefined;
    var maxLng = undefined;

    for ( var i=0; i<latlngs.length; i++ ) {
      var latlng = latlngs[i];
      if ( minLat == undefined || minLat > latlng.lat ) minLat = latlng.lat;
      if ( minLng == undefined || minLng > latlng.lng ) minLng = latlng.lng;
      if ( maxLat == undefined || maxLat < latlng.lat ) maxLat = latlng.lat;
      if ( maxLng == undefined || maxLng < latlng.lng ) maxLng = latlng.lng;
    }

    return L.latLng( (minLat + maxLat) / 2, (minLng + maxLng) / 2 );

  },
  _startAddInnerPolygon: function () {
    // ポリゴン編集開始
    L.drawLocal.draw.handlers.polygon.tooltip.start = '中抜き-開始位置をクリック';
    L.drawLocal.draw.handlers.polygon.tooltip.cont = '中抜き-次の位置を選択';
    L.drawLocal.draw.handlers.polygon.tooltip.end = GSI.TEXT.LINEEDITTIP + '中抜き-次の位置を選択(最終点を2回クリックして終了)';

    this._editingPathList = [];

    // デフォルト
    var shapeOptions = {
      color: '#000000',
      fillColor: '#ffffff',
      weight: 2,
      opacity: 0.5,
      fillOpacity: 0.5,
      stroke: true,
      fill: true,
      clickable: true,
      geodesic: true
    };

    if ( this._editingEditingLayer.options.weight ) {
      shapeOptions.weight = this._editingEditingLayer.options.weight;
    }
    if ( this._editingEditingLayer.options.color ) {
      shapeOptions.color = this._editingEditingLayer.options.color;
    }
    if ( !this._editingEditingLayer.options.stroke ) {
      shapeOptions.stroke = false;
    }
    if ( this._editingEditingLayer.options.opacity != undefined ) {
      shapeOptions.opacity = this._editingEditingLayer.options.opacity;
    }

    if (!this._pathCreatedEventHandler) {
      this._pathCreatedEventHandler = L.bind(this._onPathCreated, this);
      this._owner._map.on('draw:created', this._pathCreatedEventHandler);
      this._owner._map.on('draw:measurechange', function () {

      });
    }

    var path = new GSI.Draw.Polygon(this._owner._map, {
      shapeOptions: shapeOptions,
      edit: { featureGroup: this._editingFreatureGroup },
      showArea: true,
      allowIntersection: false,
      ownerPolygon : this._editingEditingLayer
    });

    path.enable();

    this._editingPathList.push(path);

    this._initializeInnerRemoveButtons();
  },

  _initializeInnerRemoveButtons : function() {
    if ( this._removeInnerButtons ) this._removeInnerButtons.remove();
    this._removeInnerButtons = L.featureGroup();

    var latlngs = this._editingEditingLayer.getLatLngs();

    if ( !L.LineUtil.isFlat(latlngs) ) {

      if ( latlngs.length < 0 || L.LineUtil.isFlat(latlngs[0])) {

        for( var i=1; i<latlngs.length; i++ ) {

          var center = this._getPolygonCenter(latlngs[i]);
          var removeMarker = L.marker(center, {
            icon: L.divIcon({ iconSize: [30, 30], iconAnchor: [16, 16], className: 'gsi_pathframerectangle_removebtn', html: "" }),
            zIndexOffset: 4000
          }).on("click", L.bind(function(idx) {
            var latlngs = this._editingEditingLayer.getLatLngs();
            latlngs.splice( idx,1);
            this._editingEditingLayer.setLatLngs(latlngs);

            this._initializeInnerRemoveButtons();
          }, this, i));
          this._removeInnerButtons.addLayer(removeMarker);

        }
      } else {
        for( var i=0; i<latlngs.length; i++ ) {
          for( var j=1; j<latlngs[i].length; j++ ) {
            var center = this._getPolygonCenter(latlngs[i][j]);
            var removeMarker = L.marker(center, {
              icon: L.divIcon({ iconSize: [30, 30], iconAnchor: [16, 16], className: 'gsi_pathframerectangle_removebtn', html: "" }),
              zIndexOffset: 4000
            }).on("click", L.bind(function(idx, idx2) {
              var latlngs = this._editingEditingLayer.getLatLngs();
              latlngs[idx].splice( idx2,1);
              this._editingEditingLayer.setLatLngs(latlngs);

              this._initializeInnerRemoveButtons();
            }, this, i,j));
            this._removeInnerButtons.addLayer(removeMarker);

          }
        }
      }
    }
    this._removeInnerButtons.addTo( this._owner._map );
  },

  startCreate: function (id) {

    this.setVisible(true);
    this.editCancel();
    this._owner._mapMouse.setClickMoveEnable(false);

    this.editMode = GSI.SakuzuListItem.CREATE;

    this._editingType = id;

    if (!this._editingFreatureGroup) {
      this._editingFreatureGroup = L.featureGroup();
      this._owner._map.addLayer(this._editingFreatureGroup);
    }

    if (!this._pathCreatedEventHandler) {
      this._pathCreatedEventHandler = L.bind(this._onPathCreated, this);
      this._owner._map.on('draw:created', this._pathCreatedEventHandler);
      this._owner._map.on('draw:measurechange', function () {

      });

    }

    this._editingEditingLayerInfo = {
      title: null,
      description: null,
      table: null
    };

    switch (id) {
      case GSI.SakuzuListItem.POINT:
        this._startEditPoint();
        break;
      case GSI.SakuzuListItem.POINT_CIRCLE:
        this._startEditPointCircle();
        break;
      case GSI.SakuzuListItem.POINT_TEXT:
        this._startEditPointText();
        break;
      case GSI.SakuzuListItem.LINESTRING:
        this._startEditLineString();
        break;
      case GSI.SakuzuListItem.POLYGON:
        this._startEditPolygon();
        break;
      case GSI.SakuzuListItem.CIRCLE:
        this._startEditCircle();
        break;
      case GSI.SakuzuListItem.FREEHAND:
        this._startEditFreehand();
        break;
    }

    this._owner._map.startAutoPan();

  },

  startEdit: function (id, layer) {
    this.setVisible(true);
    this.editCancel();
    this._owner._mapMouse.setClickMoveEnable(false);

    this.editMode = GSI.SakuzuListItem.EDIT;

    this._editingType = id;

    if (!this._editingFreatureGroup) {
      this._editingFreatureGroup = L.featureGroup();
      this._owner._map.addLayer(this._editingFreatureGroup);
    }
    if (!layer._information) {
      layer._information = this._getLayerInfo(layer);
    }
    this._editingEditingLayerInfo = $.extend(true, {}, layer._information ? layer._information : {});

    this._editingOriginalLayer = layer;

    (layer._parent ? layer._parent : this._layer).removeLayer(layer);
    this._editingEditingLayer = this._cloneLayer(this._editingType, layer);
    this._editingEditingLayerSRC = $.extend(true, {}, this._editingEditingLayer);
    this._editingFreatureGroup.addLayer(this._editingEditingLayer);

    this._destroyEditEventHandler();
    this._destroyEditPathList();

    this._startPathEdit();
  },

  _cloneLatLngs: function (src) {
    var result = [];

    if (src.length > 0 && src[0] instanceof L.LatLng) {
      for (var i = 0; i < src.length; i++) {
        if (src[i].lat) {
          result.push(L.latLng(src[i].lat, src[i].lng, src[i].alt));
        }
      }
    }
    else {
      for (var i = 0; i < src.length; i++) {
        result[i] = [];
        for (var j = 0; j < src[i].length; j++) {
          if (src[i][j].lat) {
            result[i].push(L.latLng(src[i][j].lat, src[i][j].lng, src[i][j].alt));
          } else {

            var latlngs = [];
            for (var k = 0; k < src[i][j].length; k++) {
              latlngs.push(L.latLng(src[i][j][k].lat, src[i][j][k].lng, src[i][j][k].alt));
            }
            result[i].push(latlngs)
          }
        }
      }
    }
    return result;
  },

  _cloneLayer: function (layerType, layer) {
    var result = null;
    switch (layerType) {
      case GSI.SakuzuListItem.POINT:
        var iconOptions = $.extend(true, {}, layer.options.icon.options);
        var icon = L.icon(iconOptions);
        result = L.marker(layer.getLatLng(), { icon: icon, draggable: false });
        break;

      case GSI.SakuzuListItem.POINT_TEXT:
        var iconOptions = $.extend(true, {}, layer.options.icon.options);
        var icon = new GSI.DivIcon(iconOptions);
        result = L.marker(layer.getLatLng(), { icon: icon, draggable: false });
        break;

      case GSI.SakuzuListItem.POLYGON:
        result = L.polygon(this._cloneLatLngs(layer.getLatLngs()), layer.options);
        result.feature = layer.feature;
        break;

      case GSI.SakuzuListItem.MULTIPOLYGON:
        result = L.polygon(this._cloneLatLngs(layer.getLatLngs()), layer.options);
        result.feature = layer.feature;
        break;

      case GSI.SakuzuListItem.LINESTRING:
      case GSI.SakuzuListItem.FREEHAND:
        result = L.polyline(this._cloneLatLngs(layer.getLatLngs()), layer.options);
        result.feature = layer.feature;
        break;

      case GSI.SakuzuListItem.POINT_CIRCLE:
        var latlng = layer.getLatLng();
        var radius = layer.getRadius();
        result = new L.CircleMarker(latlng, layer.options);
        result.setRadius(radius);
        result._radius_px = radius;
        break;
      case GSI.SakuzuListItem.CIRCLE:
        var latlng = layer.getLatLng();
        var radius = layer.getRadius();
        var radius_px = null;
        result = L.circle(latlng, radius, layer.options);
        break;

      case GSI.SakuzuListItem.MULTILINESTRING:
      case GSI.SakuzuListItem.MULTIPOINT:
        result = L.featureGroup();
        result.feature = layer.feature;
        var layers = layer.getLayers();
        for (var i = 0; i < layers.length; i++) {
          var childLayerType = this._getType(layers[i]);
          var childLayer = this._cloneLayer(childLayerType, layers[i]);
          if (childLayer) {
            childLayer._information = null;
            result.addLayer(childLayer);
          }
        }
        break;
    }

    if (result) {
      result._information = layer._information;
      result._layerInfo = layer._layerInfo;
      result._edited = layer._edited;
    }
    return result;
  },

  _getType: function (layer) {
    var itemType = '';

    if (layer instanceof L.CircleMarker && !(layer instanceof L.Circle)) {
      itemType = GSI.SakuzuListItem.POINT_CIRCLE;
    }
    else if (layer instanceof L.Circle) {
      // 円
      itemType = GSI.SakuzuListItem.CIRCLE;

    }
    else {
      if (layer.getLayers) {
        itemType = GSI.SakuzuListItem.FEATURES;
        if (layer.feature && layer.feature.geometry && layer.feature.geometry.type) {
          switch (layer.feature.geometry.type) {
            case "MultiPolygon":
              itemType = GSI.SakuzuListItem.MULTIPOLYGON;
              break;

            case "MultiLineString":
              itemType = GSI.SakuzuListItem.MULTILINESTRING;
              break;

            case "MultiPoint":
              itemType = GSI.SakuzuListItem.MULTIPOINT;
              break;
          }
        }
      }
      else {
        var geoJSON = layer.toGeoJSON();

        switch (geoJSON.geometry.type) {
          case "Point":
            // DivIcon判定
            if (layer.options.icon instanceof L.DivIcon) {
              itemType = GSI.SakuzuListItem.POINT_TEXT;
            }
            else {
              itemType = GSI.SakuzuListItem.POINT;
            }
            break;

          case "Polygon":
            itemType = GSI.SakuzuListItem.POLYGON;
            break;

          case "MultiPolygon":
            itemType = GSI.SakuzuListItem.MULTIPOLYGON;
            break;
          case "LineString":
            itemType = GSI.SakuzuListItem.LINESTRING;
            break;
        }
      }
    }
    return itemType;
  },

  _onLayerClick: function (layer) {
    var itemType = this._getType(layer);
    if (itemType != '') {
      this._owner.fire('startedit', { itemType: itemType, layer: layer });
    }
  },

  _getLayers: function (layer, list, parent) {
    if (!layer) return;

    var layerType = this._getType(layer);

    if (layerType != GSI.SakuzuListItem.FEATURES) {
      layer._parent = parent;
      list.push(layer);
    }
    else {
      var layers = layer.getLayers();
      for (var i = 0; i < layers.length; i++)
        this._getLayers(layers[i], list, layer);
    }
  },

  startSelectTarget: function () {
    this.setVisible(true);
    this._owner._mapMouse.setClickMoveEnable(false);

    if (!this._layer) return;
    this.editMode = GSI.SakuzuListItem.EDIT;
    // 選択用rectangle
    if (!this._editingBoundsRects) {
      this._editingBoundsRects = L.featureGroup().addTo(this._owner._map);
    }

    if (!this._reservedFreatureGroup) {
      this._reservedFreatureGroup = L.featureGroup();
      this._owner._map.addLayer(this._reservedFreatureGroup);
    }

    if (!this._editingFreatureGroup) {
      this._editingFreatureGroup = L.featureGroup();
      this._owner._map.addLayer(this._editingFreatureGroup);
    }

    var layers = [];
    this._originalLayers = [];

    this._getLayers(this._layer, layers);
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      layer._edited = false;
      layer.id = (i + 1);
      // ポップアップストップ
      if (layer.closePopup) layer.closePopup();
      if (layer.unbindPopup) layer.unbindPopup();

      if (!layer._information) {
        layer._information = this._getLayerInfo(layer);
      }
      layer._layerInfo = $.extend(true, {}, layer._information);
      (layer._parent ? layer._parent : this._layer).removeLayer(layer);
      layer._originalLayer = null;
      this._addReservedFeature(layer);
      this._addReservedFrameRectangle(layer._cloneLayer);
      this._originalLayers.push(layer);

    }
    this._owner._map.addLayer(this._reservedFrameFreatureGroup);

    return;

  },

  getReserveLength : function() {
    if ( !this._reservedFreatureGroup ) return 0;
    return this._reservedFreatureGroup.getLayers().length;

  },

  getEditedReserveLength : function() {
    if ( !this._reservedFreatureGroup ) return 0;
    var layers = this._reservedFreatureGroup.getLayers();
    var num = 0;
    for(var i=0;i<layers.length; i++ ) {
      if ( layers[i]._edited ) num++;

    }
    return num;

  },

  getRemovedReserveLength : function() {
    if ( !this._reservedFreatureGroup || !this._originalLayers) return 0;
    return this._originalLayers.length - this._reservedFreatureGroup.getLayers().length;

  },

  _addReservedFeature: function (layer, edited) {
    var cloneLayer = this._cloneLayer(this._getType(layer), layer);
    cloneLayer._originalLayer = (layer._originalLayer ? layer._originalLayer : layer);
    layer._cloneLayer = cloneLayer;

    if ( edited == true ) {
      cloneLayer._edited = true;
      layer._edited = true;
    }
    this._reservedFreatureGroup.addLayer(cloneLayer);

    this._fireReserve();
  },

  _refreshEditingBoundsRects: function () {
    // 選択用rectangle
    if (!this._editingBoundsRects) {
      this._editingBoundsRects = L.featureGroup().addTo(this._owner._map);
    }
    else {
      this._editingBoundsRects.clearLayers();
    }

    var layers = [];
    this._getLayers(this._layer, layers);

    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      layer.id = (i + 1);

      var rect = null;
      var rectStyle = { color: "#ff3333", weight: 2, fill: false, opacity: 1, dashArray: [3, 3] };

      if (layer.getRadius) {
        var latlng = layer._latlng;
        var radius = layer.getRadius();

        if ((layer.feature && layer.feature.propertiesl && layer.feature.properties._markerType == "CircleMarker") || (layer.getLabel && layer._showLabel)) {
          rect = new GSI.PixelRectangle(layer.getLatLng(), radius * 2, radius * 2, radius, radius, rectStyle);

          radius = GSI.Utils.ConverUnit(this._owner._map, layer, radius, "px", "m");
        }
        else {
          var latRadius = (radius / 40075017 * 360);
          var lngRadius = (latRadius / Math.cos(L.LatLng.DEG_TO_RAD * latlng.lat));

          rect = L.rectangle(
            new L.LatLngBounds(
              [latlng.lat - latRadius, latlng.lng - lngRadius],
              [latlng.lat + latRadius, latlng.lng + lngRadius]),
            rectStyle);
        }
      }
      else if (layer.getBounds) {
        rect = L.rectangle(layer.getBounds(), rectStyle);
      }
      else {
        if (layer.getLatLng) {
          var w = 50;
          var h = 50;
          var anchorX = 25;
          var anchorY = 25;

          if (layer.options.icon && layer.options.icon.options.iconUrl && layer.options.icon.options.iconSize) {
            w = layer.options.icon.options.iconSize[0] + 8;
            h = layer.options.icon.options.iconSize[1] + 8;
          }
          else if (layer._icon) {
            w = $(layer._icon).outerWidth(true) + 8;
            h = $(layer._icon).outerHeight(true) + 8;
          }

          if (layer.options.icon && layer.options.icon.options.iconAnchor) {
            anchorX = layer.options.icon.options.iconAnchor[0] + 4;
            anchorY = layer.options.icon.options.iconAnchor[1] + 4;
          }
          else if (layer.options.icon && (layer.options.icon.options.html || layer.options.icon.options.html != '')) {
            anchorX = 4;
            anchorY = 4;
          }
          else {
            anchorX = Math.round(w / 2);
            anchorY = Math.round(h / 2);
          }

          rect = new GSI.PixelRectangle(layer.getLatLng(), w, h, anchorX, anchorY, rectStyle);
        }
      }
      layer._boundRect = rect;
      if (rect) {
        rect.id = layer.id;
        this._editingBoundsRects.addLayer(rect);
      }
    }
  },

  _startEditPoint: function () {
    // ポイント編集開始
    L.drawLocal.draw.handlers.marker.tooltip.start = 'マーカーを置くポイントをクリック';

    this._editingPathList = [];

    var myiconScale = CONFIG.SAKUZU.SYMBOL.ICON_SCALE;
    var myiconSize = this._owner._defaultIcon.size;
    var __myIconSize = [
      Math.floor(this._owner._defaultIcon.size[0] * myiconScale),
      Math.floor(this._owner._defaultIcon.size[1] * myiconScale)
    ];
    var myiconAnchor = this._owner._defaultIcon.anchor;
    var __myiconAnchor = [
      Math.floor(this._owner._defaultIcon.anchor[0] * myiconScale),
      Math.floor(this._owner._defaultIcon.anchor[1] * myiconScale)
    ];

    this._owner._defaultIcon.url = CONFIG.SAKUZU.SYMBOL.URL + CONFIG.SAKUZU.SYMBOL.DEFAULTICON;
    this._owner._defaultIcon._iconScale = CONFIG.SAKUZU.SYMBOL.ICON_SCALE;

    var path = new L.Draw.Marker(this._owner._map, {
      edit: { featureGroup: this._editingFreatureGroup },
      showLength: false,
      icon: L.icon({
        iconUrl: this._owner._defaultIcon.url,
        iconSize: __myIconSize,
        iconAnchor: __myiconAnchor,
        _iconScale: CONFIG.SAKUZU.SYMBOL.ICON_SCALE
      })
    });

    path.enable();

    this._editingPathList.push(path);
  },

  _startEditPointCircle: function () {
    L.drawLocal.draw.handlers.circle.tooltip.start = '中心位置をクリックしドラッグしてください';
    L.drawLocal.draw.handlers.simpleshape.tooltip.end = 'マウスボタンを離して終了';

    this._editingPathList = [];
    // デフォルト
    var shapeOptions = {
      color: '#000000',
      fillColor: '#ff0000',
      weight: 3,
      opacity: 0.5,
      fillOpacity: 0.5,
      stroke: true,
      fill: true,
      clickable: true
    };
    var path = new GSI.Draw.CircleMarker(this._owner._map, {
      shapeOptions: shapeOptions,
      repeatMode : true,
      edit: { featureGroup: this._editingFreatureGroup },
      showLength: true
    });
    path.on('change', L.bind(this._onCircleChange, this));
    path.enable();

    this._editingPathList.push(path);
  },

  _startEditPointText: function () {
    // ポイント(テキスト)編集開始
    L.drawLocal.draw.handlers.marker.tooltip.start = 'テキストを置くポイントをクリック';

    this._editingPathList = [];

    var path = new L.Draw.Marker(this._owner._map, {
      edit: { featureGroup: this._editingFreatureGroup },
      showLength: false,
      icon: GSI.divIcon({
        className: 'gsi-div-icon',
        html: ''
      })
    });

    path.enable();

    this._editingPathList.push(path);
  },

  _startEditLineString: function () {
    // ライン編集開始
    L.drawLocal.draw.handlers.polyline.tooltip.start = '開始位置をクリック';
    L.drawLocal.draw.handlers.polyline.tooltip.cont = '次の位置を選択(最終点を2回クリックして終了)';
    L.drawLocal.draw.handlers.polyline.tooltip.end = GSI.TEXT.LINEEDITTIP + '次の位置を選択(最終点を2回クリックして終了)';

    this._editingPathList = [];

    // デフォルト
    var shapeOptions = {
      color: '#000000',
      weight: 3,
      stroke: true,
      fill: false,
      clickable: true,
      geodesic: true
    };

    var path = new GSI.Draw.Polyline(this._owner._map, {
      shapeOptions: shapeOptions,
      edit: { featureGroup: this._editingFreatureGroup },
      showLength: true
    });
    path.enable();

    this._editingPathList.push(path);

  },

  _startEditPolygon: function () {
    // ポリゴン編集開始
    L.drawLocal.draw.handlers.polygon.tooltip.start = '開始位置をクリック';
    L.drawLocal.draw.handlers.polygon.tooltip.cont = '次の位置を選択';
    L.drawLocal.draw.handlers.polygon.tooltip.end = GSI.TEXT.LINEEDITTIP + '次の位置を選択(最終点を2回クリックして終了)';

    this._editingPathList = [];

    // デフォルト
    var shapeOptions = {
      color: '#000000',
      fillColor: '#ff0000',
      weight: 3,
      opacity: 0.5,
      fillOpacity: 0.5,
      stroke: true,
      fill: true,
      clickable: true,
      geodesic: true
    };

    var path = new GSI.Draw.Polygon(this._owner._map, {
      shapeOptions: shapeOptions,
      edit: { featureGroup: this._editingFreatureGroup },
      showArea: true,
      allowIntersection: false
    });
    path.enable();

    this._editingPathList.push(path);
  },

  _startEditCircle: function () {
    L.drawLocal.draw.handlers.circle.tooltip.start = '中心位置をクリックしドラッグしてください';
    L.drawLocal.draw.handlers.simpleshape.tooltip.end = 'マウスボタンを離して終了';

    this._editingPathList = [];

    // デフォルト
    var shapeOptions = {
      color: '#000000',
      fillColor: '#ff0000',
      weight: 3,
      opacity: 0.5,
      fillOpacity: 0.5,
      stroke: true,
      fill: true,
      clickable: true
    };

    var path = new GSI.Draw.Circle(this._owner._map, {
      shapeOptions: shapeOptions,
      repeatMode : true,
      edit: { featureGroup: this._editingFreatureGroup },
      showLength: true
    });
    path.on('change', L.bind(this._onCircleChange, this));
    path.enable();

    this._editingPathList.push(path);
  },

  _startEditFreehand: function () {
    L.drawLocal.draw.handlers.simpleshape.tooltip.end = 'マウスボタンを離して終了';

    this._editingPathList = [];

    // デフォルト
    var shapeOptions = {
      color: '#000000',
      weight: 3,
      opacity: 0.5,
      stroke: true,
      fill: false,
      clickable: true
    };

    var path = new GSI.Draw.FreehandPolyline(this._owner._map, {
      shapeOptions: shapeOptions,
      repeatMode : true,
      edit: { featureGroup: this._editingFreatureGroup },
      showLength: true
    });
    path.enable();

    this._editingPathList.push(path);
  },

  _onCircleChange: function (event) {
    if (this._editingType == GSI.SakuzuListItem.POINT_CIRCLE && event.radius) {
      this._editingEditingLayer_radius_px = event.radius;
      if (this._editingEditingLayer) {
        this._editingEditingLayer._radius_px = this._editingEditingLayer_radius_px;
      }
    }
    try {
      this.fire('circlechange', event);
      this._owner.fire('circlechange', event);
    } catch(ex ) {}
  },

  createNext: function (info) {
    var layerType = this._getType(this._editingEditingLayer);

    if (layerType == GSI.SakuzuListItem.LINESTRING || layerType == GSI.SakuzuListItem.POLYGON
      || layerType == GSI.SakuzuListItem.POINT_CIRCLE || layerType == GSI.SakuzuListItem.CIRCLE
      || layerType == GSI.SakuzuListItem.POINT || layerType == GSI.SakuzuListItem.POINT_TEXT) {
      if (this._reservedFrameFreatureGroup) {
        this._reservedFrameFreatureGroup.addTo(this._owner._map);
      }
    }

    this._owner._map.startAutoPan();

    var prevLayer = this._editingEditingLayer;

    // 続けて作成
    switch (layerType) {
      case GSI.SakuzuListItem.POINT:
        // ポイント編集開始
        L.drawLocal.draw.handlers.marker.tooltip.start = 'マーカーを置くポイントをクリック';

        var myiconScale = CONFIG.SAKUZU.SYMBOL.ICON_SCALE;
        var myiconSize = this._owner._defaultIcon.size;
        var __myIconSize = [
          Math.floor(this._owner._defaultIcon.size[0] * myiconScale),
          Math.floor(this._owner._defaultIcon.size[1] * myiconScale)
        ];
        var myiconAnchor = this._owner._defaultIcon.anchor;
        var __myiconAnchor = [
          Math.floor(this._owner._defaultIcon.anchor[0] * myiconScale),
          Math.floor(this._owner._defaultIcon.anchor[1] * myiconScale)
        ];

        var path = new L.Draw.Marker(this._owner._map, {
          edit: { featureGroup: this._editingFreatureGroup },
          showLength: false,
          icon: L.icon({
            iconUrl: this._owner._defaultIcon.url,
            iconSize: __myIconSize,
            iconAnchor: __myiconAnchor,
            _iconScale: CONFIG.SAKUZU.SYMBOL.ICON_SCALE
          })
        });

        this._nextPath = path;
        this._nextPath._layerType = layerType;
        path.enable();

        break;

      case GSI.SakuzuListItem.POINT_TEXT:
        // ポイント(テキスト)編集開始
        L.drawLocal.draw.handlers.marker.tooltip.start = 'テキストを置くポイントをクリック';

        var path = new L.Draw.Marker(this._owner._map, {
          edit: { featureGroup: this._editingFreatureGroup },
          showLength: false,
          icon: GSI.divIcon({
            className: 'gsi-div-icon',
            html: ''
          })
        });

        this._nextPath = path;
        this._nextPath._layerType = layerType;
        path.enable();

        break;

      case GSI.SakuzuListItem.LINESTRING:

        if (this._editingType == GSI.SakuzuListItem.FREEHAND) {
          L.drawLocal.draw.handlers.simpleshape.tooltip.end = 'マウスボタンを離して終了';

          // デフォルト
          var shapeOptions = {
            color: '#000000',
            weight: 3,
            opacity: 0.5,
            stroke: true,
            fill: false,
            clickable: true
          };
          if (prevLayer && prevLayer.options) {
            for (var key in shapeOptions) {
              if (prevLayer.options[key] || prevLayer.options[key] == 0 || prevLayer.options[key] == false) {
                shapeOptions[key] = prevLayer.options[key];
              }
            }
          }

          var path = new GSI.Draw.FreehandPolyline(this._owner._map, {
            shapeOptions: shapeOptions,
            repeatMode:true,
            edit: { featureGroup: this._editingFreatureGroup },
            showLength: true
          });

          this._nextPath = path;
          path.enable();

        } else {
        // ライン編集開始
          L.drawLocal.draw.handlers.polyline.tooltip.start = '開始位置をクリック';
          L.drawLocal.draw.handlers.polyline.tooltip.cont = '次の位置を選択(最終点を2回クリックして終了)';
          L.drawLocal.draw.handlers.polyline.tooltip.end = GSI.TEXT.LINEEDITTIP + '次の位置を選択(最終点を2回クリックして終了)';

          // デフォルト
          var shapeOptions = {
            color: '#000000',
            weight: 3,
            stroke: true,
            fill: false,
            clickable: true,
            geodesic: true,
            opacity : 0.5,
            dashArray : null
          };

          if (prevLayer && prevLayer.options) {
            for (var key in shapeOptions) {

              if (prevLayer.options[key] || prevLayer.options[key] == 0 || prevLayer.options[key] == false) {
                shapeOptions[key] = prevLayer.options[key];
              }
            }
          }

          var path = new GSI.Draw.Polyline(this._owner._map, {
            shapeOptions: shapeOptions,
            edit: { featureGroup: this._editingFreatureGroup },
            showLength: true
          });
          this._nextPath = path;

          path.enable();
        }

        break;

      case GSI.SakuzuListItem.POLYGON:
        // ポリゴン編集開始
        L.drawLocal.draw.handlers.polygon.tooltip.start = '開始位置をクリック';
        L.drawLocal.draw.handlers.polygon.tooltip.cont = '次の位置を選択';
        L.drawLocal.draw.handlers.polygon.tooltip.end = GSI.TEXT.LINEEDITTIP + '次の位置を選択(最終点を2回クリックして終了)';

        var shapeOptions = {
          color: '#000000',
          fillColor: '#ff0000',
          weight: 3,
          opacity: 0.5,
          fillOpacity: 0.5,
          stroke: true,
          fill: true,
          clickable: true,
          geodesic: true,
          dashArray : null
        };

        if (prevLayer && prevLayer.options) {
          for (var key in shapeOptions) {
            if (prevLayer.options[key] || prevLayer.options[key] == 0 || prevLayer.options[key] == false) {
              shapeOptions[key] = prevLayer.options[key];
            }
          }
        }

        var path = new GSI.Draw.Polygon(this._owner._map, {
          shapeOptions: shapeOptions,
          edit: { featureGroup: this._editingFreatureGroup },
          showArea: true,
          allowIntersection: false
        });

        this._nextPath = path;

        path.enable();
        break;

      case GSI.SakuzuListItem.POINT_CIRCLE:

        L.drawLocal.draw.handlers.circle.tooltip.start = '中心位置をクリックしドラッグしてください';
        L.drawLocal.draw.handlers.simpleshape.tooltip.end = 'マウスボタンを離して終了';

        // デフォルト
        var shapeOptions = {
          color: '#000000',
          fillColor: '#ff0000',
          weight: 3,
          opacity: 0.5,
          fillOpacity: 0.5,
          stroke: true,
          fill: true,
          clickable: true,
          dashArray : null
        };

        if (prevLayer && prevLayer.options) {
          for (var key in shapeOptions) {
            if (prevLayer.options[key] || prevLayer.options[key] == 0 || prevLayer.options[key] == false) {
              shapeOptions[key] = prevLayer.options[key];
            }
          }
        }
        var path = new GSI.Draw.CircleMarker(this._owner._map, {
          shapeOptions: shapeOptions,
          repeatMode : true,
          edit: { featureGroup: this._editingFreatureGroup },
          showLength: true
        });

        this._nextPath = path;

        path.on('change', L.bind(this._onCircleChange, this));
        path.enable();

        break;

      case GSI.SakuzuListItem.CIRCLE:

        L.drawLocal.draw.handlers.circle.tooltip.start = '中心位置をクリックしドラッグしてください';
        L.drawLocal.draw.handlers.simpleshape.tooltip.end = 'マウスボタンを離して終了';

        // デフォルト
        var shapeOptions = {
          color: '#000000',
          fillColor: '#ff0000',
          weight: 3,
          opacity: 0.5,
          fillOpacity: 0.5,
          stroke: true,
          fill: true,
          clickable: true,
          dashArray : null
        };

        if (prevLayer && prevLayer.options) {
          for (var key in shapeOptions) {
            if (prevLayer.options[key] || prevLayer.options[key] == 0 || prevLayer.options[key] == false) {
              shapeOptions[key] = prevLayer.options[key];
            }
          }
        }

        var path = new GSI.Draw.Circle(this._owner._map, {
          shapeOptions: shapeOptions,
          repeatMode:true,
          edit: { featureGroup: this._editingFreatureGroup },
          showLength: true
        });

        this._nextPath = path;

        path.on('change', L.bind(this._onCircleChange, this));
        path.enable();

        break;

    }

    if ( this._removeInnerButtons ) this._removeInnerButtons.remove();
    this._removeInnerButtons = null;

    var path = this._nextPath;

    if (!this._reservedFreatureGroup) {
      this._reservedFreatureGroup = L.featureGroup();
      this._owner._map.addLayer(this._reservedFreatureGroup);
    }

    var oldEditingLayer = this._editingEditingLayer;
    if (this._editingPathList) {
      for (var i = 0; i < this._editingPathList.length; i++) {
        this._editingPathList[i].disable();
      }
    }
    this._editingPathList = [];
    this._editingFreatureGroup.removeLayer(oldEditingLayer);
    this._editingEditingLayer = null;

    this._editingEditingLayerInfo = {
      title: null,
      description: null,
      table: null
    };

    var reservedFrameRectangle = null;

    if (oldEditingLayer) {
      if ( info )
        oldEditingLayer._layerInfo = $.extend( true, {}, info );
      this._editingEditingLayer = null;

      this._addReservedFeature(oldEditingLayer);

      oldEditingLayer._cloneLayer._layerInfo = oldEditingLayer._layerInfo;

      reservedFrameRectangle = this._addReservedFrameRectangle(oldEditingLayer._cloneLayer);
      this._reservedFrameFreatureGroup.addTo(this._owner._map);
    }

    this._editingPathList.push(path);

    if (layerType == GSI.SakuzuListItem.POINT_CIRCLE || layerType == GSI.SakuzuListItem.POINT_CIRCLE) {
      this._onCircleChange({ radius: null, unit: "m", skipEvent: true });
    }

    return reservedFrameRectangle;
  },

  editRollback : function(finish) {
    if ( !this._editingEditingLayer || !this._editingOriginalLayer ) return;

    if (!this._reservedFreatureGroup) {
      this._reservedFreatureGroup = L.featureGroup();
      this._owner._map.addLayer(this._reservedFreatureGroup);
    }

    if (this._editingPathList) {
      for (var i = 0; i < this._editingPathList.length; i++) {
        this._editingPathList[i].disable();
      }
    }
    this._editingPathList = [];

    this._editingFreatureGroup.removeLayer(this._editingEditingLayer);

    if ( !finish) {

      this._editingEditingLayer = this._editingOriginalLayer;
      this._editingEditingLayer._layerInfo = this._editingEditingLayer._information;

      if ( this._editingEditingLayer._cloneLayer )
        this._editingEditingLayer._cloneLayer._layerInfo = this._editingEditingLayer._layerInfo;

      this._editingOriginalLayer = null;
      return;
    }

    var oldEditingLayer = this._editingOriginalLayer;

    this._editingEditingLayerInfo = {
      title: null,
      description: null,
      table: null
    };

    if ( !finish) return ;
    var reservedFrameRectangle = null;

    if (oldEditingLayer) {

      this._addReservedFeature(oldEditingLayer);

      oldEditingLayer._cloneLayer._layerInfo = oldEditingLayer._layerInfo;

      reservedFrameRectangle = this._addReservedFrameRectangle(oldEditingLayer._cloneLayer);
      this._reservedFrameFreatureGroup.addTo(this._owner._map);
    }

    this._editingEditingLayer = null;
    this._editingOriginalLayer = null;

  },

  nextCreate: function (editingType) {
    var layerType = this._getType(this._editingEditingLayer);

    if (layerType == GSI.SakuzuListItem.LINESTRING || layerType == GSI.SakuzuListItem.POLYGON
      || layerType == GSI.SakuzuListItem.POINT_CIRCLE || layerType == GSI.SakuzuListItem.CIRCLE
      || layerType == GSI.SakuzuListItem.POINT || layerType == GSI.SakuzuListItem.POINT_TEXT) {
      if (this._reservedFrameFreatureGroup) {
        this._reservedFrameFreatureGroup.addTo(this._owner._map);
      }
    }

    this._owner._map.startAutoPan();

    var prevLayer = this._editingEditingLayer;

    // 続けて作成
    switch (layerType) {
      case GSI.SakuzuListItem.POINT:
        // ポイント編集開始
        L.drawLocal.draw.handlers.marker.tooltip.start = 'マーカーを置くポイントをクリック';

        var myiconScale = CONFIG.SAKUZU.SYMBOL.ICON_SCALE;
        var myiconSize = this._owner._defaultIcon.size;
        var __myIconSize = [
          Math.floor(this._owner._defaultIcon.size[0] * myiconScale),
          Math.floor(this._owner._defaultIcon.size[1] * myiconScale)
        ];
        var myiconAnchor = this._owner._defaultIcon.anchor;
        var __myiconAnchor = [
          Math.floor(this._owner._defaultIcon.anchor[0] * myiconScale),
          Math.floor(this._owner._defaultIcon.anchor[1] * myiconScale)
        ];

        var path = new L.Draw.Marker(this._owner._map, {
          edit: { featureGroup: this._editingFreatureGroup },
          showLength: false,
          icon: L.icon({
            iconUrl: this._owner._defaultIcon.url,
            iconSize: __myIconSize,
            iconAnchor: __myiconAnchor,
            _iconScale: CONFIG.SAKUZU.SYMBOL.ICON_SCALE
          })
        });

        this._nextPath = path;
        this._nextPath._layerType = layerType;
        path.enable();

        break;

      case GSI.SakuzuListItem.POINT_TEXT:
        // ポイント(テキスト)編集開始
        L.drawLocal.draw.handlers.marker.tooltip.start = 'テキストを置くポイントをクリック';

        var path = new L.Draw.Marker(this._owner._map, {
          edit: { featureGroup: this._editingFreatureGroup },
          showLength: false,
          icon: GSI.divIcon({
            className: 'gsi-div-icon',
            html: ''
          })
        });

        this._nextPath = path;
        this._nextPath._layerType = layerType;
        path.enable();

        break;

      case GSI.SakuzuListItem.LINESTRING:

        if (this._editingType == GSI.SakuzuListItem.FREEHAND) {
          L.drawLocal.draw.handlers.simpleshape.tooltip.end = 'マウスボタンを離して終了';

          // デフォルト
          var shapeOptions = {
            color: '#000000',
            weight: 3,
            opacity: 0.5,
            stroke: true,
            fill: false,
            clickable: true
          };

          if (prevLayer && prevLayer.options) {
            for (var key in shapeOptions) {
              if (prevLayer.options[key] || prevLayer.options[key] == 0 || prevLayer.options[key] == false) {
                shapeOptions[key] = prevLayer.options[key];
              }
            }
          }

          var path = new GSI.Draw.FreehandPolyline(this._owner._map, {
            shapeOptions: shapeOptions,
            edit: { featureGroup: this._editingFreatureGroup },
            showLength: true
          });

          this._nextPath = path;
          path.enable();

        } else {
        // ライン編集開始
          L.drawLocal.draw.handlers.polyline.tooltip.start = '開始位置をクリック';
          L.drawLocal.draw.handlers.polyline.tooltip.cont = '次の位置を選択(最終点を2回クリックして終了)';
          L.drawLocal.draw.handlers.polyline.tooltip.end = GSI.TEXT.LINEEDITTIP + '次の位置を選択(最終点を2回クリックして終了)';

          // デフォルト
          var shapeOptions = {
            color: '#000000',
            weight: 3,
            stroke: true,
            fill: false,
            clickable: true,
            geodesic: true,
            opacity : 0.5
          };

          if (prevLayer && prevLayer.options) {
            for (var key in shapeOptions) {

              if (prevLayer.options[key] || prevLayer.options[key] == 0 || prevLayer.options[key] == false) {
                shapeOptions[key] = prevLayer.options[key];
              }
            }
          }

          var path = new GSI.Draw.Polyline(this._owner._map, {
            shapeOptions: shapeOptions,
            edit: { featureGroup: this._editingFreatureGroup },
            showLength: true
          });
          this._nextPath = path;

          path.enable();
        }

        break;

      case GSI.SakuzuListItem.POLYGON:
        // ポリゴン編集開始
        L.drawLocal.draw.handlers.polygon.tooltip.start = '開始位置をクリック';
        L.drawLocal.draw.handlers.polygon.tooltip.cont = '次の位置を選択';
        L.drawLocal.draw.handlers.polygon.tooltip.end = GSI.TEXT.LINEEDITTIP + '次の位置を選択(最終点を2回クリックして終了)';

        var shapeOptions = {
          color: '#000000',
          fillColor: '#ff0000',
          weight: 3,
          opacity: 0.5,
          fillOpacity: 0.5,
          stroke: true,
          fill: true,
          clickable: true,
          geodesic: true
        };

        if (prevLayer && prevLayer.options) {
          for (var key in shapeOptions) {
            if (prevLayer.options[key] || prevLayer.options[key] == 0 || prevLayer.options[key] == false) {
              shapeOptions[key] = prevLayer.options[key];
            }
          }
        }

        var path = new GSI.Draw.Polygon(this._owner._map, {
          shapeOptions: shapeOptions,
          edit: { featureGroup: this._editingFreatureGroup },
          showArea: true,
          allowIntersection: false
        });

        this._nextPath = path;

        path.enable();
        break;

      case GSI.SakuzuListItem.POINT_CIRCLE:

        L.drawLocal.draw.handlers.circle.tooltip.start = '中心位置をクリックしドラッグしてください';
        L.drawLocal.draw.handlers.simpleshape.tooltip.end = 'マウスボタンを離して終了';

        // デフォルト
        var shapeOptions = {
          color: '#000000',
          fillColor: '#ff0000',
          weight: 3,
          opacity: 0.5,
          fillOpacity: 0.5,
          stroke: true,
          fill: true,
          clickable: true
        };

        if (prevLayer && prevLayer.options) {
          for (var key in shapeOptions) {
            if (prevLayer.options[key] || prevLayer.options[key] == 0 || prevLayer.options[key] == false) {
              shapeOptions[key] = prevLayer.options[key];
            }
          }
        }

        var path = new GSI.Draw.CircleMarker(this._owner._map, {
          shapeOptions: shapeOptions,
          edit: { featureGroup: this._editingFreatureGroup },
          showLength: true
        });

        this._nextPath = path;

        path.on('change', L.bind(this._onCircleChange, this));
        path.enable();

        break;

      case GSI.SakuzuListItem.CIRCLE:

        L.drawLocal.draw.handlers.circle.tooltip.start = '中心位置をクリックしドラッグしてください';
        L.drawLocal.draw.handlers.simpleshape.tooltip.end = 'マウスボタンを離して終了';

        // デフォルト
        var shapeOptions = {
          color: '#000000',
          fillColor: '#ff0000',
          weight: 3,
          opacity: 0.5,
          fillOpacity: 0.5,
          stroke: true,
          fill: true,
          clickable: true
        };

        if (prevLayer && prevLayer.options) {
          for (var key in shapeOptions) {
            if (prevLayer.options[key] || prevLayer.options[key] == 0 || prevLayer.options[key] == false) {
              shapeOptions[key] = prevLayer.options[key];
            }
          }
        }

        var path = new GSI.Draw.Circle(this._owner._map, {
          shapeOptions: shapeOptions,
          edit: { featureGroup: this._editingFreatureGroup },
          showLength: true
        });

        this._nextPath = path;

        path.on('change', L.bind(this._onCircleChange, this));
        path.enable();

        break;

    }

    if ( this._removeInnerButtons ) this._removeInnerButtons.remove();
    this._removeInnerButtons = null;

    var path = this._nextPath;

    if (!this._reservedFreatureGroup) {
      this._reservedFreatureGroup = L.featureGroup();
      this._owner._map.addLayer(this._reservedFreatureGroup);
    }

    var oldEditingLayer = this._editingEditingLayer;
    if (this._editingPathList) {
      for (var i = 0; i < this._editingPathList.length; i++) {
        this._editingPathList[i].disable();
      }
    }
    this._editingPathList = [];
    this._editingFreatureGroup.removeLayer(oldEditingLayer);
    this._editingEditingLayer = null;

    this._editingEditingLayerInfo = {
      title: null,
      description: null,
      table: null
    };

    if (oldEditingLayer) {
      oldEditingLayer._layerInfo = {};

      this._editingEditingLayer = path;
      // created
      try {
        this._owner.fire("next", {
          layerType: this._editingType,
          currentLayer: oldEditingLayer,
          nextPath: path
        });
      }catch(ex) {

      }

      this._editingEditingLayer = null;

      this._addReservedFeature(oldEditingLayer);

      oldEditingLayer._cloneLayer._layerInfo = oldEditingLayer._layerInfo;

      this._addReservedFrameRectangle(oldEditingLayer._cloneLayer);
      this._reservedFrameFreatureGroup.addTo(this._owner._map);

      this._owner.fire("ready");
    }

    this._editingPathList.push(path);

    if (layerType == GSI.SakuzuListItem.POINT_CIRCLE || layerType == GSI.SakuzuListItem.POINT_CIRCLE) {
      this._onCircleChange({ radius: null, unit: "m", skipEvent: true });
    }

  },

  nextCircleCreate: function () {
    this.nextCreate();

    var path = this._nextPath;

    if (!this._reservedFreatureGroup) {
      this._reservedFreatureGroup = L.featureGroup();
      this._owner._map.addLayer(this._reservedFreatureGroup);
    }

    var oldEditingLayer = this._editingEditingLayer;
    if (this._editingPathList) {
      for (var i = 0; i < this._editingPathList.length; i++) {
        this._editingPathList[i].disable();
      }
    }
    this._editingPathList = [];
    this._editingFreatureGroup.removeLayer(oldEditingLayer);
    this._editingEditingLayer = null;

    this._editingEditingLayerInfo = {
      title: null,
      description: null,
      table: null
    };

    if (oldEditingLayer) {
      oldEditingLayer._layerInfo = {};

      this._editingEditingLayer = path;
      // created
      this._owner.fire("next", {
        layerType: this._editingType,
        currentLayer: oldEditingLayer,
        nextPath: path
      });

      this._editingEditingLayer = null;

      this._addReservedFeature(oldEditingLayer);

      oldEditingLayer._cloneLayer._layerInfo = oldEditingLayer._layerInfo;

      this._addReservedFrameRectangle(oldEditingLayer._cloneLayer);
      this._reservedFrameFreatureGroup.addTo(this._owner._map);

      this._owner.fire("ready");
    }

    this._editingPathList.push(path);
    this._onCircleChange({ radius: null, unit: "m", skipEvent: true });

  },

  _onPathCreated: function (event) {
    if (this._editingType == GSI.SakuzuListItem.POINT_CIRCLE || this._editingType == GSI.SakuzuListItem.CIRCLE) {

      this._editingEditingLayer = event.layer;

      if (this._editingType == GSI.SakuzuListItem.POINT_CIRCLE) {
        event.layer._radius_px = this._editingEditingLayer_radius_px;
      }
      this._editingFreatureGroup.addLayer(event.layer);

      this._destroyEditPathList();

    } else if ( this._editingType == GSI.SakuzuListItem.POLYGONINNER) {

      var latlngs = this._editingEditingLayer.getLatLngs();

      if ( L.LineUtil.isFlat(latlngs) ) latlngs = [latlngs];

      var inner = $.extend(true, [], ( L.LineUtil.isFlat(event.layer._latlngs ) ? event.layer._latlngs :  event.layer._latlngs[0] ) );
      latlngs.push(inner);
      this._editingEditingLayer.setLatLngs(latlngs);
      this._startAddInnerPolygon();

      return;

    } else if ( this._editingType == GSI.SakuzuListItem.POLYGONINNER2) {

      var latlngs = this._editingEditingLayer.getLatLngs();

      if ( L.LineUtil.isFlat(latlngs) ) latlngs = [latlngs];

      var inner = $.extend(true, [], ( L.LineUtil.isFlat(event.layer._latlngs ) ? event.layer._latlngs :  event.layer._latlngs[0] ) );

      if ( event.layer.options._ownerIndex || event.layer.options._ownerIndex == 0 )
        latlngs[event.layer.options._ownerIndex].push(inner);
      else
        latlngs.push(inner);

      this._editingEditingLayer.setLatLngs(latlngs);
      this._startAddInnerPolygon2();

      return;

    } else {

      this._editingEditingLayer = event.layer;
      this._editingFreatureGroup.addLayer(event.layer);

      this._destroyEditPathList();

    }

    this._startPathEdit();
    this._owner._map.stopAutoPan();

    var reservedFrameRectangle = this.createNext();
    this._editReservedPath(reservedFrameRectangle, reservedFrameRectangle._targetPath, true);

    this.fire("created", {"layer":this._editingEditingLayer, "info": this._editingEditingLayerInfo});
    this._owner.fire('created');

    this._fireReserve();
  },

  restartCreate : function() {

    if (this._editingPathList) {
      for (var i = 0; i < this._editingPathList.length; i++) {
        this._editingPathList[i].disable();
      }
    }
    this._editingPathList = [];

    this._editingFreatureGroup.removeLayer(this._editingEditingLayer);
    this._editingEditingLayer = null;

    this.setVisible(true);

    if (!this._editingFreatureGroup) {
      this._editingFreatureGroup = L.featureGroup();
      this._owner._map.addLayer(this._editingFreatureGroup);
    }
    this._fireReserve();

    if (!this._pathCreatedEventHandler) {
      this._pathCreatedEventHandler = L.bind(this._onPathCreated, this);
      this._owner._map.on('draw:created', this._pathCreatedEventHandler);
      this._owner._map.on('draw:measurechange', function () {

      });
    }

    this._editingEditingLayerInfo = {
      title: null,
      description: null,
      table: null
    };

    switch (this._editingType) {
      case GSI.SakuzuListItem.POINT:
        this._startEditPoint();
        break;
      case GSI.SakuzuListItem.POINT_CIRCLE:
        this._startEditPointCircle();
        break;
      case GSI.SakuzuListItem.POINT_TEXT:
        this._startEditPointText();
        break;
      case GSI.SakuzuListItem.LINESTRING:
        this._startEditLineString();
        break;
      case GSI.SakuzuListItem.POLYGON:
        this._startEditPolygon();
        break;
      case GSI.SakuzuListItem.CIRCLE:
        this._startEditCircle();
        break;
      case GSI.SakuzuListItem.FREEHAND:
        this._startEditFreehand();
        break;
    }

    this._owner._map.startAutoPan();
  },

  removeEditingLayer: function () {
    if (!this._reservedFreatureGroup) {
      this._reservedFreatureGroup = L.featureGroup();
      this._owner._map.addLayer(this._reservedFreatureGroup);
    }

    var oldEditingLayer = this._editingEditingLayer;
    if (this._editingPathList) {
      for (var i = 0; i < this._editingPathList.length; i++) {
        this._editingPathList[i].disable();
      }
    }

    this._editingPathList = [];

    if (oldEditingLayer) {
      this._editingFreatureGroup.removeLayer(oldEditingLayer);
      this._editingEditingLayer = null;

      if (!oldEditingLayer._layerInfo) {
        oldEditingLayer._layerInfo = {};
      }

      this._addReservedFeature(oldEditingLayer);

    }

    this._editingEditingLayer = null;

    if (oldEditingLayer) {
      oldEditingLayer._cloneLayer._layerInfo = oldEditingLayer._layerInfo;
      this._addReservedFrameRectangle(oldEditingLayer._cloneLayer);
    }
    this._reservedFrameFreatureGroup.addTo(this._owner._map);

    this._reservedFreatureGroup.removeLayer(oldEditingLayer._cloneLayer);
    this._reservedFrameFreatureGroup.removeLayer(oldEditingLayer._cloneLayer._reservedFrameRectangle);
    this._owner.fire("createchange");

  },

  editingCancel : function() {

  },

  editingToReserve :function(info) {
    this._owner._map.stopAutoPan();

    if ( this._polyInnerPath ) this.commitPolygonInner();

    if (!this._reservedFreatureGroup) {
      this._reservedFreatureGroup = L.featureGroup();
      this._owner._map.addLayer(this._reservedFreatureGroup);
    }

    var oldEditingLayer = this._editingEditingLayer;
    if (this._editingPathList) {
      for (var i = 0; i < this._editingPathList.length; i++) {
        this._editingPathList[i].disable();
      }
    }

    this._editingPathList = [];

    if (oldEditingLayer) {
      this._editingFreatureGroup.removeLayer(oldEditingLayer);
      this._editingEditingLayer = null;

      if (!oldEditingLayer._layerInfo) {
        oldEditingLayer._layerInfo = {};
      }

      if ( info ) {
        var newLayerInfo =$.extend( true, {}, info );
        oldEditingLayer._layerInfo = newLayerInfo;
      }
      var changed = !this._layerEquals( this._editingOriginalLayer, oldEditingLayer );
      this._addReservedFeature(oldEditingLayer, changed);
      oldEditingLayer._cloneLayer._layerInfo = oldEditingLayer._layerInfo;
      this._addReservedFrameRectangle(oldEditingLayer._cloneLayer);
    }
    this._reservedFrameFreatureGroup.addTo(this._owner._map);
    this._editingOriginalLayer = null;
  },

  isEditingChange : function() {
    if ( !this._editingOriginalLayer || !this._editingEditingLayer ) return false;
    return !this._layerEquals( this._editingOriginalLayer, this._editingEditingLayer );
  },

  setEditingInfo : function( info ) {
    if ( !this._editingEditingLayer) return;

    if ( info ) {
      this._editingEditingLayer._layerInfo = $.extend( true, {}, info );
    } else {
      oldEditingLayer._layerInfo = {};
    }
  },

  _layerEquals : function( layer1, layer2 ) {
    var layerType = this._getType( layer1);
    layer1._information = $.extend( true, {}, layer1._layerInfo );
    layer2._information = $.extend( true, {}, layer2._layerInfo );
    var getGetJSON = L.bind(function(layer) {
      var itemType = this._getType(layer);
      var geoJSONData = null;

      switch (itemType) {
        case GSI.SakuzuListItem.POINT:
        case GSI.SakuzuListItem.POINT_TEXT:
        case GSI.SakuzuListItem.MULTIPOINT:
          geoJSONData = this._makeGeoJSONPoint(layer);
          break;

        case GSI.SakuzuListItem.POLYGON:
        case GSI.SakuzuListItem.MULTIPOLYGON:
          geoJSONData = this._makeGeoJSONPolygon(layer);
          break;

        case GSI.SakuzuListItem.LINESTRING:
        case GSI.SakuzuListItem.MULTILINESTRING:
          geoJSONData = this._makeGeoJSONLine(layer);
          break;

        case GSI.SakuzuListItem.CIRCLE:
        case GSI.SakuzuListItem.POINT_CIRCLE:
          geoJSONData = this._makeGeoJSONCircle(layer);
          if (itemType == GSI.SakuzuListItem.POINT_CIRCLE) {
            geoJSONData.properties["_markerType"] = "CircleMarker";
          }
          break;
      }

      return geoJSONData;

    },this);

    var l1Txt = JSON.stringify( getGetJSON( layer1) );
    var l2Txt  =JSON.stringify( getGetJSON( layer2) );

    return ( l1Txt == l2Txt && layer1.options.geodesic == layer2.options.geodesic );
  },

  _editReservedPath: function (rect, layer, withoutEvent) {

    this._owner._map.stopAutoPan();

    if ( this._polyInnerPath ) this.commitPolygonInner();

    if (!this._reservedFreatureGroup) {
      this._reservedFreatureGroup = L.featureGroup();
      this._owner._map.addLayer(this._reservedFreatureGroup);
    }

    var oldEditingLayer = this._editingEditingLayer;
    if (this._editingPathList) {
      for (var i = 0; i < this._editingPathList.length; i++) {
        this._editingPathList[i].disable();
      }
    }
    if ( rect ) this._reservedFrameFreatureGroup.removeLayer(rect);
    this._reservedFreatureGroup.removeLayer(layer);

    this._editingPathList = [];

    if (oldEditingLayer) {
      this._editingFreatureGroup.removeLayer(oldEditingLayer);
      this._editingEditingLayer = null;

      if (!oldEditingLayer._layerInfo) {
        oldEditingLayer._layerInfo = {};
      }

      this._addReservedFeature(oldEditingLayer);
    }

    this._editingOriginalLayer = layer;

    if ( !layer) {

      if (oldEditingLayer) {
        oldEditingLayer._cloneLayer._layerInfo = oldEditingLayer._layerInfo;
        this._addReservedFrameRectangle(oldEditingLayer._cloneLayer);
      }
      this._reservedFrameFreatureGroup.addTo(this._owner._map);
      return;
    }
    if (this.editMode == GSI.SakuzuListItem.CREATE) {

    } else {
      this._editingType = this._getType(layer);
    }

    (layer._parent ? layer._parent : this._layer).removeLayer(layer);
    this._editingEditingLayer = this._cloneLayer(this._editingType ,layer);
    this._editingFreatureGroup.addLayer(this._editingEditingLayer);

    if(!withoutEvent) {
      this.fire("editstart", {"layer": this._editingEditingLayer, "info":this._editingEditingLayer._layerInfo});
    }
    try {
      this._owner.fire("createedit", {
        oldLayer: oldEditingLayer,
        currentLayer: this._editingEditingLayer,
        itemType: this._getType(layer)
      });
    } catch(ex) {}

    if (oldEditingLayer) {
      oldEditingLayer._cloneLayer._layerInfo = oldEditingLayer._layerInfo;
      this._addReservedFrameRectangle(oldEditingLayer._cloneLayer);
    }
    this._reservedFrameFreatureGroup.addTo(this._owner._map);
    this._startPathEdit();

    if(!withoutEvent) this._fireReserve();
  },

  _fireReserve : function() {
    this.fire("reserve", {"len": this._reservedFreatureGroup.getLayers().length});
  },

  _nextStartCreate: function (layerType, path) {
    this.editMode = GSI.SakuzuListItem.CREATE;

    if (!this._reservedFreatureGroup) {
      this._reservedFreatureGroup = L.featureGroup();
      this._owner._map.addLayer(this._reservedFreatureGroup);
    }

    var oldEditingLayer = this._editingEditingLayer;
    for (var i = 0; i < this._editingPathList.length; i++) {
      this._editingPathList[i].disable();
    }

    this._editingPathList = [];
    this._editingFreatureGroup.removeLayer(oldEditingLayer);
    this._editingEditingLayer = null;

    this._editingEditingLayerInfo = {
      title: null,
      description: null,
      table: null
    };

    if (oldEditingLayer) {
      oldEditingLayer._layerInfo = {};

      this._addReservedFeature(oldEditingLayer);

      this._editingPathList.push(path);
      this._nextPath = null;
      // created
      this._owner.fire("next", {
        layerType: layerType,
        currentLayer: oldEditingLayer,
        nextPath: path
      });

      oldEditingLayer._cloneLayer._layerInfo = oldEditingLayer._layerInfo;

      this._addReservedFrameRectangle(oldEditingLayer._cloneLayer);

      this._owner.fire("ready");
    }
  },

  _addReservedFrameRectangle: function (layer) {
    if (!this._reservedFrameFreatureGroup)
      this._reservedFrameFreatureGroup = L.featureGroup();

    var reservedFrameRectangle = new GSI.PathFrameRectangle(layer);
    layer._reservedFrameRectangle = reservedFrameRectangle;
    layer.off("moveend").on("moveend", L.bind(function (e) {
      e.target._reservedFrameRectangle._refresh();
    }, this));

    this._reservedFrameFreatureGroup.addLayer(reservedFrameRectangle);
    this._owner._map.removeLayer(this._reservedFrameFreatureGroup);

    reservedFrameRectangle
      .on("requestremove", L.bind(function (e) {
        this._reservedFreatureGroup.removeLayer(e.target._targetPath);
        this._reservedFrameFreatureGroup.removeLayer(e.target);
        this._fireReserve();
        this._owner.fire("createchange");
      }, this))
      .on("requestedit", L.bind(function (e) {
        this.fire("reqiestedit");
        this._editReservedPath(e.target, e.target._targetPath);

      }, this))
      .on("requestaddinner", L.bind(function (e) {

        this._startAddInner(e.target, e.target._targetPath);

      }, this));
    return reservedFrameRectangle;
  },

  restartEdit: function () {
    for (var i = 0; i < this._editingPathList.length; i++) {
      this._editingPathList[i].disable();
      this._editingPathList[i].enable();
    }
  },

  isReady: function () {
    return (this._editingEditingLayer ? true :
      this._reservedFreatureGroup && this._reservedFreatureGroup.getLayers().length > 0 ? true : false);
  },

  _startPathEdit: function (targetLayer) {

    var clearPathList = false;
    var layerType = null;
    if (!targetLayer) {
      layerType = this._editingType;
      clearPathList = true;
      targetLayer = this._editingEditingLayer;
    }
    else {
      layerType = this._getType(targetLayer);
    }

    switch (layerType) {
      case GSI.SakuzuListItem.POINT:
      case GSI.SakuzuListItem.POINT_TEXT:
        var path = new GSI.Edit.Marker(targetLayer, { edit: { featureGroup: this._editingFreatureGroup } });
        path.enable();
        if (clearPathList) this._editingPathList = [];
        this._editingPathList.push(path);
        break;

      case GSI.SakuzuListItem.FREEHAND:
      case GSI.SakuzuListItem.LINESTRING:
      case GSI.SakuzuListItem.POLYGON:

        targetLayer.options.editing = {};
        var path = new GSI.Edit.Poly(targetLayer, { isPolygon: (layerType == GSI.SakuzuListItem.POLYGON), edit: { featureGroup: this._editingFreatureGroup } });
        path.enable();
        if (clearPathList) this._editingPathList = [];
        this._editingPathList.push(path);
        break;

      case GSI.SakuzuListItem.POINT_CIRCLE:
      case GSI.SakuzuListItem.CIRCLE:
        var path = null;
        if (layerType == GSI.SakuzuListItem.CIRCLE) { path = new GSI.Edit.Circle(targetLayer, { edit: { featureGroup: this._editingFreatureGroup } }); }
        if (layerType == GSI.SakuzuListItem.POINT_CIRCLE) { path = new GSI.Edit.CircleMarker(targetLayer, { edit: { featureGroup: this._editingFreatureGroup }, map: this._owner._map }); }
        path.on('change', L.bind(this._onCircleChange, this));
        path.enable();
        if (clearPathList) this._editingPathList = [];
        this._editingPathList.push(path);
        this._nextPath = null;
        this._onCircleChange({ radius: path._shape._mRadius ? path._shape._mRadius : path._shape._radius, unit: "m" });
        break;

      case GSI.SakuzuListItem.MULTIPOINT:
      case GSI.SakuzuListItem.MULTILINESTRING:
        var layers = targetLayer.getLayers();
        if (clearPathList) this._editingPathList = [];
        for (var i = 0; i < layers.length; i++) {
          this._startPathEdit(layers[i]);
        }
        break;

      case GSI.SakuzuListItem.MULTIPOLYGON:
        targetLayer.options.editing = {};
        var path = new GSI.Edit.Poly(targetLayer, { isPolygon: true, edit: { featureGroup: this._editingFreatureGroup } });
        path.enable();
        if (clearPathList) this._editingPathList = [];
        this._editingPathList.push(path);
        break;
    }
  },

  startPolygonInner : function() {

    var targetLayer = this._editingEditingLayer;

    for ( var i=0; i<this._editingPathList.length; i++ ) {
      this._editingPathList[i].disable();
    }

    this._editingTypeBuff = this._editingType;

    this._editingType = GSI.SakuzuListItem.POLYGONINNER2;

    this._startAddInnerPolygon2();
  },

  commitPolygonInner : function() {
    if ( this._polyInnerPath ) this._polyInnerPath.disable();
    this._polyInnerPath = undefined;
    if ( this._removeInnerButtons ) this._removeInnerButtons.remove();
    this._removeInnerButtons = undefined;

    this._editingType = this._editingTypeBuff;

    for ( var i=0; i<this._editingPathList.length; i++ ) {
      this._editingPathList[i].enable();
    }
  },

  rollbackPolygonInner : function() {

  },

  _startAddInnerPolygon2 : function() {

    // ポリゴン編集開始
    L.drawLocal.draw.handlers.polygon.tooltip.start = '中抜き-開始位置をクリック';
    L.drawLocal.draw.handlers.polygon.tooltip.cont = '中抜き-次の位置を選択';
    L.drawLocal.draw.handlers.polygon.tooltip.end = GSI.TEXT.LINEEDITTIP + '中抜き-次の位置を選択(最終点を2回クリックして終了)';

    // デフォルト
    var shapeOptions = {
      color: '#000000',
      fillColor: '#ffffff',
      weight: 2,
      opacity: 0.5,
      fillOpacity: 0.5,
      stroke: true,
      fill: true,
      clickable: true,
      geodesic: true
    };

    if ( this._editingEditingLayer.options.weight ) {
      shapeOptions.weight = this._editingEditingLayer.options.weight;
    }
    if ( this._editingEditingLayer.options.color ) {
      shapeOptions.color = this._editingEditingLayer.options.color;
    }
    if ( !this._editingEditingLayer.options.stroke ) {
      shapeOptions.stroke = false;
    }
    if ( this._editingEditingLayer.options.opacity != undefined ) {
      shapeOptions.opacity = this._editingEditingLayer.options.opacity;
    }

    if (!this._pathCreatedEventHandler) {
      this._pathCreatedEventHandler = L.bind(this._onPathCreated, this);
      this._owner._map.on('draw:created', this._pathCreatedEventHandler);
      this._owner._map.on('draw:measurechange', function () {

      });
    }

    var path = new GSI.Draw.Polygon(this._owner._map, {
      shapeOptions: shapeOptions,
      edit: { featureGroup: this._editingFreatureGroup },
      showArea: true,
      allowIntersection: false,
      ownerPolygon : this._editingEditingLayer
    });

    path.enable();

    this._polyInnerPath = path;

    this._initializeInnerRemoveButtons();

  },

  editFinish: function (force) {

    this._owner._map.stopAutoPan();

    delete this._originalLayers;
    this._originalLayers = null;

    if (!force && this.editMode == GSI.SakuzuListItem.NONE) return;

    if (this._editingEditingLayer) {
      this._editingEditingLayer._parent = (this._editingOriginalLayer ? this._editingOriginalLayer._parent : null);
      this._destroyEditPathList();
      this._editingFreatureGroup.removeLayer(this._editingEditingLayer);
      (this._editingEditingLayer._parent ? this._editingEditingLayer._parent : this._layer).addLayer(this._editingEditingLayer);

      if (this._editingOriginalLayer && this._editingOriginalLayer._clickEditHandler) {
        this._editingOriginalLayer.off('click', this._editingOriginalLayer._clickEditHandler);
        this._editingEditingLayer._clickEditHandler = L.bind(this._onLayerClick, this, this._editingEditingLayer);
        this._editingEditingLayer.on('click', this._editingEditingLayer._clickEditHandler);
      }
    }
    // 保留中の情報を確定
    if (this._reservedFreatureGroup) {
      var layers = this._reservedFreatureGroup.getLayers();

      for (var i = 0; i < layers.length; i++) {
        var l = layers[i];
        l._originalLayer = null;

        if (l instanceof L.Marker) {
          l.options.draggable = false;
          l.dragging.disable();
          l.setZIndexOffset(0);
          l.off("moveend");
        }

        if (l.options.icon && l.options.icon.setLabelText) {
          l.options.icon.options.labelVisible = this._iconLabelVisible;
          l.options.icon.setLabelText(
            l._layerInfo.title
          );
        }

        this._reservedFreatureGroup.removeLayer(l);
        (l._parent ? l._parent : this._layer).addLayer(l);
        l._information = l._layerInfo;
        delete l['_layerInfo'];
        this._bindPopup(l);

      }
    }

    if (this._editingEditingLayer) {
      if (this._editingEditingLayer.options.icon) {
        this._editingEditingLayer.options.icon.options.labelVisible = this._iconLabelVisible;

        if (this._editingEditingLayer.options.icon.setLabelText)
          this._editingEditingLayer.options.icon.setLabelText(
            this._editingEditingLayer._layerInfo.title
          );
      }
      this._editingEditingLayer._information = this._editingEditingLayer._layerInfo;
      this._bindPopup(this._editingEditingLayer);
    }
    this._destroyEditObjects();
    if (this.editMode == GSI.SakuzuListItem.EDIT) {
      this._owner._mapMouse.setClickMoveEnable(false);
    }
    this.editMode = GSI.SakuzuListItem.NONE;
    this._owner.fire('change');
  },

  editFinish_CircleMarker: function () {
    if (this._editingType == GSI.SakuzuListItem.POINT_CIRCLE) {
      var o = this._editingEditingLayer;
      var vLatLng = o.getLatLng();
      var vRadius = o._radius_px;
      if (!vRadius) {
        vRadius = GSI.Utils.ConverUnit(GSI.GLOBALS.map, o, o.getRadius(), "m", "px");
      }

      var vOptions = o.options;
      var oMarker = new L.circleMarker(vLatLng, vOptions);
      oMarker.setRadius(vRadius);

      this._editingEditingLayer = oMarker;
    }
  },

  _bindPopup: function (layer) {
    if (layer) {
      if (!layer._information) {
        layer._information = this._getLayerInfo(layer);
      }

      var title = layer._information.title;
      var description = layer._information.description;

      if (!description || description == '')
        description = this._infoTable2Description(layer._information.table);

      var popupContent = '';
      if (title && title != '') {
        popupContent = '<h2>' + GSI.Utils.encodeHTML(title) + '</h2>';
      }

      if (description && description != '') {
        popupContent += description;
      }

      if (popupContent != '') layer.bindPopup(popupContent,
        {
          maxWidth: 5000
        });
    }
  },

  editSelectFinish: function (force) {
    if (force) this.editMode = GSI.SakuzuListItem.EDIT;

    this.editCancel();
    if (this._layer) {
      var layers = this._layer.getLayers();
      for (var i = 0; i < layers.length; i++) {
        this._bindPopup(layers[i]);
      }
    }
    this._bindPopup();
    this._destroyEditSelectObjects();
  },

  editCancel: function (force) {

    this._owner._map.stopAutoPan();

    if (!force && this.editMode == GSI.SakuzuListItem.NONE) return;

    if (this._originalLayers) {
      for (var i = 0; i < this._originalLayers.length; i++) {
        var originalLayer = this._originalLayers[i];

        if (!originalLayer) continue;
        (originalLayer._parent ? originalLayer._parent : this._layer)
          .addLayer(originalLayer);
        this._bindPopup(originalLayer);
      }
      delete this._originalLayers;
      this._originalLayers = null;
    }

    this._bindPopup();
    this._destroyEditObjects();

    if (this.editMode == GSI.SakuzuListItem.EDIT)
      this._owner._mapMouse.setClickMoveEnable(false);

    this.editMode = GSI.SakuzuListItem.NONE;
  },

  removeEditObject: function () {
    if (this._editingBoundsRects) {
      if (this._editingOriginalLayer && this._editingOriginalLayer._boundRect)
        this._editingBoundsRects.removeLayer(this._editingOriginalLayer._boundRect);
      if (this._editingEditingLayer && this._editingEditingLayer._boundRect)
        this._editingBoundsRects.removeLayer(this._editingEditingLayer._boundRect);
    }
    this._editingOriginalLayer = null;
    this.editCancel();

    this._owner.fire('change');
  },

  _destroyEditEventHandler: function () {
    if (this._pathCreatedEventHandler) {
      this._owner._map.off('draw:created', this._pathCreatedEventHandler);
      delete this._pathCreatedEventHandler;
      this._pathCreatedEventHandler = null;
    }
  },

  _destroyEditPathList: function () {
    if (this._editingPathList) {
      for (var i = 0; i < this._editingPathList.length; i++) {
        try {
          var path = this._editingPathList[i];
          path.disable();
          delete path;
          path = null;
          delete this._editingPathList[i];
          this._editingPathList[i] = null;
        }
        catch (e) {
          console.log(e);
         }
      }

      delete this._editingPathList;
      this._editingPathList = null;
    }

    if (this._nextPath) {
      try {
        this._nextPath.disable();
        delete this._nextPath;
        this._nextPath = null;
      }
      catch (e) { }
    }
  },

  _destroyEditObjects: function () {
    this._editingEditingLayerInfo = null;

    if ( this._polyInnerPath ) this._polyInnerPath.disable();
    this._polyInnerPath = null;

    if ( this._removeInnerButtons ) this._removeInnerButtons.remove();
    this._removeInnerButtons = null;

    this._owner._mapMouse.setClickMoveEnable(true);

    this._destroyEditEventHandler();
    this._destroyEditPathList();

    if (this._editingFreatureGroup) {
      try {
        this._owner._map.removeLayer(this._editingFreatureGroup);
        delete this._editingFreatureGroup;
      }
      catch (e) { }
      this._editingFreatureGroup = null;
    }

    if (this._editingOriginalLayer) {
      (this._editingOriginalLayer._parent ? this._editingOriginalLayer._parent : this._layer).removeLayer(this._editingOriginalLayer);
      this._editingOriginalLayer = null;
    }

    if (this._editingEditingLayer) {
      delete this._editingEditingLayer;
      this._editingEditingLayer = null;
    }

    if (this._reservedFreatureGroup) {
      try {
        this._owner._map.removeLayer(this._reservedFreatureGroup);
      }
      catch (e) { }
      delete this._reservedFreatureGroup;
      this._reservedFreatureGroup = null;
    }

    if (this._reservedFrameFreatureGroup) {

      try {
        this._owner._map.removeLayer(this._reservedFrameFreatureGroup);
      }
      catch (e) { }
      delete this._reservedFrameFreatureGroup;
      this._reservedFrameFreatureGroup = null;
    }
  },

  _destroyEditSelectObjects: function () {
    this._owner._mapMouse.setClickMoveEnable(true);

    if (this._editingBoundsRects) {
      this._owner._map.removeLayer(this._editingBoundsRects);
      delete this._editingBoundsRects;
      this._editingBoundsRects = null;
    }

    var layers = this._layer.getLayers();

    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];

      // 編集
      if (layer._clickEditHandler) {
        layer.off('click', layer._clickEditHandler);
        delete layer._clickEditHandler;
        layer._clickEditHandler = null;
      }
    }
  },

  _infoTable2Description: function (table) {

    if (!table) return '';

    var trHtml = '';
    for (var i = 0; i < table.length; i++) {
      var key = table[i].key;
      var value = table[i].value;

      if (key && key != '') {
        if (!value || value == '') {
          value = '';
        }

        value = value.replace(/\n/g, "<br>");

        trHtml += '<tr><td>' + GSI.Utils.encodeHTML(key).replace(/\n/g, "<br>") + '</td><td>' + value + '</td></tr>' + '\n';
      }
    }

    if (trHtml != '') {
      return '<table>\n' + trHtml + '</table>';
    }
    else {
      return '';
    }
  },

  _getLayerInfo: function (layer, convertToDescription) {
    var result = $.extend(true, {}, layer._information ? layer._information : {});

    if (!layer._information) {
      if (layer.feature && layer.feature.properties) {
        for (var key in layer.feature.properties) {
          if (key != '' && CONFIG.GEOJSONSPECIALKEYS[key]) continue;

          var value = layer.feature.properties[key];

          if (value == null) {
            value = "";
          }

          if ((typeof value != "string") && (typeof value != "number")) continue;

          if (key == 'name') {
            result.title = value;
          }
          else if (key == 'description') {
            result.description = value;
          }
          else {
            if (!result.table) result.table = [];
            result.table.push({ key: key, value: '' + value });
          }
        }
      }
      else {
        return result;
      }
    }
    if (convertToDescription && !result.description || result.description == '') {
      result.description = this._infoTable2Description(result.table);
    }

    return result;
  },

  toKML: function (styleList) {
    if ( !this._layer.getLayers ) return [];
    // KML生成
    var data = '';
    var layers = this._layer.getLayers();

    for (var i = 0; i < layers.length; i++) {
      var layer2 = layers[i];
      var itemType = this._getType(layer2);
      var layerData = null;

      switch (itemType) {
        case GSI.SakuzuListItem.POINT:
          layerData = this._makeKMLPoint(layer2, this._getKMLStyleId(itemType, styleList, layer2));
          break;
        case GSI.SakuzuListItem.POLYGON:
        case GSI.SakuzuListItem.CIRCLE:
          layerData = this._makeKMLPolygon(layer2, this._getKMLStyleId(itemType, styleList, layer2));
          break;
        case GSI.SakuzuListItem.LINESTRING:
          layerData = this._makeKMLLine(layer2, this._getKMLStyleId(itemType, styleList, layer2));
          break;
        case GSI.SakuzuListItem.FEATURES:
          layerData = this._makeKMLFeatures(layer2, styleList);
          break;
        case GSI.SakuzuListItem.MULTILINESTRING:
          layerData = this._makeKMLMultiLine(layer2, styleList);
          break;
        case GSI.SakuzuListItem.MULTIPOLYGON:
          layerData = this._makeKMLMultiPolygon(layer2, this._getKMLStyleId(itemType, styleList, layer2));
          break;
        case GSI.SakuzuListItem.MULTIPOINT:
          layerData = this._makeKMLMultiPoint(layer2, styleList);
          break;
      }

      if (layerData) {
        data += layerData.data;
      }
    }

    var styles = '';

    if (data != '') {
      for (var styleId in styleList) {
        styles += styleList[styleId].text;
      }
    }

    return styles + data;
  },

  _color2kmlColor: function (color, opacity) {
    if (color && color != '' && color.charAt(0) == '#') {
      color = color.slice(1);

      if (color.length == 3) {
        color = color.slice(-1) + color.slice(1, -1) + color.slice(0, 1);
      }
      else if (color.length == 6) {
        color = color.slice(-2) + color.slice(2, -2) + color.slice(0, 2);
      }
    }
    else {
      color = '000000';
    }
    opacity = ('' + opacity.toString(16));
    if (opacity.length == 1) opacity = '0' + opacity;

    color = opacity + '' + color;
    return color;
  },

  _getKMLStyleId: function (itemType, styleList, layer) {
    //#yellowLineGreenPoly
    var styleId = '';

    switch (itemType) {
      case GSI.SakuzuListItem.POINT:
        var iconUrl = layer.options.icon.options.iconUrl;
        var iconSize = layer.options.icon.options.iconSize;
        var iconAnchor = layer.options.icon.options.iconAnchor;
        var iconScale = layer.options.icon.options._iconScale;

        if (!iconScale) iconScale = 1;
        var hotSpot = {
          x: Math.round((iconAnchor[0] / iconSize[0]) * 10) / 10,
          y: Math.round((iconAnchor[1] / iconSize[1]) * 10) / 10,
        };
        styleId = this._findKMLStyle(styleList, itemType, {
          iconUrl: iconUrl,
          iconScale: iconScale,
          hotSpot: hotSpot.x + ',' + hotSpot.y
        });

        if (!styleId) {
          styleId = 'PolyStyle' + this._owner.getStyleId();

          var text =
            '<Style id="' + styleId + '">\n' +
            '  <IconStyle>\n' +
            '  <Icon>\n' +
            '  <href>' + iconUrl + '</href>\n' +
            '  </Icon>\n' +
            '  <scale>' + iconScale + '</scale>\n';

          if (hotSpot.x != 0.5 || hotSpot.y != 0.5) {
            text +=
              '  <hotSpot x="' + hotSpot.x + '" y="' + hotSpot.y + '" xunits="fraction" yunits="fraction" />\n';
          }
          text +=
            '  </IconStyle>\n' +
            '</Style>\n';
          styleList[styleId] = {
            type: itemType,
            text: text,
            style: {
              iconUrl: iconUrl,
              iconScale: iconScale,
              hotSpot: hotSpot.x + ',' + hotSpot.y
            }
          };
        }

        break;

      case GSI.SakuzuListItem.POLYGON:
      case GSI.SakuzuListItem.MULTIPOLYGON:
      case GSI.SakuzuListItem.CIRCLE:

        var color = layer.options.color;
        var opacity = Math.floor((layer.options.opacity || layer.options.opacity == 0 ? layer.options.opacity : 1) * 255);
        var weight = layer.options.weight;
        var fillColor = layer.options.fillColor;

        if (!fillColor) fillColor = color;
        var fillOpacity = Math.floor((layer.options.fillOpacity || layer.options.fillOpacity == 0 ? layer.options.fillOpacity : 1) * 255);
        color = this._color2kmlColor(color, opacity);
        fillColor = this._color2kmlColor(fillColor, fillOpacity);

        styleId = this._findKMLStyle(styleList, itemType, {
          color: color,
          weight: weight,
          fillColor: fillColor
        });

        if (!styleId) {
          styleId = 'PolyStyle' + this._owner.getStyleId();

          var text =
            '<Style id="' + styleId + '">\n' +
            '  <LineStyle>\n' +
            '  <color>' + color + '</color>\n' +
            '  <width>' + weight + '</width>\n' +
            '  </LineStyle>\n' +
            '  <PolyStyle>\n' +
            '  <color>' + fillColor + '</color>\n' +
            '  </PolyStyle>\n' +
            '</Style>\n';
          styleList[styleId] = {
            type: itemType,
            text: text,
            style: {
              color: color,
              weight: weight,
              fillColor: fillColor
            }
          };
        }
        break;

      case GSI.SakuzuListItem.LINESTRING:
        var color = layer.options.color;
        var opacity = Math.floor((layer.options.opacity || layer.options.opacity == 0 ? layer.options.opacity : 1) * 255);
        var weight = layer.options.weight;
        color = this._color2kmlColor(color, opacity);

        if (opacity.length == 1) opacity = '0' + opacity;

        styleId = this._findKMLStyle(styleList, itemType, {
          color: color,
          weight: weight
        });

        if (!styleId) {
          styleId = 'LineStyle' + this._owner.getStyleId();

          var text =
            '<Style id="' + styleId + '">\n' +
            '  <LineStyle>\n' +
            '  <color>' + color + '</color>\n' +
            '  <width>' + weight + '</width>\n' +
            '  </LineStyle>\n' +
            '</Style>\n';
          styleList[styleId] = {
            type: itemType,
            text: text,
            style: {
              color: color,
              weight: weight
            }
          };
        }
        break;
    }

    return styleId;
  },

  _findKMLStyle: function (styleList, itemType, style) {
    var id = null;
    for (var key in styleList) {
      var styleData = styleList[key];

      if (styleData.type == itemType) {
        var hit = true;
        for (var key2 in style) {
          if (styleData.style[key2] != style[key2]) {
            hit = false;
            break;
          }
        }

        if (hit) {
          id = key;
          break;
        }
      }
    }

    return id;
  },

  _makeKMLFeatures: function (layer, styleList) {
    var result = {
      data: ''
    };
    var layers = layer.getLayers();

    for (var i = 0; i < layers.length; i++) {
      var layer2 = layers[i];
      var itemType = this._getType(layer2);
      var layerData = null;

      switch (itemType) {
        case GSI.SakuzuListItem.POINT:
          layerData = this._makeKMLPoint(layer2, this._getKMLStyleId(itemType, styleList, layer2));
          if (layerData) result.data += layerData.data;
          break;
        case GSI.SakuzuListItem.POLYGON:
        case GSI.SakuzuListItem.CIRCLE:
          layerData = this._makeKMLPolygon(layer2, this._getKMLStyleId(itemType, styleList, layer2));
          if (layerData) result.data += layerData.data;
          break;
        case GSI.SakuzuListItem.LINESTRING:
          layerData = this._makeKMLLine(layer2, this._getKMLStyleId(itemType, styleList, layer2));
          if (layerData) result.data += layerData.data;
          break;
        case GSI.SakuzuListItem.FEATURES:
        case GSI.SakuzuListItem.MULTILINESTRING:
        case GSI.SakuzuListItem.MULTIPOLYGON:
        case GSI.SakuzuListItem.MULTIPOINT:
          layerData = this._makeKMLFeatures(layer2, styleList);
          if (layerData) {
            result.data += layerData.data;
          }
          break;
      }
    }
    if (result.data != '') {
      result.data = '<Folder>\n' + result.data + '</Folder>\n';
    }

    return result;
  },

  _makeKMLMultiPolygon: function (layer, styleId) {
    var latLngs = layer.getLatLngs();

    var info = this._getLayerInfo(layer, false);
    var title = info.title;
    var description = info.description;
    var table = info.table;
    if (description) {
      description = description.replace(/[\n\r]/g, '');
    }
    else if (table && table.length > 0) {
      description = this._infoTable2Description(table);
      description = description.replace(/[\n\r]/g, '');
      table = JSON.stringify(table);
    }

    var result = {
      style: '',
      data: ''
    };
    result.data  = "";
    for( var i=0; i<latLngs.length; i++ ) {

      result.data += '<Placemark>\n';

      if (title && title != '')
        result.data += '<name>' + GSI.Utils.encodeHTML(title) + '</name>' + '\n';

      if (description && description != '')
        result.data += '<description><![CDATA[ ' + description + ' ]]></description>' + '\n';

      result.data +=
        '<styleUrl>#' + styleId + '</styleUrl>' + '\n' +
        '<Polygon>' + '\n';

      for( var j= 0; j<latLngs[i].length; j++ ) {
        result.data += ( j== 0 ? '<outerBoundaryIs>' : '<innerBoundaryIs>' ) + '\n' +
        '<LinearRing>' + '\n' +
        '<coordinates>';
        for (var k = 0; k < latLngs[i][j].length; k++) {
          result.data += (k > 0 ? ' ' : '')
            + latLngs[i][j][k].lng + "," + latLngs[i][j][k].lat + (latLngs[i][j][k].alt ? "," + latLngs[i][j][k].alt : "");
        }
        // close polygon
        if (latLngs[i][j].length > 0) {
          result.data += ' ' + latLngs[i][j][0].lng + "," + latLngs[i][j][0].lat + (latLngs[i][j][0].alt ? "," + latLngs[i][j][0].alt : "");
        }
        result.data += '</coordinates>\n' +
        '</LinearRing>' + '\n' +
        ( j== 0 ? '</outerBoundaryIs>' : '</innerBoundaryIs>' ) + '\n';
      }
      result.data +=
        '</Polygon>\n';
      result.data +=
        '</Placemark>\n';
    }

    return result;
  },

  _makeKMLMultiLine: function (layer, styleList) {
    var info = this._getLayerInfo(layer, false);
    var result = {
      data: ''
    };
    var layerId = '';
    var layers = layer.getLayers();

    for (var i = 0; i < layers.length; i++) {
      var layer2 = layers[i];
      var itemType = this._getType(layer2);
      var layerData = null;

      if (itemType == GSI.SakuzuListItem.LINESTRING) {
        if (layerId == '')
          layerId = this._getKMLStyleId(itemType, styleList, layer2);
        layerData = this._makeKMLLine(layer2, layerId, info);
        if (layerData) result.data += layerData.data;
      }
    }

    if (result.data != '') {
      result.data = '<Folder>\n' + result.data + '</Folder>\n';
    }

    return result;
  },

  _makeKMLMultiPoint: function (layer, styleList) {
    var info = this._getLayerInfo(layer, false);
    var result = {
      data: ''
    };
    var layerId = '';
    var layers = layer.getLayers();

    for (var i = 0; i < layers.length; i++) {
      var layer2 = layers[i];
      var itemType = this._getType(layer2);
      var layerData = null;

      if (itemType == GSI.SakuzuListItem.POINT) {
        if (layerId == '')
          layerId = this._getKMLStyleId(itemType, styleList, layer2);
        layerData = this._makeKMLPoint(layer2, layerId, info);
        if (layerData) result.data += layerData.data;
      }
    }

    if (result.data != '') {
      result.data = '<Folder>\n' + result.data + '</Folder>\n';
    }

    return result;
  },

  _makeKMLPoint: function (layer, styleId, info) {
    var latLng = layer.getLatLng();

    if (!info) info = this._getLayerInfo(layer, false);

    var title = info.title;
    var description = info.description;
    var table = info.table;

    if (description) {
      description = description.replace(/[\n\r]/g, '');
    }
    else if (table && table.length > 0) {
      description = this._infoTable2Description(table);
      description = description.replace(/[\n\r]/g, '');
      table = JSON.stringify(table);
    }

    var result = {
      data: ''
    };

    result.data = '<Placemark>\n';

    if (title && title != '')
      result.data += '<name>' + GSI.Utils.encodeHTML(title) + '</name>' + '\n';

    if (description && description != '')
      result.data += '<description><![CDATA[ ' + description + ' ]]></description>' + '\n';

    result.data +=
      '<styleUrl>#' + styleId + '</styleUrl>' + '\n' +
      '<Point>\n' +
      '<coordinates>';

    result.data += latLng.lng + "," + latLng.lat + (latLng.alt ? "," + latLng.alt : ""); // + "\n";

    result.data +=
      '</coordinates>\n' +
      '</Point>\n' +
      '</Placemark>\n';
    return result;
  },

  _makeKMLPolygon: function (layer, styleId, info) {
    var latLngs = null;

    if (layer.getRadius) {
      // 円→ポリゴン
      latLngs = [];
      var numSides = CONFIG.CIRCLETOPOLYGONNUMSIDES;
      var center = layer.getLatLng();
      var center_lat_rad = center.lat * Math.PI / 180;
      var center_lng_rad = center.lng * Math.PI / 180;
      var dmax_lat = layer._mRadius / 6378137;
      var xys = [];
      xys.push([dmax_lat, 0]);
      for (var i = 1; i < numSides; i++) {
        var y = dmax_lat - 2 * dmax_lat / numSides * i;
        var x = 2 * Math.asin(Math.sqrt((Math.pow(Math.sin(dmax_lat / 2), 2) - Math.pow(Math.sin((y) / 2), 2)) / (Math.cos(center_lat_rad + y) * Math.cos(center_lat_rad))));
        if (x !== x) {
          return;
        } else {
          xys.push([y, x]);
        }
      }
      xys.push([-dmax_lat, 0]);
      for (var i = 1; i < numSides; i++) {
        xys.push([xys[numSides - i][0], -xys[numSides - i][1]]);
      }
      xys.push([dmax_lat, 0]);
      for (var i = 0; i < xys.length; i++) {
        latLngs.push(L.latLng((center_lat_rad + xys[i][0]) / (Math.PI / 180), (center_lng_rad + xys[i][1]) / (Math.PI / 180), center.alt));
      }
    }
    else {
      latLngs = layer.getLatLngs();
    }

    if (!info) info = this._getLayerInfo(layer, false);
    var title = info.title;
    var description = info.description;
    var table = info.table;
    if (description) {
      description = description.replace(/[\n\r]/g, '');
    }
    else if (table && table.length > 0) {
      description = this._infoTable2Description(table);
      description = description.replace(/[\n\r]/g, '');
      table = JSON.stringify(table);
    }

    var result = {
      style: '',
      data: ''
    };

    result.data = '<Placemark>\n';

    if (title && title != '')
      result.data += '<name>' + GSI.Utils.encodeHTML(title) + '</name>' + '\n';

    if (description && description != '')
      result.data += '<description><![CDATA[ ' + description + ' ]]></description>' + '\n';

    result.data +=
      '<styleUrl>#' + styleId + '</styleUrl>' + '\n' +
      '<Polygon>' + '\n';

    var flat = L.LineUtil.isFlat(latLngs);

    if (flat) latLngs = [latLngs];
    for( var i= 0; i<latLngs.length; i++ ) {
      result.data += ( i== 0 ? '<outerBoundaryIs>' : '<innerBoundaryIs>' ) + '\n' +
      '<LinearRing>' + '\n' +
      '<coordinates>';
      for (var j = 0; j < latLngs[i].length; j++) {
        result.data += (j > 0 ? ' ' : '')
          + latLngs[i][j].lng + "," + latLngs[i][j].lat + (latLngs[i][j].alt ? "," + latLngs[i][j].alt : "");
      }
      // close polygon
      if (latLngs[i].length > 0) {
        result.data += ' ' + latLngs[i][0].lng + "," + latLngs[i][0].lat + (latLngs[i][0].alt ? "," + latLngs[i][0].alt : "");
      }
      result.data += '</coordinates>\n' +
      '</LinearRing>' + '\n' +
      ( i== 0 ? '</outerBoundaryIs>' : '</innerBoundaryIs>' ) + '\n';
    }
    result.data +=
      '</Polygon>\n' +
      '</Placemark>\n';

    return result;
  },

  _makeKMLLine: function (layer, styleId, info) {
    var latLngs = layer.getLatLngs();

    if (!info) info = this._getLayerInfo(layer, false);

    var title = info.title;
    var description = info.description;
    var table = info.table;
    if (description) {
      description = description.replace(/[\n\r]/g, '');
    }
    else if (table && table.length > 0) {
      description = this._infoTable2Description(table);
      description = description.replace(/[\n\r]/g, '');
      table = JSON.stringify(table);
    }
    var result = {
      style: '',
      data: ''
    };

    result.data = '<Placemark>\n';

    if (title && title != '')
      result.data += '<name>' + GSI.Utils.encodeHTML(title) + '</name>' + '\n';

    if (description && description != '')
      result.data += '<description><![CDATA[ ' + description + ' ]]></description>' + '\n';

    result.data +=
      '<styleUrl>#' + styleId + '</styleUrl>' + '\n' +
      '<LineString>' + '\n' +
      '<coordinates>';

    var flat = L.LineUtil.isFlat(latLngs);

    if (!flat) latLngs = latLngs[0];
    for (var i = 0; i < latLngs.length; i++) {
      result.data += (i > 0 ? ' ' : '')
        + latLngs[i].lng + "," + latLngs[i].lat + (latLngs[i].alt ? "," + latLngs[i].alt : "");

    }
    result.data += '</coordinates>\n' +
      '</LineString>\n' +
      '</Placemark>\n';

    return result;
  },

  toGeoJSON: function () {

    if ( !this._layer.getLayers ) return [];

    // GeoJSON生成
    var features = [];
    var layers = this._layer.getLayers();

    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      var itemType = this._getType(layer);
      var geoJSONData = null;

      switch (itemType) {
        case GSI.SakuzuListItem.POINT:
        case GSI.SakuzuListItem.POINT_TEXT:
        case GSI.SakuzuListItem.MULTIPOINT:
          geoJSONData = this._makeGeoJSONPoint(layer);
          if (geoJSONData) features.push(geoJSONData);
          break;

        case GSI.SakuzuListItem.POLYGON:
        case GSI.SakuzuListItem.MULTIPOLYGON:
          geoJSONData = this._makeGeoJSONPolygon(layer);
          if (geoJSONData) features.push(geoJSONData);
          break;

        case GSI.SakuzuListItem.LINESTRING:
        case GSI.SakuzuListItem.MULTILINESTRING:
          geoJSONData = this._makeGeoJSONLine(layer);
          if (geoJSONData) features.push(geoJSONData);
          break;

        case GSI.SakuzuListItem.CIRCLE:
        case GSI.SakuzuListItem.POINT_CIRCLE:
          geoJSONData = this._makeGeoJSONCircle(layer);
          if (itemType == GSI.SakuzuListItem.POINT_CIRCLE) {
            geoJSONData.properties["_markerType"] = "CircleMarker";
          }
          if (geoJSONData) features.push(geoJSONData);
          break;

        case GSI.SakuzuListItem.FEATURES:
          this._makeGeoJSONFeatures(layer, features);
          break;
      }
    }

    return features;
  },

  _makeGeoJSONFeatures: function (layer, features) {
    try {
      var layers = layer.getLayers();

      for (var i = 0; i < layers.length; i++) {
        var layer2 = layers[i];
        var itemType = this._getType(layer2);
        var geoJSONData = null;

        switch (itemType) {
          case GSI.SakuzuListItem.POINT:
          case GSI.SakuzuListItem.POINT_TEXT:
            geoJSONData = this._makeGeoJSONPoint(layer2);
            if (geoJSONData) features.push(geoJSONData);
            break;
          case GSI.SakuzuListItem.CIRCLE:
          case GSI.SakuzuListItem.POINT_CIRCLE:
            geoJSONData = this._makeGeoJSONCircle(layer2);
            if (itemType == GSI.SakuzuListItem.POINT_CIRCLE) {
              geoJSONData.properties["_markerType"] = "CircleMarker";
            }
            if (geoJSONData) features.push(geoJSONData);
            break;
          case GSI.SakuzuListItem.POLYGON:
            geoJSONData = this._makeGeoJSONPolygon(layer2);
            if (geoJSONData) features.push(geoJSONData);
            break;
          case GSI.SakuzuListItem.LINESTRING:
            geoJSONData = this._makeGeoJSONLine(layer2);
            if (geoJSONData) features.push(geoJSONData);
            break;
          case GSI.SakuzuListItem.FEATURES:
            this._makeGeoJSONFeatures(layer2, features);
            break;
        }
      }
    }
    catch (e) { }
  },

  _layerInfo2Properties: function (info) {
    if (!info) return {};
    var result = {};

    if (info.title && info.title != '')
      result['name'] = info.title;
    if (info.description && info.description != '') {
      result['description'] = info.description;
    }
    else if (info.table) {
      for (var i = 0; i < info.table.length; i++) {
        result[info.table[i].key] = info.table[i].value;
      }
    }

    return result;
  },

  _makeGeoJSONLine: function (layer) {

    var result = layer.toGeoJSON();

    result.properties = this._layerInfo2Properties(this._getLayerInfo(layer));

    var options = layer.options;
    if (!options && layer.getLayers) {
      var layers = layer.getLayers();
      if (layers.length > 0) {
        options = layers[0].options;
      }
    }

    var color = options.color;
    var opacity = (options.opacity || options.opacity == 0 ? options.opacity : 1);
    var weight = options.weight;
    var dashArray = options.dashArray;

    result.properties["_color"] = color;
    result.properties["_opacity"] = opacity;
    result.properties["_weight"] = parseInt(weight);
    if ( dashArray && dashArray != "" ) result.properties["_dashArray"] = dashArray;

    if (layer.feature && layer.feature.properties) {
      for (var key in layer.feature.properties) {
        if (CONFIG.GEOJSONSPECIALKEYS[key]) {
          key = key.slice(1);
          if (!result.properties["_" + key])
            result.properties["_" + key] = options[key];
        }
      }
    }
    return result;
  },

  _makeGeoJSONCircle: function (layer) {
    var result = layer.toGeoJSON();

    result.properties = this._layerInfo2Properties(this._getLayerInfo(layer));

    var options = layer.options;
    if (!options && layer.getLayers) {
      var layers = layer.getLayers();
      if (layers.length > 0) {
        options = layers[0].options;
      }
    }
    var color = options.color;
    var opacity = (options.opacity || options.opacity == 0 ? options.opacity : 1);
    var weight = options.weight;

    var fillColor = options.fillColor;
    var fillOpacity = (options.fillOpacity || options.fillOpacity == 0 ? options.fillOpacity : 1);

    var dashArray = options.dashArray;

    result.properties["_markerType"] = "Circle";
    result.properties["_color"] = color;
    result.properties["_opacity"] = opacity;
    result.properties["_weight"] = parseInt(weight);
    result.properties["_fillColor"] = fillColor;
    result.properties["_fillOpacity"] = fillOpacity;
    result.properties["_radius"] = parseFloat(parseFloat(layer.getRadius()).toFixed(1));
    if ( dashArray && dashArray != "" ) result.properties["_dashArray"] = dashArray;

    if (layer.feature && layer.feature.properties) {
      for (var key in layer.feature.properties) {
        if (CONFIG.GEOJSONSPECIALKEYS[key]) {
          key = key.slice(1);
          if (!result.properties["_" + key]) {
            result.properties["_" + key] = options[key];
          }
        }
      }
    }

    return result;
  },

  _makeGeoJSONPoint: function (layer) {
    var result = layer.toGeoJSON();
    result.properties = this._layerInfo2Properties(this._getLayerInfo(layer));

    var options = layer.options;
    if (!options && layer.getLayers) {
      var layers = layer.getLayers();
      if (layers.length > 0) {
        options = layers[0].options;
      }
    }

    var iconUrl = options.icon.options.iconUrl;
    var iconSize = options.icon.options.iconSize;
    var iconAnchor = options.icon.options.iconAnchor;
    var html = options.icon.options.html;
    if (options.icon.options.className == 'gsi-div-icon') {
      result.properties["_markerType"] = "DivIcon";
      result.properties["_html"] = (html || html != '' ? html : '　');
    }
    else {
      result.properties["_markerType"] = "Icon";
      result.properties["_iconUrl"] = iconUrl;
    }
    result.properties["_iconSize"] = iconSize;
    result.properties["_iconAnchor"] = iconAnchor;

    if (!result.properties["_iconSize"]) delete result.properties["_iconSize"];

    if (!result.properties["_iconAnchor"]) delete result.properties["_iconAnchor"];

    if (layer.feature && layer.feature.properties) {
      for (var key in layer.feature.properties) {
        if (CONFIG.GEOJSONSPECIALKEYS[key]) {
          key = key.slice(1);
          if (!result.properties["_" + key]) {
            result.properties["_" + key] = options.icon.options[key];
          }
        }
      }
    }

    return result;
  },

  _makeGeoJSONPolygon: function (layer) {

    var result = layer.toGeoJSON();

    result.properties = this._layerInfo2Properties(this._getLayerInfo(layer));

    var options = layer.options;
    if (!options && layer.getLayers) {
      var layers = layer.getLayers();
      if (layers.length > 0) {
        options = layers[0].options;
      }
    }

    if (!options) options = {};

    var color = options.color;
    var opacity = (options.opacity || options.opacity == 0 ? options.opacity : 1);
    var weight = options.weight;
    var fillColor = options.fillColor;
    var fillOpacity = (options.fillOpacity || options.fillOpacity == 0 ? options.fillOpacity : 1);
    var dashArray = options.dashArray;

    if (!fillColor) fillColor = color;

    result.properties["_color"] = color;
    result.properties["_opacity"] = opacity;
    result.properties["_weight"] = parseInt(weight);
    result.properties["_fillColor"] = fillColor;
    result.properties["_fillOpacity"] = fillOpacity;
    if ( dashArray && dashArray != "" ) result.properties["_dashArray"] = dashArray;

    if (layer.feature && layer.feature.properties) {
      for (var key in layer.feature.properties) {
        if (CONFIG.GEOJSONSPECIALKEYS[key]) {
          key = key.slice(1);
          if (!result.properties["_" + key])
            result.properties["_" + key] = options[key];
        }
      }
    }

    return result;
  }
});

GSI.SakuzuListItem.GEOJSON = 1;
GSI.SakuzuListItem.KML = 2;
GSI.SakuzuListItem.IMAGE = 4;
GSI.SakuzuListItem.IMAGEICON = 5;

GSI.SakuzuListItem.NONE = 0;
GSI.SakuzuListItem.CREATE = 1;
GSI.SakuzuListItem.EDIT = 2;

GSI.SakuzuListItem.POINT = "point";
GSI.SakuzuListItem.POINT_CIRCLE = "point_circle";
GSI.SakuzuListItem.POINT_TEXT = "point_text";
GSI.SakuzuListItem.LINESTRING = "line";
GSI.SakuzuListItem.POLYGON = "polygon";
GSI.SakuzuListItem.POLYGONINNER = "polygon_inner";
GSI.SakuzuListItem.POLYGONINNER2 = "polygon_inner2";
GSI.SakuzuListItem.CIRCLE = "circle";
GSI.SakuzuListItem.FREEHAND = "freehand";
GSI.SakuzuListItem.FEATURES = "features";

GSI.SakuzuListItem.MULTIPOINT = "multipoint";
GSI.SakuzuListItem.MULTILINESTRING = "multiline";
GSI.SakuzuListItem.MULTIPOLYGON = "multipolygon";

GSI.SakuzuListItem.typeToTitle = function(drawType) {
  var result = "";
  switch(drawType) {
    case GSI.SakuzuListItem.POINT:
      result = "マーカー（アイコン）";
      break;

    case GSI.SakuzuListItem.POINT_CIRCLE:
        result = "マーカー（円）";
        break;

    case GSI.SakuzuListItem.POINT_TEXT:
        result = "テキスト";
        break;

    case GSI.SakuzuListItem.LINESTRING:
        result = "線";
        break;

    case GSI.SakuzuListItem.POLYGON:
        result = "ポリゴン";
        break;

    case GSI.SakuzuListItem.CIRCLE:
        result = "円";
        break;

    case GSI.SakuzuListItem.FREEHAND:
        result = "フリーハンドの線";
        break;

    case GSI.SakuzuListItem.MULTIPOLYGON:
      result = "マルチポリゴン";
      break;

    default:
      result = "編集（または削除）";
      break;
  }
  return result;
};

GSI.SakuzuList = L.Evented.extend({

  _list: [],
  initialize: function (gsimaps, map, mapMouse, defaultIcon, options) {
    this._map = map;
    this._gsimaps = gsimaps;
    this._mapMouse = mapMouse;
    // ↓値をコピー
    this._defaultIcon = $.extend(true, {}, defaultIcon);
    // 作図データ
    if (options.defaultList && options.defaultList.length > 0) {
      for (var i = 0; i < options.defaultList.length; i++) {
        var fileName = (i == 0 ? GSI.TEXT.SAKUZU.SAKUZUTITLE : options.defaultList[i].fileName);
        var noExt = (i == 0);

        var geoJSON = {
          "type": "FeatureCollection",
          "features": options.defaultList[i].features
        };
        var item = this._loadJSON(fileName, geoJSON, options.defaultList[i], noExt);

        if (i == 0 && !item) {
          this._list.push(new GSI.SakuzuListItem(this, null, GSI.TEXT.SAKUZU.SAKUZUTITLE, '', null, true));
        }
        if (!options.defaultList[i].visible) {
          item.setVisible(false);
        }
      }
    }
    else {
      this._list.push(new GSI.SakuzuListItem(this, null, GSI.TEXT.SAKUZU.SAKUZUTITLE, '', null, true));
    }
  },
  getSakuzuItem: function () {
    return this._list[0];
  },
  eachItems: function (fnc) {
    for (var i = 0; i < this._list.length; i++) {
      fnc(this._list[i]);
    }
  },

  getSaveTargetLayerCount : function() {
    var totalLayerCount = 0;
    for (var i = 0; i < this._list.length; i++) {
      var item = this._list[i];
      var dataType = item.getDataType();
      if (dataType != GSI.SakuzuListItem.IMAGE && dataType != GSI.SakuzuListItem.IMAGEICON)
        totalLayerCount+=item.getLayerCount();
    }

    return totalLayerCount;
  },

  getLength: function () {
    return this._list.length;
  },
  get: function (idx) {
    return this._list[idx];
  },
  remove: function (obj) {
    for (var i = 0; i < this._list.length; i++) {
      if (this._list[i] == obj) {
        this.removeByIndex(i);
        break;
      }
    }
  },
  removeByIndex: function (idx) {
    if (idx == 0) {
      this._list[idx].removeAllLayers();
    }
    else {
      this._list[idx].destroy();
      this._list.splice(idx, 1);
    }

    this.fire('change');
  },
  loadFromFile: function (files) {
    if (files && files.length > 0) {
      this._fileReader = new FileReader();
      this._fileReader.onload = L.bind(this._onFileLoad, this, files[0].name);
      this._fileReader.onerror = function () { alert(GSI.TEXT.SAKUZU.LOAD_ERROR); };
      this._fileReader.readAsArrayBuffer(files[0]);
    }
    else {
      alert(GSI.TEXT.SAKUZU.LOAD_NOFILE);
    }
  },

  loadFromImage: function( buff, fileName ) {

    var layer = new GSI.GeoTIFFImageOverlay();
    layer._setImage( buff );

    var item = new GSI.SakuzuListItem(
      this, GSI.SakuzuListItem.IMAGE, fileName, fileName, layer, true);
    this._list.push(item);

    try {
      if (item && item._layer && item._layer.getBounds) this._map.fitBounds(item._layer.getBounds());
    }
    catch (e) { }

    this.fire('load', { error: (item ? false : true) });
    this.fire('change');

  },

  getGeotiffList : function() {

    var list =[];

    for( var i=0; i<this._list.length; i++ ) {
      var item = this._list[i];
      if ( !item._visible || item._dataType != GSI.SakuzuListItem.IMAGE ) continue;

      list.push( {
        canvas : item._layer._image,
        sw: item._layer._bounds.getSouthWest(),
        ne: item._layer._bounds.getNorthEast()
      });
    }

    return list;
  },

  loadFromImageList: function( list ) {

    var addedList = [];
    for( var i=0; i<list.length; i++ ) {
      var buff  = list[i].data;
      var fileName = list[i].fileName;
      var file = list[i].file;
      // Tiff
      try {
        var layer = new GSI.GeoTIFFImageOverlay();
        layer._setImage( buff );

        var item = new GSI.SakuzuListItem(
          this, GSI.SakuzuListItem.IMAGE, fileName, fileName, layer, true);
        this._list.push(item);
        addedList.push( item);
      }catch (ex) {
        // Jpeg
        try {

          var layer = new GSI.GeoJpegMarker(list[i].data, list[i].fileName, file);

          var item = new GSI.SakuzuListItem(
            this, GSI.SakuzuListItem.IMAGEICON, fileName, fileName, layer, true);
          this._list.push(item);
          addedList.push( item);
        } catch( ex) {

        }
      }
    }

    var boundsAll = null;
    for( var i=0; i<addedList.length; i++ ) {
      var addedItem = addedList[i];
      if (addedItem._layer && addedItem._layer.getBounds) {

        try {
          var bounds = addedItem._layer.getBounds();
          if ( !boundsAll ) boundsAll= bounds;
          else boundsAll.extend( bounds);
        } catch (e) {
        }
      } else if (addedItem._layer && addedItem._layer.getLatLng) {

        try {
          var latLng = addedItem._layer.getLatLng();
          if ( !boundsAll ) boundsAll= new L.LatLngBounds();

          boundsAll.extend( latLng);
        } catch (e) {
        }
      }

    }
    if ( boundsAll)
      this._map.fitBounds(boundsAll);

    this.fire('load', { error: (addedList.length > 0 ? false : true) });
    this.fire('change');

  },

  loadFromText: function (text, fileName) {
    var item = null;
    try {
      var json = JSON.parse(text);
      item = this._loadJSON(fileName, json);
    }
    catch (e) {
      try {
        item = this._loadKML(fileName, text);
      }
      catch (e) { }
    }

    try {
      if (item && item._layer && item._layer.getBounds) this._map.fitBounds(item._layer.getBounds());
    }
    catch (e) { }

    this.fire('load', { error: (item ? false : true) });
    this.fire('change');
  },

  loadFromTextList: function (list) {
    var addedList = [];
    for( var i=0; i<list.length; i++ ) {
      var item = null;
      try {
        var json = JSON.parse(list[i].data);
        item = this._loadJSON(list[i].fileName, json, false, list[i].fKey);
      }
      catch (e) {
        try {
          item = this._loadKML(list[i].fileName, list[i].data, list[i].fKey);
        }
        catch (e) { }
      }
      if ( item ) {
        addedList.push(item);
      }
    }

    var boundsAll = null;
    for( var i=0; i<addedList.length; i++ ) {
      var addedItem = addedList[i];

      if (addedItem._layer && addedItem._layer.getBounds) {

        try {
          var bounds = addedItem._layer.getBounds();
          if ( !boundsAll ) boundsAll= bounds;
          else boundsAll.extend( bounds);
        } catch (e) {
         }

      }
      if ( boundsAll)
        this._map.fitBounds(boundsAll);
    }
    this.fire('load', { error: (addedList.length ? false : true) });
    this.fire('change');
  },

  loadFromCSV : function(txt, fname) {
    if ( !this._csvLoadDialog) {
      var windowSize = GSI.Utils.getScreenSize();
      this._csvLoadDialog = new GSI.CSVLoadDialog(this._gsimaps, this._gsimaps._mainMap._dialogManager, this._gsimaps._mainMap.getMap(), {
        width: 350,
        left: Math.floor( windowSize.w /2 - 180 ),
        top: Math.floor( windowSize.h /2 - 180 ),
        height:"auto",
        effect: CONFIG.EFFECTS.DIALOG,
        resizable: "e,w"
      });
    }
    this._csvLoadDialog.show(txt,fname);
  },

  loadFromCSVList : function(list) {
    if ( !this._csvLoadDialog) {
      var windowSize = GSI.Utils.getScreenSize();
      this._csvLoadDialog = new GSI.CSVLoadDialog(this._gsimaps, this._gsimaps._mainMap._dialogManager, this._gsimaps._mainMap.getMap(), {
        width: 350,
        left: Math.floor( windowSize.w /2 - 180 ),
        top: Math.floor( windowSize.h /2 - 180 ),
        height:"auto",
        effect: CONFIG.EFFECTS.DIALOG,
        resizable: "e,w"
      });
    }

    this._csvLoadDialog.show(list);
  },

  addCSVGeoJSON: function( geoJSON, fileName ) {
    item = this._loadJSON(fileName, geoJSON);

    try {
      if (item && item._layer && item._layer.getBounds) this._map.fitBounds(item._layer.getBounds());
    }
    catch (e) { }

    this.fire('load', { error: (item ? false : true) });
    this.fire('change');

  },

  _onFileLoad: function (fileName) {
    var item = null;

    if ( fileName.match(/\.tif[f]*$/i )) {
      this.loadFromImage(this._fileReader.result, fileName);
      return;
    } else if (fileName.match(/\.csv$/i) ) {

      var arr = Encoding.convert(new Uint8Array(this._fileReader.result), "UNICODE", "AUTO");
      if ( arr[0] == 65279 ) arr.splice(0,1);
      var txt = Encoding.codeToString(arr);
      this.loadFromCSV( txt, fileName );
      this.fire('load', { error: false });
      return;
    }
    try {

      var arr = Encoding.convert(new Uint8Array(this._fileReader.result), "UNICODE", "AUTO");
      if ( arr[0] == 65279 ) arr.splice(0,1);
      var txt = Encoding.codeToString(arr);
      var json = JSON.parse(txt);

      item = this._loadJSON(fileName, json);
    }
    catch (e) {

      try {
        item = this._loadKML(fileName, txt);
      }
      catch (e) { }
    }

    try {
      if (item && item._layer && item._layer.getBounds) this._map.fitBounds(item._layer.getBounds());
    }
    catch (e) { }

    this.fire('load', { error: (item ? false : true) });
    this.fire('change');
  },

  _loadJSON: function (fileName, json, noExt, fKey) {
    var layer = new GSI.GeoJSON(null, { geodesic: true });
    layer.addData(json);
    if (!fileName) {
      fileName = "file-" + this._list.length + ".geojson";
    }
    else if (!noExt && !fileName.match(/\./)) {
      fileName += '.geojson';
    }
    if (layer.getLayers().length > 0) {
      var item = new GSI.SakuzuListItem(
        this, GSI.SakuzuListItem.GEOJSON, fileName, fileName, layer, true, false, fKey);
      this._list.push(item);
      return item;
    }

    else return null;
  },
  _loadKML: function (fileName, text, fKey) {
    text = text ? text : this._fileReader.result;
    var xmlDoc = null;
    if (window.ActiveXObject) {
      xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
      xmlDoc.async = false;
      xmlDoc.loadXML(text ? text : this._fileReader.result);
    }
    else if (window.DOMParser) {
      xmlDoc = new DOMParser().parseFromString(
        text ? text : this._fileReader.result,
        "application/xml"
      );
    }

    var layer = new GSI.KML(null, { async: true, geodesic: true });

    layer._kmlText = text;
    layer._addKML(xmlDoc, {});

    if (!fileName) {
      fileName = "file-" + this._list.length + ".kml";
    }
    else if (!fileName.match(/\./)) {
      fileName += '.kml';
    }

    if (layer.getLayers().length > 0) {
      var item = new GSI.SakuzuListItem(
        this, GSI.SakuzuListItem.KML, fileName, fileName, layer, true, false, fKey);

      this._list.push(item);
      return item;
    }
    else return null;

  },
  _styleId: 1,
  getStyleId: function () {
    var result = this._styleId;
    this._styleId++;

    return result;
  },
  toKML: function () {
    this._styleId = 1;

    var styleList = {};
    var result = '';

    for (var i = 0; i < this._list.length; i++) {
      var item = this._list[i];
      if (item.getVisible()) {
        result += item.toKML(styleList);
      }
    }
    if (result != '') {
      result =
        '<?xml version="1.0" encoding="UTF-8"?>' + "\n" +
        '<kml xmlns="http://www.opengis.net/kml/2.2">' + "\n" +
        '<Document>\n' +
        result +
        '</Document>\n' +
        '</kml>';
    }
    return result;
  },
  getGeoJSONList: function () {
    this._styleId = 1;
    var result = [];

    for (var i = 0; i < this._list.length; i++) {
      var item = this._list[i];
      var resultItem = {
        fileName: item.getFileName(),
        visible: item.getVisible(),
        features: item.toGeoJSON()
      };
      result.push(resultItem);
    }

    return result;
  },
  toGeoJSON: function () {
    this._styleId = 1;
    var result = {
      "type": "FeatureCollection",
      "features": []
    };
    for (var i = 0; i < this._list.length; i++) {
      var item = this._list[i];
      if (item.getVisible()) {
        var features = item.toGeoJSON();

        for (var j = 0; j < features.length; j++) {
          result.features.push(features[j]);
        }
      }
    }

    return JSON.stringify(result, null, "  ");
  },
  getData: function () {
    var result = [];
    for (var i = 0; i < this._list.length; i++) {
      var item = this._list[i];
      if (item.getVisible()) {
        if (item._layer && item._layer._kmlText && item._layer._kmlText != "") {
          this._styleId = 1;

          var styleList = {};

          var kml = '';

          if (item._layer._edited) {
            kml =
              '<?xml version="1.0" encoding="UTF-8"?>' + "\n" +
              '<kml xmlns="http://www.opengis.net/kml/2.2">' + "\n" +
              '<Document>\n' +
              item.toKML(styleList) +
              '</Document>\n' +
              '</kml>';
          }
          else {
            kml = item._layer._kmlText;
          }
          result.push({
            "kmltext": kml
          });
          continue;
        }
        var features = item.toGeoJSON();
        for (var j = 0; j < features.length; j++) {
          result.push(features[j]);
        }
      }
    }
    return result;
  }
});

/************************************************************************
 L.Class
 - GSI.Dialog
   - GSI.SakuzuDialog (作図ダイアログ管理)
 ************************************************************************/
GSI.SakuzuDialog = GSI.Dialog.extend({
  options: {
    title: GSI.TEXT.SAKUZU.DIALOG_TITLE,
    minimize: true
  },
  initialize: function (dialogManager, map, sakuzuList, options) {
    this._map = map;
    this._sakuzuList = sakuzuList;

    this._sakuzuList.on('change', L.bind(this._onSakuzuListChange, this));
    this._sakuzuList.on('visiblechange', L.bind(this._onVisibleChange, this));

    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);
  },

  setMaxScrollHeight: function (maxHeight) { },

  createHeader: function () {
    this._title = $('<div>').html(this.options.title);

    return $('<div>').append(this._title);
  },

  _createAfter : function() {
    //ui-resizable-handle ui-resizable-s
    this.container.find(".ui-resizable-handle.ui-resizable-s").on("dblclick", L.bind(function(){
      this._topPanelHeight = undefined;
      try {
        this._topPanelList.css({"height":"auto"});
        this.container.css({"height":"auto"});
      } catch(ex) {}
    },this));
  },

  createContent: function () {
    this._sakuzuFrame = $('<div>').addClass('gsi_sakuzu_dialog_frame');
    return this._sakuzuFrame;
  },

  _createTopPanel: function () {
    // 初期画面
    if (this._topPanel) return;

    this._topPanel = $('<div>');

    this._topPanelToolBar = this._createTopPanelToolbar();
    this._topPanelList = this._createTopPanelList();
    this._topPanel.append(this._topPanelToolBar);
    this._topPanel.append(this._topPanelList);

    this._sakuzuFrame.append(this._topPanel);
  },

  _createTopPanelToolbar: function () {
    var frame = $("<div>").addClass('gsi_sakuzu_dialog_modeselect');
    var btn = null;

    // ファイル
    btn = $('<a>').addClass("").attr({ "href": "javascript:void(0);" }).append(
      $('<img>').attr({ 'src': 'image/sakuzu/icon_fileopen.png',
      'title': GSI.Utils.getTooltipText("SAKUZU","LOAD") }).css({ 'width': '24px', 'height': '24px' })
    ).on('click',L.bind(this._toolBtnClick, this, "file_load"));
    frame.append(btn);
    this._openFileButton = btn;

    btn = $('<a>').attr({ "href": "javascript:void(0);" }).append(
      $('<img>').attr({ 'src': 'image/sakuzu/icon_filesave.png',
      'title': GSI.Utils.getTooltipText("SAKUZU","SAVE") }).css({ 'width': '24px', 'height': '24px' })
    ).on('click',L.bind(this._toolBtnClick, this, "file_save"));
    frame.append(btn);
    this._saveFileButton = btn;

    frame.append($('<img>').addClass('sep').attr({ 'src': 'image/sakuzu/toolbar_sep.png' }).css(
      { 'margin-left': '4px', 'margin-right': '5px', 'width': '1px', 'height': '20px' }));

    // ポイント
    btn = $('<a>').addClass(GSI.SakuzuListItem.POINT).attr({ "href": "javascript:void(0);" }).append(
      $('<img>').attr({ 'src': 'image/sakuzu/icon_mark.png',
      'title': GSI.Utils.getTooltipText("SAKUZU","MARKER") }).css({ 'width': '24px', 'height': '24px' })
    ).on('click',L.bind(this._toolBtnClick, this, GSI.SakuzuListItem.POINT));
    frame.append(btn);

    // 円（マーカー）
    btn = $('<a>').addClass(GSI.SakuzuListItem.POINT_CIRCLE).attr({ "href": "javascript:void(0);" }).append(
      $('<img>').attr({ 'src': 'image/sakuzu/icon_markc.png',
      'title': GSI.Utils.getTooltipText("SAKUZU","CIRCLEMARKER") }).css({ 'width': '24px', 'height': '24px' })
    ).on('click',L.bind(this._toolBtnClick, this, GSI.SakuzuListItem.POINT_CIRCLE));
    frame.append(btn);

    // 線
    btn = $('<a>').addClass(GSI.SakuzuListItem.LINESTRING).attr({ "href": "javascript:void(0);" }).append(
      $('<img>').attr({ 'src': 'image/sakuzu/icon_line.png',
      'title': GSI.Utils.getTooltipText("SAKUZU","LINE") }).css({ 'width': '24px', 'height': '24px' })
    ).on('click',L.bind(this._toolBtnClick, this, GSI.SakuzuListItem.LINESTRING));
    frame.append(btn);

    // ポリゴン
    btn = $('<a>').addClass(GSI.SakuzuListItem.POLYGON).attr({ "href": "javascript:void(0);" }).append(
      $('<img>').attr({ 'src': 'image/sakuzu/icon_polygon.png',
      'title': GSI.Utils.getTooltipText("SAKUZU","POLYGON") }).css({ 'width': '24px', 'height': '24px' })
    ).on('click',L.bind(this._toolBtnClick, this, GSI.SakuzuListItem.POLYGON));
    frame.append(btn);

    // 円
    btn = $('<a>').addClass(GSI.SakuzuListItem.CIRCLE).attr({ "href": "javascript:void(0);" }).append(
      $('<img>').attr({ 'src': 'image/sakuzu/icon_circle.png',
      'title': GSI.Utils.getTooltipText("SAKUZU","CIRCLE") }).css({ 'width': '24px', 'height': '24px' })
    ).on('click',L.bind(this._toolBtnClick, this, GSI.SakuzuListItem.CIRCLE));
    frame.append(btn);

    // ポイント(テキスト)
    btn = $('<a>').addClass(GSI.SakuzuListItem.POINT_TEXT).attr({ "href": "javascript:void(0);" }).append(
      $('<img>').attr({ 'src': 'image/sakuzu/icon_text.png',
      'title': GSI.Utils.getTooltipText("SAKUZU","TEXT") }).css({ 'width': '24px', 'height': '24px' })
    ).on('click',L.bind(this._toolBtnClick, this, GSI.SakuzuListItem.POINT_TEXT));
    frame.append(btn);

    // フリーハンド
    btn = $('<a>').addClass(GSI.SakuzuListItem.FREEHAND).attr({ "href": "javascript:void(0);" }).append(
      $('<img>').attr({ 'src': 'image/sakuzu/icon_freehand.png',
      'title': GSI.Utils.getTooltipText("SAKUZU","FREEHAND") }).css({ 'width': '24px', 'height': '24px' })
    ).on('click',L.bind(this._toolBtnClick, this, GSI.SakuzuListItem.FREEHAND));
    frame.append(btn);

    frame.append($('<div>').css({ clear: 'both' }));

    return frame;
  },

  _createTopPanelList: function () {
    var frame = $('<div>').addClass('gsi-sakuzudialog-list-container');
    this._listUL = $("<ul>");
    this._refreshList(true);
    frame.append(this._listUL);

    return frame;
  },

  _refreshToolButton : function() {

    this._topPanelToolBar.find("a").removeClass("active");
    if ( this._drawManager && this._drawManager.isRunning() && this._drawManager.getDrawType()!="") {

      this._topPanelToolBar.find("a." + this._drawManager.getDrawType() ).addClass("active");
    }

    var liList = this._listUL.find("li");
    liList.removeClass("editing");
    liList.removeClass("creating");

    if ( !this._drawManager ) return;
    for( var i=0; i<liList.length; i++ ) {
      var sakuzuItem = $(liList[i]).data("sakuzuItem");
      if ( sakuzuItem == this._drawManager.getSakuzuItem()) {
        var editing = this._drawManager instanceof GSI.EditManager;
        $(liList[i]).addClass(editing ? "editing" : "creating");
        break;
      }
    }

  },

  _onVisibleChange: function (event) {
    this._refreshList();
  },

  _onSakuzuListChange : function() {
    this._refreshList();
    this._refreshFileButton();
  },

  _refreshFileButton : function() {

    if ( this._sakuzuList.getSaveTargetLayerCount() > 0 ) {
      this._saveFileButton.removeClass("disabled");
    } else {
      this._saveFileButton.addClass("disabled");
    }
  },

  _refreshList: function () {
    //自動調整用css再設定
    this.container.css({height:"auto"});
    
    this._listUL.empty();

    var liHeight = 0;

    this._sakuzuList.eachItems(L.bind(function (item) {
      item._viewData = {};

      var table = $("<table>").css({"width": "100%"});
      var tbody = $("<tbody>")
      var tr = $('<tr>');
      var td = null;
      var id = 'GSI_SakuzuDialog_check' + GSI.Utils.getCurrentID();

      // 表示チェック
//      var checkBox = $('<input>').attr({ 'id': id, 'type': 'checkbox', 'checked': item.getVisible() }).addClass('normalcheck');
      var checkBox = $('<input>').attr({ 'id': id, 'type': 'checkbox'}).addClass('normalcheck');
      checkBox.prop('checked', item.getVisible());
      checkBox.on('click',L.bind(function (checkBox, item) {
        item.setVisible(checkBox.is(':checked'));
      }, this, checkBox, item));

      var dataType = item.getDataType();
      item._viewData.checkbox = checkBox;

      var label = $('<label>').attr({ 'for': id }).html(item.getTitle()).addClass("title");
      var span = $('<span>').html(item.getTitle()).addClass("title");
      // 名称
      var title = $('<div>').append(checkBox).append(label).append(span)
        .css({ "word-break": "break-all" })
        .addClass('folder');

      // レイヤー数
      var layerCount = item.getLayerCount();
      var num = $('<span>').addClass('num').html(layerCount);

      td = $('<td>').append(title).css({ 'width': '100%', "word-break": "break-all" });
      tr.append(td);

      // ボタン類
      td = $('<td>').css({ "text-align": "right" }).append(num);
      tr.append(td);

      var buttonClassName = 'normalbutton sakuzubutton' + (layerCount <= 0 ? ' disabled' : '');
      var editBtn = null;
      var opacityBtn = null;

      if (dataType == GSI.SakuzuListItem.IMAGE) {
        opacityBtn = $('<a>').attr({ "href": "javascript:void(0);" })
          .html(GSI.TEXT.SAKUZU.DIALOG_LIST_OPACITYBTN).addClass(buttonClassName);
        td = $('<td>').append(opacityBtn);

      } else if (dataType != GSI.SakuzuListItem.IMAGEICON) {
        editBtn = $('<a>').attr({ "href": "javascript:void(0);" }).html(GSI.TEXT.SAKUZU.DIALOG_LIST_EDITBTN).addClass(buttonClassName);
        td = $('<td>').append(editBtn);
        editBtn.addClass("editbutton")
      }
      tr.append(td);

      var clearBtn = $('<a>').attr({ "href": "javascript:void(0);" }).html(GSI.TEXT.SAKUZU.DIALOG_LIST_REMOVEBTN).addClass(buttonClassName);
      td = $('<td>').append(clearBtn);
      tr.append(td);
      tbody.append(tr);

      // アイコンラベル
      if (dataType != GSI.SakuzuListItem.IMAGE && dataType != GSI.SakuzuListItem.IMAGEICON) {
        tr = $('<tr>');
        id = 'GSI_SakuzuDialog_label_check' + GSI.Utils.getCurrentID();
//        var checkbox2 = $('<input>').attr({ 'id': id, 'type': 'checkbox', 'checked': item.getIconLabelVisible() }).addClass('normalcheck');
        var checkbox2 = $('<input>').attr({ 'id': id, 'type': 'checkbox'}).addClass('normalcheck');
        checkbox2.prop('checked', item.getIconLabelVisible());

        checkbox2.on('click',L.bind(function (checkBox2, item) {
          item.setIconLabelVisible(checkBox2.is(':checked'));
          // ラベル選択コンボボックス 表示/非表示
          if (checkBox2.is(':checked')) {
            $('#' + checkBox2[0].id + 'div').slideDown(200);
          } else {
            $('#' + checkBox2[0].id + 'div').slideUp(200);;
          }
        }, this, checkbox2, item));

        label = $('<label>').attr({ 'for': id }).html(GSI.TEXT.SAKUZU.DIALOG_LIST_VISIBLEICONLABELBTN);
        td = $('<td>').attr({ "colspan": 4, "align": "right" }).append(checkbox2).append(label);

        // ラベル選択コンボボックス作成
        var keyNameList = ['name'];
        item._layer.getLayers().forEach(function(lval,index,ar) {
          if (lval.feature) {
            if (lval.feature.geometry.type.toLowerCase() == 'point' && (lval.feature.properties._markerType == undefined || lval.feature.properties._markerType.toLowerCase() =="icon")) {
              var obj = lval.feature.properties;
              Object.keys(obj).forEach(function (key) {
                if(key === "description") return;
                if (key[0] != '_' && !keyNameList.includes(key)) {
                  keyNameList.push(key);
                }
              });
            }
          } else {
            if (lval._icon != undefined && lval.options.icon.options.iconUrl && lval._information.table != null) {
              var ary = lval._information.table;
              ary.forEach(function(aval,index,ar) {
                if(aval.key === "description") return;
                if (!keyNameList.includes(aval.key)) {
                  keyNameList.push(aval.key);
                }
              });
            }
          }
        });
        id = id + 'div';
        var keyNameDiv = $('<div>').attr({ 'id': id });
        if (!checkbox2.is(':checked')) keyNameDiv.css({ "display": "none" });
        var keyNameLabel =  $('<label>').html(GSI.TEXT.SAKUZU.DIALOG_LIST_SELECTLABEL);
        id = 'GSI_SakuzuDialog_label_select' + GSI.Utils.getCurrentID();
        var keyNameSelect = $('<select>').attr({ 'id': id });
        keyNameList.forEach(function(val,index,ar) {
          keyNameSelect.append($('<option>').html(val).val(val));
        });
        keyNameSelect.on('change',L.bind(function (selectBox, item) {
          var arylist = item._layer.getLayers();
          var selval = selectBox.val();
          item._iconLabelSelectValue = selval
          arylist.forEach(function(val,index,ar) {
            if (val.feature) {
              var valText = "";
              if (selval =='name') {
                valText = val.feature.properties['name'];
              } else {
                if (val.feature.properties[selval]) valText = val.feature.properties[selval];
              }
              if (val.options.icon && val.options.icon.options && val.options.icon.options.iconUrl && val.options.icon.setLabelText) val.options.icon.setLabelText(valText);
            } else if (val._information){
              var valText = "";
              if (selval =='name') {
                valText = val._information.title;
              }else{
                if (val._information.table && val._information.table.length > 0) {
                  val._information.table.forEach(function(tval,index,ar) {
                    if (tval.key == selval) valText = tval.value;
                  });
                }
              }
              if (val.options.icon && val.options.icon.options && val.options.icon.options.iconUrl && val.options.icon.setLabelText) val.options.icon.setLabelText(valText);
            }
          });
        }, this, keyNameSelect, item));
        if (keyNameList.includes(item._iconLabelSelectValue)) {
          keyNameSelect.val(item._iconLabelSelectValue);
          var arylist = item._layer.getLayers();
          var selval = item._iconLabelSelectValue;
          arylist.forEach(function(val,index,ar) {
            if (val.feature) {
              var valText = "";
              if (selval =='name') {
                valText = val.feature.properties['name'];
              } else {
                if (val.feature.properties[selval]) valText = val.feature.properties[selval];
              }
              if (val.options.icon && val.options.icon.options && val.options.icon.options.iconUrl && val.options.icon.setLabelText) val.options.icon.setLabelText(valText);
            } else if (val._information){
              var valText = "";
              if (selval =='name') {
                valText = val._information.title;
              } else {
                if (val._information.table && val._information.table.length > 0) {
                  val._information.table.forEach(function(tval,index,ar) {
                    if (tval.key == selval) valText = tval.value;
                  });
                }
              }
              if (val.options.icon && val.options.icon.options && val.options.icon.options.iconUrl && val.options.icon.setLabelText) val.options.icon.setLabelText(valText);
            }
          });
        } else {
          item._iconLabelSelectValue = 'name';
        }
        keyNameDiv.append(keyNameLabel).append(keyNameSelect);
        td.append(keyNameDiv);

        var labelSizeFrame = $("<div>").addClass("labelsizeframe");
        var labelLarge = $("<a>").attr({ "href": "javascript:void(0);" }).html("大").addClass("large");
        var labelMiddle = $("<a>").attr({ "href": "javascript:void(0);" }).html("中").addClass("middle");
        var labelSmall = $("<a>").attr({ "href": "javascript:void(0);" }).html("小").addClass("small");

        labelLarge.on('click',L.bind(function (labelSizeFrame, item) {
          item.setIconLabelSize("large");
          this._refreshIconLabelSizeButton(labelSizeFrame, item);
        }, this, labelSizeFrame, item));

        labelLarge.attr({"title":GSI.Utils.getTooltipText("SAKUZU","LABEL_L")});

        labelMiddle.on('click',L.bind(function (labelSizeFrame, item) {
          item.setIconLabelSize("middle");
          this._refreshIconLabelSizeButton(labelSizeFrame, item);
        }, this, labelSizeFrame, item));

        labelSmall.on('click',L.bind(function (labelSizeFrame, item) {
          item.setIconLabelSize("small");
          this._refreshIconLabelSizeButton(labelSizeFrame, item);
        }, this, labelSizeFrame, item));

        labelLarge.attr({"title":GSI.Utils.getTooltipText("SAKUZU","LABEL_L")});
        labelMiddle.attr({"title":GSI.Utils.getTooltipText("SAKUZU","LABEL_M")});
        labelSmall.attr({"title":GSI.Utils.getTooltipText("SAKUZU","LABEL_S")});

        labelSizeFrame.append(labelLarge).append(labelMiddle).append(labelSmall);
        this._refreshIconLabelSizeButton(labelSizeFrame, item);
        td.append(labelSizeFrame);
        tr.append(td);
        tbody.append(tr);
      } else {

        tr = $('<tr>');
        td = $("<td>").attr({ "colspan": 4, "align": "right" }).html("このレイヤーは保存されません。");
        tr.append(td);
        tbody.append(tr);
      }

      table.append( tbody );
      var li = $("<li>").append( table ).data({"sakuzuItem": item });
      this._listUL.append( li );

      if (editBtn) {
        editBtn.on('click',L.bind(this._onEditSakuzuItemClick, this, item, li ));
        editBtn.attr({"title":GSI.Utils.getTooltipText("SAKUZU","EDIT")});
      }
      if ( clearBtn ){
        clearBtn.on('click',L.bind(this._onClearButtonClick, this, item));
        clearBtn.attr({"title":GSI.Utils.getTooltipText("SAKUZU","REMOVE")});
      }
      if (opacityBtn) opacityBtn.on('click',L.bind(this._onOpacityBtnClick, this, item, opacityBtn, tr));

    }, this));

    this._refreshToolButton();

    for(var x = 0; x < this._listUL.length; x++){
      liHeight += $(this._listUL[x]).outerHeight();
    }

    if (liHeight > 0 && this._userResized == false){
      //ダイアログが表示されていて、変更された時
      var ws = GSI.Utils.getScreenSize();
      var titleHeight = this._title? this._title.outerHeight(): 30;
      var tBarHeight = this._topPanelToolBar? this._topPanelToolBar.outerHeight() : 40;
      var limitHeight = ws.h - 50 - titleHeight - tBarHeight - this.container.offset().top;

      if (liHeight > limitHeight){
        liHeight = limitHeight;
      }
      $(this.container).find(".gsi-sakuzudialog-list-container").css({"height": liHeight});
    }
  },

  _onOpacityBtnClick:function(item,btn, tr) {

    var opacity = ( item._opacity != undefined ? item._opacity : 1 );//(item._visibleInfo ? item._visibleInfo.opacity : 1);
    if (!this._opacityWindow) {
      this._opacityWindow = $('<div>').addClass('viewlistdialog_opacity_window');
      this._opacityValue = $('<div>').addClass('value').html('透過率:');
      this._opacitySlider = $('<div>').addClass('slider').html('&nbsp;');
      this._opacityWindow.append(this._opacityValue).append(this._opacitySlider);
      $("body").append(this._opacityWindow);
      this._opacitySlider.slider({
        min: 0,
        max: 100
      });
    }
    else if (this._opacityWindow && this._opacityWindow.is(":visible") && this._opacityWindow.data("item") == item) {
      this._opacityWindow.slideUp(200);
      return;
    }
    var offset = btn.offset();
    this._opacityWindow.css({
      top: offset.top + btn.outerHeight(),
      left: ( offset.left + btn.outerWidth() - 300 ) + 'px'
    }).data({ "item": item });

    var opacityPercentage = Math.round(100 - (opacity * 100));
    this._opacityValue.html('透過率:' + opacityPercentage + '%');
    this._opacitySlider.data({ "__target_item": item }).slider("option", "value", opacityPercentage);
    this._opacitySlider.off("slide").on("slide", L.bind(function (event, ui) {
      var item = this._opacitySlider.data('__target_item');
      var value = ui.value;
      this._opacityValue.html('透過率:' + value + '%');
      var opacity = value / 100.0;
      if (opacity < 0) opacity = 0;
      if (opacity > 1) opacity = 1;
      opacity = 1 - opacity;
      item._layer.setOpacity(opacity);
      item._opacity = opacity;
    }, this));

    if (this._hideOpacityWindowHandler) {
      $(document.body).off('mousedown', this._hideOpacityWindowHandler);
      $(document.body).off('touchstart', this._hideOpacityWindowHandler);

    }
    this._hideOpacityWindowHandler = L.bind(function (event) {
      if (!this._opacityWindow
        || event.target == this._opacityWindow[0]
        || $(event.target).is(".opacity_btn")) return;

      var parents = $(event.target).parents();

      var hit = false;
      for (var i = 0; i < parents.length; i++) {
        if ($(parents[i]).is(".viewlistdialog_opacity_window")) {
          hit = true;
          break;
        }
      }
      if (!hit) {
        this._opacityWindow.slideUp(200);
        $(document.body).off('mousedown', this._hideOpacityWindowHandler);
        $(document.body).off('touchstart', this._hideOpacityWindowHandler);
      }
    }, this);

    $(document.body).on('mousedown', this._hideOpacityWindowHandler);
    $(document.body).on('touchstart', this._hideOpacityWindowHandler);

    this._opacityWindow.hide().slideDown(200);
  },

  _refreshIconLabelSizeButton: function (frame, item) {
    var labelLarge = frame.find("a.large");
    var labelMiddle = frame.find("a.middle");
    var labelSmall = frame.find("a.small");

    switch (item.getIconLabelSize()) {
      case "large":
        labelLarge.addClass("active");
        labelMiddle.removeClass("active");
        labelSmall.removeClass("active");
        break;

      case "small":
        labelLarge.removeClass("active");
        labelMiddle.removeClass("active");
        labelSmall.addClass("active");
        break;

      default:
        labelLarge.removeClass("active");
        labelMiddle.addClass("active");
        labelSmall.removeClass("active");
        break;
    }
  },

  _onClearButtonClick : function(item ) {
    if( this._drawManager && this._drawManager.getReserveLength() > 0 ) {

      this._showDrawManagerConfirm( L.bind(this._clearLayer,this, item),

        [{"id":"ok","caption":"確定して続行"},{"id":"destroy","caption":"破棄して続行"},{"id":"cancel","caption":"キャンセル"}]
      );
    } else {
      this._clearLayer( item );
    }
  },

  _clearLayer: function (item) {
    if( this._drawManager ) this._drawManager.cancel();

    if (item.getLayerCount() > 0) {
      if (!confirm(GSI.TEXT.SAKUZU.DIALOG_EDIT_REMOVELAYERCONFIRMMSG)) return;
    }

    item.remove();
  },

  _showDrawManagerConfirm : function(func, buttons) {
    if( this._drawManager && this._drawManager.changed() ) {
      if ( !this._drawManagerConfirm  ) {
        this._drawManagerConfirm = new GSI.SakuzuConfirm();
        this._drawManagerConfirm.on("hide", L.bind(function(func,evt){
          if( evt.button == "ok") {
            this._onReserveOkClick();
          }
          if( evt.button != "cancel") {
            // 終了時のアラート表示 外す
            window._shareDialogFlag = false;
            if (!window._sakuzuDialogFlag) $(window).off('beforeunload');            
            func();
          }
        }, this, func));
      }
      this._drawManagerConfirm.show(
        '確定していない<span class="strong">' + GSI.SakuzuListItem.typeToTitle(this._drawManager.getDrawType()) +
        '</span>が<span class="strong">' + this._drawManager.getReserveLength() + "</span>件あります。",
        buttons
      );
    } else {
      func();
    }
  },

  // 編集開始
  _onEditSakuzuItemClick: function (item, li) {

    if( this._drawManager && this._drawManager instanceof GSI.EditManager && this._drawManager.getSakuzuItem() == item) {
      if ( this._drawManager.getReserveLength() <= 0) {
        this._drawManager.cancel();
      }
      return;
    }

    if (item.getLayerCount() <= 0) return;

    if( this._drawManager && this._drawManager.getReserveLength() > 0 ) {

      this._showDrawManagerConfirm( L.bind(this._execEditStart,this, item),

        [{"id":"ok","caption":"確定して続行"},{"id":"destroy","caption":"破棄して続行"},{"id":"cancel","caption":"キャンセル"}]
      );
    } else {
      this._execEditStart( item );
    }
  },

  _execEditStart : function(item) {

    if ( this._drawManager ) {
      this._drawManager.cancel();
    }
    this._drawManager = new GSI.EditManager( this._dialogManager, item);
    this._drawManager.on("reservechange", L.bind(this._onReserveChange, this));
    this._drawManager.on("start", L.bind(this._onDrawManagerStart, this));
    this._drawManager.on("stop", L.bind(this._onDrawManagerStop, this));
    this._drawManager.start();

  },

  // 作成・ファイル保存読み込み開始
  _toolBtnClick: function (btnId) {
    if( this._drawManager && this._drawManager.getReserveLength() > 0 ) {

      if ( this._drawManager.getDrawType() == btnId ) return;

      this._showDrawManagerConfirm( L.bind(this._execToolButton,this, btnId),

        [{"id":"ok","caption":"確定して続行"},{"id":"destroy","caption":"破棄して続行"},{"id":"cancel","caption":"キャンセル"}]
      );
    } else {
      if ( this._drawManager && this._drawManager.getDrawType() == btnId ) {
        this._drawManager.cancel();
      } else {
        this._execToolButton( btnId );
      }
    }
  },

  _execToolButton : function( btnId) {

    if ( this._drawManager ) {
      this._drawManager.cancel();
    }

    if (btnId == 'file_load') {
      if ( !this._fileLoadWindow ) {
        this._fileLoadWindow = new GSI.SakuzuLoadFileWindow (this._sakuzuList);
      }
      this._fileLoadWindow.show();

    }
    else if (btnId == 'file_save') {

      if ( this._sakuzuList.getSaveTargetLayerCount() <= 0 ) {
        return;
      }
      if ( !this._fileSaveWindow ) {
        this._fileSaveWindow = new GSI.SakuzuSaveFileWindow (this._sakuzuList);
      }
      this._fileSaveWindow.show();
    }
    else {
      this._startCreateDraw( btnId);

    }
  },

  _startCreateDraw : function( id) {
    if ( this._drawManager ) {
      this._drawManager.cancel();
    }
    this._drawManager = new GSI.DrawManager( id,this._dialogManager, this._sakuzuList.getSakuzuItem());
    this._drawManager.on("reservechange", L.bind(this._onReserveChange, this));
    this._drawManager.on("start", L.bind(this._onDrawManagerStart, this));
    this._drawManager.on("stop", L.bind(this._onDrawManagerStop, this));
    this._drawManager.start();
  },

  _onDrawManagerStart : function() {
    this._refreshToolButton();
  },

  _onDrawManagerStop : function() {
    this._refreshToolButton();

    if ( this._reserveInfoPanel ) {
      this._reserveInfoPanel.slideUp(300);
    }
  },

  _onReserveOkClick : function() {
    // 終了時のアラート表示 外す
    window._shareDialogFlag = false;
    if (!window._sakuzuDialogFlag) $(window).off('beforeunload');

    var sakuzuItem = this._drawManager.getSakuzuItem();
    if ( this._drawManager  ) {
      this._drawManager.commit();
    }

    if (sakuzuItem) {
      sakuzuItem.editFinish();
    }
    this._sakuzuList._defaultIcon.url = CONFIG.SAKUZU.SYMBOL.URL + CONFIG.SAKUZU.SYMBOL.DEFAULTICON;
    this._sakuzuList._defaultIcon._iconScale = CONFIG.SAKUZU.SYMBOL.ICON_SCALE;

    this._topPanelToolBar.find("a").removeClass("active");
    this._drawManager.cancel();

    if ( this._reserveInfoPanel ) {
      this._reserveInfoPanel.slideUp(300);
    }
  },

  _onReserveCancelClick : function() {

    // 終了時のアラート表示 外す
    window._shareDialogFlag = false;
    if (!window._sakuzuDialogFlag) $(window).off('beforeunload');

    var sakuzuItem = this._drawManager.getSakuzuItem();

    if (sakuzuItem) {
      sakuzuItem.editCancel();
    }
    this._sakuzuList._defaultIcon.url = CONFIG.SAKUZU.SYMBOL.URL + CONFIG.SAKUZU.SYMBOL.DEFAULTICON;
    this._sakuzuList._defaultIcon._iconScale = CONFIG.SAKUZU.SYMBOL.ICON_SCALE;

    this._drawManager.cancel();
    if ( this._reserveInfoPanel ) {
      this._reserveInfoPanel.slideUp(300);
    }
  },

  _onReserveChange : function(evt) {
    if ( evt.len > 0 ) {
      if ( !this._reserveInfoPanel ) {
        this._reserveInfoPanel = $("<div>").addClass("gsi-reserveinfo-panel").hide();
        this._reserveInfoPanelMessage = $("<div>").addClass("message");
        this._reserveInfoPanel.append( this._reserveInfoPanelMessage );

        var buttonPanel = $("<div>").addClass("button-panel");

        this._reserveOkButton = $("<a>").addClass("normalbutton").attr({"href":"javascript:void(0);"}).html("確定");
        this._reserveCancelButton = $("<a>").addClass("normalbutton").attr({"href":"javascript:void(0);"}).html("取り消し");

        buttonPanel.append( this._reserveOkButton);
        buttonPanel.append( this._reserveCancelButton);

        this._reserveInfoPanel.append( buttonPanel);
        this._topPanelList .append( this._reserveInfoPanel);

        this._reserveOkButton.on("click", L.bind(this._onReserveOkClick,this));
        this._reserveCancelButton.on("click", L.bind(this._onReserveCancelClick,this));
      }

      this._reserveInfoPanelMessage.html(
        '確定していない<span class="strong">' + GSI.SakuzuListItem.typeToTitle(evt.drawType) + '</span>が<span class="strong">' + evt.len + "</span>件あります。"
      );
      this._reserveInfoPanel.slideDown(300);

    } else {
      if ( this._reserveInfoPanel ) {
        // 終了時のアラート表示 外す
        window._shareDialogFlag = false;
        if (!window._sakuzuDialogFlag) $(window).off('beforeunload');
        this._reserveInfoPanel.slideUp(300);
      }
    }
  },

  setTitle: function (title) {
    this._title.html(title);
  },

  hide: function () {

    this._showDrawManagerConfirm( L.bind( this._execHide,this),
      [{"id":"ok","caption":"確定して閉じる"},{"id":"destroy","caption":"破棄して閉じる"},{"id":"cancel","caption":"キャンセル"}]
    );
  },

  _execHide : function() {

    if ( this._fileLoadWindow) {
      this._fileLoadWindow.destroy();
    }

    if ( this._fileSaveWindow) {
      this._fileSaveWindow.destroy();
    }

    if ( this._reserveInfoPanel ) {
      this._reserveInfoPanel.hide();
    }

    if ( this._drawManager ) {

      this._drawManager.cancel();
    }

    this._map.stopAutoPan();
    GSI.Dialog.prototype.hide.call(this);

  },

  show: function () {

    if (this.container && this._dialogManager.isMinimized(this)) {
      this._dialogManager.removeMinimizeList(this);
      this.normalize();
      return;
    }

    this._showTopPanel();

    GSI.Dialog.prototype.show.call(this);
    this._refreshFileButton();

    var liHeight = 0;
    for(var x = 0; x < this._listUL.length; x++){
      liHeight += $(this._listUL[x]).outerHeight();
    }

    if (liHeight > 0 && this._userResized == false){
      //ダイアログが表示されていない時に、変更された時
      var ws = GSI.Utils.getScreenSize();
      var titleHeight = this._title? this._title.outerHeight(): 30;
      var tBarHeight = this._topPanelToolBar? this._topPanelToolBar.outerHeight() : 40;
      //not offset().top, need offsetTop
      var limitHeight = ws.h - 50 - titleHeight - tBarHeight - $(this.container)[0].offsetTop;

      if (liHeight > limitHeight){
        liHeight = limitHeight;
      }
      $(this.container).find(".gsi-sakuzudialog-list-container").css({"height": liHeight});
    }

  },

  _showTopPanel: function (beforePanel) {
    if ( this._createPathMessagePanel ) {
      this._createPathMessagePanel.hide();
    }

    this._createTopPanel();

    if (!this._topPanelHeight)
      this.container.css({ height: 'auto' });
    else {
      this.container.css({ height: this._topPanelHeight + "px" });
    }
    if (beforePanel) {
      beforePanel.fadeOut('normal', L.bind(function () {
        this.setTitle(GSI.TEXT.SAKUZU.DIALOG_TITLE);
        this._topPanel.fadeIn('fast');
        this._refreshTopPanelSize();
      }, this));
    }
    else {
      this.setTitle(GSI.TEXT.SAKUZU.DIALOG_TITLE);
      this._topPanel.show();
    }

    this._sakuzuList.eachItems(L.bind(function (item) {
      item.setIconLabelSize();
    }, this));
  },

  _beforePanelChange: function () {
  },

  _refreshTopPanelSize: function () {
    if (!this._topPanelHeight) return;
    this._topPanelList.css({ "height": (this._topPanelHeight - 33 - this._topPanelToolBar.outerHeight()) + "px" });
  },

  _onResize: function (ui) {
    if (ui.originalSize.height != ui.size.height) {
      var containerHeight = this.container.outerHeight() - 6;
      if (this._topPanel && this._topPanel.is(":visible")) {
        this._topPanelHeight = containerHeight
      }
    }
    this._refreshTopPanelSize();

  }
});

/*******************************************************
 L.Class
 - GSI.Dialog
   - GSI.SakuzuConfirm
*******************************************************/
GSI.SakuzuConfirm = L.Evented.extend({

  initialize: function () {
    this._buttons = [
      {
        "id": "ok",
        "caption": "確定"
      },
      {
        "id": "destroy",
        "caption": "破棄"
      },
      {
        "id": "cancel",
        "caption": "キャンセル"
      }

    ];
  },

  show: function (message, buttons) {

    if (buttons) this._buttons = $.extend(true, [], buttons);
    this._create();
    this._resetButtons();
    this._messageContainer.html(message);
    this._container.fadeIn(200);
  },

  hide: function () {
    if (!this._container) return;
    this._container.fadeOut(200);
  },

  _resetButtons: function () {
    this._buttonContainer.empty();
    for (var i = 0; i < this._buttons.length; i++) {
      var button = this._buttons[i];
      var a = $("<a>").addClass("normalbutton").attr({ "href": "javascript:void(0);" }).html(button["caption"]);
      a.on("click", L.bind(function (button) {
        this.fire("hide", { "button": button["id"] });
        this.hide();
      }, this, button));
      this._buttonContainer.append(a);
    }
  },

  _create: function () {

    this._container = $("<div>")
      .addClass("gsi-topmostwindow-container").addClass("gsi-sakuzuconfirm-container").hide();

    this._frame = $("<div>").addClass("frame");

    this._messageContainer = $("<div>").addClass("message");

    this._buttonContainer = $("<div>").addClass("button-frame");

    this._frame.append(this._messageContainer);
    this._frame.append(this._buttonContainer);
    this._container.append(this._frame);

    $("body").append(this._container);
  }
});

/*******************************************************
 L.Class
 - GSI.Dialog
   - GSI.SakuzuInfoEditDialog
    作図情報入力用ダイアログ
*******************************************************/
GSI.SakuzuInfoEditDialog = GSI.Dialog.extend({

  options: {
    title: "作図情報の入力",
    width: "350px",
    transparentGradate: false,
    minimize: false
  },

  // 初期化
  initialize: function (dialogManager, options) {
    GSI.Dialog.prototype.initialize.call(this, dialogManager, options);

    this.container.css({ "border": "1px solid #333" });
    this.headerFrame
      .addClass("gsi-sakuzuinfoedit-dialog-header");
    this.contentFrame.addClass("gsi-sakuzuinfoedit-dialog-content-contentframe");
    this.headerTitle.css({"padding":"0px"})

    this.options.effect = {
      "animation" : "fade",
      "speed" :200
    };
  },

  setSakuzuItem : function(sakuzuItem) {
    this._sakuzuItem =sakuzuItem;
  },

  setLayer : function(layer) {
    this._layer = layer;
  },

  setInfo : function( info ) {
    this._info = info;
  },

  hasLayer : function() {
    return( this._layer ? true : false );
  },

  setType : function(drawType) {
    this._drawType = drawType;
  },

  _okButtonClick : function() {

    this.commit();

    this.fire("ok", {
      "layer" : this._layer,
      "info" : this._info
    });
  },

  commit : function() {
    if ( !this.hasLayer()) return;
    this._info= this._viewToInfo();
    this._sakuzuItem.setEditingInfo(this._info);

  },

  _onCheckChangeTimer : function() {
    if ( !this.hasLayer()) return;
    this.fire("check", {"changed" : this._sakuzuItem.isEditingChange()})
  },

  isChange : function() {
    if ( !this.hasLayer()) return false;
    this.commit();
    var result = this._sakuzuItem.isEditingChange();
    if ( !result ) result = this._layer._edited;
    return result;
  },

  _cancelButtonClick : function() {
    this.fire("cancel");
  },

  // 表示
  show: function (position) {

    if (!this.container) this.create();

    if ( this._drawType== "") {
      this._drawType = this._sakuzuItem._getType( this._layer );
    }

    this.closeBtn.hide();
    if ( this.frame ) {
      this.frame.empty();
      this._createView();
      this._resetView();
    }

    var visible = this.container.is(":visible");
    if (!visible) this.container.css({ "visibility": "hidden" }).show();

    var size = {
      width:this.container.outerWidth(),
      height:this.container.outerHeight()
    };

    var windowSize = this._dialogManager.getScreenSize();
    if (this._drawType == GSI.SakuzuListItem.POINT ||
        this._drawType == GSI.SakuzuListItem.POINT_TEXT) {
        if ( position.y +size.height > windowSize.h) {
          position.y = position.y - size.height;
        } else {
          position.y += 90;
        }
        position.x = position.x - Math.floor(size.width/2);

    } else {
      position.x = position.x - Math.floor(size.width/3);
      position.y = position.y - size.height;
    }

    if ( position.x + size.width > windowSize.w ) position.x = windowSize.w-size.width;
    if ( position.y + size.height > windowSize.h ) position.y = windowSize.h-size.height;

    if ( position.x < 0 ) position.x =0;
    if ( position.y < 0 ) position.y =0;

    this.container.css({
      "left": position.x+"px",
      "top": position.y+"px"
    });

    if (!visible) this.container.css({ "visibility": "visible" }).hide();

    this._resetTitle();

    if ( !this._checkChangeTimer ) {
      this._checkChangeTimer = setInterval( L.bind( this._onCheckChangeTimer, this ), 200 );
    }
    // 終了時のアラート表示 追加
    window._shareDialogFlag = true;
    $(window).off('beforeunload').on('beforeunload', function(e) { return 'このページから移動しますか？ 入力した情報は保存されません。';});
    GSI.Dialog.prototype.show.call(this);
  },

  _resetTitle : function() {

    var title = "作図情報の入力";
    if ( this._sakuzuItem && this._layer ) {

      var layerType = this._drawType;
      if ( layerType== "")
        layerType = this._sakuzuItem._getType( this._layer );
      title = '<span class="strong">' + GSI.SakuzuListItem.typeToTitle(layerType) + "</span>の情報入力";
    }

    this.setTitle( title );
  },

  afterShow: function () {
  },

  _cloceButtonClick: function () {
    this._cancelButtonClick();
  },

  hide: function () {
    this._clearHandler();
    this._layer = null;
    this._sakuzuItem = null;
    GSI.Dialog.prototype.hide.call(this);

    // カラーピッカーのエレメント掃除
    var colorPickers = $(".color-picker");

    for( var i=0; i<colorPickers.length; i++ ) {
      var elem = $(colorPickers[i]);
      var id = elem.attr("id");
      if ( !id ) continue;
      if ( id.indexOf("GSI_SakuzuDialog_") == 0 ) {
        elem.remove();
      }
    }
  },

  _clearHandler : function() {
    if ( this._checkChangeTimer ) {
      clearTimeout( this._checkChangeTimer );
      this._checkChangeTimer = null;
    }

    if ( this._circleChangeHandler ) {
      if ( this._sakuzuItem ) {
        this._sakuzuItem.off( "circlechange", this._circleChangeHandler );
      }
      this._circleChangeHandler  = null;
    }

    if (this._lineInputCheckTimer) {
      clearTimeout(this._lineInputCheckTimer);
      this._lineInputCheckTimer = null;
    }

    if (this._fillInputCheckTimer) {
      clearTimeout(this._fillInputCheckTimer);
      this._fillInputCheckTimer = null;
    }

    if ( this._pointEditTextareaCheckTimer ) {
      clearTimeout(this._pointEditTextareaCheckTimer);
      this._pointEditTextareaCheckTimer = null;
    }
  },

  create: function () {

    GSI.Dialog.prototype.create.call(this);
  },

  setTitle : function(title) {
    this.options.title = title;
    if ( this.title) {
      this.title.html(this.options.title);
    }
  },

  createHeader: function () {
    this.title = $('<div>').html(this.options.title).addClass("gsi-sakuzuinfoedit-dialog-title");
    return $('<div>').append(this.title);
  },

  createContent: function () {
    this.frame = $('<div>').addClass("gsi-sakuzuinfoedit-dialog-content");
    this._createView();
    this._resetView();
    return this.frame;

  },

  _setLayerStyle : function(style) {

    this._sakuzuItem.setEditingStyle(style);

  },

  // 編集部分生成
  _createView : function() {
    this._container = $("<div>");

    // マーカー編集
    if (this._drawType == GSI.SakuzuListItem.POINT ||
      this._drawType == GSI.SakuzuListItem.POINT_TEXT) {
      this._markerEditPanel = this._createMarkerEditPanel();
      this._container.append( this._markerEditPanel);
    }

    // 円編集
    if ( this._drawType == GSI.SakuzuListItem.POINT_CIRCLE ||
      this._drawType == GSI.SakuzuListItem.CIRCLE ) {
      this._lineEditPanel = this._createLineEditPanel();
      this._container.append( this._lineEditPanel);
      this._polygonEditPanel = this._createPolygonEditPanel();
      this._container.append( this._polygonEditPanel);
      this._circleEditPanel = this._createCircleEditPanel();
      this._container.append( this._circleEditPanel);
    }

    // ライン編集
    if ( this._drawType == GSI.SakuzuListItem.LINESTRING) {
      this._lineEditPanel = this._createLineEditPanel();
      this._container.append( this._lineEditPanel);
    }

    // ポリゴン編集
    if( this._drawType == GSI.SakuzuListItem.POLYGON ||
      this._drawType == GSI.SakuzuListItem.MULTIPOLYGON) {
      this._lineEditPanel = this._createLineEditPanel();
      this._container.append( this._lineEditPanel);
      this._polygonEditPanel = this._createPolygonEditPanel(true);
      this._container.append( this._polygonEditPanel);
    }

    // フリーハンド
    if( this._drawType == GSI.SakuzuListItem.FREEHAND) {
      this._lineEditPanel = this._createLineEditPanel();
      this._container.append( this._lineEditPanel);
    }

    // 情報編集部
    this._infoEditPanel = this._createInfoEditPanel();
    this._container.append( this._infoEditPanel);

    // ok cancel
    this._buttonPanel = this._createButtonPanel();
    this._container.append( this._buttonPanel);

    this.frame.append( this._container );
  },

  // 値リセット
  _resetView : function() {
    // マーカー編集部
    if(this._drawType == GSI.SakuzuListItem.POINT || this._drawType == GSI.SakuzuListItem.POINT_TEXT) {
      this._refreshMarkerEditPanel(this._layer.options);
    }
    // 円編集部
    if ( this._drawType == GSI.SakuzuListItem.POINT_CIRCLE ||
      this._drawType == GSI.SakuzuListItem.CIRCLE ) {
      this._refreshLineEditPanel( this._layer.options);
      this._refreshPolygonEditPanel( this._layer.options);
      this._refreshCircleEditPanel( this._layer.options);
    }
    // ライン編集部
    if ( this._drawType == GSI.SakuzuListItem.LINESTRING ) {
      this._refreshLineEditPanel( this._layer.options);
    }
    // ポリゴン編集部
    if ( this._drawType == GSI.SakuzuListItem.POLYGON ||
      this._drawType == GSI.SakuzuListItem.MULTIPOLYGON) {
      this._refreshLineEditPanel( this._layer.options);
      this._refreshPolygonEditPanel( this._layer.options);
    }
    // フリーハンド
    if( this._drawType == GSI.SakuzuListItem.FREEHAND) {
      this._refreshLineEditPanel( this._layer.options);
    }

    // 情報
    this._refreshInfoEditPanel( this._info );

  },

  _refreshMarkerEditPanel : function( style ) {
    if (!style.icon.options.iconUrl && (style.icon.options.html || style.icon.options.html == '')) {
      var text = style.icon.options.html;

      this._setPointTextMode(true, text);
      this._pointEditMarkerFrame.hide();
      this._pointEditTextFrame.show();
    }
    else {
      this._pointIconImage.attr({ src: style.icon.options.iconUrl });
      this._pointIconSelector.setSelectedIcon(style.icon.options.iconUrl);
      this._pointIconSizeSelect.val(parseFloat(style.icon.options._iconScale).toFixed(1));
      this._pointEditTextFrame.hide();
      this._pointEditMarkerFrame.show();
    }
  },

  // ライン編集部の値リセット
  _refreshLineEditPanel : function(style) {
    // 大圏航路と等角航路
    if ( this._taikenKouroRadio ) {
      if (style.geodesic) {
        this._taikenKouroRadio[0].checked = true;
      } else {
        this._toukakuKouroRadio[0].checked = true;
      }
    }
    this._lineWeightSelect.val(style.weight);
    this._lineColorSelector.css({ background: style.color });//.ColorPickerSetColor(style.color);
    var opacity = style.opacity;
    opacity = Math.round((1 - opacity) * 100);
    this._lineOpacitySlider.slider("value", opacity);

    var dashArrayMode = 'normal';
    if (style.dashArray) {
      try {
        var parts = style.dashArray.split(",");
        if (parts.length >= 2) {
          dashArrayMode = 'dash';
          var val1 = parseInt((parts[0]) ? parts[0].trim() : '');
          var val2 = parseInt((parts[1]) ? parts[1].trim() : '');
          if (style.lineCap && style.lineCap == "butt") {
            if (val1 == val2) dashArrayMode = "dot";
          } else {

            if (val1 / val2 == CONFIG.SAKUZU.LINEDASHARRAY["dot"][0] / (parseInt(style.weight) * CONFIG.SAKUZU.LINEDASHARRAY["dot"][1])) {
              dashArrayMode = "dot";
            }
          }
        }

      } catch (ex) { }
    }
    this._lineTypeSelect.val(dashArrayMode);
  },

  _refreshPolygonEditPanel : function(style) {
    this._fillColorSelector.css({ background: style.fillColor });//.ColorPickerSetColor(style.color);
    var opacity = style.fillOpacity;
    opacity = Math.round((1 - opacity) * 100);
    this._fillOpacitySlider.slider("value", opacity);

  },

  _refreshCircleEditPanel : function( style ) {

    this._circleRadiusUnitSelect.children('option').remove();
    if (this._drawType == GSI.SakuzuListItem.POINT_CIRCLE) {
      this._circleRadiusUnitSelect.append($('<option>').html("px").val("px"));
      this._circleRadiusUnitSelect.val("px");

      this._circleRadiusInput.val(Math.round(style.radius));
    }
    else {
      this._circleRadiusUnitSelect.append($('<option>').html("m").val("m"));
      this._circleRadiusUnitSelect.append($('<option>').html("km").val("km"));

      if (style.radius || style.radius == 0) {
        try {
          if (style.radius > 1000) {
            this._circleRadiusInput.val((style.radius / 1000).toFixed(4));
            this._circleRadiusUnitSelect.val('km');
          }
          else {

            this._circleRadiusInput.val(style.radius.toFixed(1));
            this._circleRadiusUnitSelect.val('m');
          }
        }
        catch (e) { }
      }
      else {
        this._circleRadiusInput.val('');
        this._circleRadiusUnitSelect.val('m');
      }
    }

    if ( !this._circleChangeHandler ) {
      if ( this._sakuzuItem ) {
        this._circleChangeHandler  = L.bind( function(evt) {
          var radius = evt.radius;
          var unit = evt.unit;

          if (this._drawType == GSI.SakuzuListItem.POINT_CIRCLE) {
            if (radius)
              this._circleRadiusInput.val(parseInt(radius, 10));
            else
              this._circleRadiusInput.val("");

          }
          else {
            if (radius)
              this._circleRadiusInput.val(radius);
            else
              this._circleRadiusInput.val("");
            this._circleRadiusUnitSelect.val(unit);
          }
          this._onCircleRadiusChange(true);
        },this);
        this._sakuzuItem.on( "circlechange", this._circleChangeHandler );
      }
    }
  },

  _refreshHeight : function() {
    this.container.css({"height":"auto"})
  },
  // 情報編集部の値リセット
  _refreshInfoEditPanel : function( info ) {
    if (info && info.title)
      this._titleInput.val(info.title);
    else
      this._titleInput.val('');

    if (info && info.description)
      this._infoFreeWordTextarea.val(info.description);
    else
      this._infoFreeWordTextarea.val('');

    this._infoTableTbody.empty();

    if (info && info.description && info.description != '') {
      this._toggleInfoBtn.html(GSI.TEXT.SAKUZU.DIALOG_EDIT_INFOTABLE_BTN);
      this._infoTable.hide();
      this._infoFreeWordTextarea.show();
    }
    else {
      this._toggleInfoBtn.html(GSI.TEXT.SAKUZU.DIALOG_EDIT_INFOFREE_BTN);
      this._infoFreeWordTextarea.hide();
      this._infoTable.show();
    }
    // ヘッダ
    var tr = $('<tr>');
    var td = $('<td>').css({ 'width': '30%', 'white-space': 'nowrap' }).html('項目名');
    tr.append(td);
    td = $('<td>').attr({ "colspan": "3" }).html('値');
    tr.append(td);
    this._infoTableTbody.append(tr);

    if (!info || !info.table || info.table.length <= 0) {
      var tr = this._createEditInfoTableLine(0);
      this._infoTableTbody.append(tr);
      return;
    }

    for (var i = 0; i < info.table.length; i++) {
      var item = info.table[i];

      var tr = this._createEditInfoTableLine(i, item.key, item.value);
      this._infoTableTbody.append(tr);
    }
    this._refreshHeight();
  },

  _createEditInfoTableLine: function (no, key, value) {
    tr = $('<tr>');
    td = $('<td>').css({ 'width': '30%', 'vertical-align': 'middle' });

    var nameTextarea = $('<textarea>').addClass('inputtextarea')
      .attr({ name: 'info_table_key', 'placeholder': '(例:営業時間)', rows: 1 })
      .css({ 'display': 'block', 'width': '100%' }).val(key ? key : '');
    td.append(nameTextarea);
    tr.append(td);
    td = $('<td>');

    var valueTextarea = $('<textarea>').addClass('inputtextarea')
      .css({ 'display': 'block', width: "100%" })
      .attr({ name: 'info_table_value', 'placeholder': '(例:10時～18時)', rows: 1 }).val(value ? value : '');
    td.append(valueTextarea);
    tr.append(td);

    td = $('<td>').css({ width: "24px", "text-align": "center" });

    var btn = $('<a>').attr({ 'href': 'javascript:void(0);' }).addClass("btn")
      .html('<img title="この行を削除" src="image/sakuzu/icon_remove.png">')
      .on('click',L.bind(
        function (tr) {
          var no = 0;
          var trList = this._infoTableTbody.find('tr');
          for (var i = 0; i < trList.length; i++) {
            if (trList[i] == tr[0]) {
              no = i;
              break;
            }
          }
          if (no == 1 && trList.length <= 2) {
            tr.find('textarea').val("");
          }
          else {
            tr.fadeOut('fast', L.bind(function (tr) {
              tr.remove();
              this._refreshHeight();
            }, this, tr ) );
          }
        },
        this, tr));

    td.append(btn);
    tr.append(td);

    td = $('<td>').css({ width: "24px", "text-align": "center" });
    var btn = $('<a>').attr({ 'href': 'javascript:void(0);' }).addClass("btn")
      .html('<img title="この下に行を追加" src="image/sakuzu/icon_enter.png">')
      .on('click',L.bind(
        function (tr) {

          var insertTr = this._createEditInfoTableLine(0, "", "");
          insertTr.hide();
          insertTr.insertAfter(tr);
          insertTr.fadeIn('fast',L.bind(function(){
            this._refreshHeight();
          },this));
          this._refreshHeight();
        },
        this, tr));
    td.append(btn);
    tr.append(td);

    return tr;
  },

  _infoTableToFreeWordText: function () {
    var keyList = this._infoTableTbody.find("textarea[name=info_table_key]");
    var valueList = this._infoTableTbody.find("textarea[name=info_table_value]");

    var trHtml = '';
    for (var i = 0; i < keyList.length; i++) {
      var key = $(keyList[i]).val();
      var value = $(valueList[i]).val();

      if (key != '') {
        trHtml += '<tr><td>' + GSI.Utils.encodeHTML(key).replace(/\n/g, "<br>") + '</td><td>' + GSI.Utils.encodeHTML(value).replace(/\n/g, "<br>") + '</td></tr>' + '\n';
      }
    }

    if (trHtml != '') {
      return '<table>\n' + trHtml + '</table>';
    }
    else {
      return '';
    }
  },

  // ライン編集部分生成
  _createLineEditPanel  : function() {
    var frame = $('<div>').addClass('lineedit-panel');

    // 大圏航路と等角航路の選択

    if ( this._drawType != GSI.SakuzuListItem.POINT_CIRCLE &&
          this._drawType != GSI.SakuzuListItem.CIRCLE ) {
      var geodesicFrame = $("<div>");

      var name = "gsi-kouro-radio" + GSI.Utils.getCurrentID();
      var id = 'gsi-kouro-radio-taiken' + GSI.Utils.getCurrentID();
      this._taikenKouroRadio = $("<input>").attr(
        {
          "name": name,
          "id": id,
          "type": "radio"
        }
      ).addClass('normalcheck').on("click", L.bind(function(){
        this._setLayerStyle({ geodesic: this._taikenKouroRadio.is(":checked") });
      }, this));
      var taikenkouroLabel = $("<label>").attr({ "for": id }).html("大圏航路");

      var id = 'gsi-kouro-radio-toukaku' + GSI.Utils.getCurrentID();
      this._toukakuKouroRadio = $("<input>").attr(
        {
          "name": name,
          "id": id,
          "type": "radio"
        }
      ).addClass('normalcheck').on("click", L.bind(function(){
        this._setLayerStyle({ geodesic: this._taikenKouroRadio.is(":checked") });
      }, this));
      var toukakukouroLabel = $("<label>").attr({ "for": id}).html("等角航路");

      if( CONFIG.TOOLTIP && CONFIG.TOOLTIP.SAKUZU) {
        this._taikenKouroRadio.attr({"title":CONFIG.TOOLTIP.SAKUZU.LINE_GEODESIC});
        this._toukakuKouroRadio.attr({"title":CONFIG.TOOLTIP.SAKUZU.LINE_STRAIGHT});
        taikenkouroLabel.attr({"title":CONFIG.TOOLTIP.SAKUZU.LINE_GEODESIC});
        toukakukouroLabel.attr({"title":CONFIG.TOOLTIP.SAKUZU.LINE_STRAIGHT});
      }

      geodesicFrame.append(this._taikenKouroRadio).append(taikenkouroLabel);
      geodesicFrame.append(this._toukakuKouroRadio).append(toukakukouroLabel);

      frame.append(geodesicFrame);
    }

    var editFrame = $('<div>').css({ 'vertical-align': 'middle' });
    var table = $('<table>');
    var tbody = $('<tbody>');
    var tr = $('<tr>');

    var lineStyleChange = function () {

      var lineType = this._lineTypeSelect.val();
      var lineWeight = parseInt(this._lineWeightSelect.val());
      var dashArray = "";
      switch (lineType) {
        case "dash":
          dashArray = (lineWeight * CONFIG.SAKUZU.LINEDASHARRAY["dash"][0]) + "," + (lineWeight * CONFIG.SAKUZU.LINEDASHARRAY["dash"][1]);
          break;
        case "dot":
          dashArray = CONFIG.SAKUZU.LINEDASHARRAY["dot"][0] + "," + (lineWeight * CONFIG.SAKUZU.LINEDASHARRAY["dot"][1]);
          break;
      }

      this._setLayerStyle({ weight: lineWeight, dashArray: dashArray });
    };
    // 線幅
    tr.append($('<td>').css({ "white-space": "nowrap" }).html('線幅:'));

    this._lineWeightSelect = $('<select>');
    this._lineWeightSelect.append($('<option>').html("1px").val("1"));
    this._lineWeightSelect.append($('<option>').html("3px").val("3"));
    this._lineWeightSelect.append($('<option>').html("5px").val("5"));
    this._lineWeightSelect.append($('<option>').html("10px").val("10"));
    this._lineWeightSelect.append($('<option>').html("15px").val("15"));
    this._lineWeightSelect.append($('<option>').html("25px").val("25"));
    this._lineWeightSelect.on('change',L.bind(lineStyleChange, this));

    tr.append($('<td>').append(this._lineWeightSelect));

    // 線色
    tr.append($('<td>').css({ "white-space": "nowrap" }).html('&nbsp;&nbsp;線色:'));

    var id = 'GSI_SakuzuDialog_lineColor_' + GSI.Utils.getCurrentID();

    this._lineColorSelector = $('<div>').attr({ id: id }).css({ "background": '#000' }).html('　　').addClass('color_select');
    this._lineColorSelector.simpleColorPicker({
      showEffect: 'slide',
      hideEffect: 'slide',
      onChangeColor: L.bind(function (color) {
        this._lineColorSelector.css({ 'background': color });
        this._setLayerStyle({ color: color });
      }, this)
    });

    tr.append($('<td>').append(this._lineColorSelector));

    // 線種
    tr.append($('<td>').css({ "white-space": "nowrap" }).html('&nbsp;&nbsp;線種:'));

    this._lineTypeSelect = $('<select>');
    this._lineTypeSelect.append($('<option>').html("実線").val("normal"));
    this._lineTypeSelect.append($('<option>').html("破線").val("dash"));
    this._lineTypeSelect.append($('<option>').html("点線").val("dot"));
    this._lineTypeSelect.on('change',L.bind(lineStyleChange, this));

    tr.append($('<td>').append(this._lineTypeSelect));

    tbody.append(tr);
    table.append(tbody);
    editFrame.append(table);

    // 透明度
    var table2 = $('<table>').css({"width":"100%"});
    var tbody2 = $('<tbody>');
    var tr2 = $('<tr>');

    this._lineOpacityTextArea = $('<div>').css({ "white-space": "nowrap" });
    this._lineOpacityTextArea.text('線の透過率:');
    this._lineOpacityInput = $("<input>").attr({ "type": "text" }).css({"margin-left":"4px"}).addClass("line-opacity");

    this._lineOpacityTextArea.append(this._lineOpacityInput).append($("<span>").html("%"));
    tr2.append(
      $('<td>').css({ 'width': '120px' }).append(this._lineOpacityTextArea)
    );

    var td2 = $('<td>').css({ "padding": "4px 4px 4px 12px" });

    var sliderChangeHandler = L.bind(function (opacitySlider) {
      opacity = this._lineOpacitySlider.slider('value');
      var opacityPercentage = opacity;
      this._lineOpacityInput.val(opacityPercentage);
      opacity = 1 - (opacity / 100);
      this._setLayerStyle({ opacity: opacity });
    }, this);

    this._lineOpacitySlider = $('<div>').slider(
      {
        range: "min", min: 0, max: 100, value: 0,
        "slide": sliderChangeHandler,
        "change": sliderChangeHandler,
        "stop": sliderChangeHandler
      }
    );

    this._lineOpacityInput.on("focus", L.bind(function (sliderChangeHandler) {
      this._lineOpacityInput.trigger('select');
      if (this._lineInputCheckTimer) {
        clearTimeout(this._lineInputCheckTimer);
        this._lineInputCheckTimer = null;
      }
      this._lineInputCheckTimer = setInterval(L.bind(function (sliderChangeHandler) {
        var opacityText = this._lineOpacityInput.val();
        opacityText = (opacityText) ? opacityText.trim() : '';
        var reg = new RegExp(/^[0-9]*$/);
        if (reg.test(opacityText)) {
          var opacity = parseInt(opacityText);
          if (opacity >= 0 && opacity <= 100) {
            this._lineOpacitySlider.slider('value', opacity);
            sliderChangeHandler();
          }
        }
      }, this, sliderChangeHandler), 50);

    }, this, sliderChangeHandler));

    this._lineOpacityInput.on("blur", L.bind(function (sliderChangeHandler) {

      if (this._lineInputCheckTimer) {
        clearTimeout(this._lineInputCheckTimer);
        this._lineInputCheckTimer = null;
      }

      var opacityText = this._lineOpacityInput.val();
      opacityText = (opacityText) ? opacityText.trim() : '';
      var valid = false;
      var reg = new RegExp(/^[0-9]*$/);
      if (reg.test(opacityText)) {
        var opacity = parseInt(opacityText);
        if (opacity >= 0 && opacity <= 100) {
          this._lineOpacitySlider.slider('value', opacity);
          sliderChangeHandler();
          valid = true;
        }
      }
      if (!valid) {
        this._lineOpacityInput.val(this._lineOpacitySlider.slider('value'));
      }
    }, this, sliderChangeHandler));

    td2.append(this._lineOpacitySlider);
    tr2.append(td2);

    tbody2.append(tr2);
    table2.append(tbody2);

    editFrame.append(table2);

    frame.append(editFrame);

    return frame;
  },

  // ポリゴン編集部分生成
  _createPolygonEditPanel : function(useInner) {
    var frame = $('<div>').addClass('polygon-panel');
    var editFrame = $('<div>').css({ 'vertical-align': 'middle' });
    var table = $('<table>');
    var tr = $('<tr>');
    var id = 'GSI_SakuzuDialog_fillColor_' + GSI.Utils.getCurrentID();

    tr.append($('<td>').css({ "white-space": "nowrap" }).html('塗潰し色:'));
    this._fillColorSelector = $('<div>').attr({ id: id }).css({ "background": '#000' }).html('　　').addClass('color_select');
    this._fillColorSelector.simpleColorPicker({
      showEffect: 'slide',
      hideEffect: 'slide',
      onChangeColor: L.bind(function (color) {
        this._fillColorSelector.css({ 'background': color });
        this._setLayerStyle({ fillColor: color });
      }, this)
    });
    tr.append($('<td>').append(this._fillColorSelector));

    table.append(tr);
    editFrame.append(table);

    // 透明度
    var table2 = $('<table>').css({"width":"100%"});
    var tbody2 = $('<tbody>');
    var tr2 = $('<tr>');

    this._fillOpacityTextArea = $('<div>').css({ "white-space": "nowrap" });
    this._fillOpacityTextArea.text('塗潰しの透過率:');

    this._fillOpacityInput = $("<input>").attr({ "type": "text" }).addClass("fill-opacity").css({"margin-left":"4px"});

    this._fillOpacityTextArea.append(this._fillOpacityInput).append($("<span>").html("%"));

    tr2.append($('<td>').css({ 'width': '120px' }).append(this._fillOpacityTextArea));

    var td2 = $('<td>').css({ "padding": "4px 0 4px 8px" });

    var sliderChangeHandler = L.bind(function (opacitySlider) {
      opacity = this._fillOpacitySlider.slider('value');
      var opacityPercentage = opacity;
      this._fillOpacityInput.val(opacityPercentage);
      opacity = 1 - (opacity / 100);
      this._setLayerStyle({ fillOpacity: opacity });
    }, this);

    this._fillOpacitySlider = $('<div>').slider(
      {
        range: "min", min: 0, max: 100, value: 0,
        "slide": sliderChangeHandler,
        "change": sliderChangeHandler,
        "stop": sliderChangeHandler
      }
    );

    this._fillOpacityInput.on("focus", L.bind(function (sliderChangeHandler) {
      this._fillOpacityInput.trigger('select');
      if (this._fillInputCheckTimer) {
        clearTimeout(this._fillInputCheckTimer);
        this._fillInputCheckTimer = null;
      }
      this._fillInputCheckTimer = setInterval(L.bind(function (sliderChangeHandler) {
        var opacityText = this._fillOpacityInput.val();
        opacityText = (opacityText) ? opacityText.trim() : '';
        var reg = new RegExp(/^[0-9]*$/);
        if (reg.test(opacityText)) {
          var opacity = parseInt(opacityText);
          if (opacity >= 0 && opacity <= 100) {
            this._fillOpacitySlider.slider('value', opacity);
            sliderChangeHandler();
          }
        }
      }, this, sliderChangeHandler), 50);

    }, this, sliderChangeHandler));

    this._fillOpacityInput.on("blur", L.bind(function (sliderChangeHandler) {

      if (this._fillInputCheckTimer) {
        clearTimeout(this._fillInputCheckTimer);
        this._fillInputCheckTimer = null;
      }

      var opacityText = this._fillOpacityInput.val();
      opacityText = (opacityText) ? opacityText.trim() : '';
      var valid = false;
      var reg = new RegExp(/^[0-9]*$/);
      if (reg.test(opacityText)) {
        var opacity = parseInt(opacityText);
        if (opacity >= 0 && opacity <= 100) {
          this._fillOpacitySlider.slider('value', opacity);
          sliderChangeHandler();
          valid = true;
        }
      }
      if (!valid) {
        this._fillOpacityInput.val(this._fillOpacitySlider.slider('value'));
      }
    }, this, sliderChangeHandler));

    td2.append(this._fillOpacitySlider);
    tr2.append(td2);

    tbody2.append(tr2);
    table2.append(tbody2);

    editFrame.append(table2);

    //　ポリゴン中抜きモードボタン
    if ( useInner ) {
      this._polyInnerModeBtn = $('<a>').attr({ 'href': 'javascript:void(0);' })
        .html(GSI.TEXT.SAKUZU.DIALOG_EDIT_POLYINNERBTN)
        .addClass('plyinnerbtn').on('click',L.bind(this._onPolyInnerClick, this));

      editFrame.append(this._polyInnerModeBtn);
    }

    frame.append(editFrame);

    return frame;
  },

  _onPolyInnerClick : function() {
    if (!this._polyInnerFrame) {
      this._polyInnerFrame = $("<div>").addClass("gsi_sakuzu_dialog_edit_polyinner");

      var frame = $("<div>").addClass("gsi_sakuzu_dialog_edit_polyinner_inner");
      var msg = $("<div>").addClass("gsi_sakuzu_dialog_edit_polyinner_message")
        .html(GSI.TEXT.SAKUZU.DIALOG_EDIT_POLYINNER_MSG);
      frame.append(msg);

      var btnFrame = $("<div>").addClass("gsi_sakuzu_dialog_edit_polyinner_btnframe");

      this._polyInnerOkBtn = $("<a>").attr({ 'href': 'javascript:void(0);' })
        .html(GSI.TEXT.SAKUZU.DIALOG_EDIT_POLYINNER_OKBTN)
        .addClass('normalbutton').on('click',L.bind(this._onPolyInnerOkClick, this));

      btnFrame.append(this._polyInnerOkBtn);

      frame.append(btnFrame);

      this._polyInnerFrame.append(frame);

      this._container.append(this._polyInnerFrame);
    }

    this._polyInnerFrame.show();
    this._sakuzuItem.startPolygonInner();
  },

  _onPolyInnerOkClick : function() {

    this._sakuzuItem.commitPolygonInner();
    this._polyInnerFrame.hide();
  },

  // 円編集部分生成
  _createCircleEditPanel: function () {
    var frame = $('<div>');
    var table = $('<table>');
    var tbody = $('<tbody>');
    var tr = $('<tr>');
    var td = null;

    td = $('<td>').html('半径:').css({ "white-space": "nowrap" });
    tr.append(td);

    td = $('<td>');
    this._circleRadiusInput = $('<input>').attr({ 'type': 'text' }).addClass('circle_input');
    this._circleRadiusChangeHandler = L.bind(function(skipRefresh){
      var radius = this._circleRadiusInput.val();

      if (radius.match(/^[0-9]+\.[0-9]+$/) || radius.match(/^[0-9]+$/)) {
        radius = parseFloat(radius);
        if (this._circleRadiusUnitSelect.val() == 'km') {
          radius *= 1000;
        }

        radius = radius.toFixed(1);
        if (skipRefresh != true)
          this._setLayerStyle({ radius: parseFloat(radius) });
      }
    }, this);
    this._circleRadiusInput.on("keyup", this._circleRadiusChangeHandler);
    this._circleRadiusInput.on("blur", this._circleRadiusChangeHandler);

    td.append(this._circleRadiusInput);
    tr.append(td);

    td = $('<td>');
    this._circleRadiusUnitSelect = $('<select>');
    this._circleRadiusUnitSelect.append($('<option>').html("px").val("px"));
    this._circleRadiusUnitSelect.append($('<option>').html("m").val("m"));
    this._circleRadiusUnitSelect.append($('<option>').html("km").val("km"));

    this._circleRadiusUnitChangeHandler = L.bind(function () {
      var radius = this._circleRadiusInput.val();
      if (this._circleRadiusUnitSelect.val() == 'km') {
        radius /= 1000;
        radius = radius.toFixed(4);
      }
      else {
        radius *= 1000;
        radius = radius.toFixed(1);
      }

      this._circleRadiusInput.val(radius);
      radius = parseFloat(radius);
      this._circleRadiusInput.val(radius);
    }, this);
    this._circleRadiusUnitSelect.on("change", this._circleRadiusUnitChangeHandler);

    td.append(this._circleRadiusUnitSelect);
    tr.append(td);

    tbody.append(tr);
    table.append(tbody);
    frame.append(table);

    return frame;
  },

  // マーカー編集部分生成
  _createMarkerEditPanel : function () {
    var frame = $('<div>').addClass('gsi_sakuzu_dialog_pointedit');

    this._pointEditMarkerFrame = $('<div>');

    var table = $('<table>');
    var tbody = $('<tbody>');

    this._pointIconImage = $('<img>');

    var tr = $('<tr>');
    tr.append($('<td>').css({ 'white-space': 'nowrap' }).html('アイコン:'));
    tr.append($('<td>').append(this._pointIconImage));
    tr.append($('<td>').css({ 'white-space': 'nowrap' }).html('&nbsp;&nbsp;拡大率:'));

    this._pointIconSizeSelect = $('<select>');
    this._pointIconSizeSelect.append($('<option>').html("0.5").val("0.5"));
    this._pointIconSizeSelect.append($('<option>').html("1.0").val("1.0"));
    this._pointIconSizeSelect.append($('<option>').html("1.5").val("1.5"));
    this._pointIconSizeSelect.append($('<option>').html("2.0").val("2.0"));

    this._pointIconSizeSelect[0].selectedIndex = 1;
    this._pointIconSizeSelect.on('change', L.bind(function () {
      var selectedIcon = this._pointIconSelector.selectedIcon;
      CONFIG.SAKUZU.SYMBOL.ICON_SCALE = parseFloat(this._pointIconSizeSelect.val());
      this._refreshEditingIcon(selectedIcon);
    }, this));

    tr.append($('<td>').append(this._pointIconSizeSelect));

    tbody.append(tr);
    table.append(tbody);

    this._pointEditMarkerFrame.append(table);
    frame.append(this._pointEditMarkerFrame);

    this._pointEditTextFrame = $('<div>').css({ position: "relative" });
    var messageFrame = $("<div>").addClass("gsi_sakuzu_dialog_pointedit_textmessage_frame").css({ position: "relative" });
    messageFrame.append($('<div>').addClass("gsi_sakuzu_dialog_pointedit_textmessage")
      .html(GSI.TEXT.SAKUZU.DIALOG_EDIT_POINTTEXT_MSG));
    this._pointEditTextModeButton = $("<a>").addClass("gsi_sakuzu_dialog_pointedit_textmode_btn").attr({ href: "javascript:void(0);" }).html("HTML入力に切り替え");
    messageFrame.append(this._pointEditTextModeButton);

    this._pointEditTextFrame.append(messageFrame);

    this._pointEditTextModeButton.on('click',L.bind(function () {
      if (this._pointEditTextArea.val() != "" && !this._pointEditTextArea.hasClass("textmode")) {
        if (!confirm('スタイル等の情報が失われる可能性があります。よろしいですか？')) return;
      }
      this._setPointTextMode(!this._pointEditTextArea.hasClass("textmode"), this._pointEditTextArea.val());
    }, this));

    this._pointEditTextArea = $('<textarea>')
      .attr({ 'placeholder': GSI.TEXT.SAKUZU.DIALOG_EDIT_POINTTEXT_HINT })
      .addClass('gsi_sakuzu_dialog_pointedit_textarea').addClass('textmode');
    this._pointEditTextFrame.append(this._pointEditTextArea);
    frame.append(this._pointEditTextFrame);

    this._pointEditTextArea
      .on('focus', L.bind(function () {
        if (!this._pointEditTextareaCheckTimer) {
          this._pointEditTextareaCheckTimer = setInterval(
            L.bind(function () {
              this._onPointIconHTMLChange();
            }, this)
            , 100);
        }
      }, this))
      .on('blur', L.bind(function () {
        if (this._pointEditTextareaCheckTimer) {
          clearTimeout( this._pointEditTextareaCheckTimer );
          this._pointEditTextareaCheckTimer = null;
        }
        this._onPointIconHTMLChange();
      }, this));

    this._pointEditTextStyleFrame = $('<div>').addClass('gsi_sakuzu_dialog_pointedit_text_style_frame');

    // font-size
    this._pointEditTextFontSizeSelect = $('<select>').addClass('font_size_select');
    this._pointEditTextStyleFrame.append(this._pointEditTextFontSizeSelect);

    this._pointEditTextFontSizeSelect
      .append($('<option>')
        .html("文字サイズ")
        .val(""));

    for (var i = 0; i < CONFIG.SAKUZU.FONTSIZELIST.length; i++) {
      this._pointEditTextFontSizeSelect
        .append($('<option>')
          .html(CONFIG.SAKUZU.FONTSIZELIST[i])
          .val(CONFIG.SAKUZU.FONTSIZELIST[i]));
    }

    this._pointEditTextFontSizeSelect
      .on('change', L.bind(function () {
        this._onPointIconHTMLChange();
      }, this));

    // bold
    this._pointEditTextFontBoldButton = $('<a>').addClass('font_bold_btn').attr({ href: "javascript:void(0);" }).html("");
    this._pointEditTextStyleFrame.append(this._pointEditTextFontBoldButton);
    this._pointEditTextFontBoldButton
      .on('click', L.bind(function () {
        this._pointEditTextFontBoldButton.data({ '_bold': this._pointEditTextFontBoldButton.data('_bold') ? false : true });
        if (this._pointEditTextFontBoldButton.data('_bold'))
          this._pointEditTextFontBoldButton.addClass('enabled');
        else
          this._pointEditTextFontBoldButton.removeClass('enabled');
        this._onPointIconHTMLChange();
      }, this));

    // italic
    this._pointEditTextFontItalicButton = $('<a>').addClass('font_italic_btn').attr({ href: "javascript:void(0);" }).html("");
    this._pointEditTextStyleFrame.append(this._pointEditTextFontItalicButton);
    this._pointEditTextFontItalicButton
      .on('click', L.bind(function () {
        this._pointEditTextFontItalicButton.data({ '_italic': this._pointEditTextFontItalicButton.data('_italic') ? false : true });

        if (this._pointEditTextFontItalicButton.data('_italic'))
          this._pointEditTextFontItalicButton.addClass('enabled');
        else
          this._pointEditTextFontItalicButton.removeClass('enabled');
        this._onPointIconHTMLChange();
      }, this));

    // underline
    this._pointEditTextFontUnderlineButton = $('<a>').addClass('font_underline_btn').attr({ href: "javascript:void(0);" }).html("");
    this._pointEditTextStyleFrame.append(this._pointEditTextFontUnderlineButton);
    this._pointEditTextFontUnderlineButton
      .on('click', L.bind(function () {
        this._pointEditTextFontUnderlineButton.data({ '_underline': this._pointEditTextFontUnderlineButton.data('_underline') ? false : true });
        if (this._pointEditTextFontUnderlineButton.data('_underline'))
          this._pointEditTextFontUnderlineButton.addClass('enabled');
        else
          this._pointEditTextFontUnderlineButton.removeClass('enabled');

        this._onPointIconHTMLChange();
      }, this));

    // color
    var id = 'GSI_SakuzuDialog_lineColor_' + GSI.Utils.getCurrentID();
    this._pointEditTextFontColorButton = $('<a>').addClass('color_btn').attr({ id: id, href: "javascript:void(0);" }).html("");
    this._pointEditTextStyleFrame.append(this._pointEditTextFontColorButton);
    this._pointEditTextFontColorButton.simpleColorPicker({
      showEffect: 'slide',
      hideEffect: 'slide',
      clearButton: true,
      onChangeColor: L.bind(function (color) {
        if (color && color != '') {
          this._pointEditTextFontColorButton.find("div").css({ "background-color": color });
          this._pointEditTextFontColorButton.addClass('enabled');
        }
        else {
          this._pointEditTextFontColorButton.find("div").css({ "background-color": "" });
          this._pointEditTextFontColorButton.removeClass('enabled');
        }
        this._pointEditTextFontColorButton.data({ '_color': color });
        this._onPointIconHTMLChange();
      }, this)
    });

    this._pointEditTextFontColorButton.append($("<div>"));

    // background-color
    id = 'GSI_SakuzuDialog_lineColor_' + GSI.Utils.getCurrentID();
    this._pointEditTextFontBGColorButton = $('<a>').addClass('background_color_btn').attr({ id: id, href: "javascript:void(0);" }).html("");
    this._pointEditTextStyleFrame.append(this._pointEditTextFontBGColorButton);

    this._pointEditTextFrame.append(this._pointEditTextStyleFrame);
    this._pointEditTextFontBGColorButton.simpleColorPicker({
      showEffect: 'slide',
      hideEffect: 'slide',
      clearButton: true,
      onChangeColor: L.bind(function (color) {
        if (color && color != '') {
          this._pointEditTextFontBGColorButton.find("div").css({ "background-color": color });
          this._pointEditTextFontBGColorButton.addClass('enabled');
        }
        else {
          this._pointEditTextFontBGColorButton.find("div").css({ "background-color": "" });
          this._pointEditTextFontBGColorButton.removeClass('enabled');
        }
        this._pointEditTextFontBGColorButton.data({ '_bgcolor': color });
        this._onPointIconHTMLChange();
      }, this)
    });
    this._pointEditTextFontBGColorButton.append($("<div>"));

    var iconList = [];

    for (var i = 0; i < CONFIG.SAKUZU.SYMBOL.FILES.length; i++) {
      iconList.push({
        url: CONFIG.SAKUZU.SYMBOL.URL + CONFIG.SAKUZU.SYMBOL.FILES[i],
        size: CONFIG.SAKUZU.SYMBOL.ICONSIZE,
        anchor: CONFIG.SAKUZU.SYMBOL.ICONANCHOR
      });
    }

    this._pointIconSelector = new GSI.IconSelector(this._pointIconImage, iconList);
    this._pointIconSelector.on('select', L.bind(function (event) {
      this._refreshEditingIcon(event.selectedIcon);
    }, this));
    this._setPointTextMode(true);

    return frame;
  },

  _refreshEditingIcon: function (selectedIcon) {
    var iconScale = parseFloat(this._pointIconSizeSelect.val());
    var iconSize = null;
    var iconAnchor = null;

    if (selectedIcon) {
      iconSize = [
        Math.floor(selectedIcon.size[0] * iconScale),
        Math.floor(selectedIcon.size[1] * iconScale)
      ];
      iconAnchor = [
        Math.floor(selectedIcon.anchor[0] * iconScale),
        Math.floor(selectedIcon.anchor[1] * iconScale)
      ];
    }

    var iconInfo = {
      iconUrl: (selectedIcon ? selectedIcon.url : null),
      iconSize: iconSize,
      iconAnchor: iconAnchor,
      _iconScale: iconScale
    };
    this._setLayerStyle({ _iconInfo: iconInfo });
  },
  _refreshEditingIconHTML: function (html) {
    this._setLayerStyle({ _iconInfo: { html: html } });
  },

  _setPointTextMode: function (textMode, text) {
    if (textMode) {

      this._pointEditTextFrame.find("div.gsi_sakuzu_dialog_pointedit_textmessage")
        .html(GSI.TEXT.SAKUZU.DIALOG_EDIT_POINTTEXT_TEXTMODE_MSG);
      this._pointEditTextArea.attr({ 'placeholder': GSI.TEXT.SAKUZU.DIALOG_EDIT_POINTTEXT_TEXTMODE_HINT });
      var fontFamily = "";
      var fontSize = "";
      var bold = false;
      var italic = false;
      var underline = false;
      var color = "";
      var bordering = "";
      var backgroundColor = "";
      if (!text || text == "") {

        this._pointEditTextArea.data({ "start_text": "", "html_text": "" });
        this._pointEditTextArea.val("");
      }
      else {
        var a = $("<div>").html(text);
        var children = a.children();
        if (children.length > 0) {
          if (children[0].style && children[0].style.fontSize) {
            fontSize = parseFloat(children[0].style.fontSize);
          }
          else {
            fontSize = parseFloat($(children[0]).css("font-size"));
          }
          var fontWeight = $(children[0]).css("font-weight");
          if (fontWeight && fontWeight != 'normal')
            bold = true;

          var fontStyle = $(children[0]).css("font-style");
          if (fontStyle && fontStyle == 'italic')
            italic = true;

          var fontUnderline = $(children[0]).css("text-decoration");
          if (fontUnderline && fontUnderline == 'underline')
            underline = true;
          color = $(children[0]).css("color");
          backgroundColor = $(children[0]).css("background-color");
          if (color == "transparent") color = "";
          if (backgroundColor == "transparent") backgroundColor = "";
          //text-shadow
          bordering = "";
          this._pointEditTextArea.val(a.html(a.html().replace(/<br>/ig, "\n")).text());
        }
        else {
          this._pointEditTextArea.val(text);
        }
      }

      this._pointEditTextFontSizeSelect.val(fontSize);
      this._pointEditTextFontBoldButton.data({ "_bold": bold })[(bold ? "add" : "remove") + "Class"]('enabled');
      this._pointEditTextFontItalicButton.data({ "_italic": italic })[(italic ? "add" : "remove") + "Class"]('enabled');
      this._pointEditTextFontUnderlineButton.data({ "_underline": underline })[(underline ? "add" : "remove") + "Class"]('enabled');
      this._pointEditTextFontColorButton.data({ "_color": color })[(color && color != '' ? "add" : "remove") + "Class"]('enabled');
      this._pointEditTextFontColorButton.find("div").css({ "background-color": color && color != '' ? color : "" });
      this._pointEditTextFontBGColorButton.data({ "_bgcolor": backgroundColor })[(backgroundColor && backgroundColor != '' ? "add" : "remove") + "Class"]('enabled');
      this._pointEditTextFontBGColorButton.find("div").css({ "background-color": backgroundColor && backgroundColor != '' ? backgroundColor : "" });

      this._pointEditTextArea.data({ "start_text": this._pointEditTextToHTML(this._pointEditTextArea.val()), "html_text": text });

      this._pointEditTextModeButton.html('HTML入力に切替');
      this._pointEditTextArea.addClass("textmode");
      this._pointEditTextStyleFrame.show();
    }
    else {
      if (this._pointEditTextArea.data("start_text") == this._pointEditTextToHTML(text)) {
        text = this._pointEditTextArea.data("html_text")
      }
      else {
        text = this._pointEditTextToHTML(text);

      }
      this._pointEditTextArea.data({ "start_text": "", "html_text": "" });

      this._pointEditTextFrame.find("div.gsi_sakuzu_dialog_pointedit_textmessage")
        .html(GSI.TEXT.SAKUZU.DIALOG_EDIT_POINTTEXT_MSG);

      this._pointEditTextArea.attr({ 'placeholder': GSI.TEXT.SAKUZU.DIALOG_EDIT_POINTTEXT_HINT });
      if (!text)
        this._pointEditTextArea.val("");
      else
        this._pointEditTextArea.val(text);
      this._pointEditTextModeButton.html('テキスト入力に切替');
      this._pointEditTextArea.removeClass("textmode");
      this._pointEditTextStyleFrame.hide();

    }
  },

  _onPointIconHTMLChange: function () {
    if (this._pointEditTextArea.hasClass("textmode")) {
      var text = this._pointEditTextToHTML(this._pointEditTextArea.val());

      if (this._pointEditTextArea.data("start_text") == text) {
        this._refreshEditingIconHTML(this._pointEditTextArea.data("html_text"));
      }
      else
        this._refreshEditingIconHTML(text);
    }
    else {
      this._refreshEditingIconHTML(this._pointEditTextArea.val());
    }
  },
  _pointEditTextToHTML: function (text) {

    // テキストモード
    var fontSize = this._pointEditTextFontSizeSelect.val();
    var style = '';
    if (fontSize && fontSize != ''){
      style += "font-size:" + fontSize + 'pt;'
    }
    else{
      //See css defnition of 'gsi-div-icon'.
      if (text.indexOf("font-size") < 0){
        style += "font-size:9.5pt;";
      }
    }

    if (this._pointEditTextFontBoldButton.data('_bold'))
      style += "font-weight:bold;";
    if (this._pointEditTextFontItalicButton.data('_italic'))
      style += "font-style:italic;";
    if (this._pointEditTextFontUnderlineButton.data('_underline'))
      style += "text-decoration:underline;";
    if (this._pointEditTextFontColorButton.data('_color') && this._pointEditTextFontColorButton.data('_color') != '')
      style += "color:" + this._pointEditTextFontColorButton.data('_color') + ";";
    if (this._pointEditTextFontBGColorButton.data('_bgcolor') && this._pointEditTextFontBGColorButton.data('_bgcolor') != '')
      style += "background-color:" + this._pointEditTextFontBGColorButton.data('_bgcolor') + ";";

    if (style != '')
      text = '<div style="' + style + '">' + text.replace(/\n/g, '<br>') + '</div>';
    else
      text = text.replace(/\n/g, '<br>');

    return text;
  },

  // 情報編集パネル
  _createInfoEditPanel: function () {
    var frame = $('<div>').addClass('infoedit-panel');
    var table = $('<table>').css({ width: '100%' });
    var tbody = $('<tbody>');
    var tr = $('<tr>');

    tr.append($('<td>').css({ 'white-space': 'nowrap' }).html('名称:'));
    var td = $('<td>');

    this._titleInput = $('<input>').addClass('inputtext').attr({ 'type': 'text', 'placeholder': '(例:A図書館)' }).css({ width: '200px' });
    td.append(this._titleInput);
    tr.append(td);

    tbody.append(tr);
    table.append(tbody);
    frame.append(table);

    // 情報
    this._toggleInfoBtn = $('<a>').html(GSI.TEXT.SAKUZU.DIALOG_EDIT_INFOFREE_BTN).attr({ 'href': 'javascript:void(0);' }).addClass('toggleinfobtn')
      .on('click',L.bind(function () {

        if (this._infoFreeWordTextarea.is(':visible')) {
          this._infoFreeWordTextarea.fadeOut('fast', L.bind(function () {
            this._toggleInfoBtn.html(GSI.TEXT.SAKUZU.DIALOG_EDIT_INFOFREE_BTN);
            this._infoTable.fadeIn('fast');
          }, this));
        }
        else {
          this._infoTable.fadeOut('fast', L.bind(function () {
            this._toggleInfoBtn.html(GSI.TEXT.SAKUZU.DIALOG_EDIT_INFOTABLE_BTN);
            var description = this._infoTableToFreeWordText();
            this._infoFreeWordTextarea.trigger('focus');
            if (description != '') this._infoFreeWordTextarea.val(description);
            this._infoFreeWordTextarea.fadeIn('fast');
          }, this));
        }

      }, this));

    frame.append(this._toggleInfoBtn);

    this._infoTableFrame = $("<div>").addClass("tableframe");
    this._infoTable = $('<table>').attr({ border: 0 }).css({ width: '100%' });
    var tbody = $('<tbody>');

    this._infoTableTbody = tbody;
    this._infoTable.append(tbody);

    this._infoTableFrame.append( this._infoTable );
    frame.append(this._infoTableFrame);

    this._infoFreeWordTextarea = $('<textarea>').attr({ 'wrap': 'off' }).addClass('inputtextarea').css({ height: '100px', 'width': '100%', "margin-top": "2px" }).hide();
    frame.append(this._infoFreeWordTextarea);

    return frame;
  },

  // OKキャンセル等ボタン
  _createButtonPanel : function() {
    var frame = $("<div>").addClass("button-panel");

    this._okButton = $("<a>").attr({"href":"javascript:void(0);"}).addClass("normalbutton").html("OK");
    this._cancelButton = $("<a>").attr({"href":"javascript:void(0);"}).addClass("normalbutton").html("キャンセル");

    this._okButton.on("click",L.bind(this._okButtonClick, this));
    this._cancelButton.on("click",L.bind(this._cancelButtonClick, this));

    frame.append( this._okButton);
    frame.append( this._cancelButton);

    return frame;
  },

  _viewToInfo: function () {
    var result = {
      title: this._titleInput.val(),
      description: null,
      table: null
    };

    if ( result.title == "" ) result.title = null;

    if (this._infoFreeWordTextarea.is(':visible')) {
      result.description = this._infoFreeWordTextarea.val();
    }
    else  {
      result.table = [];
      var keyTextAreaList = this._infoTableTbody.find("textarea[name=info_table_key]");
      var valueTextAreaList = this._infoTableTbody.find("textarea[name=info_table_value]");

      for (var i = 0; i < keyTextAreaList.length; i++) {
        var item = {
          key: $(keyTextAreaList[i]).val(),
          value: $(valueTextAreaList[i]).val()
        };
        if (item.key != '')
          result.table.push(item);
      }

      if ( result.table.length<=0 ) result.table = null;
    }

    return result;
  }
});

/*******************************************************

 GSI.SakuzuLoadFileWindow
    作図ファイル読み込み画面

*******************************************************/
GSI.SakuzuLoadFileWindow = L.Evented.extend({
  initialize: function (sakuzuList) {
    this._sakuzuList = sakuzuList;
  },

  show: function () {
    this._create();

    this._container.fadeIn(200);
  },

  hide: function () {

    this._container.fadeOut(200);
  },

  destroy: function () {
    if (this._container) {
      this._container.remove();
      this._container = null;
    }
  },

  _onOkButtonClick: function () {
    if (!this._load()) {
      return;
    }
  },
  _onCancelButtonClick: function () {
    this.hide();
  },

  _create: function () {
    if (this._container) this._container.remove();
    this._container = $("<div>").addClass("gsi-topmostwindow-container").addClass("gsi-sakuzu-load-window").hide();

    this._frame = $("<div>").addClass("frame");

    this._message = $("<div>").addClass("message");
    this._message.html(GSI.TEXT.SAKUZU.DIALOG_LOAD_COMMENT);

    this._fileLoadInput = $('<input>').attr({ type: "file", "multiple": "multiple" });
    this._fileLoadInputFrame = $("<div>").addClass("fileload-frame");
    this._fileLoadInputFrame.append(this._fileLoadInput);

    this._buttonFrame = $("<div>").addClass("button-frame");

    this._okButton = $("<a>").addClass("normalbutton").html(GSI.TEXT.SAKUZU.DIALOG_LOAD_OKBTN);
    this._cancelButton = $("<a>").addClass("normalbutton").html(GSI.TEXT.SAKUZU.DIALOG_LOAD_CANCELBTN);
    this._okButton.on("click", L.bind(this._onOkButtonClick, this));
    this._cancelButton.on("click", L.bind(this._onCancelButtonClick, this));

    this._buttonFrame.append(this._okButton).append(this._cancelButton);
    this._frame.append(this._message);
    this._frame.append(this._fileLoadInputFrame);
    this._frame.append(this._buttonFrame);

    this._container.append(this._frame);

    $("body").append(this._container);
  },

  _load: function () {
    var files = this._fileLoadInput.prop('files');
    if (!files) files = this._fileLoadInput.attr('files');

    if (!files) {
      alert(GSI.TEXT.SAKUZU.DIALOG_LOAD_NOFILE);
      return;
    }

    var loader = new GSI.LocalFileLoader(files);
    loader.on("load", L.bind(function (evt) {

      var list = evt.list;

      var imageList = [];
      var sakuzuList = [];
      var csvList = [];

      for (var i = 0; i < list.length; i++) {
        var item = list[i];

        if (item.fileName.match(/\.tif[f]*$/i)
          || item.fileName.match(/\.jpg$/i)
          || item.fileName.match(/\.jpeg$/i)) {
          imageList.push({
            "data": item.reader.result,
            "fileName": item.fileName,
            "file": item.file
          });
        } else if (item.fileName.match(/\.csv$/i)) {
          var arr = Encoding.convert(new Uint8Array(item.reader.result), "UNICODE", "AUTO");
          if (arr[0] == 65279) arr.splice(0, 1);
          csvList.push({
            "data": Encoding.codeToString(arr),
            "fileName": item.fileName
          });
        } else {
          var arr = Encoding.convert(new Uint8Array(item.reader.result), "UNICODE", "AUTO");
          if (arr[0] == 65279) arr.splice(0, 1);
          sakuzuList.push({
            "data": Encoding.codeToString(arr),
            "fileName": item.fileName
          });
        }
      }

      if (imageList.length > 0) {
        this._sakuzuList.loadFromImageList(imageList);
      }

      if (csvList.length > 0) {
        this._sakuzuList.loadFromCSVList(csvList);
      }

      if (sakuzuList.length > 0) {
        this._sakuzuList.loadFromTextList(sakuzuList);
      }
      this.hide();

    }, this));
    loader.load();
  }
});

/*******************************************************

 GSI.SakuzuSaveFileWindow
    作図ファイル保存画面

*******************************************************/
GSI.SakuzuSaveFileWindow = L.Evented.extend({
  initialize: function (sakuzuList) {
    this._sakuzuList = sakuzuList;
  },

  show: function () {
    this._create();

    this._container.fadeIn(200);
  },

  hide: function () {

    this._container.fadeOut(200);
  },

  destroy: function () {
    if (this._container) {
      this._container.remove();
      this._container = null;
    }
  },

  _onOkButtonClick: function () {
    if (!this._save()) {
      return;
    }
  },
  _onCancelButtonClick: function () {
    this.hide();
  },

  _create: function () {
    if (this._container) this._container.remove();
    this._container = $("<div>").addClass("gsi-topmostwindow-container").addClass("gsi-sakuzu-save-window").hide();

    this._frame = $("<div>").addClass("frame");

    // メッセージ
    this._message = $("<div>").addClass("message");
    this._message.append($("<div>").html(GSI.TEXT.SAKUZU.DIALOG_SAVE_COMMENT));
    this._message.append($("<div>").addClass("small").html(GSI.TEXT.SAKUZU.DIALOG_SAVE_COMMENT2));

    // 形式選択

    var selectFrame = $('<div>').addClass('selectframe');
    var id = 'GSI_SakuzuDialog_check' + GSI.Utils.getCurrentID();

    var radio = $('<input>').attr({ id: id, type: "radio", name: "gsi_sakuzu_dialog_savetype", value: "kml" }).addClass('normalcheck');
    var label = $('<label>').attr({ 'for': id }).html('KML形式');
    selectFrame.append(radio);
    selectFrame.append(label);

    radio.on('click',L.bind(this._onSaveTypeChange, this, radio));

    id = 'GSI_SakuzuDialog_check' + GSI.Utils.getCurrentID();
    var radio = $('<input>').attr({ id: id, type: "radio", name: "gsi_sakuzu_dialog_savetype", value: "geojson" }).addClass('normalcheck');
    var label = $('<label>').attr({ 'for': id }).html('GeoJSON形式');
    selectFrame.append(radio);
    selectFrame.append(label);

    radio.on('click',L.bind(this._onSaveTypeChange, this, radio));

    // テキストエリア
    var textareaFrame = $("<div>").addClass("textarea-frame");

    this._fileSaveTextarea = $('<textarea>').attr({ 'wrap': 'off' }).css({ 'readonly': 'readonly' });
    this._fileSaveTextarea.on("focus", L.bind(function () {
      setTimeout(L.bind(function () {
        this._fileSaveTextarea.trigger('select');
      }, this), 0);
    }, this));
    textareaFrame.append(this._fileSaveTextarea);

    // ボタン
    this._buttonFrame = $("<div>").addClass("button-frame");

    this._okButton = $("<a>").addClass("normalbutton").html(GSI.TEXT.SAKUZU.DIALOG_SAVE_OKBTN).addClass('disabled');
    this._cancelButton = $("<a>").addClass("normalbutton").html(GSI.TEXT.SAKUZU.DIALOG_SAVE_CANCELBTN);
    this._okButton.on("click", L.bind(this._onOkButtonClick, this));
    this._cancelButton.on("click", L.bind(this._onCancelButtonClick, this));

    this._buttonFrame.append(this._okButton).append(this._cancelButton);
    this._frame.append(this._message);
    this._frame.append(selectFrame);
    this._frame.append(textareaFrame);
    this._frame.append(this._buttonFrame);

    this._container.append(this._frame);

    $("body").append(this._container);
  },

  _onSaveTypeChange: function (radio) {

    this._fileSaveTextarea.trigger('focus');
    switch (radio.val()) {
      case 'kml':
        this._fileSaveTextarea.val(this._sakuzuList.toKML());
        break;

      case 'geojson':
        this._fileSaveTextarea.val(this._sakuzuList.toGeoJSON());
        break;
    }

    if (this._fileSaveTextarea.val() != '') {
      this._okButton.removeClass('disabled');
    }
    else {
      this._okButton.addClass('disabled');
    }
  },

  _save: function () {

    if (this._fileSaveTextarea.val() == '') return false;

    var ext = ".kml";
    var contentType = "application/vnd.google-earth.kml+xml";

    if (this._container.find("input[name=gsi_sakuzu_dialog_savetype]:checked").val() == 'geojson') {
      ext = ".geojson";
      contentType = "application/json";
    }

    var fileName = 'gsi' + GSI.Utils.getTimeStampString() + ext;
    var blob = new Blob([this._fileSaveTextarea.val()], { "type": contentType });

    GSI.Utils.saveFile(contentType, fileName, blob, L.bind(function (evt) {

      if (evt.button == "cancel") {
        this._container.fadeIn(200);
      } else {
        this.destroy();
      }
    }, this));
    this._container.fadeOut(200);
  }
});

/************************************************************************
 L.Marker
 - GSI.GeoJpegMarker（位置情報付きJPEG）
 ************************************************************************/
GSI.GeoJpegMarker = L.Marker.extend({

  ICONLIST: {
    "none": "https://maps.gsi.go.jp/portal/sys/v4/symbols/180.png",
    "w": "https://maps.gsi.go.jp/portal/sys/v4/symbols/188.png",
    "nw": "https://maps.gsi.go.jp/portal/sys/v4/symbols/181.png",
    "n": "https://maps.gsi.go.jp/portal/sys/v4/symbols/182.png",
    "ne": "https://maps.gsi.go.jp/portal/sys/v4/symbols/183.png",
    "e": "https://maps.gsi.go.jp/portal/sys/v4/symbols/184.png",
    "se": "https://maps.gsi.go.jp/portal/sys/v4/symbols/185.png",
    "s": "https://maps.gsi.go.jp/portal/sys/v4/symbols/186.png",
    "sw": "https://maps.gsi.go.jp/portal/sys/v4/symbols/187.png"
  },

  initialize: function (bytes, fileName, file, options) {
    this._fileName = fileName;

    this._exif = EXIF.readFromBinaryFile(bytes);
    this._gpsInfo = this._getGPSInfoFromExif(this._exif);

    var latlng = L.latLng(this._gpsInfo.lat, this._gpsInfo.lng);
    var directionIcon = this.ICONLIST[this._gpsInfo.directionKey];

    if (!options) options = {};
    options.icon = L.icon({
      iconUrl: directionIcon,
      iconSize: [20, 20],
      iconAnchor: [10, 10]
    });
    this._loadJPEGImage(file);

    L.Marker.prototype.initialize.call(this, latlng, options);
  },

  _loadJPEGImage: function (file) {
    this._jpegImage = new Image();
    var reader = new FileReader();

    reader.onload = L.bind(function (reader) {
      this._jpegImage.onload = L.bind(function () {
        var orientation = this._exif["Orientation"];
        var rotate = 0;
        switch (orientation) {
          case 3:
            rotate = 180;
            break;
          case 6:
            rotate = 90;
            break;
          case 8:
            rotate = 270;
            break;
        }
        var canvas = this._createCanvas(this._jpegImage, rotate);

        this._canvasImage = new Image();
        this._canvasImage.src = canvas.toDataURL('image/jpeg');
        this.bindPopup(this._createPopupContent(canvas.width, canvas.height));

      }, this);
      this._jpegImage.src = reader.result;

    }, this, reader);
    reader.readAsDataURL(file);

  },

  _createCanvas: function (img, rotate) {
    var canvas = document.createElement("canvas");

    var srcSize = {
      width: img.width,
      height: img.height
    }
    canvas.width = srcSize.width;
    canvas.height = srcSize.height;

    var srcCtx = canvas.getContext("2d");

    srcCtx.drawImage(img, 0, 0);
    var srcData = srcCtx.getImageData(0, 0, srcSize.width, srcSize.height);

    var size = {
      width: (rotate == 0 || rotate == 180 ? srcSize.width : srcSize.height),
      height: (rotate == 0 || rotate == 180 ? srcSize.height : srcSize.width)
    };

    var destData = srcCtx.createImageData(size.width, size.height);

    this._rotateImage(srcData, srcSize, destData, size, rotate);

    canvas.width = size.width;
    canvas.height = size.height;

    srcCtx.putImageData(destData, 0, 0, 0, 0, size.width, size.height);

    return canvas;
  },

  _rotateImage: function (src, srcSize, dest, destSize, rotate) {
    for (var y = 0; y < srcSize.height; y++) {
      for (var x = 0; x < srcSize.width; x++) {
        var srcIdx = (y * srcSize.width * 4) + (x * 4);
        var x2 = x;
        var y2 = y;
        switch (rotate) {
          case 90:
            x2 = destSize.width - y - 1;
            y2 = x;
            break;
          case 180:
            x2 = srcSize.width - x - 1;
            y2 = srcSize.height - y - 1;
            break;
          case 270:
            x2 = y;
            y2 = destSize.height - x - 1;
            break;
        }

        var destIdx = (y2 * destSize.width * 4) + (x2 * 4);
        dest.data[destIdx] = src.data[srcIdx];
        dest.data[destIdx + 1] = src.data[srcIdx + 1];
        dest.data[destIdx + 2] = src.data[srcIdx + 2];
        dest.data[destIdx + 3] = src.data[srcIdx + 3];

      }
    }
  },

  _createPopupContent: function (width, height) {
    var html = '<div class="gsi-jpeginfo-popup">';

    html += '<img style="' + (width > height ? "max-width:300px" : "max-height:300px") + ';" src="' + this._canvasImage.src + '">';

    html += "<table>";
    html += '<tr><th>撮影日時</th><td>' +
      (this._exif['DateTimeOriginal'] ? this._exif['DateTimeOriginal'] : "不明") + '</td></tr>';
    html += '<tr><th>撮影位置</th><td>' +
      this._gpsInfo.lat + ",<br>" + this._gpsInfo.lng + '</td></tr>';
    html += '<tr><th>撮影向き</th><td>' +
      (!this._gpsInfo.direction || isNaN(this._gpsInfo.direction) ? "不明" : this._gpsInfo.direction + "度") + '</td></tr>';
    html += "</table>";

    html += "</div>";
    return html;
  },

  _getGPSInfoFromExif: function (exif) {

    var lat = exif["GPSLatitude"];
    var lng = exif["GPSLongitude"];
    var latRef = exif["GPSLatitudeRef"];
    var lngRef = exif["GPSLongitudeRef"];

    var result = {
      lat: lat[0] + (lat[1] / 60) + (lat[2] / 3600),
      lng: lng[0] + (lng[1] / 60) + (lng[2] / 3600),
      direction: exif["GPSImgDirection"]
    };

    if (latRef == "S") {
      result.lat = -result.lat;
    }
    if (lngRef == "W") {
      result.lng = -result.lng;
    }
    result.directionKey = this._getDirectionKey(result.direction);
    return result;
  },

  _getDirectionKey: function (direction) {
    if (direction >= 337.5 && direction < 22.5) {
      return "n";
    } else if (direction >= 22.5 && direction < 67.5) {
      return "ne";
    } else if (direction >= 67.5 && direction < 112.5) {
      return "e";
    } else if (direction >= 112.5 && direction < 157.5) {
      return "se";
    } else if (direction >= 157.5 && direction < 202.5) {
      return "s";
    } else if (direction >= 202.5 && direction < 247.5) {
      return "sw";
    } else if (direction >= 247.5 && direction < 292.5) {
      return "w";
    } else if (direction >= 292.5 && direction < 337.5) {
      return "nw";
    } else {
      return "none";
    }
  }
});

/************************************************************************
 L.Evented
 - GSI.DrawManager（作図新規作成基底クラス）
 ************************************************************************/
GSI.DrawManager = L.Evented.extend({
  _drawType: "",

  initialize: function (drawType, dialogManager, sakuzuItem, options) {
    L.setOptions(this, options);
    this._drawType = drawType;
    this._sakuzuItem = sakuzuItem;
    this._dialogManager = dialogManager;
  },

  getSakuzuItem: function () {
    return this._sakuzuItem;
  },
  getDrawType: function () {
    return this._drawType;
  },

  isRunning: function () {
    return this._sakuzuItem != null;
  },

  start: function () {

    if (this._dialog) {
      this._dialog.hide();
    }
    if (!this._createHandler) {
      this._createHandler = L.bind(this._onCreate, this);
      this._sakuzuItem.on("created", this._createHandler);
    }
    if (!this._reserveHandler) {
      this._reserveHandler = L.bind(this._onReserve, this);
      this._sakuzuItem.on("reserve", this._reserveHandler);
    }
    if (!this._editStartHandler) {
      this._editStartHandler = L.bind(this._onEditStart, this);
      this._sakuzuItem.on("editstart", this._editStartHandler);
    }

    if (!this._requestEditHandler) {
      this._requestEditHandler = L.bind(this._onRequestEdit, this);
      this._sakuzuItem.on("reqiestedit", this._requestEditHandler);
    }

    this._execStart();

    this.fire("start");
  },

  _execStart: function () {
    this._sakuzuItem.startCreate(this._drawType);
  },

  commit: function () {
    if (this._dialog) this._dialog.commit();
  },

  cancel: function () {
    if (this._sakuzuItem) this._sakuzuItem.editCancel(true);
    this._hideInfoEdit();
    if (this._createHandler) {
      this._sakuzuItem.off("created", this._createHandler);
      this._createHandler = null;
    }
    if (this._reserveHandler) {
      this._sakuzuItem.off("reserve", this._reserveHandler);
      this._reserveHandler = null;
    }
    if (this._editStartHandler) {
      this._sakuzuItem.off("editstart", this._editStartHandler);
      this._editStartHandler = null;
    }
    if (this._requestEditHandler) {
      this._sakuzuItem.off("reqiestedit", this._requestEditHandler);
      this._requestEditHandler = null;
    }

    this._creating = false;
    this._sakuzuItem = null;
    this._drawType = "";
    this._layer = null;
    this.fire("stop");
  },

  _onRequestEdit: function () {
    if (this._dialog) this._dialog.commit();
  },

  _getDialogPosition: function (map, bounds) {
    return map.latLngToContainerPoint(bounds.getNorthEast());
  },

  _showInfoEdit: function (layer, info) {
    var map = this._sakuzuItem.getMap();
    var bounds = GSI.PathFrameRectangle.createTargetBounds(map, layer);
    var dialogPosition = this._getDialogPosition(map, bounds);
    if (!this._dialog) {
      this._dialog = new GSI.SakuzuInfoEditDialog(this._dialogManager, {});
      this._dialog.on("ok", L.bind(this._dialogOk, this));
      this._dialog.on("cancel", L.bind(this._dialogCancel, this));
      this._dialog.on("check", L.bind(this._dialogCheck, this));
    }
    this._dialog.setLayer(layer);
    this._dialog.setInfo(info);
    this._dialog.setSakuzuItem(this._sakuzuItem);
    this._dialog.setType(this._drawType);
    this._dialog.show(dialogPosition);

  },

  _hideInfoEdit: function () {

    if (!this._dialog) return;
    this._dialog.hide();
  },

  _onCreate: function (evt) {
    this._creating = true;
    this._showInfoEdit(evt.layer, evt.info);
  },

  _onEditStart: function (evt) {
    this._creating = false;
    this._showInfoEdit(evt.layer, evt.info);
  },

  changed: function () {
    return (this.getReserveLength() > 0 ? true : false);
  },

  getReserveLength: function () {
    // 編集中はreservelistから外れるので1つ足す
    return (this._sakuzuItem ? this._sakuzuItem.getReserveLength() + (this._dialog && this._dialog.hasLayer() ? 1 : 0) : 0);
  },

  _onReserve: function () {
    this.fire("reservechange", {
      "drawType": this._drawType,
      "len": this.getReserveLength()
    });
  },

  _dialogOk: function (evt) {
    this._dialog.hide();
    this._sakuzuItem.createNext(evt.info);
    this._creating = false;
  },

  _dialogCancel: function () {

    if (this._creating) {
      this._sakuzuItem.restartCreate();
    } else {

      this._sakuzuItem.editRollback();
      this._sakuzuItem.createNext();
    }
    if (this._dialog) {
      this._dialog.hide();
    }
    this._creating = false;

    this._onReserve();
  },

  _dialogCheck: function () { }

});

/************************************************************************
 GSI.DrawManager
 - GSI.EditManager（作図編集クラス）
 ************************************************************************/
GSI.EditManager = GSI.DrawManager.extend({
  _drawType: "",

  initialize: function (dialogManager, sakuzuItem, options) {

    GSI.DrawManager.prototype.initialize.call(this, "", dialogManager, sakuzuItem, options);
  },

  _execStart: function () {
    this._sakuzuItem.startSelectTarget();

  },

  changed: function () {
    var len = this.getReserveLength();

    if (len > 0) return true;
    else return false;

  },

  getReserveLength: function () {
    if (!this._sakuzuItem) return 0;
    var len = this._sakuzuItem.getEditedReserveLength() +
      (this._sakuzuItem.getRemovedReserveLength() - (this._dialog && this._dialog.hasLayer() ? 1 : 0));
    if (this._dialog && this._dialog.isChange()) len++;

    return len;
  },

  _onReserve: function (evt) {

    this.fire("reservechange", { "drawType": this._drawType, "len": this.getReserveLength() })
  },

  _showInfoEdit: function (layer, info) {

    GSI.DrawManager.prototype._showInfoEdit.call(this, layer, info);

  },

  _dialogOk: function (evt) {
    this._sakuzuItem.editingToReserve(evt.info);
    if (this._dialog) {
      this._dialog.hide();
    }
    this._onReserve();
  },

  _dialogCancel: function () {
    this._sakuzuItem.editRollback(true);

    if (this._dialog) {
      this._dialog.hide();
    }
    this._onReserve();
  },

  _dialogCheck: function () {
    this._onReserve();
  }
});

/************************************************************************
 L.Evented
 - GSI.MapMenu（地図メニュー）
 ************************************************************************/
GSI.MapMenu = L.Evented.extend({
  options: {
    position: "left",
    panelPosition: "left",
    zIndex: 15000,
    visible: true
  },

  initialize: function (gsimaps, mapManager, map, container, panelVisible, panelOverlap, options) {
    options = L.setOptions(this, options);
    this._gsimaps = gsimaps;
    this._mapManager = mapManager;
    this._map = map;
    this._container = container;
    this._panelVisible = panelVisible;
    this._panelOverlap = panelOverlap;
    this._initializeView(panelVisible, panelOverlap);

    this._gsimaps.on("initialized", L.bind(function() {
      this._mapPanel.getMapListPanel().getBaseMapPanel().setList(
        this._gsimaps._layersJSON.getBase()
      );
    },this));

  },

  destroy : function() {
    if ( this._mapPanel ) {
      this._mapPanel.destroy();
    }
  },

  setTopMargin : function() {
    $( this._rootButton.elem ).addClass("margintop");
    this._mapPanel.setHideButtonTopMargin();
  },
  removeTopMargin : function() {
    $( this._rootButton.elem ).removeClass("margintop");
    this._mapPanel.removeHideButtonTopMargin();
  },

  _initializeView: function (panelVisible, panelOverlap) {
    // トップボタン生成
    var elem = $('<a>')
      .attr({ 'href': 'javascript:void(0);' })
      .html('<img src="" class="" title="地図を選択">')
      .css({ "white-space": "nowrap", "position": "relative" })
      .addClass('gsi-mapmenu-btn')
      .on('click',L.bind(this._onItemClick, this));

    var title = $("<div>").html("地図");
    elem.append(title);
    this._rootButton = new GSI.Control.Button(elem[0], { position: 'top' + this.options.position });
    this._rootButton.addTo(this._map);
    this._onBaseChange({});

    var img = $(this._rootButton.elem).find( "img");
    img.attr({"src":"./image/map/layer_map.png"});

    this._mapPanel = new GSI.MapPanel(this._mapManager, this._container, panelVisible, panelOverlap,{
      "position" : (this.options.panelPosition == "right" ? "right" : "left"),
      "hideButtonHidden" : !this.options.visible
    });
    this._mapPanel
      .on("show", L.bind(function(evt) {
        this._rootButton.hide();
        this.fire("panelshow", evt);
      },this))
      .on("resize", L.bind(function(evt){
        this.fire("panelresize", evt);
      },this))
      .on("hide", L.bind(function(evt) {
        this.fire("panelhide", evt);
      },this))
      .on("showafter", L.bind(function(evt) {
        this.fire("panelchange", evt);
      },this))
      .on("hideafter", L.bind(function(evt) {
        this._rootButton.show();
        this.fire("panelchange", evt);
      },this))
      .on("overlapchange", L.bind(function(evt) {
        if ( this.getPanelVisible())
          this.fire("paneloverlapchange", evt);
      },this));

    this.rootItem = {
      elem: elem,
      children: [],
      depth: 0
    };
    if ( panelVisible || !this.options.visible) {
      this._rootButton.hide();
    }
    this._mapPanel.create();
  },

  setButtonLeftPosition : function(left) {

    if (left == undefined) left = 0;
    this.rootItem.left = left;
    this.rootItem.elem.css({ "margin-left": left + "px" });

  },

  _onItemClick : function() {
    this.showPanel();
  },

  showPanel : function(noAnimate) {
    this._mapPanel.show(noAnimate);
  },

  hidePanel : function(noAnimate) {
    this._mapPanel.hide(noAnimate);
  },

  getPanelVisible : function() {
    return this._mapPanel.getVisible();
  },

  getPanelPosition : function() {
    return this._mapPanel.options.position;
  },

  getPanelWidth : function () {
    return this._mapPanel.getWidth();
  },

  setData : function( data ) {
    this._cocoTileLayer = data.cocoTileLayer;
    this._mapLayerList = data.mapLayerList;
    this._mapPanel._mapListPanel.initCurrentPath(data.currentPath );
    this._mapPanel._mapListPanel._baseMapPanel.on("change", L.bind( this._onBaseChange, this ));

    this._mapPanel._mapListPanel.setCocoTileLayer( this._cocoTileLayer );
    this._mapPanel._mapListPanel.setMapLayerList( this._mapLayerList );

    this._mapPanel._showingMapListPanel.setCocoTileLayer( this._cocoTileLayer );
    this._mapPanel._showingMapListPanel.setMapLayerList( this._mapLayerList );
  },

  setTree : function( tree, visibleLayers, visibleLayersHash ) {
    this._mapPanel._mapListPanel.setTree(tree, visibleLayers, visibleLayersHash );

  },

  isPanelOverlap : function() {
    return this._mapPanel.isOverlap();
  },

  setPanelOverlap : function(on) {
    this._mapPanel.setOverlap(on);
  },

  getMapListPanel : function() {
    return this._mapPanel._mapListPanel;
  },

  getShowingMapListPanel : function() {
    return this._mapPanel._showingMapListPanel;
  },
  _onBaseChange : function( evt) {

  }
});

/************************************************************************
 L.Evented
 - GSI.MapPanel（表示用パネル）
 ************************************************************************/
GSI.MapPanel = L.Evented.extend({

  options : {
    position : "left",
    toggleSpeed : 200
  },

  SIZEMODE : [
    { width:210, screenWidth: 350, minMode :true},
    { width:280, screenWidth: 600},
    { width:350}
  ],
  initialize : function(mapManager,parentContainer, visible, overlap, options) {

    options = L.setOptions(this, options);
    this._overlap = overlap;

    this._sizeMode = ( CONFIG.MOBILE ? 0 : 2);
    this._mapManager = mapManager;
    this._parentContainer = parentContainer;
    this._splitterInitialized = false;
    this._initialVisible = visible;

    if ( !this._windowResizeHandler ) {
      this._windowResizeHandler = L.bind( this._onWindowResize, this );
      $(window).on("resize", this._windowResizeHandler);
    }
  },

  isOverlap : function() {
    return this._overlap;
  },

  setOverlap : function(on) {
    if ( this._overlap == on ) return;
    this._overlap = on;

    if ( this._overlap )
      this._container.addClass("overlap");
    else
      this._container.removeClass("overlap");

    this.fire("overlapchange",{"overlap":this._overlap});
  },

  getVisible : function() {
    return this._container.is(":visible");
  },
  getWidth : function() {
    return this._container.outerWidth();
  },

  show : function(noAnimate) {
    this.create();
    if ( this._container.is(":visible")) return;
    this._container.css({"visibility":"hidden"});
    this._container.show();

    if ( !this._splitterInitialized ) {
      this._splitter.adjust( Math.round( this._container.outerHeight() *0.7 ) );
      this._splitterInitialized = true;

    }

    var bottomHeight = this._showingMapListPanel.getHeight();

    if ( bottomHeight < 80 ) {

      this._splitter.adjust( this._container.outerHeight() - 80 );
    }

    var width = this._container.outerWidth();

    this._container.hide().css({"visibility":"visible"});
    this.fire("show",{"width":width, "duration": this.options.toggleSpeed,
      "position": ( this.options.position == "right" ? "right" : "left" )});
    this._container.show("slide",{"direction":( this.options.position == "right" ? "right" : "left" )},this.options.toggleSpeed, L.bind(function() {
      this.fire("showafter");
    },this));
    this._mapListPanel.adjust();
    this._showingMapListPanel.adjust();

    if ( CONFIG.MOBILE ) {
      if ( !this._bodyMousedownHandler ) {
        this._bodyMousedownHandler = L.bind( function(evt) {
          var target = evt.target;
          if ( $(target).hasClass("close-btn")) return;
          while( target) {
            if ( target == this._container[0]) return;
            target = target.parentNode;
          }
        },this);
        $(document.body).on("mousedown",this._bodyMousedownHandler);
      }
    }
  },

  hide : function() {
    if ( this._bodyMousedownHandler ) {
      $(document.body).off("mousedown",this._bodyMousedownHandler);
      this._bodyMousedownHandler  = undefined;
    }
    this.fire("hide", { "position": ( this.options.position == "right" ? "right" : "left" ), "duration": this.options.toggleSpeed});
    this._container.hide("slide",{"direction":( this.options.position == "right" ? "right" : "left" )},this.options.toggleSpeed, L.bind(function() {
      this.fire("hideafter");
    },this));
  },

  destroy : function() {

    if ( this._windowResizeHandler ) {
      $(window).off("resize", this._windowResizeHandler);
      this._windowResizeHandler = undefined;
    }

    if ( this._bodyMousedownHandler ) {
      $(document.body).off("mousedown",this._bodyMousedownHandler);
      this._bodyMousedownHandler  = undefined;
    }

    if ( this._container ) {
      this._container.remove();
      this._container = undefined;
    }
  },

  setHideButtonTopMargin : function() {
    this._closeButton.addClass("margintop");
  },

  removeHideButtonTopMargin : function() {
    this._closeButton.removeClass("margintop");

  },

  create : function() {
    if ( this._container ) return false;

    this._container = $("<div>").addClass("gsi-mapmenu-container");
    if ( this.SIZEMODE[this._sizeMode].minMode) {
      this._container.addClass("minmode");
    }

    if ( this.options.position == "right") {
      //右表示
      this._container.addClass("right");
    }

    if ( this._overlap ) {
      this._container.addClass("overlap");
    }
    this.setWidth( this.SIZEMODE[this._sizeMode].width);
    if ( !this._initialVisible )this._container.hide();

    this._parentContainer.append( this._container );

    // 閉じるボタン
    this._closeButton = $("<a>")
      .addClass("close-btn")
      .on("click", L.bind(this._onCloseButtonClick,this))
      .attr({"href":"javascript:void(0);"});

    if ( !this.options.hideButtonHidden ) {
      this._container.append(this._closeButton);
    }

    // 表示できる地図用パネル
    this._mapListPanel = new GSI.MapListPanel(this._mapManager,this._container);
    this._mapListPanel.show();

    // 表示中地図用パネル
    this._showingMapListPanel = new GSI.ShowingMapListPanel(this._mapManager,this._container);

    this._showingMapListPanel.on("folderclick",L.bind(function(evt, a) {
      this._mapListPanel.openFolder( evt.folder );
    },this));
    this._showingMapListPanel.show();

    // サイズ調節用スプリッター
    this._splitter= new GSI.MapPanelSplitter(this._container, null, this._mapListPanel, this._showingMapListPanel);
    this._splitter.show();
    this._splitter.on("change", L.bind(function(){
      this._mapListPanel.adjust();
    }, this ) );
    this.adjust();

    if ( this._initialVisible ) {
      this._splitter.adjust( Math.round( this._container.outerHeight() *0.7 ) );
      this._splitterInitialized = true;
    }

    this._onWindowResize();

    return true;
  },

  _onCloseButtonClick : function() {
    this.hide();
  },

  adjust : function() {
    this._splitter.adjust();
  },

  setWidth : function(w) {
    this._width = w;
    this._container.css({"width":this._width + "px"});
    if ( this._container.is(":visible")) this.fire("resize",{"width":w, "position": ( this.options.position == "right" ? "right" : "left" )});
  },

  setSizeMode : function(mode ) {
    if ( this._sizeMode == mode ) return;
    this._sizeMode = mode;
    this.setWidth( this.SIZEMODE[mode].width);

    if ( this._mapListPanel ) this._mapListPanel.refreshSize();
    if ( this._showingMapListPanel ) this._showingMapListPanel.setMiniMode(this.SIZEMODE[mode].minMode);

  },

  _onWindowResize : function() {

    if ( !this._container.parent().is(":visible"))return;

    var size = GSI.Utils.getScreenSize();

    if ( CONFIG.MOBILE ) {
      this.setSizeMode( 0);
    } else {
      for( var i=0; i<this.SIZEMODE.length; i++ ) {
        var mode = this.SIZEMODE[i];
        if ( !mode.screenWidth || mode.screenWidth >= size.w ) {

          this.setSizeMode( i);
          break;
        }
      }
    }
    var isVisible = this._container.is(":visible");

    if ( !isVisible) {
      this._container.css({"visibility":"hidden"});
      this._container.show();
    }
    var bottomHeight = this._showingMapListPanel.getHeight();

    if ( bottomHeight < 80 ) {
      bottomHeight = 80;
      this._splitter.adjust( this._container.outerHeight() - bottomHeight );
    }

    if ( !isVisible) {
      this._container.hide().css({"visibility":"visible"});
    }
  },

  getMapListPanel : function() {
    return this._mapListPanel;
  }
});

/************************************************************************
 L.Evented
 - GSI.MapPanelContainer（パネル基底クラス）
 ************************************************************************/
GSI.MapPanelContainer = L.Evented.extend({

  options: {
    className : ""
  },

  getHeight : function() {
    if ( !this._container ) return -1;
    return this._container.outerHeight();
  },

  initialize : function(parentContainer, options) {
    this._parentContainer = parentContainer;
    options = L.setOptions(this, options);
  },

  getContainer : function() {
    return this._container;
  },

  destroy : function() {

  },

  create : function() {

    if ( this._container ) return;

    this._container = $("<div>").addClass(this.options.className).hide();

    this._parentContainer.append( this._container );
    if ( this._createAfter ) this._createAfter();
  },

  show : function() {
    this.create();
    this._container.show();
    if ( this._showAfter ) this._showAfter();
  },

  hide : function() {
    if ( !this._container ) return;
    this._container.hide();
  }
});

/************************************************************************
 GSI.MapPanelContainer
 - GSI.MapPanelSplitter（上下分割、サイズ変更用スプリッタ）
 ************************************************************************/
GSI.MapPanelSplitter = GSI.MapPanelContainer.extend({

  options: {
    className : "gsi-maplistpanelsplitter-container"
  },

  initialize : function(parentContainer, options, topPanel, bottomPanel) {
    GSI.MapPanelContainer.prototype.initialize.call(this, parentContainer, options);
    this._topPanel = topPanel;
    this._bottomPanel = bottomPanel;
    this._ljsSrc = null;
  },

  _createAfter : function() {

    this._container.draggable({
      containment : "parent",
      axis: "y",
      start : L.bind( this._onDragStart, this),
      drag : L.bind( this._onDragMove, this),
      stop : L.bind( this._onDragStop, this),
    });
  },

  _onDragStart : function(evt, ui) {
    this.adjust( ui.position.top);
  },

  _onDragMove : function(evt, ui) {
    this.adjust( ui.position.top);

  },

  _onDragStop : function(evt, ui) {
    this.adjust( ui.position.top);
  },
  adjust : function(topHeight) {

    var topPanelContainer = this._topPanel.getContainer();
    var bottomPanelContainer = this._bottomPanel.getContainer();

    if ( topHeight ) {
      topPanelContainer.css( {"height": topHeight + "px"});
    } else {
      topHeight = topPanelContainer.outerHeight();
    }
    var splitterHeight = 0;// this._container.outerHeight();

    this._container.css( {"top": ( topHeight ) + "px"});

    bottomPanelContainer.css( {"top": ( topHeight + splitterHeight ) + "px"});

    this.fire("change");
  }
});

/************************************************************************
 GSI.MapPanelContainer
 - GSI.BaeMapPanel（ベースマップ表示用パネル）
 ************************************************************************/
GSI.BaseMapPanel = GSI.MapPanelContainer.extend({

  options: {
    className : "gsi-basemappanel-container"
  },

  initialize : function(mapListPanel, parentContainer, options) {

    this._mapListPanel = mapListPanel;

    this._list = CONFIG.BASEMAPLIST;

    GSI.MapPanelContainer.prototype.initialize.call(this, parentContainer, options);
  },

  setList : function( list ) {
    this._initializeList( list );
    this.refresh();
    this.fire("initialized");
  },

  _createAfter : function() {

    this._listFrame = $( "<ul>");
    this._initializeList(this._list);
    this._container.append( this._listFrame );

  },

  _initializeList : function(list) {

    this._listFrame.empty();
    for( var i=0; i<list.length; i++ ) {
      var item = list[i];
      var li = this._createListItem(item);

      this._listFrame.append( li );

    }
  },
  getPosition : function() {

    return this._container.position();
  },

  getSize : function() {

    var result = {
      width : this._container.outerWidth(),
      height : this._container.outerHeight()
    };

    return result;
  },

  _createListItem : function(item) {
    var li = $("<li>");
    var a = $( "<a>")
      .attr({"href":"javascript:void(0);","title": ""+item.title+""})
      .data({"item":item})
      .on('click', L.bind(this._onItemClick,this, item));

    var thumbImage = item.thumb;
    if ( !thumbImage || thumbImage == "" ) {
      thumbImage = "image/map/layer_" + item.id + ".png";

    }
    item.thumb = thumbImage;

    var img = $("<img>").attr( {"src":thumbImage,"alt": item.title});

    var title = $( "<div>").html( item.title).addClass("title");

    a.append(img);
    a.append( title );

    li.append( a );
    if ( item["__hidden"]) {
      li.hide();
    }
    return li;
  },

  setMapLayerList : function(mapLayerList) {
    this._mapLayerList = mapLayerList;
  },

  refresh : function() {

    this.fire("change", {"item": null});
    var aList = this._listFrame.find("li a");
    for( var i=0; i<aList.length; i++ ) {
      var a = $( aList[i] );
      var item = a.data("item");
      if ( this._mapLayerList.exists( item ) ) {
        a.addClass("active");
        this.fire("change", {"item": item});
      } else {
        a.removeClass("active");
      }
    }
  },

  _onItemClick : function(item) {

    this.fire( "select", {item:item});
  },

  adjust : function(w) {
    if ( w <= 0 ) return;
    w-=2;
    var aList = this._listFrame.find("li a");

    var size = Math.floor( w / aList.length )-1;

    if ( size< 50 ) {
      aList.addClass("mini");
    } else {
      aList.removeClass("mini");
    }
    aList.css({"width": size + "px", "height" : size+"px"});
  }
});

/************************************************************************
 GSI.MapPanelContainer
 - GSI.MapListPanel（表示できるリスト表示用パネル）
 ************************************************************************/
GSI.MapListPanel = GSI.MapPanelContainer.extend({

  options: {
    className : "gsi-maplistpanel-container"
  },

  initialize : function(mapManager, parentContainer, options) {
    this._activeTabIndex = 0;
    this._mapManager = mapManager;
    GSI.MapPanelContainer.prototype.initialize.call(this, parentContainer, options);
  },

  refreshSize : function() {
    this.adjust();
  },

  getBaseMapPanel : function() {
    return this._baseMapPanel;
  },

  _createAfter : function() {

    // ベースマップ表示用パネル
    this._baseMapPanel= new GSI.BaseMapPanel(this,this._container, null);
    this._baseMapPanel.on("select", L.bind( this._onBaseSelect, this));
    this._baseMapPanel.on("initialized", L.bind( this.adjust, this));
    this._baseMapPanel.show();

    // 表示できる情報用
    this._contentFrame = $( "<div>"  ).addClass("gsi-maplist-contentframe");
    this._headerFrame = $( "<div>").addClass("gsi-maplist-headerframe");
    this._headerFrame.append( $("<div>").addClass("title").html("地図の種類") );

    this._contentContainer= $("<div>").addClass("gsi-maplist-contentcontainer");
    // this._searchFrame = this._createSearchFrame();
    this._controlFrame = this._createControl();
    this._pankzFrame = $("<div>").addClass("gsi-maplist-pankzframe");
    this._titleTextFrame = $( "<div>");

    this._listFrame = $( "<div>" ).addClass("scroll-frame");

    this._pankzFrame.append( this._titleTextFrame );

    this._contentFrame.append( this._headerFrame);
    // this._contentContainer.append( this._searchFrame);
    this._contentContainer.append( this._controlFrame);
    this._contentContainer.append( this._pankzFrame);

    this._searchResultTextFrame = $('<div>').append($('<span>').html(this.options.title)).addClass("layertreedialog_searchresult_text_frame").hide()

    this._clearSearchButton = $("<a>").attr({ "href": "javascript:void(0);" }).html("×検索解除");
    this._clearSearchButton.on("click", L.bind(this._onClearSearchClick, this));

    this._searchResultTextFrame.append(this._clearSearchButton);

    this._contentContainer.append(this._searchResultTextFrame );
    this._contentContainer.append( this._listFrame );
    this._contentFrame.append( this._contentContainer);
    this._container.append( this._contentFrame);

    this._searchResult = $("<div>").addClass("layertreedialog_searchresult_frame").hide();
    this._searchResult.append($("<ul>"));
    this._contentContainer.append(this._searchResult);

    this.adjust();

  },

  _onBaseSelect : function( evt ) {
    var item = evt.item;
    var baseLayerTarget = null;

    for (var i = 0; i < this._mapManager._baseLayer.baseLayerList.length; i++) {
      if (item.id == this._mapManager._baseLayer.baseLayerList[i].id) {
        baseLayerTarget = this._mapManager._baseLayer.baseLayerList[i];
        break;
      }
    }

    if (baseLayerTarget ) {
      var f = false;
      if (this._mapLayerList.exists(baseLayerTarget)) {
        f = true;
      }
      for (var i = 0; i < this._mapManager._baseLayer.baseLayerList.length; i++) {
        var baseLayer = this._mapManager._baseLayer.baseLayerList[i];
        if (this._mapLayerList.exists(baseLayer)) {
          this._mapLayerList.remove(baseLayer);
        }
      }
      if (f) {
        this._mapManager._map.removeLayer(this._mapManager._baseLayer);
      }
      else {
        this._mapManager._map.addLayer(this._mapManager._baseLayer);
        this._mapLayerList.append(item);
        GSI.Utils.sendSelectedLayer(this._mapManager._baseLayer.getActiveId());
      }
    }
  },

  onCOCOTileLoad: function (e) {
    if (!this.tree) return;
    this._initializeList(this.current ? this.current.entries : (this.tree ? this.tree[this._activeTabIndex].entries : true), true);
    this._refreshSearchResult();

  },
  onCOCOTileHide: function (e) {
    if (!this.tree) return;
    this._initializeList(this.current ? this.current.entries : (this.tree ? this.tree[this._activeTabIndex].entries : true), true);
    this._refreshSearchResult();

  },

  initCurrentPath : function(path) {

    this._current_id = this.path = path;
  },

  _createControl: function () {
    var frame = $('<div>').addClass('gsi-maplist-controlframe');

    this.onOffSwitch = new GSI.OnOffSwitch({ className: 'onoff',
      checked: ( this._cocoTileLayer ? this._cocoTileLayer.getVisible() : false ), title: "" });

    var onoffFrame = $('<div>');
    var label = $('<label>').css({ "padding-left": "5px" }).attr({ 'for': this.onOffSwitch.getId() }).html('表示範囲に絞込み');

    this.onOffSwitch.on('change', L.bind(this._onCocoTileCheckChange, this, this.onOffSwitch));

    onoffFrame.append(this.onOffSwitch.getElement());
    onoffFrame.append(label);

    onoffFrame.hide();

    this._showAllButton = $('<a>').attr({ href: 'javascript:void(0);' }).html('全選択').addClass('normalbutton showallbutton');
    this._hideAllButton = $('<a>').attr({ href: 'javascript:void(0);' }).html('全非選択').addClass('normalbutton showallbutton');

    frame.append(this._hideAllButton);
    frame.append(this._showAllButton);
    frame.append(onoffFrame);

    this._showAllButton.on('click',L.bind(this._onShowAllClick, this));
    this._hideAllButton.on('click',L.bind(this._onHideAllClick, this));

    return frame;
  },

  _onShowAllClick: function () {
    var cocoVisible = this._cocoTileLayer.getVisible();
    var list = (this.current ? this.current.entries : this.tree);
    if (!list || list.length <= 0) return;

    var showList = [];

    for (var i = 0; i < list.length; i++) {
      var item = list[i];
      if (item.entries) continue;
      if (cocoVisible && item.cocotile && !item.hasTile) continue;

      showList.push(item);
    }

    if (showList.length > 0)
      this._mapLayerList.appendList(showList);
  },
  _onHideAllClick: function () {
    var list = (this.current ? this.current.entries : this.tree);
    if (!list || list.length <= 0) return;

    for (var i = 0; i < list.length; i++) {
      var item = list[i];
      if (item.entries) continue;
      if (this._mapLayerList.exists(item)) {
        this._mapLayerList.remove(item);
      }
    }
  },
/*
  _createSearchFrame: function () {
    // 検索
    this._searchFrame = $("<div>").addClass("gsi-maplist-searchframe");
    this._queryInput = $("<input>").attr({ "type": "search", "placeholder": "例：写真/標高/災害" });
    this._layerTreeSearcher = new GSI.LayerTreeSearcher(this._queryInput, this._mapManager);
    this._layerTreeSearcher
      .on("start", L.bind(function (e) { this._startSearch(); }, this))
      .on("focus", L.bind(function (e) { this._showSearchResult(); }, this))
      .on("clear", L.bind(function (e) { this._clearSearch(); }, this))
      .on("hit", L.bind(function (e) { this._appendSearchResult(e.list, e.result); }, this))
      .on("finish", L.bind(function (e) { this._finishSearch(e.result); }, this));
    this._queryInput
      .on("click", function () { this.focus(); })
      .on("focus", L.bind(function () {
        this._layerTreeSearcher.start();
      }, this))
      .on("blur", L.bind(function () {
        this._layerTreeSearcher.stop();
      }, this));
    this._searchFrame.append(this._queryInput);

    return this._searchFrame;

  },
*/
  _showAfter : function() {
    this.adjust();
  },

  adjust : function() {
    this._baseMapPanel.adjust(this._container.outerWidth());
    this._contentFrame.css({"top": this._baseMapPanel.getSize().height + "px"});
    var pankzHeight = this._pankzFrame.outerHeight();
    var height = this._contentFrame.outerHeight();

    this._listFrame.css({"height": (height-this._pankzFrame.position().top-pankzHeight) + "px"});
  },

  getCurrentPath: function () {
    var id = "";
    if (this._current_id) {
      id = this._current_id;
    }

    return id;
  },
  setCurrentPath: function (path) {
    this.options.currentPath = path;
    this.setTree(this.tree);
  },

  setLayers: function(layers, tree, layersHash){
    if (layers && layers.length > 0){
      this._visibleLayers = [];
      this._visibleLayersHash = {};
      this._visibleLayers = GSI.Utils.objAssign(this._visibleLayers, this._mapManager._layersJSON.visibleLayers);
      this._visibleLayersHash = GSI.Utils.objAssign(this._visibleLayersHash, this._mapManager._layersJSON.visibleLayersHash);

      var needsrc = [];
      if (this._visibleLayers && this._visibleLayers.length > 0){
        for (var x = 0; x < this._visibleLayers.length; x++){
          var v = this._visibleLayers[x];
          needsrc.push(v.id);
        }
      }
      if (needsrc.length > 0){
        var outerthis = this;
        this._ljsSrc = new GSI.layersJSONSearchSRC(this._mapManager);
        this._ljsSrc.on('searchEnd', L.bind(function(){
          if (tree && layersHash){
            outerthis.setTree(tree, layers, layersHash);
          }
        }));
        this._ljsSrc.kick(needsrc);
      }
    }   
  },

  setMapLayerList : function(mapLayerList) {
    this._mapLayerList = mapLayerList;
    this._baseMapPanel.setMapLayerList( mapLayerList);
    this._mapLayerList.on('change', L.bind(this.onMapLayerListChange, this));
  },
  setCocoTileLayer : function(cocoTileLayer) {
    this._cocoTileLayer = cocoTileLayer;

    cocoTileLayer.on('load', L.bind(this.onCOCOTileLoad, this));
    cocoTileLayer.on('hide', L.bind(this.onCOCOTileHide, this));
  },

  setTree : function(tree, visibleLayers, visibleLayersHash) {
    if ( visibleLayers ) {

      this._visibleLayers = visibleLayers;
      this._visibleLayersHash = visibleLayersHash;

      this.options.currentPath = this.path;

      this.setTree(tree);
    } else {
      this.tree = tree;
      this.current = null;
      this.initializeList();
    }
  },

  setTree_Init: function (tree, visibleLayers, visibleLayersHash) {

    this._visibleLayers = visibleLayers;
    this._visibleLayersHash = visibleLayersHash;

    this.options.currentPath = this.path;

    this.setTree(tree);
  },

  onMapLayerListChange: function () {
    this._initializeList(this.current ? this.current.entries : (this.tree ? this.tree[this._activeTabIndex].entries : true), true);
    this._toolTipViewCounter = 0;
    this._baseMapPanel.refresh();

    if(this._mapManager._footer){
      this._mapManager._footer.updateLakeDepthVisible(false);
    }
  },

  onCocoTileCheckChange: function (onOffSwitch) {
    this.onOffSwitch.checked(onOffSwitch.checked());
    this._onCocoTileCheckChangeProc(onOffSwitch);
  },
  _onCocoTileCheckChange: function (onOffSwitch) {
    this._onCocoTileCheckChangeProc(onOffSwitch);
  },
  _onCocoTileCheckChangeProc: function (onOffSwitch) {
    if (onOffSwitch.checked()) {
      if (!this._initializeList_ID_Mode_cocoTileLayer) {
        var path = "";
        this._CurrentData_SRC = {};
        this._CurrentData_SRC_ID = "";
        this._initializeList_ID_Mode = "cocoTileLayer";
        this._initializeList_IDProc_Data(this.tree, path);
        //this._CurrentData_SRC_ID = path;
        this._initializeList_IDProc_DataSrc("", path);

        this._initializeList_ID_Mode_cocoTileLayer = true;
      }
      else {
        this._cocoTileLayer.setVisible(onOffSwitch.checked());
      }
    }
    else {
      this._cocoTileLayer.setVisible(onOffSwitch.checked());
    }
  },

  initializeList: function () {
    if (!this._container) return;
    this._hideItemTooltip();
    if (!this._listContainer) {
      this._listContainer = $('<ul>').addClass('layertreedialog_ul');
      this._listFrame.empty().append(this._listContainer);
    }
    this._contentFrame.scrollTop(0);
    this._listContainer.empty();
    if (this.options.currentPath) {
      this._initializeList_CurrentPath(this.options.currentPath);
    }
    else {
      var needsrc = [];
      if (this._visibleLayers && this._visibleLayers.length > 0){
        for (var x = 0; x < this._visibleLayers.length; x++){
          var v = this._visibleLayers[x];
          needsrc.push(v.id);
        }
      }
      if (needsrc.length > 0){
        var outerthis = this;
        this._ljsSrc = new GSI.layersJSONSearchSRC(this._mapManager);
        this._ljsSrc.on('searchEnd', L.bind( function (){
          outerthis._initializeListProc();
        }));
        this._ljsSrc.kick(needsrc);
      }
      else{
        this._initializeListProc();
      }
    }

    if ( this._showAllButton ) {
      if (this.current && this.current.toggleall) {
        this._showAllButton.show();
        this._hideAllButton.show();
      }
      else {
        this._showAllButton.hide();
        this._hideAllButton.hide();
      }
      this.adjust();
    }
  },

  _hideItemTooltip: function (a, item) {
    if (this._hideToolTipHandler) {
      $(document.body).off('mousedown', this._hideToolTipHandler);
      $(document.body).off('touchstart', this._hideToolTipHandler);
      this._listFrame.off('scroll', this._hideToolTipHandler);
      this._hideToolTipHandler = null;
    }
    if (this._itemTooltip) {
      this._itemTooltip.stop().hide();
    }
  },
  _initializeList: function (list, liRefresh) {
    this._hideItemTooltip();

    if (!list || list.length <= 0) {
      this._listContainer.empty();
      var li = $('<li>').addClass('nodata').html('データがありません');
      this._listContainer.append(li);
      return;
    }

    if (!this._listContainer){
      return;
    }
    var liList = (liRefresh ? this._listContainer.children('li') : null);

    var showAllButtonEnable = false;
    var hideAllButtonEnable = false;

    var idx = 0;
    for (var i = 0; i < list.length; i++) {
      var item = list[i];
      var li = (liRefresh ? $(liList[idx]).empty() : $('<li>'));
      var a = $('<a>').attr({ 'href': 'javascript:void(0);' });
      a.data({ 'data': item });
      idx++;
      if ((item.entries && !item.isMultiLayer) || item.src) {
        if ( CONFIG.layerBaseFolderVisible || item.title_sys != CONFIG.layerBaseFolderSYS)
          this._makeFolder(li, a, item);
        else {
          idx--;
          continue;
        };
      }
      else {
        this._makeLayer(li, a, item);
      }
      li.append(a);
      this._listContainer.append(li);

      if ((item.entries) || (this._cocoTileLayer.getVisible() && item.cocotile && !item.hasTile)) continue;

      if (item._visibleInfo) hideAllButtonEnable = true;
      else showAllButtonEnable = true;
    }

    if ( this._showAllButton ) {
      if (showAllButtonEnable) {
        this._showAllButton.removeClass('disabled');
      }
      else {
        this._showAllButton.addClass('disabled');
      }
    }

    if ( this._hideAllButton ) {
      if (hideAllButtonEnable) {
        this._hideAllButton.removeClass('disabled');
      }
      else {
        this._hideAllButton.addClass('disabled');
      }
    }
  },

  _initializeListProc: function () {
    if (this._visibleLayers && this._visibleLayers.length > 0) {
      var fAppend = true;

      if (fAppend) {
        for (var i = 0; i < this._visibleLayers.length; i++) {
          var l = this._visibleLayers[i];
          if (l.info != null) {
            this._mapLayerList.append(l.info, true, l.hidden, null, l.blend);
          }
        }
        this._visibleLayers.length = 0;
        this._initializeListProc();
      }
    }
    else {
      this.refreshTitle();
      this._initializeList(this.current ? this.current.entries : this.tree[this._activeTabIndex].entries);
      if (this._userResized) this._onResize();
    }
  },

  _initializeList_VisibleLayers: function (id) {
    this._initializeList_ID_Mode = "visible";
    this._initializeList_ID_Mode_ID = id;
    this._initializeList_ID(id);
  },

  _initializeList_CurrentPath: function (id) {
    this._initializeList_ID_Mode = "current";
    this._initializeList_ID_Mode_ID = id;
    this._initializeList_ID(id);
  },

  _initializeList_ID: function (path) {
    var current = null;
    if (!path || path == '') return null;

    this._CurrentData_SRC = {};
    this._CurrentData_SRC_ID = "";
    current = this._initializeList_IDProc_Data(this.tree, path);
    var keys = Object.keys(this._CurrentData_SRC);
    if (current == null && keys.length > 0) {
      //this._CurrentData_SRC_ID = path;
      var srcurl = this._CurrentData_SRC[keys[0]].src;
      this._initializeList_IDProc_DataSrc(srcurl, path);
    }
    else {
      if (current != null){
        //lcdがベースマップだとこれが邪魔だが、これがないとsrc属性を探せない
        if (!this._visibleLayers || this._visibleLayers.length < 1){
          this._mapManager._layersJSON._initializeTree(this.tree, current.id);
          this._visibleLayers = GSI.Utils.objAssign(this._visibleLayers,this._mapManager._layersJSON.visibleLayers);
          this._visibleLayersHash = GSI.Utils.objAssign(this._visibleLayersHash,this._mapManager._layersJSON.visibleLayersHash);
        }
      }
      this._initializeList_IDProc(current);
    }
    return current;
  },
  _initializeList_IDProc: function (current) {
    var fInit = true;
    if (this._initializeList_ID_Mode == "visible") {
      if (current == null && this.visibleLayers) {
        for (var i = 0; i < this.visibleLayers.length; i++) {
          var l = this.visibleLayers[i];
          if (l.id == this._initializeList_ID_Mode_ID) {
            this.visibleLayers.splice(i, 1);
            break;
          }
        }
      }
    }
    if (this._initializeList_ID_Mode == "current") {
      this.current = current;
      var target = this.current;
      if ( target && target.title_sys == CONFIG.layerBaseFolderSYS && !CONFIG.layerBaseFolderVisible ) {
        target = null;
        this.current = null;
      }

      if (target) {

        while (target.parent) {
          target = target.parent;
        }
        if (this.tree) {
          this._activeTabIndex = 0;

        }
      }
      this.options.currentPath = null;
    }
    if (this._initializeList_ID_Mode == "cocoTileLayer") {
      this._cocoTileLayer.setVisible(true);
      fInit = false;
    }

    this._initializeList_ID_Mode = "";

    if (fInit) {
      this._initializeListProc();
    }
  },
  _initializeList_IDProc_Data: function (tree, id) {

    var current = null;
    _DEV_DBG_HashLsPath = true;
    for (var i = 0; i < tree.length; i++) {
      if (tree[i].src && !tree[i].entries) {
        if (!tree[i].src_ && tree[i].src.indexOf('./') == 0) {
          var path = tree[i].src_url.substring(0, tree[i].src_url.lastIndexOf('/'));
          tree[i].src_ = true;
          tree[i].src = path + "/" + tree[i].src.substr(2);
        }
        this._CurrentData_SRC[tree[i].src] = tree[i];
      }
      else if (tree[i].entries && !tree[i].isMultiLayer) {
        current = this._initializeList_IDProc_Data(tree[i].entries, id);
        if (current != null) {
          break;
        }
      }
      else {
        if (tree[i].id == id) {
          if (tree[i].parent) {
            current = tree[i].parent;

            this._CurrentData_SRC = {};
          }
          else {
            current = null;
          }
          break;
        }
      }
    }

    return current;
  },
  _initializeList_IDProc_DataSrc: function (srcurl, path) {
    var keys = Object.keys(this._CurrentData_SRC);
    if (keys.length > 0) {
      if (GSI.GLOBALS.layersJSONCache &&
        GSI.GLOBALS.layersJSONCache[srcurl]) {
        this._initializeList_IDProc_DataSrc_Success(
          srcurl,
          path,
          GSI.GLOBALS.layersJSONCache[srcurl]
        );
      }
      else {
        this.ajax = $.ajax({
          type: "GET",
          url: srcurl,
          dataType: "text",
          cache: true,
          success: L.bind(this._initializeList_IDProc_DataSrc_Success, this, srcurl, path),
          error: L.bind(this._initializeList_IDProc_DataSrc_Error, this, srcurl, path)
        });
      }
    }
    else {

      this._initializeList_IDProc(null);
    }
  },
  _initializeList_IDProc_DataSrc_Success: function (srcurl, path, data) {
    var keys = Object.keys(this._CurrentData_SRC);
    if (keys.length > 0) {

      if (!GSI.GLOBALS.layersJSONCache) GSI.GLOBALS.layersJSONCache = {};

      GSI.GLOBALS.layersJSONCache[srcurl] = data;

      var json = JSON.parse(data);
      if (json.layers) {
        for (var i = 0; i < json.layers.length; i++) {
          json.layers[i].parent = this._CurrentData_SRC[srcurl];
          if(this._CurrentData_SRC[srcurl]){
            json.layers[i].src_url = this._CurrentData_SRC[srcurl].src_url;
          }
        }
      }
      this._CurrentData_SRC[srcurl].entries = json.layers;

      this._mapManager._layersJSON._initializeTree(this._CurrentData_SRC[srcurl].entries, this._CurrentData_SRC[srcurl]);

      current = this._initializeList_IDProc_Data(this._CurrentData_SRC[srcurl].entries, path);

      if (current == null) {
        this._initializeList_IDProc_DataSrc_Error(srcurl, path);
      }
      else {
        if (this._visibleLayers == null || this._visibleLayers.length == 0){
          this._visibleLayers = this._mapManager._layersJSON.visibleLayers;
          this._visibleLayersHash = this._mapManager._layersJSON.visibleLayersHash;
          if (!this._current_id || this._current_id == ""){
            this._current_id = this.options.currentPath;
          }
        }
        this._initializeList_IDProc(current);
      }
    }
  },
  _initializeList_IDProc_DataSrc_Error: function (srcurl, path) {
    delete this._CurrentData_SRC[srcurl];
    var src = "";
    for(var key in this._CurrentData_SRC){
      src = this._CurrentData_SRC[key].src;
      break;
    }
    this._initializeList_IDProc_DataSrc(src, path);
  },

  _makePankz : function( target ) {
    var pankz = $("<div>");

    if (target._isOutside) {
      return "外部タイル";
    }

    if (target._appendInfo) target = target._appendInfo;

    var num = 0;
    target = target;
    while (target) {
      if (num > 0) {
        var a = $('<a>').html(target.title).attr({ 'href': 'javascript:void(0);' });
        var span = $('<span>').html("&nbsp;&gt;&nbsp;");
        pankz.prepend(span);
        a.on('click',
          L.bind(this._onFolderClick, this, a)
        ).data({ 'data': target });
        pankz.prepend(a);
      }
      else {
        var span = $('<span>').html(target.title);
        pankz.prepend(span);
      }

      num++;
      target = target.parent;
    }

    return pankz;
  },
  refreshTitle: function () {
    this._titleTextFrame.empty();

    var num = 0;
    var target = this.current;
    while (target) {
      if (num > 0) {
        var a = $('<a>').html(target.title).attr({ 'href': 'javascript:void(0);' });
        var span = $('<span>').html("&nbsp;&gt;&nbsp;");
        this._titleTextFrame.prepend(span);
        a.on('click',
          L.bind(this._onFolderClick, this, a)
        ).data({ 'data': target });
        this._titleTextFrame.prepend(a);
      }
      else {
        var span = $('<span>').html(target.title);
        this._titleTextFrame.prepend(span);
      }

      num++;
      target = target.parent;
    }
    if (num > 0) {

    } else {
      var title = (!this.tree || this.tree.length <= this._activeTabIndex ? this.options.title : this.tree[this._activeTabIndex].title);
      var span = $('<span>').html(title);
      this._titleTextFrame.prepend(span);
    }

    this.adjust();
  },

  _makeLayer: function (li, a, item) {
    var cocoVisible = this._cocoTileLayer.getVisible();

    var target = this.current;

    var title = $('<div>').addClass('title').addClass('withinfo').html(item.title);
    var icon = item.iconUrl;
    if (icon) {
      a.css(
        {
          "background-image": "url(" + icon + ")"
        }
      );
    }
    if (item._visibleInfo || this._mapLayerList.exists(item)) {
      a.addClass('view');
    }
    else {
      a.removeClass('view');
    }
    a.addClass('item').append(title);

    if ( item.area ) {
      // 範囲
      var areaBtn = $('<a>').attr({
        'href': 'javascript:void(0);',
        'title' : GSI.Utils.getTooltipText("SELECTMAP","AREA") }).addClass('area_btn').html("");
      li.append(areaBtn);
      areaBtn.off('click').on('click', L.bind(this._onAreaBtnClick, this, a, item));
    }
    // 自分で作る色別標高図 設定
    if(item.id == CONFIG.FREERELIEFID){
      var settingBtn =  $('<a>').attr({
        'href': 'javascript:void(0);',
        'title' : GSI.Utils.getTooltipText("SELECTMAP","SETTING") }).addClass('setting_btn').html("");
      li.append(settingBtn);
      settingBtn.off('click').on('click', L.bind(this._onReliefStyleEidtClick, this, a, item));
    }
    // 詳細
    var descriptionBtn = $('<a>').attr({
      'href': 'javascript:void(0);',
      'title' : GSI.Utils.getTooltipText("SELECTMAP","INFORMATION") }).addClass('description_btn').html("i");
    li.append(descriptionBtn);
    descriptionBtn.off('click').on('click', L.bind(this._onLayerMouseEnter, this, a, item));

    if (CONFIG.VISIBLELAYERTYPE) {
      var info = $('<div>').addClass('info');
      if (item.cocotile) {
        var span = $('<span>').addClass('cocotile').html('ココタイル');
        info.append(span);
      }

      var typeTitle = CONFIG.LAYERTYPELIST[item.layerType];
      if (!typeTitle) typeTitle = { caption: item.layerType };
      var span = $('<span>').html(typeTitle.caption).addClass('layertype');
      info.append(span);

      li.append(info);
    }
    if (cocoVisible && item.cocotile && !item.hasTile) {
      a.removeClass('view');
      a.addClass('nococotile');
      li.addClass('nococotile');
    }
    else {
      a.removeClass('nococotile');
      li.removeClass('nococotile');
    }

    a.on('click',L.bind(this.onItemClick, this, a));
  },

  _onAreaBtnClick : function(a, item) {
    if (this._mapLayerList.exists(item) == false){
      this.onItemClick(a, item);
    }
    if ( !item.area ) return;
    var map = this._mapManager.getMap();

    var lat =undefined;
    var lng = undefined;
    var zoom = undefined;

    if ( item.area.lat || item.area.lat == 0 ) {
      lat = item.area.lat;
    }
    if ( item.area.lng || item.area.lng == 0 ) {
      lng = item.area.lng;
    }

    if ( item.area.zoom  ) {
      zoom = item.area.zoom;
    }
    if ( lat != undefined && lng != undefined && zoom != undefined) {
      map.setView([lat, lng], zoom);
      map.setView([lat, lng], zoom);  // 1回だけだとデータが表示されない場合がある
    } else if ( lat != undefined && lng != undefined ) {
      map.setView( [lat, lng]);
    } else if( zoom != undefined) {
      map.setZoom( zoom );
    }
  },

  _makeFolder: function (li, a, item) {

    var cocoVisible = this._cocoTileLayer.getVisible();
    if (item.title_sys && item.title_sys == CONFIG.layerBaseFolderSYS) {
      cocoVisible = false;
    }

    var entriesCount = -1;
    if (item.entries) {
      entriesCount = item.entries.length;
    }
    var isVisible = true;
    if (cocoVisible) {
      var getCOCOTileVisibleCount = function (entries, isTop) {
        var counter = 0;
        var currentCounter = 0;

        if (entries) {
          for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];
            if (entry.entries) {
              var entriesCount = getCOCOTileVisibleCount(entry.entries, false);
              counter += entriesCount.total;

              if (isTop && entriesCount.total > 0) {
                currentCounter++;
              }
            }
            else {
              if (!entry.cocotile || entry.hasTile) {
                currentCounter++;
                counter++;
              }
            }
          }
        }

        return { current: currentCounter, total: counter };
      };

      var count = getCOCOTileVisibleCount(item.entries, true);
      entriesCount = count.current;
      if (count.total <= 0) isVisible = false;
    }

    // 子要素あり
    var title = $('<div>').addClass('title').html(item.title);
    var num = $('<div>').addClass('num').append($('<span>').html(entriesCount));
    if (entriesCount >= 0) {
      a.addClass('folder').append(title).on('click',L.bind(this._onFolderClick, this, a));
    }
    else {
      a.addClass('folder').append(title).on('click',L.bind(this._onFolderClick, this, a));
    }

    if (item.iconUrl && item.iconUrl != "") {
      a.css({ "background-image": "url(" + item.iconUrl + ")" });
    }
    if (!isVisible) {
      a.addClass('nococotile');
      li.addClass('nococotile');
    }
    else {
      a.removeClass('nococotile');
      li.removeClass('nococotile');
    }
    if (item.html) {
      title.addClass("withinfo");
      var flddescriptionBtn = $('<a>').attr({ 'href': 'javascript:void(0);' }).addClass('flddescription_btn').html("i");
      li.append(flddescriptionBtn);
      flddescriptionBtn.off('click').on('click', L.bind(this._onLayerMouseEnter, this, a, item));
    }
  },

  _onFolderClick: function (a, item) {
    if (a) item = a.data('data');
    this.openFolder(item);
  },

  openFolder : function(item) {
    if ((item) && (item.title_evac && item.title_evac == CONFIG.layerEvacuationFolderSYS)) {
      if (this._checkEvacuationLayer() == false && !CONFIG.layerEvacuationIsConfirmOK) {
        this._mapManager._confirmDlg.onPositiveButtonClick = L.bind(this.onConfirmOkClick, this, item);
        this._mapManager._confirmDlg.show();
      }
      else {
        this._expandFolder(item);
      }
    }
    else {
      this._expandFolder(item);
      // 202303 hideにする条件を変更。
//      if (this._checkEvacuationLayer() == false && !CONFIG.layerEvacuationIsConfirmOK) {
      if (this._checkEvacuationLayer() == false) {
          this._mapManager._evacDialog.hide();
      }
    }
  },

  onConfirmOkClick: function (item) {
    this._mapManager._confirmDlg.hide();
    this._mapManager._evacDialog.show();

    CONFIG.layerEvacuationIsConfirmOK = true;
    this._expandFolder(item);
  },

  onFolderClick_Proc: function (item) {
    this.current = item;
    this._listContainer.fadeOut('fast',
      L.bind(function () {
        this._listContainer.fadeIn('fast');
        this.initializeList();
      }, this)
    );
  },

  _expandFolder: function (item) {
    var f = true;
    if (item) {
      if (item.src) {
        if (!item.entries) {
          if (!item.parent) item.parent = this.current;

          if (!item.src_ && item.src.indexOf('./') == 0) {
            var path = item.src_url.substring(0, item.src_url.lastIndexOf('/'));
            item.src_ = true;
            item.src = path + "/" + item.src.substr(2);
          }
          if (GSI.GLOBALS.layersJSONCache && GSI.GLOBALS.layersJSONCache[item.src]) {
            this.ajax_item = item;
            this._onFolderClickLoad(GSI.GLOBALS.layersJSONCache[item.src]);
          }
          else {
            this.ajax_item = item;
            this.ajax = $.ajax({
              type: "GET",
              url: item.src,
              dataType: "text",
              cache: CONFIG.LOADLAYERSTXTCACHE,
              success: L.bind(this._onFolderClickLoad, this),
              error: L.bind(this._onFolderClickLoadError, this)
            });
          }
          f = false;
        }
      }
    }

    if (f) {
      this.onFolderClick_Proc(item);
    }
  },

  _onFolderClickLoad: function (data) {
    var item = this.ajax_item;
    if (item) {

      if (!GSI.GLOBALS.layersJSONCache) GSI.GLOBALS.layersJSONCache = {};
      GSI.GLOBALS.layersJSONCache[item.src] = data;

      var json = JSON.parse(data);
      if (json.layers) {
        for (var i = 0; i < json.layers.length; i++) {
          json.layers[i].src_url = item.src_url;
        }
      }

      item.entries = json.layers;

      this._mapManager._layersJSON._initializeTree(item.entries, item);

      this.onFolderClick_Proc(item);
    }
  },
  _onFolderClickLoadError: function () {
    alert('レイヤー設定ファイルが読み込めませんでした。');
  },

  _checkEvacuationLayer: function () {
    if (this._mapLayerList) {
      var l = this._mapLayerList.getList();
      for (i = 0; i < l.length; i++) {
        if (l[i].id.indexOf(CONFIG.layerEvacuationHeader) >= 0) {
          return true;
        }
      }
      var tl = this._mapLayerList.getTileList();

      for (i = 0; i < tl.length; i++) {
        if (tl[i].id.indexOf(CONFIG.layerEvacuationHeader) >= 0) {
          return true;
        }
      }
    }
    return false;
  },

  _onLayerMouseEnter: function (a, item) {
    if (!this._toolTipViewCounter) {
      this._toolTipViewCounter = 0;
    }
    this._toolTipViewCounter++;

    this._showItemTooltip(a, item);
  },
  _onLayerMouseLeave: function (a, item) {
    this._hideItemTooltip(a, item);
  },

  onZoomCheck: function (item) {
    var zoom = this._mapManager.getMap().getZoom();
    if (item.maxZoom && zoom > item.maxZoom){
      return true;
    }
    if (item.minZoom && zoom < item.minZoom){
      return true;
    }
    return false;
  },

  onItemClick: function (a, item) {
    var target = this.current;

    if (a) item = a.data('data');

    this._current_id = item.id;

    var baseLayerTarget = null;

    for (var i = 0; i < this._mapManager._baseLayer.baseLayerList.length; i++) {
      if (item.id == this._mapManager._baseLayer.baseLayerList[i].id) {
        baseLayerTarget = this._mapManager._baseLayer.baseLayerList[i];
        break;
      }
    }

    var added = true;

    if (baseLayerTarget || (target && target.title_sys && target.title_sys == CONFIG.layerBaseFolderSYS)) {
      var f = false;
      if (this._mapLayerList.exists(item)) {
        f = true;
        added = false;
      }
      for (var i = 0; i < this._mapManager._baseLayer.baseLayerList.length; i++) {
        var baseLayer = this._mapManager._baseLayer.baseLayerList[i];
        if (this._mapLayerList.exists(baseLayer)) {
          this._mapLayerList.remove(baseLayer);
        }
      }
      if (f) {
        if ( this._currentItemId == item.id ) this._currentItemId = "";
        this._mapManager._map.removeLayer(this._mapManager._baseLayer);

      }
      else {
        this._currentItemId = item.id;
        this._mapManager._map.addLayer(this._mapManager._baseLayer);
        this._mapLayerList.append(item);
        GSI.Utils.sendSelectedLayer(this._current_id);
      }
    }
    else if (target && target.title_evac && target.title_evac == CONFIG.layerEvacuationFolderSYS) {

      var f = false;
      if (this._mapLayerList.exists(item)) {
        f = true;
        added = false;

      }

      this._onHideAllClick();
      if (f == false) {
        this._mapLayerList.append(item);
        if (this._mapManager._dialogManager.isVisibleDialog(GSI.GLOBALS.evacDialog) == false) {
          this._mapManager._evacDialog.show();
        }
        GSI.Utils.sendSelectedLayer(this._current_id);
      }
    }
    else if (target && target.title_disasterlore && target.title_disasterlore == CONFIG.DisasterLoreFolderSYS) {
      var f = false;
      if (item.id == CONFIG.DisasterLoreAll){
        if (this._mapLayerList.exists(item)) {
          f = true;
          added = false;
        }
        else{
          this._onHideAllClick();
        }
      }
      else{
        if (this._mapLayerList.exists(item)){
          f = true;
          added = false;
        }
        else{
          for(var x = 0; x < this._mapLayerList.list.length; x++){
            if (this._mapLayerList.list[x].id == CONFIG.DisasterLoreAll){
              this._mapLayerList.remove(this._mapLayerList.list[x]);
              break;
            }
          }
        }
      }
      if (f == false) {
        this._currentItemId = item.id;
        this._mapLayerList.append(item);
        GSI.Utils.sendSelectedLayer(this._current_id);
      }
      else{
        if ( this._currentItemId == item.id ) this._currentItemId = "";
        this._mapLayerList.remove(item);
      }
    }
    else if (target && target.title_evac && target.title_evac == CONFIG.VolcanoTerrainFolderSYS) {

      var f = false;
      if (this._mapLayerList.exists(item)) {
        f = true;
        added = false;

      }

      this._onHideAllClick();
      if (f == false) {
        // 火山地形図データの初期状態は合成して表示
        this._mapLayerList.append(item, null, null, null, true);
        GSI.Utils.sendSelectedLayer(this._current_id);
      }
    }
    else {
      if (!this._mapLayerList.exists(item)) {
        this._currentItemId = item.id;
        if (CONFIG.BLENDLAYERS[item.id])
          this._mapLayerList.append(item, null, null, null, true);
        else
          this._mapLayerList.append(item);
        GSI.Utils.sendSelectedLayer(this._current_id);

      }
      else {
        if ( this._currentItemId == item.id ) this._currentItemId = "";
        this._mapLayerList.remove(item);
        added = false;
      }
    }

    if (item && item.id == CONFIG.FREERELIEFID) {
      var targetItem = this._mapManager._layersJSON.layersHash[item.id];

      if (!targetItem) targetItem = item;
      if (targetItem._visibleInfo) this._onReliefStyleEidtClick(a, targetItem);
      else if (this._mapLayerList && this._mapLayerList._editReliefDialog) {
        this._mapLayerList._editReliefDialog.hide();
      }
    }

    // 202303 evacDialog生成後にzoomGuideを調整
    if (GSI.GLOBALS.gsimaps._mainMap && GSI.GLOBALS.gsimaps._mainMap._zoomGuide.getVisible()
        && !a[0].className.includes('view') && this.onZoomCheck(item)) {      

      $("#zoomGuideCheckbox").off('change').on('change', function(){
        var bol = $('#zoomGuideCheckbox').is(":checked");
        GSI.GLOBALS.gsimaps._mainMap._zoomGuide.setVisible(!bol);
      });

      // var posid = this._mapManager.options.position;
      // posid = posid.replace('full','left');
      var mintxt = '', maxtxt = '', minmaxtxt = GSI.TEXT.ANNAI.MINMAX;
      if (item.minZoom) mintxt = item.minZoom;
      if (item.maxZoom) maxtxt = item.maxZoom;
      minmaxtxt = minmaxtxt.replace('min', mintxt);
      minmaxtxt = minmaxtxt.replace('max', maxtxt);
      $('#zoomGuideCheckbox').prop('checked', false);
      $('#zoomGuideMinMax').text(minmaxtxt);

      // 202303 evacDialogが表示されている、もしくはこれから表示される場合に表示位置を調整する。
      var evacDialogOffset = $('#evacDialogContainer').offset();
      var evacCheck = false;

      if (target && target.title_evac && target.title_evac == CONFIG.layerEvacuationFolderSYS) {
        if (!this._mapLayerList.exists(item)) {
          if (this._mapManager._dialogManager.isVisibleDialog(GSI.GLOBALS.evacDialog) == false) {
            evacCheck = true;
          }
        }
      }
      
      if (evacDialogOffset || evacCheck) {
        var bottom = Number($(window).height()) - (Number(evacDialogOffset.top));
        bottom += 'px';
        $('#zoomGuidePanel').css('bottom', bottom);
      }

      $('#zoomGuidePanel').show();
      clearTimeout(GSI.ZOOMGUIDETIMER);
      GSI.ZOOMGUIDETIMER = setTimeout(function(){
        $('#zoomGuidePanel').slideUp(function() {
          if (evacDialogOffset) {
            $('#zoomGuidePanel').css('bottom', '35px');
          }
        });
      },3000);
    }

  },
  selectReliefFree: function (a, item) {
    //var target = this.current;

    //if (a) item = a.data('data');

    if (GSI.GLOBALS.gsimaps._mainMap._zoomGuide.getVisible()
    && !a[0].className.includes('view')
    && this.onZoomCheck(item)) {      

      $("#zoomGuideCheckbox").off('change').on('change', function(){
        var bol = $('#zoomGuideCheckbox').is(":checked");
        GSI.GLOBALS.gsimaps._mainMap._zoomGuide.setVisible(!bol);
      });

      // var posid = this._mapManager.options.position;
      // posid = posid.replace('full','left');
      var mintxt = '', maxtxt = '', minmaxtxt = GSI.TEXT.ANNAI.MINMAX;
      if (item.minZoom) mintxt = item.minZoom;
      if (item.maxZoom) maxtxt = item.maxZoom;
      minmaxtxt = minmaxtxt.replace('min', mintxt);
      minmaxtxt = minmaxtxt.replace('max', maxtxt);
      $('#zoomGuideCheckbox').prop('checked', false);
      $('#zoomGuideMinMax').text(minmaxtxt);
      $('#zoomGuidePanel').show();
      clearTimeout(GSI.ZOOMGUIDETIMER);
      GSI.ZOOMGUIDETIMER = setTimeout(function(){
        $('#zoomGuidePanel').slideUp();
      },3000);
    }

    //var added = true;

    if (!this._mapLayerList.exists(item)) {
      this._currentItemId = item.id;
      if (CONFIG.BLENDLAYERS[item.id])
        this._mapLayerList.append(item, null, null, null, true);
      else
        this._mapLayerList.append(item);
      GSI.Utils.sendSelectedLayer(this._current_id);

    }
    else {
      return;
    }

    this._current_id = item.id;

    if (item && item.id == CONFIG.FREERELIEFID) {
      var targetItem = this._mapManager._layersJSON.layersHash[item.id];

      if (!targetItem) targetItem = item;
      if (targetItem._visibleInfo) this._onReliefStyleEidtClick(a, targetItem);
      else if (this._mapLayerList && this._mapLayerList._editReliefDialog) {
        this._mapLayerList._editReliefDialog.hide();
      }
    }
  },

  _makeToolTip: function (item) {
    var infoFrame = $('<div>').addClass('layerinfo');

    var legend = null;
    var description = null;

    if ( CONFIG.baseMapDescription[item.id]) {
      var baseMapDescription =$('<div>').addClass('description').html(CONFIG.baseMapDescription[item.id] );
      infoFrame.append(baseMapDescription);
    }

    if (item.legendUrl && item.legendUrl != '') {
      legend = $('<a>').html(item.id=="english" ? "Show legend" : '凡例を表示').addClass('legend').attr({ 'href': item.legendUrl, 'target': '_blank' });
    }
    if (legend)
      infoFrame.append(legend);

    if (item.html) {

      var html = item.html.replace("GSI.GLOBALS.map",
        (this._mapManager == GSI.GLOBALS.gsimaps._mainMap ? "GSI.GLOBALS.gsimaps._mainMap._map" : "GSI.GLOBALS.gsimaps._subMap._map"));

      description = $('<div>').addClass('description').html(html);
    }
    if (description)
      infoFrame.append(description);

    if (item.id == CONFIG.FREERELIEFID) {
      var canvas = GSI.EditReliefDialog.makeHanreiImage(this._mapLayerList.getElevationData());
      if (canvas) {
        infoFrame.append(canvas);
      }
    }
    return infoFrame;
  },
  _onReliefStyleEidtClick: function (a, item) {
    this._curItem = undefined;
    this._hideItemTooltip();
    windowSize = GSI.Utils.getScreenSize();

    if (!this._mapLayerList._editReliefDialog) {
      this._mapLayerList._editReliefDialog = new GSI.EditReliefDialog(this._mapManager._dialogManager,
          this._mapManager.getMap(), this._mapLayerList, {
        width: 300, left: parseInt(windowSize.w / 2 - 160), top: windowSize.h - 500,
        effect: CONFIG.EFFECTS.DIALOG, listItem: a, listObj: item
      }
      );
    }
    this._mapLayerList._editReliefDialog.show();
  },

  _showItemTooltip: function (a, item) {
    if (item) {
      if (!this._curItem) {
        this._curItem = item;
      }
      else {
        if ((this._toolTipViewCounter % 2) == 0) {
          if (this._curItem == item) {
            this._curItem = undefined;
            this._toolTipViewCounter = 0;
            return;
          }
          else {
            this._toolTipViewCounter--;
          }
        }
        this._curItem = item;
      }

      if (!this._itemTooltip) {
        this._itemTooltip = $('<div>').addClass('gsi_layertreedialog_itemtooltip').hide();
        $(document.body).append(this._itemTooltip);
      }

      var offset = a.offset();

      var screenSize = GSI.Utils.getScreenSize();
      var left = offset.left + parseInt(a.outerWidth(true));
      var top = offset.top;

      this._itemTooltip.empty().append(this._makeToolTip(item));

      this._itemTooltip.css({
        left: 0 + 'px',
        top: 0 + 'px'
      });
      this._itemTooltip.css({ "visibility": "hidden", "width": "auto" });
      this._itemTooltip.css({
        "max-height":
          Math.floor(screenSize.h * 0.8) + "px"
      });
      this._itemTooltip.show();

      var tooltipWidth = this._itemTooltip.outerWidth();

      var maxWidth = (screenSize.w >= 350 ? 350 : screenSize.w);
      if (tooltipWidth + 30 > maxWidth) {
        tooltipWidth = maxWidth;
      } else {
        tooltipWidth += 30;
      }
      this._itemTooltip.css({ "width": tooltipWidth + "px" });

      if (left + tooltipWidth > screenSize.w) {
        left = screenSize.w - tooltipWidth;
        top = offset.top + a.outerHeight();
      }
      if (top + this._itemTooltip.outerHeight() > screenSize.h) {
        top = offset.top - this._itemTooltip.outerHeight();
      }

      if (top < 0) top = 0;

      this._itemTooltip.hide();
      this._itemTooltip.css({ "visibility": "visible" });

      this._itemTooltip.css({
        left: left + 'px',
        top: top + 'px'
      });

      this._itemTooltip.stop().hide().fadeIn('normal');

      if (this._hideToolTipHandler) {
        $(document.body).off('mousedown', this._hideToolTipHandler);
        $(document.body).off('touchstart', this._hideToolTipHandler);
        this._listFrame.off('scroll', this._hideToolTipHandler);
        this._hideToolTipHandler = null;
      }

      this._hideToolTipHandler = L.bind(function (event) {
        if (!this._itemTooltip || event.target == this._itemTooltip[0]) return;

        var parents = $(event.target).parents();

        for (var i = 0; i < parents.length; i++) {
          if (parents[i] == this._itemTooltip[0]) return;
        }

        this._hideItemTooltip();

        if (event.type == "scroll") {
          this._toolTipViewCounter = 0;
        }
      }, this);

      $(document.body).on('mousedown', this._hideToolTipHandler);
      $(document.body).on('touchstart', this._hideToolTipHandler);
      this._listFrame.on('scroll', this._hideToolTipHandler);

    }
    else {
      this._hideItemTooltip();
    }
  },

  // 結果用パンくず作成
  _makePankzu: function (target) {

    if (target._appendInfo) target = target._appendInfo;

    target = target.parent;
    var result = '';
    while (target) {
      result = target.title + (result == '' ? '' : '&gt;') + result;
      target = target.parent;
    }

    return result;
  },

  // 検索クリア
  _clearSearch: function () {
    this._searchResult.find("ul").empty().hide();
    this._hideSearchResult();
  },

  // 検索開始
  _startSearch: function () {
    this._searchResult.find("ul").empty().scrollTop(0).hide();

    this._searchResultTextFrame.find("span").html("検索中");
    this._searchResultTextFrame.css({ "background-image": "url(./image/system/loading003.gif)" });

    this._showSearchResult();
  },

  // 結果行作成
  _makeSearchResultItem: function (item) {
    var cocoVisible = this._cocoTileLayer.getVisible();
    var li = $("<li>");

    if (item.type == "LayerGroup" && item.layerType != "multiLayer")
      li.addClass("folder");

    li.data({ "item": item });

    if (!cocoVisible || !item.cocotile || item.hasTile)
      li.removeClass("nococotile");
    else
      li.addClass("nococotile");

    var a = $("<a>").attr({ "href": "javascript:void(0);" });

    var div = $("<div>").addClass("pankuzu").html(this._makePankzu(item));

    a.append(div);

    div = $("<div>").addClass("title").html(item.title);

    a.append(div);

    li.append(a);

    a.on('click',L.bind(function (item) {
      if (item.type == "LayerGroup" && item.layerType != "multiLayer") {
        this._hideSearchResult();
        this.onFolderClick(null, item);
      }
      else {
        this.onItemClick(null, item)
      }
    }, this, item));

    return li;
  },

  _showSearchResult: function () {

    this._listFrame.stop().hide();
    this._searchResult.stop().show();
    this._titleTextFrame.hide();
    this._searchResultTextFrame.show();

    if (!this._searchResultWindowMouseDown) {
      this._searchResultWindowMouseDown = L.bind(function (e) {
        if (this._searchResult[0] != e.target
          && this._searchResult.find(e.target).length <= 0
          && this._queryInput[0] != e.target
        ) {
          this._queryInput[0].trigger('blur');
          this._hideSearchResult();
        }
      }, this);
    }
  },

  // 検索解除クリック時
  _onClearSearchClick: function () {
    this._hideSearchResult();
  },

  _hideSearchResult: function () {
    this._searchResult.stop().hide();
    this._listFrame.stop().show();
    this._searchResultTextFrame.hide();
    this._titleTextFrame.show();

  },

  // 検索結果表示
  _appendSearchResult: function (list, all) {
    var cocoVisible = this._cocoTileLayer.getVisible();
    var ul = this._searchResult.find("ul");
    if (all && all.length > 0) ul.show();

    for (var i = 0; i < list.length; i++) {
      ul.append(this._makeSearchResultItem(list[i]));
    }

    if (all) {
      var num = this._getSearchResultNum();
      this._searchResultTextFrame.find("span")
        .html("検索中" + (cocoVisible ? "(表示範囲) " : "") + ":" + num + "件");
    }
    else {
      this._searchResultTextFrame.find("span")
        .html("検索中" + (cocoVisible ? "(表示範囲) " : "") + ":");
    }
  },

  // ヒットしたフォルダ内のレイヤ件数
  _getInnerGroupLayerCount: function (item) {
    var result = 0;

    if (!item.entries) return result;
    for (var j = 0; j < item.entries.length; j++) {
      if (item.entries[j].type != "LayerGroup") result++;
      else {
        result += this._getInnerGroupLayerCount(item.entries[j]);

      }
    }

    return result;
  },

  // ヒットしたレイヤ件数
  _getSearchResultNum: function () {
    var result = 0;

    var ul = this._searchResult.find("ul");
    var list = ul.find("li").not(".nococotile");

    for (var i = 0; i < list.length; i++) {
      var item = $(list[i]).data("item");

      if (item.type == "LayerGroup" && item.entries) {

        result += this._getInnerGroupLayerCount(item);

      }
      else
        result++;
    }

    return result;
  },

  _refreshSearchResult: function () {
    if (!this._searchResult) return;

    var cocoVisible = this._cocoTileLayer.getVisible();
    var ul = this._searchResult.find("ul");

    var liList = ul.find("li");

    for (var i = 0; i < liList.length; i++) {
      var li = $(liList[i]);
      var item = li.data("item");
      if (!cocoVisible || !item.cocotile || item.hasTile)
        li.removeClass("nococotile");
      else
        li.addClass("nococotile");
    }

    this._finishSearch();
  },

  // 検索終了
  _finishSearch: function (list) {

    var cocoVisible = this._cocoTileLayer.getVisible();
    var ul = this._searchResult.find("ul");
    var num = this._getSearchResultNum();
    this._searchResultTextFrame.css({ "background-image": "url(./image/system/info.png)" })
      .find("span")
      .html("検索結果" + (cocoVisible ? "(表示範囲) " : "") + ":" + num + "件");
  }
});

/************************************************************************
 GSI.MapPanelContainer
 - GSI.ShowingMapListPanel（表示中リスト表示用パネル）
 ************************************************************************/
GSI.ShowingMapListPanel = GSI.MapPanelContainer.extend({

  options: {
    className : "gsi-showingmaplistpanel-container"
  },

  initialize : function(mapManager,parentContainer, options) {
    this._mapManager = mapManager;
    this._mini = false;
    GSI.MapPanelContainer.prototype.initialize.call(this, parentContainer, options);
  },

  setMapLayerList : function(mapLayerList) {
    this._mapLayerList = mapLayerList;
    this._mapLayerList.on('change', L.bind(this._onMapLayerListChange, this));
  },
  setCocoTileLayer : function(cocoTileLayer) {
    this._cocoTileLayer = cocoTileLayer;
    cocoTileLayer.on('load', L.bind(this.onCOCOTileLoad, this));
    cocoTileLayer.on('hide', L.bind(this.onCOCOTileHide, this));

  },
  _showAfter : function() {
    this.adjust();
  },

  onCOCOTileLoad: function (e) {
    this._initializeList(true);
  },
  onCOCOTileHide: function (e) {
    this._initializeList(true);
  },

  adjust : function() {
    var controlHeight = this._controlFrame.outerHeight();
    this._listFrame.css({"top": ( this._controlFrame.position().top + 1 + controlHeight) + "px"});
  },
  _createAfter : function() {
    this._createContent();

    this._container.append( this._contentFrame);

    this.adjust();
  },

  _createContent: function () {
    this._contentFrame = $('<div>').addClass("gsi-showingmaplist-contentframe");

    this._headerFrame = $( "<div>").addClass("gsi-showingmaplist-headerframe");
    var title = $("<div>").addClass("title").html("選択中の地図");
    var resetButton = $("<a>").addClass("normalbutton").addClass("reset-button")
    .attr({
      "title": GSI.Utils.getTooltipText("SELECTMAP","RESET"),
      "href":"javascript:void(0);"}).html("リセット");

    resetButton.on('click',L.bind(this._onResetClick, this));
    this._headerFrame.append(title);
    this._headerFrame.append(resetButton);
    this._controlFrame = this._createControl();
    this._controlFrame.hide();

    this._listFrame = $('<div>').addClass('gsi-showingmaplist-scrollframe');

    this._listContainer = $('<ul>').addClass('viewlistdialog_ul')
    if (this._mini) {
      this._listContainer.addClass("mini");
    }
    var li = $('<li>').addClass('nodata').html('選択中の情報はありません');
    this._listContainer.append(li);

    this._listFrame.append(this._listContainer);

    this._contentFrame.append(this._headerFrame);
    this._contentFrame.append(this._controlFrame);
    this._contentFrame.append(this._listFrame);

    return this._contentFrame;
  },
  _createControl: function () {
    var frame = $('<div>').css({ 'height': '26px' }).addClass('gsi-showingmaplist-controlframe');

    this._saveOutsideTileBtn = $("<a>").css({ "font-size": "9px", "line-height": "20px", "position": "absolute", 'right': '4px', 'bottom': '2px', 'cursor': 'pointer' }).addClass('view_list_dialog_button').html("外部タイル設定保存");

    var frameRange = $('<div>').css({ 'position': 'absolute', 'right': '5px', 'bottom': '2px', 'opacity': '1' });

    frame.append(this._saveOutsideTileBtn);

    frame.append(frameRange);

    var dummy = $('<div>').html('&nbsp;').css({ "font-size": '9.5pt' });
    frame.append(dummy);

    this._saveOutsideTileBtn.on('click',L.bind(this._sasveOutsideTileBtnClick, this));

    return frame;
  },

  initializeList: function () {
    if (!this._contentFrame) return;

    if (!this._listContainer) {
      this._listContainer = $('<ul>').addClass('viewlistdialog_ul');
      if (this._mini) this._listContainer.addClass("mini");
      this._listFrame.empty().append(this._listContainer);
    }

    if (!this._tileListContainer) {
      this._tileListContainer = $('<ul>').addClass('viewlistdialog_ul');
      if (this._mini) this._tileListContainer.addClass("mini");
      this._listFrame.append(this._tileListContainer);
      if ( !CONFIG.MOBILE ) {
        this._tileListContainer.sortable({
          cursor: 'move',
          update: L.bind(this._onSortChange, this),
          handle: ".item_frame",
          cancel: ".item_frame_fixed",
          scroll: false,
          helper : 'clone',
          delay: 500
        });
      }
      this._tileListContainer.disableSelection();
    }

    this._contentFrame.scrollTop(0);
    this._listContainer.empty();
    this._tileListContainer.empty();

    this._initializeList();
    if (this._userResized) this._onResize();
  },

  _onSortChange: function (event, ui) {
    var liList = this._tileListContainer.find('li');
    var list = [];
    var f = true;
    for (var i = 0; i < liList.length; i++) {
      var item = $(liList[i]).data('data');
      if (item.parent && item.parent.title_sys && item.parent.title_sys == CONFIG.layerBaseFolderSYS) {
        if (i != liList.length - 1) {
          f = false;
          if ( !CONFIG.MOBILE ) this._tileListContainer.sortable("cancel");
          break;
        }
      }
      if (item) list.push(item);
    }

    if (f) {
      for (var i = 0; i < liList.length; i++) {
        var li = $(liList[i]);
        var isFirstTile = (i == 0);

        var isLastTile = (i >= list.length - 1 || (i == list.length - 2 &&
          list[list.length - 1].parent && list[list.length - 1].parent.title_sys && list[list.length - 1].parent.title_sys == CONFIG.layerBaseFolderSYS));

        if (isFirstTile)
          li.find(".updown_frame a.up").addClass("disabled");//.hide();
        else
          li.find(".updown_frame a.up").removeClass("disabled");//

        if (isLastTile)
          li.find(".updown_frame a.down").addClass("disabled");//.hide();
        else
          li.find(".updown_frame a.down").removeClass("disabled");//.show();
      }

      this._mapLayerList.refreshTileList(list);
    }
  },

  _sasveOutsideTileBtnClick: function () {
    var layersJSON = {
      "layers": [
        {
          "type": "LayerGroup",
          "title": "外部タイル",
          "entries": []
        }
      ]
    };

    var tileList = this._mapLayerList.getTileList();
    var hasOutsideTile = false;
    for (var i = 0; i < tileList.length; i++) {
      var item = tileList[i];
      if (!item._isOutside) continue;

      var entry = {
        "type": "Layer",
        "title": item.title,
        "url": item.url
      };
      if (item.minZoom || item.minZoom == 0) entry.minZoom = item.minZoom;
      if (item.maxZoom || item.maxZoom == 0) entry.maxZoom = item.maxZoom;
      if (item.maxNativeZoom || item.maxNativeZoom == 0) entry.maxNativeZoom = item.maxNativeZoom;
      if (item.tms) entry.tms = true;

      layersJSON.layers[0].entries.push(entry);
    }
    var layersJSONText = JSON.stringify(layersJSON, null, "  ");

    var blob = new Blob([layersJSONText], { "type": "text/plain" })

    var fileName = 'layers' + GSI.Utils.getTimeStampString();

    GSI.Utils.saveFile( "text/plain", fileName + ".txt", blob );

  },

  _onAddClick: function () {
    this._mapManager._layerTreeDialog.show();
  },
  _onResetClick: function () {
    this._resetTiles();
    this._checkEvacuationLayer();
  },

  setMiniMode : function(value) {
    if ( this._mini == value ) return;
    this._mini = value;
    if ( this._listContainer ) {
      if ( this._mini ) this._listContainer.addClass("mini");
      else this._listContainer.removeClass("mini");
    }
    if ( this._tileListContainer ) {
      if ( this._mini ) this._tileListContainer.addClass("mini");
      else this._tileListContainer.removeClass("mini");
    }
    if ( this._mapLayerList ) this.initializeList();
  },

  _enableLakeDepthForItem: function(id, enabled){
    if(id == "lakedata" && this._mapManager._footer){
      this._mapManager._footer.updateLakeDepthVisible(enabled);
      if(enabled) this._mapManager._footer._refresh();
    }
  },

  _makeLayer: function (li, a, item, isTile, isFirstTile, isLastTile) {
    var cocoVisible = this._cocoTileLayer.getVisible();

    if (item._isOutside)
      li.addClass("outside");

    var vClass = 'item_frame';
    var vClassTitle = 'title';
    var fBaseMap = false;
    var enablemt = false;
    if (item.parent && item.parent.title_sys && item.parent.title_sys == CONFIG.layerBaseFolderSYS) {
      vClass = 'item_frame_fixed';
      vClassTitle = 'title_base';
      fBaseMap = true;
    }

    a.addClass(vClass);

    if ((!GSI.Utils.Browser.ie && !L.Browser.edge) && (item.url) && (!fBaseMap)) {

      if ( item.layerType=="tile" ) { // item.url.match(/\.png|\.jpg|\.jpeg/g) ) {
        vClassTitle = 'title_mt';
        enablemt = true;
      }
    }

    li.data({ 'data': item });

    // タイトル
    var title = $('<div>').addClass(vClassTitle);

    // パンくず
    var pankuzu = $('<div>').addClass('pankuzu').html("&nbsp;");

    title.html(item.title);

    var viewMark = $('<span>');
    viewMark.addClass('viewmark');
    if (!item._visibleInfo._isHidden) {
      viewMark.addClass('viewmark');
      a.addClass('view');
      this._enableLakeDepthForItem(item.id, true);
    }
    else {
      viewMark.addClass('disable');
      a.removeClass('view');
      this._enableLakeDepthForItem(item.id, false);
    }
    a.append( viewMark);
    a.addClass('item').append(title);

    if (cocoVisible && item.cocotile && !item.hasTile) {
      a.removeClass('view');
      a.addClass('nococotile');
    }

    var buttonElements = {
      grayScale : undefined,
      mp : undefined,
      opacity : undefined,
      colorSet : undefined
    };

    // グレースケール
    if (fBaseMap) {
      if (
        (!GSI.Utils.Browser.ie && !GSI.Utils.Browser.isAndroid)
        ||
        (GSI.Utils.Browser.ie && (GSI.Utils.Browser.version < 10 || (CONFIG.USEIE10GRAYSCALE && GSI.Utils.Browser.version == 10) || (CONFIG.USEIE11GRAYSCALE && GSI.Utils.Browser.version >= 11)))
      ) {
        var grayScale = new GSI.ToggleSwitch({ className: 'toggle', checked: (this._mapManager._baseLayer.getGrayScale()) });
        var grayScaleElement = grayScale.getElement();
        grayScaleElement.attr({"title": GSI.Utils.getTooltipText("SELECTMAP","GRAYSCALE")});
        grayScaleElement.addClass("grayscale");
        grayScaleElement.on('change', L.bind(this._gray_scale, this, a, grayScale));

        li.append(grayScaleElement);
        buttonElements.grayScale = grayScaleElement.find("input");
      }
    }
    else {
      //乗算
      if (enablemt) {
        var mp = new GSI.ToggleSwitch({ className: 'toggle', checked: (item._visibleInfo.blend) });
        var mpElement = mp.getElement();
        mpElement.addClass("multiplytile");
        mpElement.attr({"title": GSI.Utils.getTooltipText("SELECTMAP","MULTIPLY")});
        mpElement.on('change', L.bind(this._onBlendSwitchChange, this, a, mp));

        li.append(mpElement);
        buttonElements.mp = mpElement.find("input");
      }
    }

    // 透過
    var opacityBtn = $("<a>").addClass("opacity_btn")
    .attr({ "href": "javascript:void(0);","title": GSI.Utils.getTooltipText("SELECTMAP","OPACITY") }).html('透過率');
    opacityBtn.on('click',L.bind(function (li) { this._onOpacityBtnClick(li); }, this,li));
    li.append(opacityBtn);
    buttonElements.opacity = opacityBtn;

    if (!L.Browser.mobile) {
      opacityBtn.tooltip({
        "show": { duration: 300 },
        "hide": { duration: 200 },
        "open": function (evt, ui) {
        },
        "position": { my: "left+20 center", at: "center center", collision: "flipfit" }
      });
    }
    // メニューボタン
    var menuBtn = $("<a>").addClass("menubtn").attr({ "href": "javascript:void(0);"});
    menuBtn.on('click',L.bind(this._onMenuButtonClick, this, menuBtn, buttonElements));
    li.append(menuBtn);

    // 自分で作る色別標高図 設定
    if(item.id == CONFIG.FREERELIEFID){
      var settingBtn = $("<span>").addClass('setting_btn')
      .attr({"title": GSI.Utils.getTooltipText("SELECTMAP","SETTING")});
      li.append(settingBtn);
      settingBtn.off('click').on('click', L.bind(this._onReliefStyleEidtClick, this, a, item));
      li.addClass("free_relief_id");
      buttonElements.colorSet = settingBtn;
    }

    // 詳細
    if (item._isOutside) {

      var outsideEditBtn = $('<span>').addClass('outside_edit_btn').html("編集");
      li.append(outsideEditBtn);
      outsideEditBtn.off('click').on('click', L.bind(this._onOutsideEidtEnter, this, a, item));
    }
    else {

      var descriptionBtn = $('<span>')
        .attr({"title": GSI.Utils.getTooltipText("SELECTMAP","INFORMATION")})
        .addClass('description_btn').html("i");
      li.append(descriptionBtn);
      descriptionBtn.off('click').on('click', L.bind(this._onLayerMouseEnter, this, a, item));
    }

    // 閉じる
    var closeBtn = $("<span>").addClass('closebtn')
      .attr({"title": GSI.Utils.getTooltipText("SELECTMAP","REMOVE")});
    li.append(closeBtn);
    closeBtn.off('click').on('click', L.bind(this._onRemoveClick, this, li));

    // ソート
    if (isTile && !fBaseMap && (!isFirstTile || !isLastTile)) {

      var updownFrame = $("<div>").addClass('updown_frame');
      var upButton = $("<a>").attr({
        "title": GSI.Utils.getTooltipText("SELECTMAP","UP"),
        "href": "javascript:void(0);" }).addClass("up")
        .on('click',L.bind(function () { this._up(li); }, this));
      var downButton = $("<a>").attr({
        "title": GSI.Utils.getTooltipText("SELECTMAP","DOWN"),
        "href": "javascript:void(0);" }).addClass("down")
        .on('click',L.bind(function () { this._down(li); }, this));

      if (isFirstTile)
        upButton.addClass("disabled");//.hide();
      else {
        upButton.removeClass("disabled");//.hide();
      }
      if (isLastTile)
        downButton.addClass("disabled");//.hide();
      else {
        downButton.removeClass("disabled");//.hide();
      }
      buttonElements.up = upButton;
      buttonElements.down = downButton;

      updownFrame.append(upButton).append(downButton);
      li.append(updownFrame);

    }

    a.on('click',L.bind(this._onItemClick, this, li, a, viewMark));
  },

  _onMenuButtonClick : function(menuBtn,menuElements) {

    if ( !this._popupLayerMenu ) {
      this._popupLayerMenu = new GSI.ShowingMapListPanel.PopupLayerMenu(
        this._listFrame, this._contentFrame.parents(".gsi-mapmenu-container"));
    }
    this._popupLayerMenu.show( menuBtn, menuElements);
  },

  refresh: function (visibleLayers) {
    this._removeAll();
    var needsrc = new Array();
    this._ljsSrc = new GSI.layersJSONSearchSRC(this._mapManager);

    for (var i = 0; i < visibleLayers.length; i++) {
      var l = visibleLayers[i];
      needsrc.push(l.id);
    }
    if (needsrc.length > 0){
      this._ljsSrc.kick(needsrc);
      var outerthis = this;
      this._ljsSrc.on('searchEnd', L.bind(function (){
        outerthis._initializeList(true);
      }));
    }
    else{
      this._initializeList(true);
    }
  },
  _initializeList: function (liRefresh) {
    this._hideItemTooltip();
    var list = this._mapLayerList.getList();
    var tileList = this._mapLayerList.getTileList();

    if (list.length <= 0 && tileList.length <= 0) {
      this._listContainer.empty();
      var li = $('<li>').addClass('nodata').html('選択中の情報はありません');
      this._listContainer.append(li);
    }

    var liList = (liRefresh ? this._listContainer.children('li') : null);
    var ul = this._listContainer;
    this._initializeListOne(list, liList, ul, liRefresh);

    if (this._tileListContainer) {
      liList = (liRefresh ? this._tileListContainer.children('li') : null);
      ul = this._tileListContainer;
      this._initializeListOne(tileList, liList, ul, liRefresh, true);
      try {
        if ( !CONFIG.MOBILE )this._tileListContainer.sortable("refresh");
      }catch(e){}
    }
  },
  _initializeListOne: function (list, liList, ul, liRefresh, isTile) {

    for (var i = 0; i < list.length; i++) {
      var item = list[i];
      var li = (liRefresh ? $(liList[i]) : $('<li>'));

      if (liRefresh) {
        this._updateLayer(li, item, isTile,
          i == 0,
          i >= list.length - 1 || (i == list.length - 2 &&
            list[list.length - 1].parent && list[list.length - 1].parent.title_sys && list[list.length - 1].parent.title_sys == CONFIG.layerBaseFolderSYS));
      }
      else {
        var a = $('<a>').attr({ 'href': 'javascript:void(0);' });
        a.data({ 'data': item });
        this._makeLayer(li, a, item, isTile, i == 0,
          i >= list.length - 1 || (i == list.length - 2 &&
            list[list.length - 1].parent && list[list.length - 1].parent.title_sys && list[list.length - 1].parent.title_sys == CONFIG.layerBaseFolderSYS));
        li.append(a);
      }

      if (!liRefresh) ul.append(li);
    }
  },
  _onAreaBtnClick : function(a, item) {
    if ( !item.area ) return;
    var map = this._mapManager.getMap();

    var lat =undefined;
    var lng = undefined;
    var zoom = undefined;

    if ( item.area.lat || item.area.lat == 0 ) {
      lat = item.area.lat;
    }
    if ( item.area.lng || item.area.lng == 0 ) {
      lng = item.area.lng;
    }

    if ( item.area.zoom  ) {
      zoom = item.area.zoom;
    }
    if ( lat != undefined && lng != undefined && zoom != undefined) {
      map.setView([lat, lng], zoom);
    } else if ( lat != undefined && lng != undefined ) {
      map.setView( [lat, lng]);
    } else if( zoom != undefined) {
      map.setZoom( zoom );
    }
  },

  _onOutsideEidtEnter: function (a, item) {
    if (!this._editOutsideDialog) {
      windowSize = GSI.Utils.getScreenSize();
      this._editOutsideDialog = new GSI.EditOutsideTileDialog(this._mapManager._dialogManager, this._map, {
        width: 320, left: parseInt(windowSize.w / 2 - 160), top: windowSize.h - 500,
        effect: CONFIG.EFFECTS.DIALOG
      }
      );

      this._editOutsideDialog.on("change", L.bind(function (e) {

        this._mapLayerList.updateTileLayer(e._target);
      }, this));
    }

    this._editOutsideDialog.show(item);

  },

  _onItemClick: function (li, a, viewMark) {
    var item = a.data('data');
    var item_layer = item._visibleInfo.layer;

    if (item.parent && item.parent.title_sys && item.parent.title_sys == CONFIG.layerBaseFolderSYS) {
      item_layer = this._mapManager._baseLayer;
    }

    if (item._visibleInfo._isHidden) {
      item._visibleInfo._isHidden = false;
      this._mapManager.getMap().addLayer(item_layer);

      viewMark.addClass('viewmark');//.html('表示');
      viewMark.removeClass('disable');

      a.addClass('view');
      if (item.id.indexOf(CONFIG.layerEvacuationHeader) >= 0) {
        if (this._mapManager._dialogManager.isVisibleDialog(this._mapManager._evacDialog) == false) {
          this._mapManager._evacDialog.show();
        }
      }
    }
    else {
      item._visibleInfo._isHidden = true;
      this._mapManager.getMap().removeLayer(item_layer);

      viewMark.addClass('viewmark');
      viewMark.addClass('disable');
      a.removeClass('view');
      if (item.id.indexOf(CONFIG.layerEvacuationHeader) >= 0) {
        this._mapManager._evacDialog.hide();
      }
    }

    if (item._visibleInfo.blend) {
      this._blendTile(a, item._visibleInfo.blend);
    }

    this._mapLayerList.fire("visiblechange");

    var cocoVisible = this._cocoTileLayer.getVisible();
    if (cocoVisible && item.cocotile && !item.hasTile) {
      a.removeClass("view");
      a.addClass("nococotile");
    }
  },
  showReliefFree: function (item) {
    if (!item) return;

    var item_layer = item._visibleInfo.layer;

    if (item._visibleInfo._isHidden) {
      item._visibleInfo._isHidden = false;
      this._mapManager.getMap().addLayer(item_layer);
    }

    if (item._visibleInfo.blend) {
      //this._blendTile(a, item._visibleInfo.blend);
      if (!GSI.Utils.Browser.ie && !GSI.Utils.Browser.edge) {
        GSI.Utils.setMixBlendMode(item, true);
      } 
    }

    this._mapLayerList.fire("visiblechange");
  },
  _onMapLayerListChange: function () {

    var tileList = this._mapLayerList.getTileList();
    var hasOutsideTile = false;
    for (var i = 0; i < tileList.length; i++) {
      if (tileList[i]._isOutside) {
        hasOutsideTile = true;
        break;
      }
    }

    if (hasOutsideTile) {
      this._controlFrame.show();
      this.adjust();
    }else {
      this._controlFrame.hide();
      this.adjust();
    }

    if (CONFIG.USEATTRPANEL == true) {
      this._mapManager._attrpanel.updateContent(this._mapLayerList);
    }

    this.initializeList();

    this.fire("change");

  },

  _hideItemTooltip: function (a, item) {
    if (this._hideToolTipHandler) {
      $(document.body).off('mousedown', this._hideToolTipHandler);
      $(document.body).off('touchstart', this._hideToolTipHandler);
      this._listFrame.off('scroll', this._hideToolTipHandler);
      this._hideToolTipHandler = null;
    }
    if (this._itemTooltip) {
      this._itemTooltip.stop().hide();
      this._toolTipViewCounter = 0;
    }
  },
  _opacity_stop: function (a, opacity, c) {
    if (this._opacity_tm != null) { clearTimeout(this._opacity_tm); }
    if (this._opacity_tmi != null) { clearInterval(this._opacity_tmi); }

    var eUpTime = new Date().getTime();
    if (eUpTime - this.eDownTime < this.eDownMS) {
      this._opacity(a, opacity, c);
    }

    this.eDownTime = null;
  },
  _gray_scale: function (a, sw) {
    var item = a.data('data');
    if (item.parent && item.parent.title_sys && item.parent.title_sys == CONFIG.layerBaseFolderSYS) {
      item._visibleInfo.grayscale = sw.checked();

      this._mapManager._baseLayer.setGrayScale(sw.checked());
    }
  },

  _updateLayer: function (li, item, isTile, isFirstTile, isLastTile) {
    var cocoVisible = this._cocoTileLayer.getVisible();

    if (cocoVisible && item.cocotile && !item.hasTile) {
      li.find("a").removeClass("view");
      li.find("a").addClass("nococotile");
    }
    else {
      if (item._visibleInfo._isHidden) {
        li.find("a").removeClass("view");
      }
      else {
        li.find("a").addClass("view");
      }
      li.find("a").removeClass("nococotile");
    }

    if (isFirstTile)
      li.find(".updown_frame a.up").addClass("disabled");//.hide();
    else
      li.find(".updown_frame a.up").removeClass("disabled");//.show();

    if (isLastTile)
      li.find(".updown_frame a.down").addClass("disabled");//.hide();
    else
      li.find(".updown_frame a.down").removeClass("disabled");//.show();

  },

  _onLayerMouseEnter: function (a, item) {
    if (!this._toolTipViewCounter) {
      this._toolTipViewCounter = 0;
    }
    this._toolTipViewCounter++;

    this._showItemTooltip(a, item);
  },
  _onLayerMouseLeave: function (a, item) {
    this._hideItemTooltip(a, item);
  },
  _onBlendSwitchChange: function (a, mp) {

    var item = a.data('data');
    item._visibleInfo.blend = mp.checked();
    this._blendTile(a, mp.checked());
  },

  _onPankzFolderClick : function(a) {
    var target = a.data("data");
    this.fire("folderclick",{"folder" : target });
  },
  _makePankz : function( target ) {
    var pankz = $("<div>");

    if (target._isOutside) {
      return "外部タイル";
    }

    if ( CONFIG.baseMapDescription[target.id]) {
      return target.title;
    }

    if (target._appendInfo) target = target._appendInfo;

    var num = 0;
    target = target;
    while (target) {
      if (num > 0) {
        var a = $('<a>').html(target.title).attr({ 'href': 'javascript:void(0);' });
        var span = $('<span>').html("&nbsp;&gt;&nbsp;");
        pankz.prepend(span);

        a.on('click',
          L.bind(this._onPankzFolderClick, this, a)
        ).data({ 'data': target });

        pankz.prepend(a);
      }
      else {
        var span = $('<span>').html(target.title);
        pankz.prepend(span);
      }

      num++;
      target = target.parent;
    }

    return pankz;
  },

  _makeToolTip: function (item) {
    var infoFrame = $('<div>').addClass('layerinfo')
      .css({ "max-width": "350px" });

    var pankzframe = $( "<div>").addClass("pankz-frame");
    pankzframe.append(this._makePankz(item));
    infoFrame.append(pankzframe);

    var legend = null;
    var description = null;

    if ( CONFIG.baseMapDescription[item.id]) {
      var baseMapDescription =$('<div>').addClass('description').html(CONFIG.baseMapDescription[item.id] );
      infoFrame.append(baseMapDescription);
    }

    if (item.legendUrl && item.legendUrl != '') {
      legend = $('<a>').html(item.id=="english" ? "Show legend" : '凡例を表示').addClass('legend').attr({ 'href': item.legendUrl, 'target': '_blank' });
    }
    if (legend)
      infoFrame.append(legend);

    if (item.html) {
      var html = item.html.replace("GSI.GLOBALS.map",
        (this._mapManager == this._mapManager._gsimaps._mainMap ? "GSI.GLOBALS.gsimaps._mainMap._map" : "GSI.GLOBALS.gsimaps._subMap._map"));
      description = $('<div>').addClass('description').html(html);
    }

    if (description)
      infoFrame.append(description);

    if (item.id == CONFIG.FREERELIEFID) {
      var canvas = GSI.EditReliefDialog.makeHanreiImage(this._mapLayerList.getElevationData());
      if (canvas) {
        infoFrame.append(canvas);
      }
    }

    return infoFrame;
  },

  _showAll: function (list) {
    for (var i = 0; i < list.length; i++) {
      var item = list[i];
      if (item._visibleInfo._isHidden) {
        item._onOffSwitch.checked(true);
        item._visibleInfo._isHidden = false;
        this._mapManager.getMap().addLayer(item._visibleInfo.layer);
      }
    }
  },
  _hideAll: function (list) {
    for (var i = 0; i < list.length; i++) {
      var item = list[i];
      if (!item._visibleInfo._isHidden) {
        item._onOffSwitch.checked(false);

        item._visibleInfo._isHidden = true;
        this._mapManager.getMap().removeLayer(item._visibleInfo.layer);
      }
    }
  },
  _removeAll: function () {
    this._mapLayerList.clear();
  },

  _onReliefStyleEidtClick: function (item) {
    this._curItem = undefined;
    this._hideItemTooltip();
    windowSize = GSI.Utils.getScreenSize();

    if (!this._mapLayerList._editReliefDialog) {
      this._mapLayerList._editReliefDialog = new GSI.EditReliefDialog(this._mapManager._dialogManager,
        this._mapManager.getMap(), this._mapLayerList, {
        width: 300, left: parseInt(windowSize.w / 2 - 160), top: windowSize.h - 500,
        effect: CONFIG.EFFECTS.DIALOG
      }
      );
    }
    this._mapLayerList._editReliefDialog.show();
  },

  _showItemTooltip: function (a, item) {
    if (item) {
      if (!this._curItem) {
        this._curItem = item;
      }
      else {
        {
          if (this._curItem == item) {
            this._curItem = undefined;
            this._toolTipViewCounter = 0;
            return;
          }
          else {
            this._toolTipViewCounter--;
          }
        }
        this._curItem = item;
      }

      if (!this._itemTooltip) {
        this._itemTooltip = $('<div>').addClass('gsi_layertreedialog_itemtooltip').hide();
        $(document.body).append(this._itemTooltip);
      }

      var offset = a.offset();

      var screenSize = GSI.Utils.getScreenSize();
      var left = offset.left + parseInt(a.outerWidth());
      var top = offset.top;

      this._itemTooltip.empty().append(this._makeToolTip(item));

      this._itemTooltip.css({
        left: 0 + 'px',
        top: 0 + 'px'
      });
      this._itemTooltip.css({ "visibility": "hidden", "width": "auto" });
      this._itemTooltip.css({
        "max-height":
          Math.floor(screenSize.h * 0.8) + "px"
      });
      this._itemTooltip.show();

      var tooltipWidth = this._itemTooltip.outerWidth();

      var maxWidth = (screenSize.w >= 350 ? 350 : screenSize.w);
      if (tooltipWidth + 30 > maxWidth) {
        tooltipWidth = maxWidth;
      } else {
        tooltipWidth += 30;
      }
      this._itemTooltip.css({ "width": tooltipWidth + "px" });

      if (left + tooltipWidth > screenSize.w) {
        left = screenSize.w - tooltipWidth;
        top = offset.top + a.outerHeight();
      }
      if (top + this._itemTooltip.outerHeight() > screenSize.h) {
        top = offset.top - this._itemTooltip.outerHeight();
      }

      if (top < 0) top = 0;

      this._itemTooltip.hide();
      this._itemTooltip.css({ "visibility": "visible" });
      this._itemTooltip.css({
        left: left + 'px',
        top: top + 'px'
      });

      this._itemTooltip.stop().hide().fadeIn('normal');

      if (this._hideToolTipHandler) {
        $(document.body).off('mousedown', this._hideToolTipHandler);
        $(document.body).off('touchstart', this._hideToolTipHandler);
        this._listFrame.off('scroll', this._hideToolTipHandler);
        this._hideToolTipHandler = null;
      }

      this._hideToolTipHandler = L.bind(function (event) {
        if (!this._itemTooltip || event.target == this._itemTooltip[0]) return;

        var parents = $(event.target).parents();

        for (var i = 0; i < parents.length; i++) {
          if (parents[i] == this._itemTooltip[0]) return;
        }

        var fToopTop = false;
        if ($(event.target).is(".switch") || $(event.target).is(".inner") || $(event.target).is(".btn")) {
          fToopTop = true;
        }

        if (!fToopTop) {
          if (!$(event.target).is(".description_btn")) {
            this._curItem = undefined;
          }
          this._hideItemTooltip();
        }

        if (event.type == "scroll") {
          this._toolTipViewCounter = 0;
        }
      }, this);

      $(document.body).on('mousedown', this._hideToolTipHandler);
      $(document.body).on('touchstart', this._hideToolTipHandler);
      this._listFrame.on('scroll', this._hideToolTipHandler);

    }
    else {
      this._hideItemTooltip();
    }
  },

  _resetTiles: function () {
    this._mapManager._baseLayer.setActiveIndex(0);
    var std = this._mapManager._baseLayer.baseLayerList[0];

    this._removeAll();
    this._mapLayerList.append(std);

    this._mapManager._baseLayer.setGrayScale(false);

    if (!this._mapManager.getMap().hasLayer(this._mapManager._baseLayer)) {
      this._mapManager.getMap().addLayer(this._mapManager._baseLayer);
    }
    this.initializeList();
  },
  _onRemoveClick: function (li) {

    var item = li.data('data');

    if (item && item.id == CONFIG.FREERELIEFID && this._mapLayerList._editReliefDialog)
      this._mapLayerList._editReliefDialog.hide();

    if (item.parent && item.parent.title_sys && item.parent.title_sys == CONFIG.layerBaseFolderSYS) {
      this._mapManager.getMap().removeLayer(this._mapManager._baseLayer);

    }
    li.fadeOut('fast', L.bind(function (li) {
      this._mapLayerList.remove(item);
      li.remove();
      this._checkEvacuationLayer();
      if (this._userResized) this._onResize();
    }, this, li));
  },

  _onOpacityBtnClick: function (li) {

    var item = li.data('data');
    var opacity = (item._visibleInfo ? item._visibleInfo.opacity : 1);
    if (!this._opacityWindow) {
      this._opacityWindow = $('<div>').addClass('viewlistdialog_opacity_window');
      this._opacityValue = $('<div>').addClass('value').html('透過率:');
      this._opacitySlider = $('<div>').addClass('slider').html('&nbsp;');
      this._opacityWindow.append(this._opacityValue).append(this._opacitySlider);
      $("body").append(this._opacityWindow);
      this._opacitySlider.slider({
        min: 0,
        max: 100
      });
    }
    else if (this._opacityWindow && this._opacityWindow.is(":visible") && this._opacityWindow.data("item") == item) {
      this._opacityWindow.slideUp(200);
      return;
    }
    var offset = li.find(".description_btn").offset();
    if ( !offset ) offset = li.find(".outside_edit_btn").offset();
    var left = offset.left - 200 ;
    if ( left < 0 ) left = 0;
    var height = li.find(".description_btn").outerHeight();
    if ( !height ) height =  li.find(".outside_edit_btn").outerHeight();

    this._opacityWindow.css({
      top: offset.top + height - 2,
      left: left+ 'px'
    }).data({ "item": item });

    var opacityPercentage = Math.round(100 - (opacity * 100));
    this._opacityValue.html('透過率:' + opacityPercentage + '%');
    this._opacitySlider.data({ "__target_item": item }).slider("option", "value", opacityPercentage);
    this._opacitySlider.off("slide").on("slide", L.bind(function (event, ui) {
      var item = this._opacitySlider.data('__target_item');
      var value = ui.value;// this._opacitySlider.slider( "option", "value" );
      this._opacityValue.html('透過率:' + value + '%');
      var opacity = value / 100.0;
      if (opacity < 0) opacity = 0;
      if (opacity > 1) opacity = 1;
      opacity = 1 - opacity;
      if (item.parent && item.parent.title_sys && item.parent.title_sys == CONFIG.layerBaseFolderSYS) {
        this._mapManager._baseLayer.setOpacity(opacity);
        item._visibleInfo.opacity = opacity;
      }
      else {
        item._visibleInfo.layer.setOpacity(opacity);
        item._visibleInfo.opacity = opacity;
      }
    }, this));

    if (this._hideOpacityWindowHandler) {
      $(document.body).off('mousedown', this._hideOpacityWindowHandler);
      $(document.body).off('touchstart', this._hideOpacityWindowHandler);

    }
    this._hideOpacityWindowHandler = L.bind(function (event) {
      if (!this._opacityWindow
        || event.target == this._opacityWindow[0]
        || $(event.target).is(".opacity_btn")) return;

      var parents = $(event.target).parents();

      var hit = false;
      for (var i = 0; i < parents.length; i++) {
        if ($(parents[i]).is(".viewlistdialog_opacity_window")) {
          hit = true;
          break;
        }
      }
      if (!hit) {
        this._opacityWindow.slideUp(200);
        $(document.body).off('mousedown', this._hideOpacityWindowHandler);
        $(document.body).off('touchstart', this._hideOpacityWindowHandler);
      }
    }, this);

    $(document.body).on('mousedown', this._hideOpacityWindowHandler);
    $(document.body).on('touchstart', this._hideOpacityWindowHandler);

    this._opacityWindow.hide().slideDown(200);

  },
  _up: function (li) {
    var item = li.data('data');
    var tileList = this._mapLayerList.getTileList();
    var hit = false;
    for (var i = 1; i < tileList.length; i++) {
      if (item == tileList[i]) {
        hit = true;
        break;
      }

    }
    if (hit) li.prev().before(li.detach());

    this._onSortChange();
    this._initializeList(true);
  },

  _down: function (li) {
    var item = li.data('data');
    var tileList = this._mapLayerList.getTileList();
    var hit = false;
    for (var i = 0; i < tileList.length; i++) {
      if (item == tileList[i]) {
        if (i < tileList.length - 1) {
          var nextItem = tileList[i + 1];

          if (nextItem.parent && nextItem.parent.title_sys && nextItem.parent.title_sys == CONFIG.layerBaseFolderSYS) {

          }
          else hit = true;
        }
        break;
      }

    }
    if (hit) li.next().after(li.detach());

    this._onSortChange();
    this._initializeList(true);
  },

  _checkEvacuationLayer: function () {
    if (this._mapLayerList) {
      var l = this._mapLayerList.getList();
      for (i = 0; i < l.length; i++) {
        if (l[i].id.indexOf(CONFIG.layerEvacuationHeader) >= 0) {
          return true;
        }
      }
      var tl = this._mapLayerList.getTileList();

      for (i = 0; i < tl.length; i++) {
        if (tl[i].id.indexOf(CONFIG.layerEvacuationHeader) >= 0) {
          return true;
        }
      }
    }
    if (this._mapManager._mapMenu.getMapListPanel().current) {
      if (this._mapManager._mapMenu.getMapListPanel().current.title_evac) {
        return true;
      }
    }

    this._mapManager._evacDialog.hide();
    return false;
  },
  _blendTile: function (a, flg) {
    if (GSI.Utils.Browser.ie || GSI.Utils.Browser.edge) {
      return;
    }

    var item = a.data('data');
    GSI.Utils.setMixBlendMode(item, flg);

  }
});

GSI.ShowingMapListPanel.PopupLayerMenu = L.Evented.extend({
  options : {

  },

  initialize : function(listFrame,ownerContainer) {
    this._listFrame = listFrame;
    this._ownerContainer = ownerContainer;
  },

  _initEvents : function() {
    if ( !this._scrollHandler ) {
      this._scrollHandler = L.bind( function(){ this.hide();}, this );
      this._listFrame.on("scroll",this._scrollHandler);
    }

    if ( !this._windowMousedownHandler ) {
      this._windowMousedownHandler = L.bind( function(evt){
        if ( !this._container) return;
        var target = evt.target;
        while(target) {
          if ( target == this._container[0]) return;
          target = target.parentNode;
        }
        this.hide();
      }, this );
      $(document.body).on("mousedown",this._windowMousedownHandler).on("touchstart",this._windowMousedownHandler);
    }
  },

  _destroyEvents : function() {
    if ( this._scrollHandler ) {
      this._listFrame.off("scroll",this._scrollHandler);
      this._scrollHandler = undefined;
    }

    if ( this._windowMousedownHandler ) {
      $(document.body).off("mousedown",this._windowMousedownHandler).off("touchstart",this._windowMousedownHandler);
      this._windowMousedownHandler = undefined;
    }
  },

  show : function(btn, buttonElements) {

    if ( this._container && this._container.is(":visible") && this._buttonElements == buttonElements ) {
      this.hide();
      return;
    }

    this._buttonElements = buttonElements;
    this._btn = btn;
    this._create();

    var framePos = this._ownerContainer.offset();

    this._container.css({
      "visibility" : "hidden"
    }).show();
    var height = this._container.outerHeight();
    var width = this._container.outerWidth();
    this._container.css({
      "visibility" : "visible"
    }).hide();

    var pos = this._btn.offset();
    pos.left = this._btn.position().left;
    pos.left -= (width-35);

    this._container.css( {
      left : pos.left + "px",
      top:( pos.top - framePos.top-height - 2) + "px"
    })

    this._initEvents();
    this._container.fadeIn(200);
  },

  _create : function() {
    if ( this._container ) this._container.remove();
    this._container = $("<div>").addClass("gsi-showingmaplist-layerpopup").hide();
    var ul = $("<ul>");

    if ( this._buttonElements.up && !this._buttonElements.up.hasClass("disabled") ) {
      ul.append( this._createLine("手前に表示",this._buttonElements.up) );
    }
    if ( this._buttonElements.down && !this._buttonElements.down.hasClass("disabled") ) {
      ul.append( this._createLine("後ろに表示",this._buttonElements.down) );
    }

    if ( this._buttonElements.grayScale ) {
      ul.append( this._createLine("グレースケール",this._buttonElements.grayScale,this._buttonElements.grayScale[0].checked) );
    }

    if ( this._buttonElements.mp ) {
      ul.append( this._createLine("合成",this._buttonElements.mp, this._buttonElements.mp[0].checked) );
    }

    if ( this._buttonElements.opacity ) {
      ul.append( this._createLine("透過率",this._buttonElements.opacity) );
    }

    if ( this._buttonElements.colorSet ) {
      ul.append( this._createLine("スタイル変更",this._buttonElements.colorSet) );
    }

    this._container.append(ul);
    this._ownerContainer.append( this._container );

  },

  _createLine : function(title, elem, checked) {
    var li = $("<li>");

    if ( checked == undefined ) {

      var a = $("<a>").attr({"href":"javascript:void(0);"});
      a.html(title);

      a.on("click",L.bind(function(elem) {
        elem.trigger('click');
        this.hide();
      },this,elem));

      li.append(a);
    } else {
      var onOff = new GSI.OnOffSwitch({ className: 'onoff', checked: checked });
      var onOffElem = onOff.getElement();
      var label = $("<label>").html(title).attr({"for":onOff.getId()});
      li.append( label );
      li.append( onOffElem );

      onOff.on('change', L.bind(function(elem,onOff,evt){
        if ( elem[0].checked != onOff.checked() ) {
          elem.trigger('click');
        }
      }, this, elem, onOff));
    }

    return li;

  },

  hide : function() {
    if ( !this._container) return;
    this._destroyEvents();
    this._container.fadeOut(200);
  }
});


/************************************************************************
 L.Evented
 - GSI.layersJSONSearchSRC

 layers_txtのsrc探索をMapListPanel以外で実行する為の補完
 ************************************************************************/

 GSI.layersJSONSearchSRC = L.Evented.extend({
  initialize: function (mapManager) {
      this._mapManager = mapManager;
      this.current = null;
      this._CurrentData_SRC = null;
      this._idMap = null;
      this._pathidx = 0;
  },
  _nextSearch: function(){
      this._pathidx += 1;
      var keys = Object.keys(this._paths);
      if (this._pathidx < keys.length){
          this._initializeList_ID(this._paths[this._pathidx]);
      }
      else{
          this.fire("searchEnd");
      }
  },
  kick: function(paths){
      this.tree = this._mapManager._layersJSON.tree;
      this._CurrentData_SRC = new Array();
      this._paths = paths;
      this._idMap = {};
      for(var s = 0; s < paths.length; s++){
          this._idMap[paths[s]] = 0;
      }
      if (paths.length > 0){
          this._initializeList_ID(paths[0]);
      }
  },
  _initializeList_ID: function (path) {
      var current = null;
      if (!path || path == '') return null;

      current = this._initializeList_IDProc_Data(this.tree, path);
      if (current == null && this._CurrentData_SRC.length > 0) {
          var srcurl = this._CurrentData_SRC[this._idMap[path]].src;
          this._initializeList_IDProc_DataSrc(srcurl, path);
      }
      else {
          //src属性の場合も2回目はこちら側を通るので、visibleLayersを作る必要がある
          if (current != null){
            if (!this._visibleLayers || this._visibleLayers.length < 1){
              this._mapManager._layersJSON._initializeTree(this.tree, current.id);
              this._visibleLayers = this._mapManager._layersJSON.visibleLayers;
              this._visibleLayersHash = this._mapManager._layersJSON.visibleLayersHash;
            }
          }
          this._initializeList_IDProc(current, path);
          this._nextSearch();
      }
      //return current;
  },
  _initializeList_IDProc_Data: function (tree, id) {

      var current = null;
      for (var i = 0; i < tree.length; i++) {
          if (tree[i].src && !tree[i].entries) {
              if (!tree[i].src_ && tree[i].src.indexOf('./') == 0) {
                  var path = tree[i].src_url.substring(0, tree[i].src_url.lastIndexOf('/'));
                  tree[i].src_ = true;
                  tree[i].src = path + "/" + tree[i].src.substr(2);
              }
              if (this._CurrentData_SRC.includes(tree[i]) == false){
                  this._CurrentData_SRC.push(tree[i]);
              }
          }
          else if (tree[i].entries && !tree[i].isMultiLayer) {
              current = this._initializeList_IDProc_Data(tree[i].entries, id);
              if (current != null) {
                  break;
              }
          }
          else {
              if (tree[i].id == id) {
                  if (tree[i].parent) {
                      current = tree[i].parent;

                      this._CurrentData_SRC.length = 0;
                  }
                  else {
                      current = null;
                  }
                  break;
              }
          }
      }
      return current;
  },
  _initializeList_IDProc: function (current, path) {
      this.current = current;
      var target = this.current;
      if (target && target.title_sys == CONFIG.layerBaseFolderSYS && !CONFIG.layerBaseFolderVisible) {
          target = null;
          this.current = null;
      }

      this._initializeListProc(path);
  },
  _initializeListProc: function (id) {
      if (this._visibleLayers && this._visibleLayers.length > 0) {
          for (var i = 0; i < this._visibleLayers.length; i++) {
              var l = this._visibleLayers[i];
              if (l.info != null && (id && l.id == id)) {
                 this._mapManager._mapLayerList.append(l.info, true, l.hidden, null, l.blend);
              }
          }
      }
  },
  _initializeList_IDProc_DataSrc: function (srcurl, path) {
      if (this._CurrentData_SRC.length > 0) {
          if (GSI.GLOBALS.layersJSONCache &&
              GSI.GLOBALS.layersJSONCache[srcurl]) {
              this._initializeList_IDProc_DataSrc_Success(
                  srcurl, path, GSI.GLOBALS.layersJSONCache[srcurl], true
              );
          }
          else {
              $.ajax({
                  type: "GET",
                  url: srcurl,
                  dataType: "text",
                  cache: true,
                  success: L.bind(this._initializeList_IDProc_DataSrc_Success, this, srcurl, path),
                  error: L.bind(this._initializeList_IDProc_DataSrc_Error, this, srcurl, path)
              });
          }
      }
      else {
          this._initializeList_IDProc(null);
      }
  },
  _initializeList_IDProc_DataSrc_Success: function (srcurl, path, data, isCached) {
      if (this._CurrentData_SRC.length > 0) {

          if (!isCached || isCached == false){
              if (!GSI.GLOBALS.layersJSONCache) GSI.GLOBALS.layersJSONCache = {};

              GSI.GLOBALS.layersJSONCache[srcurl] = data;
          }

          var json = JSON.parse(data);
          if (json.layers) {
              for (var i = 0; i < json.layers.length; i++) {
                  json.layers[i].parent = this._CurrentData_SRC[this._idMap[path]];
                  json.layers[i].src_url = this._CurrentData_SRC[this._idMap[path]].src_url;
              }
          }

          this._CurrentData_SRC[this._idMap[path]].entries = json.layers;
          this._mapManager._layersJSON._initializeTree(this._CurrentData_SRC[this._idMap[path]].entries, this._CurrentData_SRC[this._idMap[path]]);
          current = this._initializeList_IDProc_Data(this._CurrentData_SRC[this._idMap[path]].entries, path);

          if (current == null) {
              if (this._CurrentData_SRC.length > this._idMap[path]){
                  this._initializeList_IDProc_DataSrc_Error(srcurl, path);
              }
              else{
                  this._nextSearch();
                  //return current;
              }
          }
          else {
              if (this._visibleLayers == null || this._visibleLayers.length == 0) {
                  this._visibleLayers = this._mapManager._layersJSON.visibleLayers;
                  this._visibleLayersHash = this._mapManager._layersJSON.visibleLayersHash;
              }
              this._initializeList_IDProc(current, path);
              this._nextSearch();
          }
      }
  },
  _initializeList_IDProc_DataSrc_Error: function (srcurl, path) {
      var idx = this._idMap[path];
      this._idMap[path] = ++idx;

      if (idx < this._CurrentData_SRC.length){
        var src = this._CurrentData_SRC[this._idMap[path]].src;
        this._initializeList_IDProc_DataSrc(src, path);
      }
      else{
        this._nextSearch();
      }
  }
});

/************************************************************************
 L.Evented
 - GSI.MenuBase
 ************************************************************************/
GSI.MenuBase = L.Evented.extend({
  options : {

  },

  initialize : function(menu, owner, opener, options) {
    options = L.setOptions(this, options);
    this._opener = opener;
    this._owner = owner;
    this._menu = menu;
    this._gsimaps = this._menu._gsimaps;
    this._container = null;
  },

  destroy : function() {
    this._stopMouseDownWatch();
    if ( this._container ) {
      this._container.remove();
      this._container = null;
    }
    if ( this._child) {
      this._child.destroy();
    }
  },

  refresh : function() {
    if ( this._child) {
      this._child.refresh();
    }
  },
  toggle : function() {

    if ( this.isVisible() ) {
      this.hide();
    } else {
      this.show();
    }
  },

  _showSlide : function(direction, duration) {
    var size = this.getSize();
    if ( direction == "bottom") {
      this._container.finish().css({"opacity":0,"transform":"scaleY(0) translateY("+ -size.height +"px)"}).show().animate(
        {
          "opacity":1
        },
        {
          "duration" : duration,
          "step" : L.bind(function(h, now) {
            var y = (h-Math.floor(h*now)) / (now*2);
            this._container.css({"transform":"scaleY("+now+") translateY(" + -y + "px)"});
          }, this, size.height ),

          "complete" : L.bind(function() {
          },this)
        }
      );
    } else {
      this._container.finish().css({"opacity":0,"transform":"scaleX(0) translateX("+ size.width +"px)"}).show().animate(
        {
          "opacity":1
        },
        {
          "duration" : duration,
          "step" : L.bind(function(w, now) {
            var x = (w-Math.floor(w*now)) / (now*2);
            this._container.css({"transform":"scaleX("+now+") translateX(" + x + "px)"});
          }, this, size.width ),

          "complete" : L.bind(function() {
          },this)
        }
      );
    }
  },

  _hideSlide : function(direction, duration) {

    var size = this.getSize();

    if ( direction == "bottom") {
      this._container.animate(
        {
          "opacity":0
        },
        {
          "duration" : duration,
          "step" : L.bind(function(h, now) {
            var y = (h-Math.floor(h*now)) / (now*2);
            this._container.css({"transform":"scaleY("+now+") translateY(" + -y + "px)"});
          }, this, size.height ),
          "complete" : L.bind(function() {
            this._container.css({"opacity":1,"transform":"scaleY(1) translateY(0px)"}).hide();
          },this)
        }
      );

    } else {
      this._container.animate(
        {
          "opacity":0
        },
        {
          "duration" : duration,
          "step" : L.bind(function(w, now) {
            var x = (w-Math.floor(w*now)) / (now*2);
            this._container.css({"transform":"scaleX("+now+") translateX(" + x + "px)"});
          }, this, size.width ),
          "complete" : L.bind(function() {
            this._container.css({"opacity":1,"transform":"scaleX(1) translateX(0px)"}).hide();
          },this)
        }
      );

    }
  },

  show : function(){
    if ( !this._owner ) return;
    if (!( this instanceof GSI.Menu.Panel )) {
      if ( this._owner instanceof GSI.Menu.PopupList || this._owner instanceof GSI.Menu.PopupMenu
        || this instanceof GSI.Menu.Panel ||  this instanceof GSI.Menu.PopupPanel) return;
    }
    this._startMouseDownWatch();
    this.refresh();
  },
  hide : function(){
    this._stopMouseDownWatch();
    if ( this._child ) {
      this._child.hide();
    }
  },

  getPosition : function() {
    if ( !this._container) return {"left":0,"top":0};
    return this._container.offset();
  },

  getSize : function() {
    if ( !this._container) return {"width":0,"height":0};

    var visible = this.isVisible();

    if ( !visible ) {
      this._container.css({"visibility":"hidden"}).show();
    }

    var result= {
      "width" : this._container.outerWidth(),
      "height" : this._container.outerHeight()
    };

    if ( !visible ) {
      this._container.css({"visibility":"visible"}).hide();
    }

    return result;
  },

  getOpener : function() {
    return this._opener;
  },

  getOwner: function() {
    return this._owner;
  },

  isVisible : function() {
    return ( this._container && this._container.is(":visible") );
  },

  hasOwner : function() {
    return ( this._owner ? true : false );
  },

  hasOpener : function() {
    return ( this._opener ? true : false );
  },

  getContainer : function() {
    return this._container;
  },

  setChild : function(child) {
    this._child = child;
  },

  childMouseOver : function( evt ) {

    var target = evt.target;
    this._menu.fire( "mouseover", {"item":target.options});
  },

  childMouseOut : function( evt ) {

    var target = evt.target;
    this._menu.fire( "mouseout", {"item":target.options});
  },

  childClick : function(evt) {

    if ( this._activeChild ) {
      this._activeChild = null;
    }

    var target = evt.target;

    var owner = target;
    if ( owner instanceof GSI.Menu.IconButton || owner instanceof GSI.Menu.PopupList.Item
      || owner instanceof GSI.Menu.Panel.Item || owner instanceof GSI.Menu.PopupPanel.Item  ) {
      owner = target.getOwner();
    }

    switch( target.options.childViewStyle) {
      case "popupmenu":
        if ( !target._child ) {
          target._child = new GSI.Menu.PopupMenu(this._menu,owner,target,{
            children:target.options.children,
            popupDirection:target.options.popupDirection});
        }
        owner._child = target._child;
        this._activeChild = target._child;
        break;

      case "popuplist":
        if ( !target._child ) {
          target._child = new GSI.Menu.PopupList(this._menu,owner, target,
            {
            children:target.options.children,
            popupDirection:target.options.popupDirection,
            childrenWidth : target.options.childrenWidth
          });
        }
        owner._child = target._child;
        this._activeChild = owner._child;
        break;

      case "panel":
        if ( !target._child ) {
          target._child = new GSI.Menu.Panel(this._menu,owner, target,{
            children:target.options.children,
            "class" : target.options.panelClass
          });
        }
        owner._child = target._child;
        this._activeChild = owner._child;
        if (!(this instanceof GSI.Menu) )
          this.hide();
        break;

      case "popuppanel":
        if ( !target._child ) {
          target._child = new GSI.Menu.PopupPanel(this._menu,owner, target,{
            children:target.options.children,
            popupDirection:target.options.popupDirection,
            "class" : target.options.panelClass
          });
        }
        owner._child = target._child;
        this._activeChild = owner._child;
        break;

      default:
        if( target.options.typeA == "check") {
          var obj = this._gsimaps._onoffObjects[target.options.id];
          if ( obj ) {
            obj.obj[obj.setter](!obj.obj[obj.getter]());
            var on = obj.obj[obj.getter]();
            if ( on ) {
              target.getContainer().addClass("on");
            } else {
              target.getContainer().removeClass("on");
            }
          }
        } else {
          this._menu.fire( "select", {"item":target.options, "from": target});
        }
        if ( !target.options.keepPanel )this.hide();
        break;
    }

    if ( this._activeChild ) this._activeChild.toggle();

    if (target && target.options){
      if (target.options.id && target.options.id != ""){
        var usedid = target.options.id;
        if (["jihokuline","houiline","toukyoken","othermap"].includes(usedid)){
          if (this._gsimaps._onoffObjects[usedid]){
            //非表示なら抜ける
            if (this._gsimaps._onoffObjects[usedid].obj.options.visible == false){
              return;
            }
          }
          GSI.Utils.sendSelectedFunction(target.options.id);
        }
      }
    }
  },

  _onMapMouseDown : function() {
    this.hide();
  },

  _hitCheck : function(target) {
    var hit = false;
    if ( this._child ) {
      hit = this._child._hitCheck(target);
      if ( hit ) return hit;
      this._child.hide(true);
    }

    while( target) {
      if ( this._container && target == this._container[0]) {
        hit = true;
        break;
      }
      target = target.parentNode;
    }
    return hit;
  },

  _onBodyMouseDown : function (evt) {
    var target = evt.target;

    var hit = false;

    if ( this._child ) {
      hit = this._child._hitCheck(target);
      if ( hit ) return;
      this._child.hide(true);
    }

    if ( !this._hitCheck(target) ) this.hide();
  },

  _startMouseDownWatch : function() {
    if ( !this._mapMousedownHandler ) {
      this._mapMousedownHandler = L.bind( this._onMapMouseDown, this );
      if ( this._gsimaps._mainMap ) {
        var map = this._gsimaps._mainMap.getMap();
        map.on("touchstart",this._mapMousedownHandler);
        map.on("mousedown", this._mapMousedownHandler);
      }
      if ( this._gsimaps._subMap ) {
        var map = this._gsimaps._subMap.getMap();
        map.on("touchstart",this._mapMousedownHandler);
        map.on("mousedown", this._mapMousedownHandler);
      }
    }

    if ( !this._mouseDownHandler ) {
      this._mouseDownHandler = L.bind( this._onBodyMouseDown, this );
      $("body").on("mousedown", this._mouseDownHandler);
    }
  },

  _stopMouseDownWatch : function() {
    if ( this._mapMousedownHandler ) {
      if ( this._gsimaps._mainMap ) {
        var map = this._gsimaps._mainMap.getMap();
        map.off("touchstart", this._mapMousedownHandler);
        map.off("mousedown", this._mapMousedownHandler);
      }
      if ( this._gsimaps._subMap ) {
        var map = this._gsimaps._subMap.getMap();
        map.off("touchstart", this._mapMousedownHandler);
        map.off("mousedown", this._mapMousedownHandler);
      }
      this._mapMousedownHandler = null;
    }

    if ( this._mouseDownHandler ) {
      $("body").off("mousedown", this._mouseDownHandler);
      this._mouseDownHandler = null;
    }
  }
});

/************************************************************************
 GSI.MenuBase
 - GSI.Menu
 ************************************************************************/
GSI.Menu = GSI.MenuBase.extend({
  options: {
    zIndex: 15000,
    visible: true
  },

  initialize : function(gsimaps, container, config,options, onOffObjects) {

    GSI.MenuBase.prototype.initialize.call(this,this, null,null,options);
    this._gsimaps = gsimaps;
    this._container = container;
    this._config = config;

    this._initializeIcons();
    this._initializeOnOffObjects(onOffObjects);
  },

  _initializeIcons : function() {

    this._iconButtons = [];
    for( var i=0; i<this._config.length; i++ ) {
      var iconInfo = this._config[i];
      if ( this._container.hasClass("local")) {
        if (iconInfo.id == "reset") continue;
      }
      var iconButton = new GSI.Menu.IconButton(this,this, iconInfo);
      iconButton.create( this._container);
      this._iconButtons.push( iconButton );
      iconButton.on("click", L.bind( this.childClick, this ) );
    }
  },

  _initializeOnOffObjects : function( onOffObjects) {
    var proc = L.bind(function(evt){
      this.refresh();
    },this);
    for (key in onOffObjects) {
      var obj = onOffObjects[key];
      if ( !obj.obj.on ) continue;
      obj.obj.on("change", proc);
    }
  },

  getToolsWidth :function () {
    return this._container.outerWidth();
  }
});

/************************************************************************
 L.Evented
 - GSI.MenuIconButton
 ************************************************************************/
GSI.Menu.IconButton = GSI.MenuBase.extend({
  options : {
    class : "gsi-header-tool-icon"
  },

  initialize : function(menu, owner, options) {
    GSI.MenuBase.prototype.initialize.call(this, menu, owner,null,options);
    this._owner = owner;
  },

  destroy : function() {
    if ( this._container ) {
      this._container.remove();
      this._container = undefined;
    }
  },

  create : function(parentContainer) {
    this._container = $("<a>").attr({"href":"javascript:void(0);"}).addClass(this.options["class"]);
    if ( this.options["url"] && this.options["url"] != "" ) {
      this._container.attr( {
        "href":this.options["url"],
        "target" : this.options["target"] ? this.options["target"] : ""
      });
    } else {
      this._container.on("click", L.bind( this._onClick, this));
    }

    if ( this.options["text"] && this.options["text"] != "" ) {
      this._container.html( this.options["text"]);
    }

    if ( this.options["description"] && this.options["description"] != "" ) {
      this._container.attr( {"title":this.options["description"]});
    }

    if ( this.options["icon"] && this.options["icon"] != "" ) {
      this._container.css({"background-image": "url(" + this.options["icon"] + ")" });
    }

    if ( this.options["title"] && this.options["title"] != "" ) {
      var titleElement = $("<span>").html( this.options["title"]).addClass("title");
      this._container.append( titleElement ).addClass("withtitle");
    }

    if ( this.options["buttonWidth"]) {
      this._container.css({width: this.options["buttonWidth"]});
    }

    parentContainer.append( this._container);
    return this._container;
  },

  _onClick : function() {
    this.fire("click");
    if ( this._container ) {
      try{
        this._container.trigger('blur');
      } catch(e) {}
    }
  }
});

/************************************************************************
 L.Evented
 - GSI.Menu.PopupMenu
 ************************************************************************/
GSI.Menu.PopupMenu = GSI.MenuBase.extend({
  options : {
    "class" : "gsi-menu-popupmenu"
  },

  initialize : function(menu, owner, opener,  options) {

    GSI.MenuBase.prototype.initialize.call(this,menu, owner,opener,options);
    this.create();
  },

  create : function() {
    this._container = $("<div>").addClass(this.options["class"]).hide();

    for( var i=0; i<this.options.children.length; i++ ) {

      var iconInfo = this.options.children[i];
      var iconButton = new GSI.Menu.IconButton(this._menu, this, iconInfo);
      iconButton.create( this._container);
      iconButton.on("click", L.bind( this.childClick, this ) );
    }
    $("body").append( this._container);
  },

  show : function() {
    var screenSize = GSI.Utils.getScreenSize();
    var pos = this._opener.getPosition();
    var openerSize = this._opener.getSize();
    var size = this.getSize();
    var right = 2;
    var top = 0;

    switch( this.options.popupDirection) {
      case "bottom":
          right = parseInt( screenSize.w - pos.left -(openerSize.width/2) -(size.width/2));
          top = pos.top + openerSize.height + 2;
        break;
    }

    if ( right <= 0 ) right = 1;

    this._container.css( {
      "top" : top + "px",
      "right" : right+ "px"
    });
    this._container.slideDown(300);

    GSI.MenuBase.prototype.show.call(this);

  },

  hide : function() {
    this._container.slideUp(300);
    GSI.MenuBase.prototype.hide.call(this);
  },

  toggle : function() {

    if ( this.isVisible() ) {
      this.hide();
    } else {
      this.show();
    }
  }
});

/************************************************************************
 L.Evented
 - GSI.Menu.PopupList
 ************************************************************************/
GSI.Menu.PopupList = GSI.MenuBase.extend({
  options : {
    "class" : "gsi-menu-popuplist"
  },

  initialize : function(menu, owner, opener, options) {

    GSI.MenuBase.prototype.initialize.call(this, menu,owner,opener,options);
    this.create();
  },

  refresh : function() {
    for( var i=0; i<this._items.length; i++ ) {
      this._items[i].refresh();
    }
    GSI.MenuBase.prototype.refresh.call(this);
  },

  create : function() {

    this._container = $("<div>").addClass(this.options.class).hide();
    var ul = $("<ul>");

    this._items = [];

    for( var i=0; i<this.options.children.length; i++ ) {
      var item = new GSI.Menu.PopupList.Item(this._menu, this, this.options.children[i]);
      item.on("click", L.bind( this.childClick, this ) );
      this._items.push(item);
      ul.append( item.getContainer() );
    }

    this._container.append(ul);
    $("body").append( this._container );
  },

  show : function() {
    var screenSize = GSI.Utils.getScreenSize();
    var pos = this._opener.getPosition();
    var openerSize = this._opener.getSize();
    var size = this.getSize();
    var right = 2;
    var top = 0;

    switch( this.options.popupDirection) {
      case "bottom":
        right = parseInt( screenSize.w - pos.left -(openerSize.width/2) -(size.width/2));
        top = pos.top + openerSize.height + 5;
        break;

      case "left":
        right = parseInt( screenSize.w - pos.left);
        top = pos.top + parseInt( openerSize.height / 2);
        break;
    }

    var left = screenSize.w - right - size.width;
    var bottom = top + size.height;

    if ( left < 0 ) right = screenSize.w - size.width - 1;
    if ( right <= 0 ) right = 1;
    if ( top < 0 ) top = 1;
    if ( bottom > screenSize.h ) top = screenSize.h - size.height - 1;

    this._container.css( {
      "top" : top + "px",
      "right" : right+ "px"
    });

    this._showSlide( this.options.popupDirection, 200);

    GSI.MenuBase.prototype.show.call(this);
  },

  hide : function() {
    this._hideSlide( this.options.popupDirection, 200);
    GSI.MenuBase.prototype.hide.call(this);
  }
});

GSI.Menu.PopupList.Item = GSI.MenuBase.extend({
  options : {
  },

  initialize : function(menu, owner, options) {

    GSI.MenuBase.prototype.initialize.call(this, menu,owner,null,options);
    this.create();
  },

  refresh:function() {
    if ( this._onOffSwitch) {
      var obj = this._gsimaps._onoffObjects[this.options.id];
      this._onOffSwitch.getCheckBox()[0].checked = ( obj ? obj.obj[obj.getter]() : false );
    }
  },

  create : function() {
    var item = this.options;
    var li= $("<li>");
    if ( item.typeA == "check") {
      var obj = this._gsimaps._onoffObjects[item.id];
      var checkState = ( obj ? obj.obj[obj.getter]() : false );

      var onOffSwitch = new GSI.OnOffSwitch({ className: 'onoff', checked: checkState, title: item.title });

      var label = $("<label>").attr({"for":onOffSwitch.getId()}).addClass("title").html(item.title);

      if ( item["description"] && item["description"] != "" ) {
        label.attr( {"title":item["description"]});
        onOffSwitch.getElement().attr( {"title":item["description"]});
      }

      this._onOffSwitch = onOffSwitch;
      onOffSwitch.getCheckBox().data({ 'data': item });
      onOffSwitch.getElement().addClass("check");

      onOffSwitch.on('change', L.bind(function(checkBox, obj){
        if ( !obj ) return;
        obj.obj[obj.setter]($(checkBox).is(":checked"));
        if ( obj.obj[obj.getter]() != $(checkBox).is(":checked") ) {
          checkBox[0].checked = !$(checkBox).is(":checked");
        }
      }, this, onOffSwitch.getCheckBox(), obj));
      li.append(label).append( onOffSwitch.getElement());

    } else {
      var a = $("<a>").attr({"href":"javascript:void(0);"}).html( item.title);

      if ( item["description"] && item["description"] != "" ) {
        a.attr( {"title":item["description"]});
      }

      if (item.arrow) {
        a.addClass("arrow");
      }
      a.on("click", L.bind( this._onClick,this));
      li.append(a);
    }

    this._container = li;
  },

  _onClick : function(evt) {
    this.fire("click");
  }
});

/************************************************************************
 L.Evented
 - GSI.Menu.Panel
 ************************************************************************/
GSI.Menu.Panel = GSI.MenuBase.extend({
  options : {
    "class" : "gsi-menu-rightpanel"
  },

  initialize : function(menu, owner, opener, options) {
    if ( options && ( !options["class"] || options["class"] == "" ) )
      options["class"] = "gsi-menu-rightpanel";

    GSI.MenuBase.prototype.initialize.call(this, menu,owner,opener,options);

    this.create();
  },

  refresh : function() {
    for( var i=0; i<this._items.length; i++ ) {
      this._items[i].refresh();
    }
    GSI.MenuBase.prototype.refresh.call(this);
  },

  create : function() {
    this._container =$("<div>").addClass(this.options["class"]).hide();
    var ul = $("<ul>");
    this._items = [];
    for( var i=0; i<this.options.children.length; i++ ) {
      var childInfo = this.options.children[i];
      var item = new GSI.Menu.Panel.Item (this._menu, this, childInfo);

      this._items.push( item );
      item.on("click", L.bind( this.childClick,this));

      ul.append( item.getContainer() );
    }

    this._container.append(ul);
    $("body").append( this._container);

  },

  _refreshHeight : function() {

    var bottom = 0;
    if ( this._gsimaps.splited() || this._gsimaps.compared() ) {
      if ( this._gsimaps._subMap._footer )
        bottom = this._gsimaps._subMap._footer.getHeight();
    } else {
      if ( this._gsimaps._mainMap._footer )
        bottom = this._gsimaps._mainMap._footer.getHeight();
    }
    this._container.css({"left":"auto","bottom" :bottom + "px"});
  },

  show : function() {

    this._refreshHeight();

    this._container.show("slide",{"direction":"right"},200);

    GSI.MenuBase.prototype.show.call(this);

    if (!this._onWindowResizeHandler) {
      this._onWindowResizeHandler = L.bind(this._refreshHeight, this);
      $(window).on('resize', this._onWindowResizeHandler);
    }
  },

  hide : function() {

    if (this._onWindowResizeHandler) {
      $(window).off('resize', this._onWindowResizeHandler);
      this._onWindowResizeHandler = null;
    }

    this._container.hide("slide",{"direction":"right"},200);

    GSI.MenuBase.prototype.hide.call(this);

    try {

      $("body").tooltip("destroy").tooltip({
        "show": { duration: 300 },
        "hide": { duration: 200 },
        "open": function (evt, ui) {
        },
        "position": { my: "right top+10", at: "center bottom", collision: "flipfit" }
      });
    }catch(ex) {

    }
  }
});

GSI.Menu.Panel.Item = GSI.MenuBase.extend({
  options : {
  },

  initialize : function(menu, owner, options) {

    GSI.MenuBase.prototype.initialize.call(this, menu,owner,null,options);
    this.create();
  },

  refresh : function() {
    if ( this.options.typeA  == "check") {
      var obj = this._gsimaps._onoffObjects[this.options.id];
      if ( obj ) {
        var on = obj.obj[obj.getter]();
        if ( on ) {
          this.getContainer().addClass("on");
        } else {
          this.getContainer().removeClass("on");
        }
      }
    }
  },
  create : function() {
    var item = this.options;
    var li= $("<li>");
    var a = $("<a>").attr({"href":"javascript:void(0);"});
    var div = $("<div>").addClass("title");

    if ( item.icon ) {
      a.addClass("image-only");
      a.css({"background-image":"url(" + item.icon +")"});
      div.html(item.title);

    } else {
      div.html(item.title);
    }

    if ( item["description"] && item["description"] != "" ) {
      a.attr( {"title":item["description"]});
    }
    a.on("click", L.bind(this._onClick, this ));

    a.append(div);
    li.append(a);
    this._container = li;
    this.refresh();
  },

  _onClick : function(evt) {
    this.fire("click");
  }
});

/************************************************************************
 L.Evented
 - GSI.Menu.PopupPanel
 ************************************************************************/
GSI.Menu.PopupPanel = GSI.MenuBase.extend({
  options : {
    "class" : "gsi-menu-popuppanel"
  },

  initialize : function(menu, owner, opener, options) {

    if ( options && ( !options["class"] || options["class"] == "" ) )
      options["class"] = "gsi-menu-popuppanel";

    GSI.MenuBase.prototype.initialize.call(this, menu,owner,opener,options);

    this.create();
  },
  refresh : function() {
    for( var i=0; i<this._items.length; i++ ) {
      this._items[i].refresh();
    }
    GSI.MenuBase.prototype.refresh.call(this);
  },

  create : function() {
    this._container =$("<div>").addClass(this.options["class"]).hide();
    this._items = [];
    for( var i=0; i<this.options.children.length; i++ ) {
      var childInfo = this.options.children[i];
      var item = new GSI.Menu.PopupPanel.Item (this._menu, this, childInfo);

      this._items.push( item );
      item.on("click", L.bind( this.childClick,this));
      item.on("mouseover", L.bind( this.childMouseOver,this));
      item.on("mouseout", L.bind( this.childMouseOut,this));

      this._container.append( item.getContainer() );
    }

    $("body").append( this._container);

  },

  show : function() {
    var screenSize = GSI.Utils.getScreenSize();
    var pos = this._opener.getPosition();
    var openerSize = this._opener.getSize();
    var size = this.getSize();
    var right = 2;
    var top = 0;

    switch( this.options.popupDirection) {
      case "bottom":
        right = parseInt( screenSize.w - pos.left -(openerSize.width/2) -(size.width/2));
        top = pos.top + openerSize.height + 5;
        break;

      case "left":
        right = parseInt( screenSize.w - pos.left) +11;
        top = pos.top + ( openerSize.height / 2 - size.height / 2);
        break;
    }

    var left = screenSize.w - right - size.width;
    var bottom = top + size.height;

    if ( left < 0 ) right = screenSize.w - size.width - 1;
    if ( right <= 0 ) right = 1;
    if ( top < 0 ) top = 1;
    if ( bottom > screenSize.h ) top = screenSize.h - size.height - 1;

    this._container.css( {
      "top" : top + "px",
      "right" : right+ "px"
    });

    this._showSlide( "right",200 );

    GSI.MenuBase.prototype.show.call(this);
  },

  hide : function(noAnimate) {
    this._hideSlide("right",200);
    GSI.MenuBase.prototype.hide.call(this);
  }
});

GSI.Menu.PopupPanel.Item = GSI.MenuBase.extend({
  options : {
  },

  initialize : function(menu, owner, options) {

    GSI.MenuBase.prototype.initialize.call(this, menu,owner,null,options);
    this.create();
  },

  refresh : function() {
    if ( this.options.typeA  == "check") {
      var obj = this._gsimaps._onoffObjects[this.options.id];
      if ( obj ) {
        var on = obj.obj[obj.getter]();
        if ( on ) {
          this.getContainer().addClass("on");
        } else {
          this.getContainer().removeClass("on");
        }
      }
    }
  },

  create : function() {
    var item = this.options;
    var a = $("<a>").attr({"href":"javascript:void(0);"});
    var div = $("<div>").addClass("title");

    if ( item.icon ) {
      a.addClass("image-only");
      a.css({"background-image":"url(" + item.icon +")"});
      if ( item.showTitle ) div.html(item.title);
    } else {
      div.html(item.title);
    }

    if ( item["description"] && item["description"] != "" ) {
      a.attr( {"title":item["description"]});
    }

    a.on("click", L.bind(this._onClick, this ));
    a.on("mouseover",L.bind( this._onMouseover, this ));
    a.on("mouseout",L.bind( this._onMouseout, this ));
    a.append(div);
    this._container = a;
    this.refresh();

  },

  _onClick : function(evt) {
    this.fire("click");
  },

  _onMouseover : function(evt) {
    this.fire("mouseover");
  },

  _onMouseout : function(evt) {
    this.fire("mouseout");
  }
});

/************************************************************************
  GSIMaps
    アプリケーション
************************************************************************/
GSI.GSIMaps = L.Evented.extend({

  _compareSliderMargin: 100,

  initialize: function (queryParams) {

    this._initialize(queryParams);

  },
  _initialize: function (queryParams) {
    if (!CONFIG.USECOOKIE) {
      Cookies.set(CONFIG.COOKIEKEY_HASH, null, { path: '/', expires: -1 });
    } else {
      if (Cookies.get(CONFIG.COOKIEKEY_HASH)) {
        Cookies.set(CONFIG.COOKIEKEY_HASH_PREV,
          Cookies.get(CONFIG.COOKIEKEY_HASH), { path: '/' });
      }
    }

    if (queryParams) {
      this._queryParams = queryParams;
      this._syncSplitMap = this._queryParams.getSyncSplitedMap();
      this._initializeProc();
    } else {
      this._queryParams = new GSI.QueryParams({ queryString: GSI.ClientMode.queryString });
      if (this._queryParams.getInit()) {
        this._syncSplitMap = this._queryParams.getSyncSplitedMap();
        this._initializeProc();
      }
    }
  },

  // 地図比較中かどうか
  compared: function () {
    return (this._subMap && this._subMap._compared ? true : false);
  },

  // 地図比較中フラグを立てる
  _setCompared: function (flg) {
    this._subMap._compared = flg;
    if (this._subMap._compared) {

      if (this._header)
        $("#map").css({ top: (this._header.getHeight() + 30) + 'px' });

      this._createCompareSlider();

    } else {
      if (this._header)
        $("#map").css({ top: this._header.getHeight() + 'px' });
      this._destroyCompareSlider();
    }
  },

  getCompareSliderPos : function(value) {

    var sideMargin = this._compareSliderMargin;

    var width = $("#map").outerWidth() - (sideMargin * 2);
    var per = value / 10000;

    var pos = Math.round((width * per) + sideMargin);

    return pos;
  },

  // 地図比較スライダー生成
  _createCompareSlider: function () {
    this._compareSliderFrame = $("<div>").addClass("gsi_mapcompare_slider_frame");

    var clearBtn =
      $("<a>").attr({ "href": "javascript:void(0);" })
        .html("比較解除").addClass("normalbutton").addClass("gsi_mapcompare_slider_clearbtn");

    clearBtn.on("click", L.bind(function () {

      this.comparison(false);
    }, this));
    this._compareSliderFrame.append(clearBtn);

    this._compareSlider = $("<div>").addClass("gsi_mapcompare_slider");
    this._compareSliderFrame.append(this._compareSlider);
    $("body").append(this._compareSliderFrame);

    var sideMargin = this._compareSliderMargin;

    this._compareSlider.css({
      "left": sideMargin + "px",
      "right": sideMargin + "px"
    })
    this._compareSlider.slider(
      {
        range: "min", min: 0, max: 10000, step: 1, value: 5000,
        "slide": L.bind(function (event, ui) {

          this._comparisonSeparater.setLeft( this.getCompareSliderPos(ui.value) );

        }, this)
      });

    if (CONFIG.TOOLTIP && CONFIG.TOOLTIP.STACKWINDOW) {
      clearBtn.attr({ "title": CONFIG.TOOLTIP.STACKWINDOW.STOP });
      this._compareSlider.find(".ui-slider-handle").attr({ "title": CONFIG.TOOLTIP.STACKWINDOW.MOVE });
    }
  },

  // 地図比較スライダー破棄
  _destroyCompareSlider: function () {

    if (this._compareSliderFrame) this._compareSliderFrame.remove();
    this._compareSliderFrame = undefined;
  },

  // 時系列表示
  comparePhoto: function() {
    var targetMap = this._mainMap;
    targetMap._mapLayerList.appendComparePhoto();
  },

  // 地図比較処理
  comparison: function (visible) {
    if (visible) {
      this.split(false);
    }

    if (visible) {

      if (!this._subMap) {
        this._mainMap._mapMenu.setPanelOverlap(true);

        this._mainMap.setPosition("full");
        var ctrlSetting = this._queryParams.getControlSetting();
        var viewSetting = this._queryParams.getViewSetting();
        var center = this._mainMap._map.getCenter();
        var zoom = this._mainMap._map.getZoom();
        // マップオブジェクト生成
        this._subMap = new GSI.MapManager(this, {
          startUpCenter: center,
          startUpZoom: zoom,
          multipopup: this._mainMap._map.options.multipopup,
          noZoomControl: true,
          noScaleControl: true,
          noFooter: true,
          mapMenuRight: true,
          panelOverlap: true
        });

        this._subMap.on("mousedown", L.bind(this._onMapMousedown, this));
        this._subMap.create();
        this._subMap.setPosition("full");

        this._subMap.initializeMap(ctrlSetting);
        this._subMap.initializeControls(this._queryParams, this._header, ctrlSetting, viewSetting);
        var layersJSON = this._layersJSON.clone();

        this._subMap._initializeDialogs(layersJSON, this._header.getHeight(), false, "");
        this._subMap._mapMenu.getMapListPanel().setTree_Init(layersJSON._data);
        this._subMap.initializeBaseLayer("std", false);

        this._subMap._baseLayer.addTo(this._subMap._map);

        this._subMap._baseLayer.setActiveIndex(0);
        var std = this._subMap._baseLayer.baseLayerList[0];

        this._subMap._mapLayerList.append(std);

        this._subMap._mapMouse.setClickMoveVisible(this._mainMap._mapMouse.getClickMoveVisible());
        this._subMap._centerCross.setVisible(this._mainMap._centerCross.getVisible());
        this._subMap._zoomGuide.setVisible(this._mainMap._zoomGuide.getVisible());

        this._setCompared(true);
        this._refreshSync(true);

      }
      if (!this._comparisonSeparater) {
        this._comparisonSeparater = new GSI.MapCompareSeparater(this, { margin: this._compareSliderMargin });
        this._comparisonSeparater.on("change", L.bind(function (e) {
          this._refreshClip(e.position);
        }, this));
      }
      this._comparisonSeparater.show();
    }
    else {

      try {

        $("body").tooltip("destroy").tooltip({
          "show": { duration: 300 },
          "hide": { duration: 200 },
          "open": function (evt, ui) {
          },
          "position": { my: "right top+10", at: "center bottom", collision: "flipfit" }
        });
      }catch(ex) {

      }

      if (this._comparisonSeparater) {
        this._comparisonSeparater.hide();
      }
      this._refreshClip();
      if (this._subMap) {
        this._setCompared(false);
        this._refreshSync(false);
        this._mainMap.setPosition("full");
        this._mainMap._mapMenu.setPanelOverlap(false);
        this._subMap.destroy();
        this._subMap = null;
      }
    }
    if (this._hash_options) this._hash_options.HashCreate();

  },

  _adjustSubMapDialogs: function (left) {

    try {
      var marginLeft = this._subMap._dialogManager._marginLeft;
      if (!marginLeft) marginLeft = 0;
      var x = this._subMap._viewListDialog.getLeft() - marginLeft;
      this._subMap._viewListDialog.setLeft(x + left);

      var x2 = this._subMap._layerTreeDialog.getLeft() - marginLeft;
      this._subMap._layerTreeDialog.setLeft(x2 + left);

    } catch (e) { }

  },

  _refreshClip: function (position) {

    if (position == undefined) {
      // クリップクリア
      if (this._subMap) {
        this._subMap.setClipLeft(0);
        this._subMap._dialogManager.setMarginLeft(0);
      }
      this._mainMap._dialogManager.setMarginRight(0);
      this._mainMap.setClipRight(0);

      this._mainMap._mapFrame.css({
        "clip": "auto"
      });
      return;
    }

    // クリップ
    var mapWidth = this._mainMap._mapFrame.outerWidth();
    var clipRight = Math.round(mapWidth * position);
    if (this._subMap) {
      this._adjustSubMapDialogs(clipRight);
      this._subMap.setClipLeft(clipRight);
      this._subMap._dialogManager.setMarginLeft(clipRight);
    }

    this._mainMap.setClipRight(mapWidth - clipRight);
    this._mainMap._dialogManager.setMarginRight(clipRight);
    this._mainMap._mapFrame.css({
      "clip": "rect(0px " + clipRight + "px 99999px 0px)"
    });

    if (this._compareSlider) {
      var width = $("#map").outerWidth();
      var left = (width * position) - this._compareSliderMargin;
      var pos = left / (width - (this._compareSliderMargin * 2));
      this._compareSlider.slider("option", "value", Math.round(10000 * pos));
    }
  },

  // ２画面表示中かどうか
  splited: function () {
    return (this._subMap && this._subMap._splited ? true : false);
  },

  // 2画面分割処理
  split: function (visible) {
    if (visible) {
      this.comparison(false);
    }

    if (visible) {
      this._mainMap._mapMenu.setPanelOverlap(true);
      if (!this._subMap) {
        this._mainMap.setPosition("left");
        var ctrlSetting = this._queryParams.getControlSetting();
        var viewSetting = this._queryParams.getViewSetting();
        var center = this._mainMap._map.getCenter();
        var zoom = this._mainMap._map.getZoom();
        // マップオブジェクト生成
        this._subMap = new GSI.MapManager(this, {
          startUpCenter: center,
          startUpZoom: zoom,
          multipopup: this._mainMap._map.options.multipopup,
          zIndex: 0,
          mapMenuRight: true,
          panelOverlap: true
        });

        this._subMap.on("mousedown", L.bind(this._onMapMousedown, this));
        this._subMap._splited = true;
        this._subMap.create();
        this._subMap.setPosition("right");

        this._subMap.initializeMap(ctrlSetting);
        this._subMap.initializeControls(this._queryParams, this._header, ctrlSetting, viewSetting);
        var layersJSON = this._layersJSON.clone();

        this._subMap._initializeDialogs(layersJSON, this._header.getHeight(), false, "");
        this._subMap._mapMenu.getMapListPanel().setTree_Init(layersJSON._data);
        this._subMap.initializeBaseLayer("std", false);

        this._subMap._baseLayer.addTo(this._subMap._map);

        this._subMap._baseLayer.setActiveIndex(0);
        var std = this._subMap._baseLayer.baseLayerList[0];

        this._subMap._mapLayerList.append(std);

        this._subMap._mapMouse.setClickMoveVisible(this._mainMap._mapMouse.getClickMoveVisible());
        this._subMap._centerCross.setVisible(this._mainMap._centerCross.getVisible());
        this._subMap._zoomGuide.setVisible(this._mainMap._zoomGuide.getVisible());

        this._subMap._syncControl = new GSI.Control.MapSplitControl({
          sync: this._syncSplitMap
        });
        this._subMap._syncControl.addTo(this._subMap._map);
        this._subMap._syncControl
          .on("stop", L.bind(function () {
            this.split(false);

          }, this))
          .on("syncchange", L.bind(function (e) {

            this._syncSplitMap = e.sync;
            this._refreshSync(this._syncSplitMap);
          }, this));

        this._refreshSync(this._syncSplitMap);

      }

      if (this._mainMap._comparePhotoControl) this._mainMap._comparePhotoControl.adjust();

    } else {

      if (this._subMap) {
        this._subMap._splited = false;
        this._refreshSync(false);
        this._mainMap.setPosition("full");
        if (!CONFIG.OVERLAPLEFTPANEL)
          this._mainMap._mapMenu.setPanelOverlap(false);
        this._subMap.destroy();
        this._subMap = null;
      }

      if (this._mainMap._comparePhotoControl) this._mainMap._comparePhotoControl.adjust();

    }
    if (this._hash_options) this._hash_options.HashCreate();
  },

  // ２画面同期設定
  _refreshSync: function (on) {
    if (!this._subMap) return;
    //sync
    if (on) {
      this._mainMap._map.sync(this._subMap._map);
      this._subMap._map.sync(this._mainMap._map);
      this._mainMap._map.invalidateSize();
      this._subMap._map.invalidateSize();
    }
    else {
      this._mainMap._map.unsync(this._subMap._map);
      this._subMap._map.unsync(this._mainMap._map);
    }
    if (this._hash_options) this._hash_options.HashCreate();
  },

  _clickMoveVisibleChange: function (visible) {
    if (this._subMap) this._subMap._mapMouse.setClickMoveVisible(visible);
    if (this._hash_options) this._hash_options.HashCreate();

  },

  _centerCrossVisibleChange: function (visible) {
    if (this._subMap) this._subMap._centerCross.setVisible(visible);
    if (this._hash_options) this._hash_options.HashCreate();

  },
  _zoomGuideVisibleChange: function (visible) {
    if (this._subMap) this._subMap._zoomGuide.setVisible(visible);

  },

  _initializeProc: function () {
    this._evacManager = new GSI.EvacuationManager(this._queryParams);

    if ((this._queryParams.params["ls"] && this._queryParams.params["ls"].indexOf(CONFIG.layerEvacuationHeader) >= 0) ||
      (this._queryParams.params["lcd"] && this._queryParams.params["lcd"].indexOf(CONFIG.layerEvacuationHeader) >= 0)) {
      var cfdlg = new GSI.Modal.confirmDialog();
      cfdlg.onPositiveButtonClick = L.bind(this.confirmOKClick, this, cfdlg);
      cfdlg.onNegativeButtonClick = L.bind(this.confirmCancelClick, this, cfdlg);
      cfdlg.show();
    }
    else {
      this._initializeProcSub();
    }
  },

  confirmOKClick: function (dlg) {
    dlg.hide();
    this._evacManager.accept();
    this._initializeProcSub();

    if (this._evacManager.isVisibleDialog() == true) {
      this._mainMap._evacDialog.show();
    }
    CONFIG.layerEvacuationIsConfirmOK = true;
  },

  confirmCancelClick: function (dlg) {
    dlg.hide();
    this._evacManager.cancel();
    this._initializeProcSub();
    CONFIG.layerEvacuationIsConfirmOK = false;
  },

  showConfirmPrevState: function () {
    return;
  },

  _initializeProcSub: function () {
    var ctrlSetting = this._queryParams.getControlSetting();
    var viewSetting = this._queryParams.getViewSetting();
    // ハッシュ解析
    var locationHash = location.hash;
    if (CONFIG.USECOOKIE) {
      if (!locationHash || locationHash == "" || locationHash == "#" ||
        locationHash.match(CONFIG.DEFAULTHASH)) {
        locationHash = Cookies.get(CONFIG.COOKIEKEY_HASH);
        if (!locationHash || locationHash == "") locationHash = "";
        if (locationHash != "" && locationHash.charAt(0) != "#") locationHash = "";
        if (locationHash != "") {
          location.replace(locationHash);
        }
      } else {
        var prevLocationHash = Cookies.get(CONFIG.COOKIEKEY_HASH_PREV);
        if (prevLocationHash) {
          if (prevLocationHash != locationHash) {
            this.showConfirmPrevState();
          }
        }
      }
    }

    var hashPosition = L.Hash.parseHash(locationHash);
    this._startUpCenter = this._queryParams.getPosition(hashPosition && hashPosition.center ? hashPosition.center : CONFIG.DEFAULT.CENTER);
    this._startUpZoom = this._queryParams.getZoom(hashPosition && hashPosition.zoom ? hashPosition.zoom : CONFIG.DEFAULT.ZOOM);

    this._startUpCenter2 = this._queryParams.getPosition2(this._startUpCenter);
    this._startUpZoom2 = this._queryParams.getZoom2(this._startUpZoom);

    var ctrlSetting = this._queryParams.getControlSetting();
    var viewSetting = this._queryParams.getViewSetting();

    // マップオブジェクト生成
    this._mainMap = new GSI.MapManager(this, {
      startUpCenter: this._startUpCenter,
      startUpZoom: this._startUpZoom,
      position: (viewSetting.splitWindow ? "left" : "full"),
      zIndex: 2,
      panelOverlap: (viewSetting.splitWindow || viewSetting.compareMap)
    });
    this._mainMap.on("mousedown", L.bind(this._onMapMousedown, this));
    this._mainMap.create();

    if (this._queryParams.getReliefData())
      this._mainMap._mapLayerList.setElevationData(this._queryParams.getReliefData());

    //最終的に生かす
    //GSI.GLOBALS.map = this._mainMap._map;

    this._mainMap.initializeMap(ctrlSetting, this._queryParams.getLeftPanelVisible());

    if (viewSetting.splitWindow) {
      // サブマップ生成
      this._subMap = new GSI.MapManager(this, {
        startUpCenter: this._startUpCenter2,
        startUpZoom: this._startUpZoom2,
        position: "right",
        multipopup: this._mainMap._map.options.multipopup,
        mapMenuRight: true,
        panelOverlap: true
      });
      this._subMap.on("mousedown", L.bind(this._onMapMousedown, this));
      this._subMap._splited = true;
      this._subMap.create();
      this._subMap.initializeMap(ctrlSetting);
    }

    if (viewSetting.compareMap) {
      // サブマップ生成
      this._subMap = new GSI.MapManager(this, {
        startUpCenter: this._startUpCenter2,
        startUpZoom: this._startUpZoom2,
        position: "full",
        multipopup: this._mainMap._map.options.multipopup,
        noZoomControl: true,
        noScaleControl: true,
        noFooter: true,
        mapMenuRight: true,
        panelOverlap: true
      });

      this._subMap.on("mousedown", L.bind(this._onMapMousedown, this));
      this._subMap.create();
      this._subMap.initializeMap(ctrlSetting);
      this._setCompared(true);

      if (this._queryParams.getReliefData2())
      this._subMap._mapLayerList.setElevationData(this._queryParams.getReliefData2());
    }
    // ヘッダー
    this._header = new GSI.Header(
      this._mainMap.getMap(), {
      visible: ctrlSetting.header.visible
      , message: (CONFIG.TOPMESSAGE && CONFIG.TOPMESSAGE.MESSAGE ? CONFIG.TOPMESSAGE.MESSAGE : null)
      , id: (CONFIG.TOPMESSAGE && CONFIG.TOPMESSAGE.ID ? CONFIG.TOPMESSAGE.ID : null)
      , expires: (CONFIG.TOPMESSAGE && CONFIG.TOPMESSAGE.EXPIRES ? CONFIG.TOPMESSAGE.EXPIRES : null)
    });
    this._mainMap.initializeControls(this._queryParams, this._header, ctrlSetting, viewSetting);

    if (this._subMap) {
      var viewSetting2 = $.extend(true, viewSetting, this._queryParams.getViewSetting2());
      this._subMap.initializeControls(this._queryParams, this._header, ctrlSetting, viewSetting2);
    }

    if (!this._subMap || !this._subMap._compared) {
      $("#map").css({ top: this._header.getHeight() + 'px' });
    } else {
      $("#map").css({ top: (this._header.getHeight() + 30) + 'px' });
    }
    try {
      this._mainMap._map.invalidateSize();
      this._subMap._map.invalidateSize();
    } catch (ex) {

    }

    // Layers.txt を読み込み
    this._layersJSON = new GSI.LayersJSON({
      layers: CONFIG.layerBase,
      layersTab: CONFIG.layersTab,
      tabUrls: null //CONFIG.layersTabUrl
    });

    this._layersJSON.on("load", L.bind(function (e) {
      var f = false;
      var headerHeight;
      this._mainMap._initializeDialogs(this._layersJSON, this._header.getHeight(),
        this._queryParams.getLeftPanelVisible(),
        this._queryParams.getCurrentPath());
      // Layers.txt を追加
      if (!this._layersJSON.loadBase()) {
        var n = 0;
        var v = this._layersJSON.getBase();
        for (n = 0; n < v.length; n++) {
          CONFIG.BASETILES[CONFIG.BASETILES.length] = v[n];
        }
        this._layersJSON.initialize_layers(this._queryParams.getLayers());

        for (var i = 0; i < this._layersJSON.visibleLayers.length; i++) {
          GSI.Utils.sendSelectedLayer(this._layersJSON.visibleLayers[i].id);
        }

        this._mainMap.initializeBaseLayer(this._queryParams.getBaseMap(), this._queryParams.getBaseMapGrayScale());

        this._layersJSON.add(CONFIG.layers);

        this._initializeProcMap();

        f = true;
      }
      else {
        f = false;
      }

      var map = this._mainMap.getMap();
      if (this._queryParams.getBaseMap() != "") {
        this._mainMap._baseLayer.addTo(map);
        if (!this._queryParams.getBaseMapDisp()) {
          map.removeLayer(this._mainMap._baseLayer);
        }
      }

      if (typeof this._mainMap._mapMenu != "undefined") {
        this._mainMap._mapMenu.getMapListPanel().setLayers(e.visibleLayers,e.tree, e.visibleLayersHash);
      }
      if (typeof this._cocoTileLayer != "undefined") {
        this._cocoTileLayer.refresh();
      }

      if (!f) {
        if (this._subMap) {
          var layersJSON = this._layersJSON.clone(this._queryParams.getLayers2());

          this._subMap._initializeDialogs(layersJSON, this._header.getHeight(),
            this._queryParams.getLeftPanel2Visible(),
            this._queryParams.getCurrentPath2());

          this._subMap.initializeBaseLayer(this._queryParams.getBaseMap2(), this._queryParams.getBaseMapGrayScale2());

          this._subMap._mapMenu.getMapListPanel().setLayers(layersJSON.visibleLayers, layersJSON.tree, layersJSON.visibleLayersHash);

          if (this._queryParams.getBaseMap2() != "") {
            this._subMap._baseLayer.addTo(this._subMap._map);
            if (!this._queryParams.getBaseMapDisp2()) {
              this._subMap.getMap().removeLayer(this._subMap._baseLayer);
            }
          }

          this._subMap._mapMouse.setClickMoveVisible(this._mainMap._mapMouse.getClickMoveVisible());
          this._subMap._centerCross.setVisible(this._mainMap._centerCross.getVisible());
          this._subMap._zoomGuide.setVisible(this._mainMap._zoomGuide.getVisible());

          if (this.compared()) {
            if (!this._comparisonSeparater) {
              this._comparisonSeparater = new GSI.MapCompareSeparater(this, { margin: this._compareSliderMargin });
              this._comparisonSeparater.on("change", L.bind(function (e) {
                this._refreshClip(e.position);
              }, this));
            }
            this._comparisonSeparater.show();
            this._refreshSync(true);
          } else {
            this._subMap._syncControl = new GSI.Control.MapSplitControl({
              sync: this._syncSplitMap
            });

            this._subMap._syncControl.addTo(this._subMap._map);

            if ( this._subMap._comparePhotoControl && this._subMap._comparePhotoControl.isVisible() ) {
              this._subMap._syncControl.setTopMargin();
            }

            this._subMap._syncControl
              .on("stop", L.bind(function () {
                this.split(false);

              }, this))
              .on("syncchange", L.bind(function (e) {

                this._syncSplitMap = e.sync;
                this._refreshSync(this._syncSplitMap);
              }, this));
            this._refreshSync(this._syncSplitMap);
          }
        }

        this.fire("initialized");

        this._hash_options = new GSI.HashOptions(this, map);
        this._hash.bind(this._hash_options, this._hash_options.Callback);
        this._hash.onMapMove();

      }
    }, this));

    this._layersJSONStartTime = +new Date();
    this._layersJSON.load();
  },

  _initializeProcMap: function () {

    var ctrlSetting = this._queryParams.getControlSetting();
    var viewSetting = this._queryParams.getViewSetting();
    var map = this._mainMap.getMap();
    // ハッシュ
    this._hash = new L.Hash(map, { useReplace: (GSI.ClientMode.location ? false : true) });
    this._onoffObjects = {};
    // 中心マーク
    this._mainMap._centerCross.on("change", L.bind(function (e) {
      this._centerCrossVisibleChange(e.visible);
    }, this));
    this._onoffObjects[CONFIG.PARAMETERNAMES.CENTERCROSS] = { obj: this._mainMap._centerCross, setter: 'setVisible', getter: 'getVisible' };
    // 表示ズームの案内
    this._mainMap._zoomGuide.on("change", L.bind(function (e) {
      this._zoomGuideVisibleChange(e.visible);
    }, this));
    this._onoffObjects[CONFIG.PARAMETERNAMES.ZOOMGUIDE] = { obj: this._mainMap._zoomGuide, setter: 'setVisible', getter: 'getVisible' };

    // 磁北線
    this._onoffObjects[CONFIG.PARAMETERNAMES.JIHOKULINE] = { obj: new GSI.JihokuLine(map, { visible: viewSetting.jihokuLine, lineStyle: CONFIG.JIHOKULINESTYLE, num: CONFIG.JIHOKULINECOUNT }), setter: 'setVisible', getter: 'getVisible' };

    // 緯度経度グリッド
    this._onoffObjects[CONFIG.PARAMETERNAMES.LATLNGGRID] = { obj: new GSI.LatLngGrid(map, { visible: viewSetting.latLngGrid, lineStyle: CONFIG.LATLNGGRIDSTYLE, condition: CONFIG.LATLNGGRID.CONDITION, labelClassName: CONFIG.LATLNGGRIDLABELCLASSNAME }), setter: 'setVisible', getter: 'getVisible' };
    // UTMグリッド
    this._onoffObjects[CONFIG.PARAMETERNAMES.UTMGRID] = { obj: new GSI.UTM.Grid(map, { visible: viewSetting.utmGrid, lineStyle: CONFIG.UTMGRIDSTYLE, condition: CONFIG.UTMGRID.CONDITION, labelClassName: CONFIG.UTMGRIDLABELCLASSNAME }), setter: 'setVisible', getter: 'getVisible' };

    // タイル座標
    this._onoffObjects[CONFIG.PARAMETERNAMES.TILEGRID] = { obj: new GSI.TileGrid(map, { visible: viewSetting.tileGrid, lineStyle: CONFIG.UTMGRIDSTYLE, condition: CONFIG.UTMGRID.CONDITION, labelClassName: CONFIG.UTMGRIDLABELCLASSNAME }), setter: 'setVisible', getter: 'getVisible' };

    // 地域メッシュ
    this._onoffObjects[CONFIG.PARAMETERNAMES.CHIIKIMESH] = { obj: new GSI.ChiikiMesh(map, { visible: viewSetting.chiikiMesh, lineStyle: CONFIG.UTMGRIDSTYLE, condition: CONFIG.UTMGRID.CONDITION, labelClassName: CONFIG.UTMGRIDLABELCLASSNAME }), setter: 'setVisible', getter: 'getVisible' };

    // 1/25000
    this._onoffObjects[CONFIG.PARAMETERNAMES.T25000GRID] = { obj: new GSI.TGrid(map, { visible: viewSetting.t25000Grid, lineStyle: CONFIG.UTMGRIDSTYLE, condition: CONFIG.UTMGRID.CONDITION, labelClassName: CONFIG.UTMGRIDLABELCLASSNAME }), setter: 'setVisible', getter: 'getVisible' };

    // // 国土基本図郭
    // if (GSI.KihonzukakuGrid) {
    //   this._onoffObjects[CONFIG.PARAMETERNAMES.KOKUDOKIHONZUKAKU] = { obj: new GSI.KihonzukakuGrid(this._mainMap._dialogManager, map, undefined, { visible: viewSetting.kokudokihonzukaku, lineStyle: CONFIG.KOKUDOKIHONZUKAKU_LINESTYLE }), setter: 'setVisible', getter: 'getVisible' };
    // }

    // ミニマップ
    this._onoffObjects[CONFIG.PARAMETERNAMES.MINIMAP] = { obj: new GSI.MiniMap(map, { visible: viewSetting.miniMap }), setter: 'setVisible', getter: 'getVisible' };

    // クリックで移動
    this._mapMouse = this._mainMap._mapMouse;
    this._mapMouse.on("change", L.bind(function (e) {
      this._clickMoveVisibleChange(e.visible);
    }, this));
    this._onoffObjects[CONFIG.PARAMETERNAMES.CLICKMOVE] = { obj: this._mapMouse, setter: 'setClickMoveVisible', getter: 'getClickMoveVisible' };

    this._multiPopup = {};
    this._multiPopup.setMultiPopupVisible = L.bind(function (val) {
      if (this._subMap) this._subMap._map.setMultiPopup(val);
      return this._mainMap._map.setMultiPopup(val);
    }, this);
    this._multiPopup.getMultiPopupVisible = L.bind(function () {
      return this._mainMap._map.options.multipopup;
    }, this);

    this._onoffObjects[CONFIG.PARAMETERNAMES.MULTIPOPUP] = { obj: this._multiPopup, setter: 'setMultiPopupVisible', getter: 'getMultiPopupVisible' };

    this._panelOverlapManager = {};

    this._panelOverlapManager.getOverlap = L.bind(function () {
      return CONFIG.OVERLAPLEFTPANEL;
    }, this);
    this._panelOverlapManager.setOverlap = L.bind(function (value) {
      CONFIG.OVERLAPLEFTPANEL = value;
      this._mainMap._mapMenu.setPanelOverlap(value);
    }, this);

    this._onoffObjects[CONFIG.PARAMETERNAMES.PANELOVERLAP] = { obj: this._panelOverlapManager, setter: 'setOverlap', getter: 'getOverlap' };

    this._onoffObjects[CONFIG.PARAMETERNAMES.USEGSIDISTANCE] = {
      obj:
      {
        setUseGSIDistance: function (on) { CONFIG.USEGSIDISTANCE = on; },
        getUseGSIDistance: function () { return CONFIG.USEGSIDISTANCE; }
      }, setter: 'setUseGSIDistance', getter: 'getUseGSIDistance'
    };

    this._onoffObjects[CONFIG.PARAMETERNAMES.SAVESTATE] = {
      obj: new GSI.SaveStateManager(this), setter: 'setVisible', getter: 'getVisible'
    };

    this._footerManager = {};

    this._footerManager.setVisible = L.bind(function (val) {
      if (this._subMap && this._subMap._footer) this._subMap._footer.setDisplayMode(val);
      this._mainMap._footer.setDisplayMode(val);

    }, this);

    this._footerManager.getVisible = L.bind(function (val) {
      return this._mainMap._map._footer.getDisplayMode();
    }, this);
    this._onoffObjects[CONFIG.PARAMETERNAMES.FOOTER] = { obj: this._footerManager, setter: 'setVisible', getter: 'getVisible' };

    // 機能メニュー
    this._funcMenu = new GSI.Menu(
      this,
      $("#header .gsi-header-tools"),
      CONFIG.UI.MENU,
      undefined,
      this._onoffObjects
    );
    this._funcMenu.on("select", L.bind(this._onMenuItemClick, this));
    this._funcMenu.on("mouseover", L.bind(this._onMenuItemMouseOver, this));
    this._funcMenu.on("mouseout", L.bind(this._onMenuItemMouseOut, this));

    $("#header").css({ "padding-right": this._funcMenu.getToolsWidth() + "px" });

    var dialogManager = this._mainMap._dialogManager;
    // 等距権

    if (this._queryParams.getReliefData())
      this._mainMap._mapLayerList.setElevationData(this._queryParams.getReliefData());

    if (this._queryParams.getReliefData2())
      this._subMap._mapLayerList.setElevationData(this._queryParams.getReliefData2());

    this._onoffObjects[CONFIG.PARAMETERNAMES.TOUKYOKEN] = { obj: new GSI.Toukyoken(
        map, dialogManager, this._funcMenu, { visible: viewSetting.toukyoKen, center: this._queryParams.getToukyokenCenter()}),
        setter: 'setVisible', getter: 'getVisible' };

    // 方位線
    this._onoffObjects[CONFIG.PARAMETERNAMES.HOUILINE] = { obj: new GSI.HouiLine(
        map, dialogManager, this._funcMenu, { visible: viewSetting.houiLine, center: this._queryParams.getHouilineCenter()}),
        setter: 'setVisible', getter: 'getVisible' };

    if (this._onoffObjects[CONFIG.PARAMETERNAMES.KOKUDOKIHONZUKAKU])
      this._onoffObjects[CONFIG.PARAMETERNAMES.KOKUDOKIHONZUKAKU].obj._menu = this._funcMenu;

    // 検索ダイアログ
    if (ctrlSetting.header.visible) {
      this._searchDialog = new GSI.SearchResultDialog(this._mainMap._dialogManager, map, {
        left: 8,
        top: 40,
        effect: CONFIG.EFFECTS.DIALOG,
        resizable: "all",
        maxMarkerNum: CONFIG.SEARCHRESULTMAXMARKERNUM
      });

      new GSI.Searcher(
        map,
        this._searchDialog,
        "#search_f",
        "#query",
        "#search_result", {
        visible: ctrlSetting.header.visible
      }
      );
    }

    this._pageStateManager = new GSI.PageStateManager(this, map, this._mainMap._baseLayer,
      this._onoffObjects, this._mainMap._mapLayerList, this._mainMap._mapMenu);

    // 共有作図情報がある場合ダイアログ生成
    this._sakuzuList = new GSI.SakuzuList(this, map, this._mapMouse, {
      url: CONFIG.SAKUZU.SYMBOL.URL + CONFIG.SAKUZU.SYMBOL.DEFAULTICON,
      size: CONFIG.SAKUZU.SYMBOL.ICONSIZE,
      anchor: CONFIG.SAKUZU.SYMBOL.ICONANCHOR,
      _iconScale: CONFIG.SAKUZU.SYMBOL.ICON_SCALE
    },
      {
        defaultList: GSI.ClientMode.sakuzuList
      }
    );

    // 画面サイズの調整
    var adjustWindow = L.bind(function () {
      var size = GSI.Utils.getScreenSize();
      this._header.refresh(size);

      // ↓Leaflet.Sync解除後のL.Map._onResizeエラー回避のため(map生成時trackResize=falseにすること)
      if (this._mainMap) L.Map.prototype._onResize.call(this._mainMap._map);
      if (this._subMap) L.Map.prototype._onResize.call(this._subMap._map);

    }, this);
    this._header.on('topmessagechange', adjustWindow);
    $(window).on('resize',adjustWindow);

    // 初期位置設定
    map.setView(this._startUpCenter, this._startUpZoom, { reset: true });

    // ファイル
    window.addEventListener("dragover", function (e) {
      e.stopPropagation();
      e.preventDefault();
      e.dataTransfer.dropEffect = "copy";
    }, false);

    window.addEventListener("drop", L.bind(function (e) {
      e.stopPropagation();
      e.preventDefault();

      var loader = new GSI.LocalFileLoader(e.dataTransfer.files);
      loader.on("load", L.bind(function (evt) {
        var list = evt.list;

        var imageList = [];
        var sakuzuList = [];
        var csvList = [];

        for (var i = 0; i < list.length; i++) {
          var item = list[i];

          if (item.fileName.match(/\.tif[f]*$/i)
            || item.fileName.match(/\.jpg$/i)
            || item.fileName.match(/\.jpeg$/i)) {
            imageList.push({
              "data": item.reader.result,
              "fileName": item.fileName,
              "file": item.file
            });
          } else if (item.fileName.match(/\.csv$/i)) {
            var arr = Encoding.convert(new Uint8Array(item.reader.result), "UNICODE", "AUTO");
            if (arr[0] == 65279) arr.splice(0, 1);
            csvList.push({
              "data": Encoding.codeToString(arr),
              "fileName": item.fileName
            });
          } else {
            var arr = Encoding.convert(new Uint8Array(item.reader.result), "UNICODE", "AUTO");
            if (arr[0] == 65279) arr.splice(0, 1);
            sakuzuList.push({
              "data": Encoding.codeToString(arr),
              "fileName": item.fileName
            });
          }
        }

        if (imageList.length > 0) {
          this._sakuzuList.loadFromImageList(imageList);
        }

        if (csvList.length > 0) {
          this._sakuzuList.loadFromCSVList(csvList);
        }

        if (sakuzuList.length > 0) {
          this._sakuzuList.loadFromTextList(sakuzuList);
        }

      }, this));
      loader.load();

    }, this), false);

    $("#title_twitter").on('click',function () {
      GSI.SHARE.showTwitter();
    });

    $("#title_facebook").on('click',function () {
      GSI.SHARE.showFacebook();
    });

  },

  executeSaveImage: function () {

    if (!this._mapToImageAreaSelectDialog) {

      var windowSize = GSI.Utils.getScreenSize();
      this._mapToImageAreaSelectDialog = new GSI.MapToImageAreaSelectDialog(this,
          this._mainMap, this._mainMap.getMap(), {
        width: 300, left: windowSize.w - 320, top: 45,
        effect: CONFIG.EFFECTS.DIALOG,
        zoomControl: undefined
      });

    }

    if ( this.compared() || this.splited()) {
      this._mapToImageAreaSelectDialog.setSubMapManager(this._subMap);
      //subMapResult.mapToImage.

      this._mapToImageAreaSelectDialog.executeAll(this.compared() ? this._comparisonSeparater.getLeft() : null );

    } else {
      this._mapToImageAreaSelectDialog.setSubMapManager(null);
      this._mapToImageAreaSelectDialog.show();
    }
  },

  showQRCodeDialog: function () {

    if (!this._qrCodeDialog) this._qrCodeDialog = new GSI.QRCodeDialog(
      this._mainMap._dialogManager,
      this._mainMap.getMap(),
      { width: 270, left: 'center', top: 45, effect: CONFIG.EFFECTS.DIALOG, resizable: false });
    this._qrCodeDialog.show();
  },

  showShareDialog: function (mode) {

    // 共有
    if (!this._shareDialog) this._shareDialog = new GSI.ShareDialog(
      this,
      this._mainMap._dialogManager,
      this._mainMap.getMap(), this._mainMap, this._pageStateManager, this._layersJSON, this._sakuzuList,
      { width: 350, left: 'center', top: 45, effect: CONFIG.EFFECTS.DIALOG, resizable: false });

    // 終了時のアラート表示 追加
    window._sakuzuDialogFlag = true;
    $(window).off('beforeunload').on('beforeunload', function(e) { return 'このページから移動しますか？ 入力した情報は保存されません。';});
    this._shareDialog.show(mode);

  },

  _onMenuItemMouseOver: function (evt) {
    if (evt.item.id != "gsi3d_s" && evt.item.id != "gsi3d_l") return;
    var id = evt.item.id;
    var map = this._mainMap.getMap();
    var dialogManager = this._mainMap._dialogManager;
    if (id == 'gsi3d_s') {
      if (this.__area3D) map.removeLayer(this.__area3D);
      var icon = L.divIcon({
        className: 'my-div-icon',
        html: '<div style="position:absolute;margin-top:-512px;margin-left:-512px;border:3px solid #cd5e3c;width:1024px; height:1024px"></div>'
      });

      this.__area3D = L.marker(map.getCenter(), { icon: icon }).addTo(map);

    }
    else if (id == 'gsi3d_l') {
      if (this.__area3D) map.removeLayer(this.__area3D);
      var icon = L.divIcon({
        className: 'my-div-icon',
        html: '<div style="position:absolute;margin-top:-1024px;margin-left:-1024px;border:3px solid #cd5e3c;width:2048px; height:2048px"></div>'
      });

      this.__area3D = L.marker(map.getCenter(), { icon: icon }).addTo(map);

    }
  },
  _onMenuItemMouseOut: function (evt) {

    var id = evt.item.id;
    var map = this._mainMap.getMap();
    if (this.__area3D) map.removeLayer(this.__area3D);
    this.__area3D = null;
  },

  /*
  メニュー選択時
  */
  _onMenuItemClick: function (evt) {
    var map = this._mainMap.getMap();
    var dialogManager = this._mainMap._dialogManager;
    var windowSize = this._mainMap._dialogManager.getScreenSize();

    switch (evt.item.id) {
      case "reset":
        Cookies.set(CONFIG.COOKIEKEY_HASH, null, { path: '/', expires: -1 });
        location.href = location.pathname;
        break;

      case "help":
        // ヘルプ表示
        showHelp();
        break;

      case "to-mobile":
      case "to-pc":
        this.openLink(evt.item.id, map);
        break;

      case "share":
        if (!this._sharePanel)
          this._sharePanel = new GSI.SharePanel(this, {});

        this._sharePanel.toggle({ "center": evt.from.getPosition().left + Math.floor(evt.from.getSize().width / 2) });
        break;

      case "placecode":
        var a = $("<a>");
        $("body").append(a);
        a.attr({ "href": "http://ucopendb.gsi.go.jp/ucode_app/logical_code/ucode_disp.php", "target": "_blank" })
          .on('click',L.bind(function (a) {
            var map = this._mainMap.getMap();
            var center = map.getCenter();
            var z = map.getZoom();

            var url = 'http://ucopendb.gsi.go.jp/ucode_app/logical_code/ucode_disp.php?lat=' + center.lat + '&lng=' + center.lng + '&zoom=' + z;
            a.attr({ "href": url });
          }, this, a));

        setTimeout(L.bind(function (a) {
          a[0].click();
          setTimeout(L.bind(function (a) {
            a.remove();
          }, this, a), 1);
        }, this, a), 1);
        break;

      case "print":
        // 印刷
        if (!this._pagePrinter) this._pagePrinter =
          new GSI.PagePrinter(
            map, this._mainMap._baseLayer,
            this._mainMap._mapLayerList,
            this._sakuzuList,
            {
              latLngGrid: this._onoffObjects[CONFIG.PARAMETERNAMES.LATLNGGRID].obj,
              utmGrid: this._onoffObjects[CONFIG.PARAMETERNAMES.UTMGRID].obj,
              tileGrid: this._onoffObjects[CONFIG.PARAMETERNAMES.TILEGRID].obj,
              t25000Grid: this._onoffObjects[CONFIG.PARAMETERNAMES.T25000GRID].obj,
              chiikiMesh: this._onoffObjects[CONFIG.PARAMETERNAMES.CHIIKIMESH].obj,
              jihokuLine: this._onoffObjects[CONFIG.PARAMETERNAMES.JIHOKULINE].obj,
              toukyoKen: this._onoffObjects[CONFIG.PARAMETERNAMES.TOUKYOKEN].obj,
              houiLine: this._onoffObjects[CONFIG.PARAMETERNAMES.HOUILINE].obj,
              kokudokihonzukaku: (!CONFIG.DISABLE_KOKUDOKIHONZUZUKAKU ? this._onoffObjects[CONFIG.PARAMETERNAMES.KOKUDOKIHONZUKAKU].obj : undefined)
            });
        this._pagePrinter.show();
        break;

      case "danmen":
        // 断面図

        if (this._sakuzuDialog && this._sakuzuDialog.getVisible()) {
          alert('作図中は断面図を作成できません');
          return;
        }
        if (this._crossSectionViewDialog && this._crossSectionViewDialog.isMinimized()) {
          alert('断面図最小化中は作図出来ません');
          return;
        }

        if (this._measureDialog && (this._measureDialog.getVisible() || this._measureDialog.isMinimized())) {
          this._measureDialog.hide();
        }

        var windowSize = GSI.Utils.getScreenSize();
        if (!this._crossSectionViewDialog) this._crossSectionViewDialog = new GSI.CrossSectionViewDialog(
          dialogManager,
          map,
          { width: 280, left: windowSize.w - 300, top: 45, effect: CONFIG.EFFECTS.DIALOG, resizable: false });
        this._crossSectionViewDialog.show();
        break;

      case 'measure':
        // 計測ダイアログ

        if (this._sakuzuDialog && this._sakuzuDialog.getVisible()) {
          alert('作図中は計測出来ません');
          return;
        }
        if (this._sakuzuDialog && this._sakuzuDialog.isMinimized()) {
          alert('作図中は計測出来ません');
          return;
        }

        if (this._crossSectionViewDialog && this._crossSectionViewDialog.getVisible()) {
          alert('断面図表示中は計測機能は使用できません');
          return;
        }
        if (this._crossSectionViewDialog && this._crossSectionViewDialog.isMinimized()) {
          alert('断面図最小化中は作図出来ません');
          return;
        }

        if (!this._measureDialog)
          this._measureDialog = new GSI.MeasureDialog(dialogManager, map, this._mapMouse, {
            left: windowSize.w - 310,
            top: 45,
            effect: CONFIG.EFFECTS.DIALOG
          });
        this._measureDialog.show();

        break;

      case 'sakuzu':
        // 作図ダイアログ

        if (this._crossSectionViewDialog && this._crossSectionViewDialog.getVisible()) {
          alert('断面図表示中は作図出来ません');
          return;
        }
        if (this._crossSectionViewDialog && this._crossSectionViewDialog.isMinimized()) {
          alert('断面図最小化中は作図出来ません');
          return;
        }

        CONFIG.SAKUZU.SYMBOL.DEFAULTICON = CONFIG.SAKUZU.SYMBOL.INIT_DEFAULTICON;
        CONFIG.SAKUZU.SYMBOL.ICON_SCALE = CONFIG.SAKUZU.SYMBOL.INIT_ICON_SCALE;
        if (this._measureDialog && (this._measureDialog.getVisible() || this._measureDialog.isMinimized())) {
          this._measureDialog.hide();
        }
        if (!this._sakuzuDialog)
          this._sakuzuDialog = new GSI.SakuzuDialog(
            dialogManager,
            map,
            this._sakuzuList,
            {
              width: 350, left: windowSize.w - 370, top: 45,
              effect: CONFIG.EFFECTS.DIALOG,
              resizable: (GSI.Utils.Browser.isSmartMobile ? false : "all")
            }
          );
        this._sakuzuDialog.show();

        break;

      case 'comparisonmap':
        this.comparison(!this.compared());
        break;

      case 'splitwindow':
        this.split(!this.splited());
        break;

      case 'photo':
        this.comparePhoto();
        break;

      case 'gsiglobe':
        this.openLink(evt.item.id, map);
        break;

      case 'gsi3d_l':
      case 'gsi3d_s':
      case 'gsivector':
        var linkUrl = GSI.Links.getURL(this._pageStateManager, evt.item.id,
          map.getCenter().wrap(), map.getZoom(), map.getBounds());
        if (!GSI.Utils.canUseWebGL()) {
          jConfirm("ご利用の環境では正しく表示されない可能性があります。", '確認', L.bind(function (linkUrl, r) {
            if (r) {
              window.open(linkUrl);
            }
          }, this, linkUrl));
          return;
        }
        window.open(linkUrl);
        break;

      case 'gsi3d_custom':

        if (!GSI.Utils.canUseWebGL()) {

          jConfirm("ご利用の環境では正しく表示されない可能性があります。", '確認', L.bind(function (map, r) {
            if (r) {
              if (!this._threeDAreaDialog) {
                var windowSize = GSI.Utils.getScreenSize();
                this._threeDAreaDialog = new GSI.ThreeDAreaDialog(this, this._mainMap._dialogManager, map, {
                  width: 300, left: windowSize.w - 320, top: 45,
                  effect: CONFIG.EFFECTS.DIALOG,
                  zoomControl: undefined
                });
              }
              this._threeDAreaDialog.show();

            }
          }, this, map));
          return;
        }

        if (!this._threeDAreaDialog) {
          var windowSize = GSI.Utils.getScreenSize();
          this._threeDAreaDialog = new GSI.ThreeDAreaDialog(this, this._mainMap._dialogManager, map, {
            width: 300, left: windowSize.w - 320, top: 45,
            effect: CONFIG.EFFECTS.DIALOG,
            zoomControl: undefined
          });
        }
        this._threeDAreaDialog.show();

        break;
      case 'loadoutsidetile':

        if (!this._loadOutsideTileDialog) {
          var windowSize = GSI.Utils.getScreenSize();
          this._loadOutsideTileDialog = new GSI.LoadOutsideTileDialog(
            this._mainMap._dialogManager,
            map,
            this._mainMap._mapLayerList,
            this._mainMap._mapMenu.getShowingMapListPanel(),
            {
              width: 320, left: parseInt(windowSize.w / 2 - 160), top: 45,
              effect: CONFIG.EFFECTS.DIALOG,
            });
        }
        this._loadOutsideTileDialog.show();
        break;

      case "link":
        this.openLink(evt.item.url, map);

        break;
    }
    if (evt.item.id != "help" && evt.item.id != "share" && evt.item.id != "print" && evt.item.id != "to-pc" && evt.item.id != "to-mobile" && evt.item.id != "reset"){
      var usedid = evt.item.id;
      GSI.Utils.sendSelectedFunction(usedid);
    }
  },

  openLink: function (url, map) {
    var linkUrl = GSI.Links.getURL(this._pageStateManager, url,
      map.getCenter().wrap(), map.getZoom(), map.getBounds());

    if (url == "gsi3d_l" || url == "gsi3d_s" || url == "gsiglobe" || url == "gsivector") {
      // WebGLの対応チェック
      if (!GSI.Utils.canUseWebGL()) {

        jConfirm("ご利用の環境では正しく表示されない可能性があります。", '確認', L.bind(function (linkUrl, r) {
          if (r) {
            window.open(linkUrl);
          }
        }, this, linkUrl));
        return;
      }
    } else if (url == "to-mobile" || url == "to-pc") {

      location.href = (url == "to-mobile" ? CONFIG.MOBILEURL : CONFIG.URL) + location.hash +
        (url == "to-pc" ? "&frommobile" : "");
      return;
    }

    if (linkUrl) {
      window.open(linkUrl);
      $(this.topSelector + ' span').removeClass('selected');
      $(this.topSelector + ' ul').hide();
    }
  },

  _onMapMousedown: function () {
    if (CONFIG.MOBILE) {
      if (this._mainMap) this._mainMap.hideMapMenu();
      if (this._subMap) this._subMap.hideMapMenu();
    }
  }
});

/************************************************************************
  GSI.MapCompareSeparater
    画像比較機能　分割
************************************************************************/
GSI.MapCompareSeparater = L.Evented.extend({
  initialize: function (gsimaps, options) {
    this._gsimaps = gsimaps;
    L.setOptions(this, options);
  },

  show: function () {
    this._create();
    this._refresh();
    this._container.show();

    if (!this._resizeHandler) {
      this._resizeHandler = L.bind(this._onResize, this);
      $(window).on("resize", this._resizeHandler);

    }
  },

  hide: function () {
    this._container.hide();

    if (this._resizeHandler) {
      $(window).off("resize", this._resizeHandler);
      this._resizeHandler = undefined;
    }
  },

  getLeft : function() {
    return this._left;
  },

  _onResize: function () {
    this._refresh();
  },

  _refresh: function () {
    var width = $("#map").outerWidth();

    if (this._position == undefined) {
      this._position = 0.5;
    }
    var left = Math.round(width * this._position);

    this._container.css({ "left": left + "px" });

    this._left = left;

    this.fire("change", {
      "position": this._position
    })

  },

  setLeft: function (left) {

    this._container.css({ "left": left + "px" });

    var width = $("#map").outerWidth();

    this._position = left / width;

    this._left = left;

    this.fire("change", {
      "position": this._position
    });
  },

  _onDrag: function (event, ui) {
    this.setLeft(ui.position.left);
  },

  _onDragEnd: function (event, ui) {
    var width = $("#map").outerWidth();

    var left = ui.position.left;
    if (left < this.options.margin) {
      left = this.options.margin;
    }

    if (left > width - this.options.margin) {
      left = width - this.options.margin;
    }

    this._position = left / width;

    this._refresh();
    this.fire("change", {
      "position": this._position
    });
  },

  _create: function () {
    if (this._container) return;

    this._container = $("<div>")
      .css({
        "position": "absolute",
        "top": "0px",
        "bottom": "0px",
        "z-index": 10000
      })
      .addClass("gsi_mapcompare_separater")
      .hide();

    $("#map").append(this._container);
    this._container.draggable({
      "axis": "x",
      "drag": L.bind(this._onDrag, this),
      "stop": L.bind(this._onDragEnd, this)
    });
  }
});

/************************************************************************
  GSI.SaveStateManager
    クッキーに保存管理
************************************************************************/
GSI.SaveStateManager = L.Evented.extend({
  initialize: function (gsimaps, options) {
    this._gsimaps = gsimaps;
    L.setOptions(this, options);
  },

  setVisible: function (on) {
    if (GSI.SaveStateManager.checkEnableCookie()) {
      Cookies.set(CONFIG.COOKIEKEY_USECOOKIE, on ? "1" : "0", { path: '/', expires: 365 });
      if (!on) {
        Cookies.set(CONFIG.COOKIEKEY_HASH, null, { path: '/', expires: -1 });
      }
      CONFIG.USECOOKIE = on;
      if (this._gsimaps._hash_options) this._gsimaps._hash_options.HashCreate(true);
    } else {

      CONFIG.USECOOKIE = false;
    }
  },

  getVisible: function (on) {
    return (
      GSI.SaveStateManager.checkEnableCookie() && CONFIG.USECOOKIE);
  }
});

// クッキーが利用可能かチェック
GSI.SaveStateManager.checkEnableCookie = function () {
  var result = true;

  if (navigator.cookieEnabled) {
    document.cookie = 'enabled_cookie=1';
    if (document.cookie) {
      if (document.cookie.length > 0) {
        if (document.cookie.indexOf('enabled_cookie') > -1) {
          result = true;
        }
      }
    }
  } else {
    result = false;
  }

  return result;
};

CONFIG.USECOOKIE = GSI.SaveStateManager.checkEnableCookie()
  && (Cookies.get(CONFIG.COOKIEKEY_USECOOKIE) != "0");

$(document).ready(function () {

  if (L.Browser.ie){
    return;
  }

  $(".logoarea a").on('click', function () {
    Cookies.set(CONFIG.COOKIEKEY_HASH, null, { path: '/', expires: -1 });
    return true;
  });

  $(".logoarea").attr({ "title": CONFIG.TOOLTIP.TOP.TOP });

  if (!L.Browser.mobile) {
    $("body").tooltip({
      "show": { duration: 300 },
      "hide": { duration: 200 },
      "open": function (evt, ui) {
      },
      "position": { my: "left top + 20", at: "center bottom", collision: "flipfit" }
    });
  }
  // CONFIG.layers情報読み込み
  $.ajax({
    type: "GET",
    dataType: "JSON",
    cache: CONFIG.LOADLAYERSTXTCACHE,
    url: CONFIG.layersURL,
    async: true
  })
    .done(function (data) {
      CONFIG.layers = data;
      for (var i = 0; i < CONFIG.layers.length; i++) {
        var url = CONFIG.layers[i].url;
        var urlParts = CONFIG.layersURL.split("/");

        if (url.indexOf("../") == 0) {
          urlParts.pop();
          urlParts.pop();
          url = url.replace("../", urlParts.join("/") + "/");
        } else if (url.indexOf("./") == 0) {
          urlParts.pop();
          url = url.replace("./", urlParts.join("/") + "/");
        }

        CONFIG.layers[i].url = url;
      }
    })
    .always(function () {
      if (!CONFIG.layers) CONFIG.layers = [];
      GSI.GLOBALS.gsimaps = new GSI.GSIMaps();
      GSI.GLOBALS.gsimaps.on("initialized", function () {
        // 表示の準備が出来た後に処理を行いたい場合はここに記述
      });

    });

});

/************************************************************************
 L.Layer
  - GSI.ComparePhotoLayer（時系列表示レイヤ）
 ************************************************************************/
GSI.ComparePhotoLayer = L.Layer.extend( {
  activeIndex: 0,
  isGrayScale: false,
  opacity: 1,
  isTileImage: true,
  initialize: function (mapManager, defaultMap, defaultMapGrayScale, layerInfo) {
    this._mapManager = mapManager;
    this.activeIndex = 0;
    this.activeIndexPre = -1;
    this._layerInfo = layerInfo;
    this._layerList = CONFIG.COMPAREPHOTO_PHOTOLIST;

    options = L.setOptions(this, {});
    options.minZoom = 2;
    this.setActiveIndex(this.activeIndex);
    this.setGrayScale(defaultMapGrayScale);

    if (!L.android) {
      this.on('tileunload', this._onTileRemove);
    }
  },

  getLayerInfo : function() {
    return this._layerInfo;
  },

  getOpacity: function (opacity) {
    return this.opacity;
  },
  setOpacity: function (opacity) {
    this.opacity = opacity;
    this.options.opacity = opacity;
    if ( this._layer ) {
      this._layer.setOpacity( opacity );
    }
  },

  getAttribution: function () {
    if (this._layerList[this.activeIndex].attribution) {
      return this._layerList[this.activeIndex].attribution;
    }
    return "";
  },

  getActiveTitle: function() {
    if ( this.activeIndex < 0 || this.activeIndex > this._layerList.length-1 ) return "";
    var year = this._layerList[this.activeIndex].year;

    return year.from + "年" + ( year.to ? "〜" + year.to + "年" : "" );
  },

  getActiveId: function () {
    return this._layerList[this.activeIndex].id;
  },
  getActiveIndex: function () {
    return this.activeIndex;
  },
  setActiveId: function (id) {
    for (var i = 0; i < this._layerList.length; i++) {
      if (this._layerList[i].id == id) {
        this.setActiveIndex(i);
      }
    }
  },
  setActiveIndex: function (idx) {
    if (this.activeIndexPre == -1 || this.activeIndexPre != idx) {
      this.activeIndex = idx;

      var url = this._layerList[idx].url;
      var options = {};

      if (this._layerList[idx].subdomains) {
        options.subdomains = this._layerList[idx].subdomains;
      }
      options.maxNativeZoom = this._layerList[idx].maxNativeZoom;

      if (this._layerList[idx].maxZoom) {
        options.maxZoom = this._layerList[idx].maxZoom;
      } else {
        options.maxZoom = 18;
      }

      if (this._layerList[idx].minZoom) {
        options.minZoom = this._layerList[idx].minZoom;
      }
      if (!options.maxNativeZoom) options.maxNativeZoom = 18;

      var errorTileUrl = "image/map/no-data.png";
      if (errorTileUrl) {
        errorTileUrl = this._layerList[idx].errorTileUrl;
      }
      options.errorTileUrl = errorTileUrl;

      if ( this._layer && this._map) {
        this._map.removeLayer(this._layer);
      }

      var zIndex = undefined;
      if ( this._layerList[idx].type == "LayerGroup") {

        this._layer = new GSI.MultiLayer( this._layerList[idx].entries);
        this._layer.isGrayScale = this.isGrayScale;
        this._layer.setOpacity( this.options.opacity ? this.options.opacity : this.opacity );
        this._layer.load();
      } else {

        if ( this._layer ) {
          zIndex = this._layer.options.zIndex;
        }

        this._layer = L.tileLayer(url, options);

        this._layer.isGrayScale = this.isGrayScale;
        this._layer.setOpacity( this.options.opacity ? this.options.opacity : this.opacity );

        this._layer._tileOnLoad = this._tileOnLoad;
        this._layer.createTile = this.createTile;
        this._layer._resetTile = this._resetTile;
        this._layer.grayscaleIE1011 = this.grayscaleIE1011;
        this._layer._getZoomForUrl = this._getZoomForUrl;

      }

      if (this._map) {
        this._layer.addTo( this._map);
        if ( zIndex ) this._layer.setZIndex(zIndex);
        this._layer._setView(this._map.getCenter(), this._map.getZoom());
      }
      this.fire("change", {index:this.activeIndex});
    }
    this.activeIndexPre = this.activeIndex;
  },

  _cancelCocotileRequest : function() {

    if ( this._cocoTileRequest ) {
      this._cocoTileRequest.abort();
      this._cocoTileRequest = undefined;
    }
  },

  onAdd  : function(map) {

    if ( this._layer && !this._layer._map) {

      this._layer.isGrayScale = this.isGrayScale;

      this._layer.setOpacity(  this.options.opacity ? this.options.opacity :this.opacity );
      this._layer.addTo( this._map);
    }

    if ( !this._selectHandler ) {
      this._selectHandler = L.bind(function(e){
        this.setActiveIndex(e.index);
      }, this);
    }

    var control =this._mapManager.getComparePhotoControl();

    if ( control ) {
      control.on("select",this._selectHandler );
    }

    this._mapManager.showComparePhotoControl();

    if ( !this._moveEndHandler ) {
      this._moveEndHandler = L.bind(this._onZoomEnd,this );
      this._map.on("zoomend",this._moveEndHandler );
    }

  },

  _onZoomEnd:function() {
      this.fire("change", {index:this.activeIndex});
  },

  onRemove : function() {

    if ( this._moveEndHandler ) {
      this._map.off("zoomend",this._moveEndHandler );
      this._moveEndHandler = undefined;
    }

    if ( this._layer ) this._layer.remove( this._map);

    var control = this._mapManager.hideComparePhotoControl();

    if ( this._selectHandler)
      control.off("select",this._selectHandler );

  },

  setZIndex: function(zIndex) {
    if ( this._layer ) {
      this._layer.setZIndex(zIndex);
    }
  },
  getGrayScale: function () {
    return this.isGrayScale;
  },
  setGrayScale: function (isGrayScale) {

    if (this.isGrayScale != isGrayScale) {
      this.isGrayScale = isGrayScale;
      if ( this._layer ) {
        this._layer.isGrayScale = this.isGrayScale;
        this._layer.redraw();
      }
    }
  },

  _getZoomForUrl: function () {

    var zoom = this._tileZoom,
      maxZoom = this.options.maxZoom,
      zoomReverse = this.options.zoomReverse,
      zoomOffset = this.options.zoomOffset;

    this.options.tileSize = 256;

    if (zoomReverse) {
      zoom = maxZoom - zoom;
    }

    return zoom + zoomOffset;
  },

  _tileOnLoad: function (done, tile) {
    var layer = this;
    var img = tile;

    if (layer && layer.isGrayScale && img.src !== L.Util.emptyImageUrl) {
      $(img).addClass("grayscale");
      if (GSI.Utils.Browser.ie) {
        if (GSI.Utils.Browser.version >= 10) {
          if (!$(img).data("_src") && img.src.indexOf("data:") < 0) {
            $(img).data({ "_src": this.src });
            img.src = this.grayscaleIE1011(img);//.src );
          }
        }
        else {
          $(img).css({ 'filter': 'gray', opacity: layer.opacity });
        }
      }
    }

    L.TileLayer.prototype._tileOnLoad.call(this, done, tile);
  },
  grayscaleIE1011: function (img) //src)
  {
    var size = this.getTileSize();

    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    canvas.width = size.x;
    canvas.height = size.y;
    ctx.drawImage(img, 0, 0);
    var imgPixels = ctx.getImageData(0, 0, canvas.width, canvas.height);

    for (var y = 0; y < imgPixels.height; y++) {
      for (var x = 0; x < imgPixels.width; x++) {
        var i = (y * 4) * imgPixels.width + x * 4;
        var avg = (imgPixels.data[i] + imgPixels.data[i + 1] + imgPixels.data[i + 2]) / 3;
        imgPixels.data[i] = avg;
        imgPixels.data[i + 1] = avg;
        imgPixels.data[i + 2] = avg;
      }
    }
    ctx.putImageData(imgPixels, 0, 0, 0, 0, imgPixels.width, imgPixels.height);

    return canvas.toDataURL();
  },
  createTile: function (coords, done) {
    var tile = L.TileLayer.prototype.createTile.call(this, coords, done);

    if (this.isGrayScale) {
      if (GSI.Utils.Browser.ie && GSI.Utils.Browser.version >= 10)
        $(tile).attr({ 'crossOrigin': 'Anonymous' });
      $(tile).addClass("grayscale");
      if (GSI.Utils.Browser.ie && GSI.Utils.Browser.version < 10) {
        $(tile).css({ 'filter': 'gray', opacity: this.opacity });
      }
    }
    return tile;
  },
  _resetTile: function (tile) {
    $(tile).data({ "_src": null });
  }
});

/************************************************************************
 L.Layer
  - GSI.ComparePhotoContainsChecker
 ************************************************************************/
GSI.ComparePhotoContainsChecker = L.Evented.extend( {

  initialize : function(map, photoList) {
    this._map = map;
    this._photoList = photoList;
  },

  start : function() {
    if ( !this._onMapMoveEndHandler ) {
      this._onMapMoveEndHandler = L.bind( this._onMapMoveEnd, this );
      this._map.on("moveend", this._onMapMoveEndHandler);
    }

    this._onMapMoveEndHandler();
  },

  stop : function() {

    this._destroyRequest();
    if ( this._onMapMoveEndHandler) {
      this._map.off("moveend", this._onMapMoveEndHandler);
      this._onMapMoveEndHandler = undefined;
    }
  },

  _destroyRequest: function() {
    if ( this._requests ) {
      for( var i=0; i<this._requests.length; i++ ) {
        this._requests[i].request.abort();
      }

      this._requests = undefined;
    }
  },

  _getTileX: function (z, lon) {
    var lng_rad = lon * Math.PI / 180; var R = 128 / Math.PI; var worldCoordX = R * (lng_rad + Math.PI);
    var pixelCoordX = worldCoordX * Math.pow(2, z); var tileCoordX = Math.floor(pixelCoordX / 256);
    return { n: tileCoordX, px: Math.floor(pixelCoordX - tileCoordX * 256) };
  },

  _getTileY: function (z, lat) {
    var lat_rad = lat * Math.PI / 180; var R = 128 / Math.PI; var worldCoordY = - R / 2 * Math.log((1 + Math.sin(lat_rad)) / (1 - Math.sin(lat_rad))) + 128; var pixelCoordY = worldCoordY * Math.pow(2, z); var tileCoordY = Math.floor(pixelCoordY / 256);
    return { n: tileCoordY, px: Math.floor(pixelCoordY - tileCoordY * 256) };
  },

  _onMapMoveEnd : function() {

    var z = this._map.getZoom();
    var center = this._map.getCenter();

    var hash = {};

    for( var i=0; i<this._photoList.length; i++ ) {
      var photo = this._photoList[i];
      var maxNativeZoom = photo.maxNativeZoom;
      var url = CONFIG.COMPAREPHOTO_COCOTILEURL;
      if ( maxNativeZoom && maxNativeZoom < z ) {
        if( hash[maxNativeZoom+""] ) continue;

        var x = this._getTileX(maxNativeZoom, center.lng);
        var y = this._getTileY(maxNativeZoom, center.lat);
        url = url.replace( "{x}", x.n).replace( "{y}", y.n).replace("{z}", maxNativeZoom);
        hash[maxNativeZoom+""] = url;
      } else {
        if( hash[z+""] ) continue;

        var x = this._getTileX(z, center.lng);
        var y = this._getTileY(z, center.lat);
        url = url.replace( "{x}", x.n).replace( "{y}", y.n).replace("{z}", z );

        hash[z+""] = url;
      }
    }

    this._requests = [];
    this._idList = [];
    for( var key in hash) {
      var url = hash[key];
      var request = $.ajax({
        type: "GET",
        url: url,
        datatype: "text",
        cache: false,
      })
      .done(L.bind(function (data) {
        try {
          var ids = data.split(",");
          for( var i=0; i<ids.length; i++ ) {
            if ( this._idList.indexOf(ids[i]) < 0 ) {
              this._idList.push(ids[i]);
            }
          }
        }catch(ex) {

        }
      },this ) )
      .always(L.bind(function(req1,b,req2) {
        var loaded = true;
        for( var i=0; i<this._requests.length; i++ ) {
          if ( req1 == this._requests[i].request || req2 == this._requests[i].request) {
            this._requests[i].loaded = true;
          }

          if ( !this._requests[i].loaded ) {
            loaded = false;
          }
        }

        if ( loaded ) {
          this.fire("load", {idList:this._idList});
        }
      }, this ) );

      this._requests.push( {
        request : request,
        loaded : false
      });
    }
  }
});

/************************************************************************
 L.Layer
  - GSI.ComparePhotoControl（時系列選択）
 ************************************************************************/
GSI.ComparePhotoControl = L.Evented.extend({

  initialize : function(mapManager) {
    this._photoList = CONFIG.COMPAREPHOTO_PHOTOLIST;

    this._mapManager = mapManager;
    this._parentContainer = mapManager._mapFrame;

    this._mapMenu = this._mapManager._mapMenu;

    this._mapMenu.on("panelshow", L.bind(this._onMapMenuShow, this));
    this._mapMenu.on("panelresize", L.bind(this._onMepMenuResize, this));
    this._mapMenu.on("panelhide", L.bind(this._onMapMenuHide, this))
    this._mapMenu.on("paneloverlapchange", L.bind(this._onMepMenuOverlapChange, this));

  },

  _onMepMenuOverlapChange: function (evt) {
    if (evt.overlap) {

      this._container.css({ "left": "0px", "right": "0px" });
    } else {
      var css = {};
      var width = this._mapMenu.getPanelVisible() ? this._mapMenu.getPanelWidth() : 0;
      if (this._mapMenu.getPanelPosition() == "right") {
        css["right"] = width + "px";
      } else {
        css["left"] = width + "px";
      }

      this._container.css(css);

    }
  },

  _onMapMenuShow: function (evt) {
    if (this._mapMenu.isPanelOverlap()) return;
    var animate = {};
    if (evt.position == "right") {
      animate["right"] = evt.width + "px";
    } else {
      animate["left"] = evt.width + "px";
    }
    this._container.animate(animate, evt.duration, L.bind(function () {
      this.refreshSize();
    }, this));
  },

  _onMepMenuResize: function (evt) {
    if (this._mapMenu.isPanelOverlap()) return;
    var css = {};
    if (evt.position == "right") {
      css["right"] = evt.width + "px";
    } else {
      css["left"] = evt.width + "px";
    }

    this._container.css(css);
    this.refreshSize();

  },

  _onMapMenuHide: function (evt) {
    if (this._mapMenu.isPanelOverlap()) return;
    var animate = {};
    if (evt.position == "right") {
      animate["right"] = "0px";
    } else {
      animate["left"] = "0px";
    }
    this._container.animate(animate, evt.duration, L.bind(function () {
      this.refreshSize();
    }, this));
  },

  refreshSize:function() {
    this.adjust();
  },

  destroyEvents : function() {
    if ( this._windowResizeHandler ) $(window).off("resize", this._windowResizeHandler);
    this._windowResizeHandler = undefined;
  },

  destroyContainsChecker : function() {

    if ( this._cocoTileLoader ) {
      this._cocoTileLoader.stop();
      this._cocoTileLoader = undefined;
    }
  },

  show : function() {
    if ( !this._container) {
      this._create();

    }

    this.destroyContainsChecker();
    this.destroyEvents();

    this._windowResizeHandler = L.bind(this._onWindowResize, this );
    $(window).on("resize", this._windowResizeHandler);

    this._container.css({"visibility":"hidden"});
    this._container.show();

    if ( this._mapMenu.getPanelVisible() ) {
      this._onMapMenuShow({
        width : this._mapMenu.getPanelWidth(),
        duration :0
      });

    }

    this.adjust();
    this._container.css({"visibility":"visible"});

    if ( !this._cocoTileLoader ) {
      this._cocoTileLoader = new GSI.ComparePhotoContainsChecker(this._mapManager.getMap(),this._photoList);
      this._cocoTileLoader.on("load", L.bind(function(evt){
        var idList = evt.idList;
        this._slider.refresh(idList);
      },this))
    }

    this._cocoTileLoader.start();
    this._slider.change();

  },

  _onWindowResize: function() {
    this.refreshSize();
  },

  isVisible : function() {
    return this._container.is(":visible");
  },

  hide : function() {

    this.destroyContainsChecker();
    this.destroyEvents();
    if ( !this._container) return;
    this._container.hide();
  },

  _onSliderChange : function(e) {
    this.fire("select",{index:e.index});
  },

  refreshList : function(idList) {
    this._slider.refresh(idList);
  },

  adjust : function() {

    this._slider.adjust();

  },

  _create : function() {
    this._container = $("<div>").addClass("gsi_comparephoto_container").hide();

    var table = $("<table>");
    var tr = $("<tr>");
    var td = $("<td>");
    this._clearButton = $("<a>").attr({"href":"javascript:void(0);"}).addClass("normalbutton").html("時系列解除").hide();

    this._slider = new GSI.ComparePhotoControl.Slider( this._container,td, this._photoList, this._clearButton);
    this._slider.on("change", L.bind(this._onSliderChange, this ));
    this._slider.create();
    tr.append(td);

    this._clearButton.on("click", L.bind(function(){
      this._mapManager._mapLayerList.remove({id:CONFIG.COMPAREPHOTO_ID });

    }, this));

    td = $("<td>");
    td.append(this._clearButton);
    tr.append(td);

    table.append(tr);

    this._container.append(table);
    this._parentContainer.append(this._container);

  },

  setLeft: function(left) {
    if ( !this._container) return;

    this._container.css({"left": ( left ) +"px"});
    this.adjust();
  },

  setRight: function(right) {

    this._container.css({"right": ( right ) +"px"});
    this.adjust();
  },

  destroy: function() {
    if ( !this._container) return;
    this._container.remove();
  }
});

GSI.ComparePhotoControl.Slider = L.Evented.extend({

  initialize : function(ownerContainer, parentContainer, photoList, clearButton) {
    this._clearButton = clearButton;
    this._ownerContainer = ownerContainer
    this._parentContainer = parentContainer;
    this._photoList = photoList;
    this._activeIndex = -1;
  },

  setActiveIndex: function(index) {
    if ( this._activeIndex == index ) return;

    if ( index >= 0 ) {
      this._handleContainer.css({
        left : Math.round(this._list[index].left) + "px"
      });
    }

    this._activeIndex = index;

    this.change();

  },

  change:function() {
    this.fire("change", {index:this._activeIndex});
  },

  refresh: function(idList) {

    for( var i=0; i<this._photoList.length; i++ ) {
      var photo = this._photoList[i];

      const id = photo.id;

      if ( idList.indexOf( id ) >= 0 ) {
        this._list[i].label.addClass("haslayer");
      } else {
        this._list[i].label.removeClass("haslayer");
      }
    }
  },

  adjust: function() {

    var isSmall = this._ownerContainer.outerWidth() < 800;

    if ( isSmall ) {
      this._container.addClass("small");
      if ( this._ownerContainer.outerWidth() < 500 ) {
        this._clearButton.html("×");
        this._clearButton.addClass("small");
      } else {
        this._clearButton.html("解除");
        this._clearButton.removeClass("small");
      }
    } else {
      this._container.removeClass("small");
      this._clearButton.html("時系列解除");
      this._clearButton.removeClass("small");
    }

    var containerWidth = this._barContainer.outerWidth();

    var sizeInterval =containerWidth / ( this._list.length -1);
    var left = 0;
    for( var i=0; i<this._list.length; i++ ) {
      var item = this._list[i];
      item.left = left;
      item.elem.css({
        left: Math.round(left) + "px"
      });

      item.label.css({
        left: Math.round(left - (item.label.outerWidth() / 2) ) + "px"
      });

      if ( isSmall && i %2 == 1) {
        item.label.addClass("top");
      } else {
        item.label.removeClass("top");
      }

      if ( this._activeIndex == i ) {
        this._handleContainer.css({
          left : Math.round(left) + "px"
        });
      }

      left += sizeInterval;
    }
  },

  create : function() {
    if ( this._container ) return;

    this._container = $("<div>").addClass("gsi_comparephoto_slider_container");

    this._container.on("click", L.bind( this._onContainerClick,this));

    // 背景用バー
    this._barContainer = $("<div>").addClass("gsi_comparephoto_slider_container_bar");

    // メモリ
    this._list = [];
    for( var i=0; i<this._photoList.length; i++ ) {
      var photo = this._photoList[i];
      var item = {};

      item.elem = $("<div>").addClass("gsi_comparephoto_slider_container_bar_line");
      item.label = $("<div>").addClass("gsi_comparephoto_slider_container_bar_label");

      item.label.html(
        photo.year.from + ( photo.year.to ? "<br>〜" + photo.year.to : ""));

      if ( i === 0 || i===this._photoList.length-1 ) {
        item.elem.hide();
      }

      this._barContainer.append( item.label);
      this._barContainer.append( item.elem);

      this._list.push( item );
    }

    // つまみ
    this._handleContainer = $("<div>").addClass("gsi_comparephoto_slider_container_handle");

    this._handleContainer.on("mousedown", L.bind(this._onHandleMouseDown, this));
    this._handleContainer.on("touchstart", L.bind(this._onHandleMouseDown, this));

    this._barContainer.append( this._handleContainer);
    this._container.append( this._barContainer);

    this._parentContainer.append(this._container);

    this.setActiveIndex(0);

  },

  destroyMouseEvents : function() {
    this._container.removeClass("dragging");

    if ( this._mouseMoveHandler ) {
      $(window).off("mousemove", this._mouseMoveHandler);
      $(window).off("touchmove", this._mouseMoveHandler);
      this._mouseMoveHandler = undefined;
    }
    if ( this._mouseUpHandler ) {
      $(window).off("mouseup", this._mouseUpHandler);
      $(window).off("touchend", this._mouseUpHandler);
      this._mouseUpHandler = undefined;
    }
  },

  _onContainerClick : function(e) {

    var targetIndex = this._screenLeftToIndex(e.pageX );

    if ( targetIndex >= 0 ) {
      this.setActiveIndex(targetIndex);
    }
  },

  _onHandleMouseDown : function(e) {

    e.preventDefault();
    e.stopPropagation();

    this.destroyMouseEvents();

    this._mouseMoveHandler = L.bind( this._onWindowMouseMove, this);
    this._mouseUpHandler = L.bind( this._onWindowMouseUp, this);
    $(window).on("mousemove", this._mouseMoveHandler);
    $(window).on("touchmove", this._mouseMoveHandler);
    $(window).on("mouseup", this._mouseUpHandler);
    $(window).on("touchend", this._mouseUpHandler);

    this._container.addClass("dragging");

  },

  _screenLeftToIndex : function ( screenLeft ) {

    var left = 0;
    var barPosition = this._barContainer.offset();

    left =  screenLeft- barPosition.left;

    var containerWidth = this._barContainer.outerWidth();

    var sizeInterval =containerWidth / ( this._list.length -1);
    var lineLeft = 0;
    var minDistance = undefined;
    var targetIndex = -1;
    for( var i=0; i<this._list.length; i++ ) {
      var item = this._list[i];
      item.left = lineLeft;

      var distance = Math.abs( item.left - left );
      if ( minDistance === undefined || minDistance > distance ) {
        targetIndex = i;
        minDistance = distance;
      }
      lineLeft += sizeInterval;
    }

    return targetIndex;
  },

  _onWindowMouseMove : function(e) {

    var pageX = e.pageX;
    if ( e.type =="touchmove") {
      pageX = e.originalEvent.changedTouches[0].pageX;
    }

    var targetIndex = this._screenLeftToIndex(pageX );

    if ( targetIndex >= 0 ) {
      this.setActiveIndex(targetIndex);
    }
  },

  _onWindowMouseUp : function(e) {
    this.destroyMouseEvents();

  }
});

function loadfile(files, key){
  var loader = new GSI.LocalFileLoader(files);
  loader.on("load", L.bind(function (evt) {
    var list = evt.list;
    var sakuzuList = [];
    for (var i = 0; i < list.length; i++) {
      var item = list[i];

      var arr = Encoding.convert(new Uint8Array(item.reader.result), "UNICODE", "AUTO");
      if (arr[0] == 65279) arr.splice(0, 1);
      sakuzuList.push({
        "data": Encoding.codeToString(arr),
        "fileName": item.fileName,
        "fKey": key
      });
    }
    loadSakuzuList(sakuzuList);
  }, GSI.GLOBALS.gsimaps));
  loader.load();
};

function loadSakuzuList(sakuzuList){
  if (GSI.GLOBALS.gsimaps._sakuzuList){
    GSI.GLOBALS.gsimaps._sakuzuList.loadFromTextList(sakuzuList);
  }else{
    setTimeout(() => {
      loadSakuzuList(sakuzuList);
    }, 2000);
  }
};

function getFileeData(url, key) {
  var fname = url.substr(url.lastIndexOf("/") + 1);
  var ftype = fname.substr(fname.lastIndexOf(".") + 1);
  if (ftype == "geojson" || ftype == "kml") {
    $.ajax({
      url: url,
      dataType: 'text'
    }).done(function (data) {
      var f = new File([data], fname, { type: "" });
      loadfile([f], key);
    }).fail(function (data) {
      console.log(data);
    });
  }
};

/************************************************************************
 L.MaplibreGL
  - GSI.PMTileLayer (PMTiles対応レイヤー)
 ************************************************************************/
GSI.PMTileLayer = L.MaplibreGL.extend({
  options:{
    opacity: 1,
  },
  initialize: function (url, options) {
    let protocol = new pmtiles.Protocol();
    maplibregl.addProtocol("pmtiles",protocol.tile);
    this.maplibreGLLayer = L.MaplibreGL.prototype.initialize.call(this, {
      ...options,
      style: url,
      maxzoom: options.maxZoom,
      minzoom: options.minZoom
    });
  },
  onAdd: function (map) {
    L.MaplibreGL.prototype.onAdd.call(this, map);
    this.setGrayscale();
    this.setOpacity(this.options.opacity);
    this._map.setMinZoom(this.options.minZoom+1);
  },
  onRemove: function (map) {
    L.MaplibreGL.prototype.onRemove.call(this, map);
    this._map.setMinZoom(0);
  },
  setOpacity:function (opacity) {
    if(this._glMap){
      var mapContainer = this._glMap.getContainer();
      mapContainer.style.opacity = opacity;
    }
  },
  getEvents: function () {
    return {
      move: this._fastupdate,
      zoomanim: this._animateZoom, // applys the zoom animation to the <canvas>
      zoom: this._pinchZoom, // animate every zoom event for smoother pinch-zooming
      zoomstart: this._zoomStart, // flag starting a zoom to disable panning
      zoomend: this._zoomEnd,
      resize: this._resize
    };
  },
  _fastupdate: function (e) {
    // update the offset so we can correct for it later when we zoom
    this._offset = this._map.containerPointToLayerPoint([0, 0]);
    
    if (this._zooming) { return; }
    
    var size = this.getSize(),
    container = this._container,
    gl = this._glMap,
    offset = this._map.getSize().multiplyBy(this.options.padding),
    topLeft = this._map.containerPointToLayerPoint([0, 0]).subtract(offset);
    this._transformGL(gl);
    L.DomUtil.setPosition(container, this._roundPoint(topLeft));
    L.Util.requestAnimFrame(function () {
        if (gl.transform.width !== size.x || gl.transform.height !== size.y) {
            container.style.width  = size.x + 'px';
            container.style.height = size.y + 'px';
            if (gl._resize !== null && gl._resize !== undefined){
                gl._resize();
            } else {
                gl.resize();
            }
        } else {
            // older versions of mapbox-gl surfaced update publicly
            if (gl._update !== null && gl._update !== undefined){
                gl._update();
            } else {
                gl.update();
            }
        }
    }, this);
  },
  _setView:function (coordinate) {
    this._glMap.setCenter([coordinate.lng, coordinate.lat]);
  },
  _resetView:function () {
    this._setView(this._map.getCenter());
  },
  setGrayscale:function () {
    let mapContainer = this._glMap.getContainer();
    if(this.isGrayScale){
      mapContainer.style.filter = 'grayscale(1)';
    } else {
      mapContainer.style.filter = '';
    }
  },
  redraw:function () {
    if(this._glMap){
      if (!this._baseStyles ){this._baseStyles = this._glMap.getStyle();}
      this.setGrayscale();
      this.setOpacity(this.options.opacity);
    }
  }
});

GSI.pmTileLayer = function (url, options) {
  return new GSI.PMTileLayer(url, options);
};
